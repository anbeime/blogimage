# 列表与网格概述

更新时间: 2025-12-16 16:38

许多应用存在滚动展示同类项目集合的需求，例如显示图片、视频、音乐、新闻、商品等。此类场景可以根据项目排列方式分别选择[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list)、[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-grid)、[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-waterflow)实现，在圆形屏幕推荐使用[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-arclist)。

## 列表

List适合单列和多列宽度相同的场景，如通讯录、音乐列表、购物清单等。

直播评论、即时聊天等应用场景需要在列表底部插入数据时，内容应自动向上滚动，以展示新插入的节点，此功能可通过配置[List从尾部开始布局](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#stackfromend19)实现。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163857.27913050769007376394312621100506:50001231000000:2800:13E46D69DEFECA70824492778BEB1DF283F465708A26736085EB465A73182D7A.png)

## 网格

网格布局由“行”和“列”分割的单元格组成，通过指定“项目”所在单元格实现多种布局，应用场景包括九宫格图片展示、日历、计算器等。

对于部分项目占用多行或多列的场景，可以通过在创建Grid时传入合适的[GridLayoutOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#gridlayoutoptions10%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)来实现。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163857.24770979189893199029466159393580:50001231000000:2800:C72D1BC1092DC01034912CF7236EFA5A3B53A6D06D1B487A9FB1959E1E97C426.png)

## 瀑布流

瀑布流布局是一种多列等宽但高度不等的布局方式，适用于需要错落排列的场景，如图片和视频展示、商品推荐等。

同一个页面内有不同列数分段混合布局的场景，可以通过设置[WaterFlowSections](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow#waterflowoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)实现。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163857.20817510529771395679363150405807:50001231000000:2800:8F20717055C3F0B29C2E0CFBA01B8A09FB02390C7F4D6ED759CB4737D42E040B.png)

## 弧形列表

弧形列表是一种专为圆形屏幕设备设计的特殊列表，支持列表项在接近屏幕上下两端自动缩放的效果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163857.60054151609260596779000388321195:50001231000000:2800:09A67848886A5CD978F068176B4A43124BEA89A6EB03F13FA781EDEB2567CB4E.png)

## 能力对比

|业务场景|List|Grid|WaterFlow|ArcList|
|:--|:--|:--|:--|:--|
|滚动通用能力|支持|支持|支持|支持|
|项目分组|[ListItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitemgroup)|[GridLayoutOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#gridlayoutoptions10%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)|[WaterFlowSections](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow#waterflowoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)|不支持|
|指定项目吸顶|支持通过[sticky](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#sticky9)属性实现吸顶|不支持|不支持|不支持|
|项目拖拽排序|支持[拖拽排序](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-drag-sorting)，包括内置动画和拖动到边缘自动滚动|仅所有项目都占1行1列时[支持内置动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#supportanimation8)，且不支持拖动到边缘自动滚动|不支持|不支持|
|项目横滑|支持通过[swipeAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitem#swipeaction9)属性实现横滑|不支持|不支持|不支持|
|项目间距|支持|支持|支持|支持|
|项目分割线|支持|不支持|不支持|不支持|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-list-and-grid "列表与网格")
# 创建列表 (List)

更新时间: 2025-12-16 16:39

## 概述

列表是一种复杂的容器，当列表项达到一定数量，内容超过屏幕大小时，可以自动提供滚动功能。它适合用于呈现同类数据类型或数据类型集，例如图片和文本。在列表中显示数据集合是许多应用程序中的常见要求（如通讯录、音乐列表、购物清单等）。

使用列表可以轻松高效地显示结构化、可滚动的信息。通过在[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)组件中按垂直或者水平方向线性排列子组件[ListItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitemgroup)或[ListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitem)，为列表中的行或列提供单个视图，或使用[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)迭代一组行或列，或混合任意数量的单个视图和ForEach结构，构建一个列表。List组件支持使用[条件渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-ifelse)、循环渲染、[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)等[渲染控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-overview)方式生成子组件。

在圆形屏幕设备上，推荐使用[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)组件，使用方式可参考[创建弧形列表 (ArcList)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-arclist)。

## 布局与约束

列表作为一种容器，会自动按其滚动方向排列子组件，向列表中添加组件或从列表中移除组件会重新排列子组件。

如下图所示，在垂直列表中，List按垂直方向自动排列ListItemGroup或ListItem。

ListItemGroup用于列表数据的分组展示，其子组件也是ListItem。ListItem表示单个列表项，可以包含单个子组件。

**图1** List、ListItemGroup和ListItem组件关系

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.82508029087734408222720095441139:50001231000000:2800:3C9C19FE3B50B3F90967E49B74C9BAF375732168A1FE9242CEE5FA73A57C6A83.png)

说明

List的子组件必须是ListItemGroup或ListItem，ListItem和ListItemGroup必须配合List来使用。

### 布局

List除了提供垂直和水平布局能力、超出屏幕时可以滚动的自适应延伸能力之外，还提供了自适应交叉轴方向上排列个数的布局能力。

利用垂直布局能力可以构建单列或者多列垂直滚动列表，如下图所示。

**图2** 垂直滚动列表（左：单列；右：多列）

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.41390028584984358959108807341580:50001231000000:2800:515A3A52C4C36A6A52DD5EB5D746C986088E81F21F6EED44C1B055D632AF684D.png)

利用水平布局能力可以构建单行或多行水平滚动列表，如下图所示。

**图3** 水平滚动列表（左：单行；右：多行）

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.65135948997787511952557502598534:50001231000000:2800:CADECA4EA61B7874DC73F8DF42DE7814333EBCCEA4984CA2376F6ECEA533B288.png)

Grid和WaterFlow也可以实现单列、多列布局，如果布局每列等宽，且不需要跨行跨列布局，相比Grid和WaterFlow，则更推荐使用List。

### 约束

列表的主轴方向是指子组件列的排列方向，也是列表的滚动方向。垂直于主轴的轴称为交叉轴，其方向与主轴方向相互垂直。

如下图所示，垂直列表的主轴是垂直方向，交叉轴是水平方向；水平列表的主轴是水平方向，交叉轴是垂直方向。

**图4** 列表的主轴与交叉轴

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.21252837383174839640091768585533:50001231000000:2800:5BFD1D5C31400F8050FB47EB33626D6B2063D71297ED5C68D2F449ED25A7AEF9.png)

如果List组件主轴或交叉轴方向设置了尺寸，则其对应方向上的尺寸为设置值。

如果List组件主轴方向没有设置尺寸，当List子组件主轴方向总尺寸小于List的父组件尺寸时，List主轴方向尺寸自动适应子组件的总尺寸。

如下图所示，一个垂直列表B没有设置高度时，其父组件A高度为200vp，若其所有子组件C的高度总和为150vp，则此时列表B的高度为150vp。

**图5** 列表主轴高度约束示例1（**A**: List的父组件; **B**: List组件; **C**: List的所有子组件）

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.34469409620862532472296538699606:50001231000000:2800:39625DFCCD6E5C922C464EC2CCA21A7D31D2ECBCE91EE8E67F6A534B8371871A.png)

如果子组件主轴方向总尺寸超过List父组件尺寸时，List主轴方向尺寸适应List的父组件尺寸。

如下图所示，同样是没有设置高度的垂直列表B，其父组件A高度为200vp，若其所有子组件C的高度总和为300vp，则此时列表B的高度为200vp。

**图6** 列表主轴高度约束示例2（**A**: List的父组件; **B**: List组件; **C**: List的所有子组件）

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.76052330666006466408604139471360:50001231000000:2800:D9F4B8FF2B0595925AC3DF65E553A68FC96E81E723A1F557EEDE842DAD95E411.png)

List组件交叉轴方向在没有设置尺寸时，其尺寸默认自适应父组件尺寸。

## 开发布局

### 设置主轴方向

List组件主轴默认是垂直方向，即默认情况下不需要手动设置List方向，就可以构建一个垂直滚动列表。

若是水平滚动列表场景，将List的listDirection属性设置为Axis.Horizontal即可实现。listDirection默认为Axis.Vertical，即主轴默认是垂直方向。

1. List() {
2.   // ...
3. }
4. .listDirection(Axis.Horizontal)

### 设置交叉轴布局

List组件的交叉轴布局可以通过[lanes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#lanes9)和[alignListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#alignlistitem9)属性进行设置，lanes属性用于确定交叉轴排列的列表项数量，alignListItem用于设置子组件在交叉轴方向的对齐方式。

List组件的lanes属性通常用于在不同尺寸的设备自适应构建不同行数或列数的列表，即一次开发、多端部署的场景。lanes属性的取值类型是"number | [LengthConstrain](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types#lengthconstrain)"，即整数或者LengthConstrain类型。以垂直列表为例，如果将lanes属性设为2，表示构建的是一个两列的垂直列表，如图2中右图所示。lanes的默认值为1，即默认情况下，垂直列表的列数是1。

1. List() {
2.   // ...
3. }
4. .lanes(2)

当其取值为LengthConstrain类型时，表示会根据LengthConstrain与List组件的尺寸自适应决定行或列数。

1. @Entry
2. @Component
3. struct EgLanes {
4.   @State egLanes: LengthConstrain = { minLength: 200, maxLength: 300 };
5.   build() {
6.     List() {
7.       // ...
8.     }
9.     .lanes(this.egLanes)
10.   }
11. }

例如，假设在垂直列表中设置了lanes的值为{ minLength: 200, maxLength: 300 }。此时：

- 当List组件宽度为300vp时，由于minLength为200vp，此时列表为一列。
    
- 当List组件宽度变化至400vp时，符合两倍的minLength，则此时列表自适应为两列。
    

同样以垂直列表为例，当alignListItem属性设置为ListItemAlign.Center表示列表项在水平方向上居中对齐。alignListItem的默认值是ListItemAlign.Start，即列表项在列表交叉轴方向上默认按首部对齐。

1. List() {
2.   // ...
3. }
4. .alignListItem(ListItemAlign.Center)

## ListItem生命周期

### 使用ForEach创建ListItem

List组件创建时，所有ListItem将会被创建。显示区域内的ListItem在首帧进行布局，预加载范围内的ListItem在空闲时完成布局。预加载范围之外的ListItem仅创建ListItem自身，ListItem其内部的子组件不会被创建。

当List组件滑动时，进入预加载及显示区域的ListItem将会创建其内部的子组件并完成布局，而滑出预加载及显示区域的ListItem将不会被销毁。

**图7** ForEach创建ListItem的生命周期

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.98678667901575717613542983583886:50001231000000:2800:A18C24F6072827C7614B13914AE037056AE3DD0679170F5862724E6D309CDB01.png)

### 使用LazyForEach创建ListItem

List组件创建时，显示区域中的ListItem会被创建与布局。预加载范围内的ListItem在空闲时创建与布局，但是不会被挂载到组件树上。预加载范围外的ListItem则不会被创建。

当List组件滑动时，进入预加载及显示区域的ListItem将被创建与布局，创建ListItem过程中，若ListItem内部包含@Reusable标记的自定义组件，则会优先从缓存池中复用。滑出预加载及显示区域的ListItem将被销毁，其内部若含@Reusable标记的自定义组件，则会被回收并加入缓存池。

**图8** LazyForEach创建ListItem的生命周期

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.43015520209823594677166315919638:50001231000000:2800:B7CC6E04EAAE9333A4C0F0794E0F6D23EC7D5CCC413128D43B7EB56B9CC0252E.png)

### 使用Repeat创建ListItem

**使用virtualScroll**

List组件创建时，使用设置了[virtualScroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#virtualscroll)的Repeat生成ListItem，此时显示区域内的ListItem将被创建和布局。预加载范围内的ListItem在渲染线程空闲时创建和布局，并且挂载至组件树上。预加载范围外的ListItem则不会被创建。

当List组件滑动时，进入预加载及显示区域的ListItem，将从缓存池中获取ListItem并复用及布局，若缓存池中无ListItem，则会新创建并布局。滑出预加载及显示区域的ListItem将被回收至缓存池。

**图9** Repeat使用virtualScroll创建ListItem的生命周期

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.08697742491270631171208965848176:50001231000000:2800:C3A32BA192C2519C945C383FB7D731342B703F578BA0A586AB194A71FFEBDD62.png)

**不使用virtualScroll**

List组件创建时，所有ListItem均被创建。显示区域内的ListItem在首帧完成布局，预加载范围内的ListItem在空闲时完成布局。预加载范围外的ListItem不会进行布局。

当List组件滑动时，进入预加载及显示区域的ListItem将进行布局。滑出预加载及显示区域的ListItem不会销毁。

**图10** Repeat不使用virtualScroll创建ListItem的生命周期

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.79660480889948801766060519556294:50001231000000:2800:4CCFE89B107022203B9D3B7C93414D49720DB61D3A3F35D2B250C167B8140871.png)

## 在列表中显示数据

列表视图垂直或水平显示项目集合，在行或列超出屏幕时提供滚动功能，使其适合显示大型数据集合。在最简单的列表形式中，List静态地创建其列表项ListItem的内容。

**图11** 城市列表

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.84359357232477886424247700490423:50001231000000:2800:F632308DE96128FBE7BDCBA1650F034A61445519FCB21E06C1267081F2828672.png)

1. @Entry
2. @Component
3. struct CityList {
4.   build() {
5.     List() {
6.       ListItem() {
7.         Text('北京').fontSize(24)
8.       }

9.       ListItem() {
10.         Text('杭州').fontSize(24)
11.       }

12.       ListItem() {
13.         Text('上海').fontSize(24)
14.       }
15.     }
16.     .backgroundColor('#FFF1F3F5')
17.     .alignListItem(ListItemAlign.Center)
18.   }
19. }

由于在ListItem中只能有一个根节点组件，不支持以平铺形式使用多个组件。因此，若列表项是由多个组件元素组成的，则需要将这多个元素组合到一个容器组件内或组成一个自定义组件。

**图12** 联系人列表项示例

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.21201715861473547495996013753463:50001231000000:2800:6E8B0030682846E61ADAC74AA0FE22743B20CDE716127CA74C2DD2D773B12EBC.png)

如上图所示，联系人列表的列表项中，每个联系人都有头像和名称。此时，需要将Image和Text封装到一个Row容器内。

1. List() {
2.   ListItem() {
3.     Row() {
4.       // app.media.iconE为自定义资源
5.       Image($r('app.media.iconE'))
6.         .width(40)
7.         .height(40)
8.         .margin(10)

9.       Text('小明')
10.         .fontSize(20)
11.     }
12.   }

13.   ListItem() {
14.     Row() {
15.       // app.media.iconF为自定义资源
16.       Image($r('app.media.iconF'))
17.         .width(40)
18.         .height(40)
19.         .margin(10)

20.       Text('小红')
21.         .fontSize(20)
22.     }
23.   }
24. }

## 迭代列表内容

通常，应用通过数据集合动态地创建列表。使用[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件，降低代码复杂度。

ArkTS通过[ForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)提供了组件的循环渲染能力。以简单形式的联系人列表为例，将联系人名称和头像数据以Contact类结构存储到contacts数组，使用ForEach中嵌套ListItem的形式来代替多个平铺的、内容相似的ListItem，从而减少重复代码。

1. import { util } from '@kit.ArkTS';

2. class Contact {
3.   key: string = util.generateRandomUUID(true);
4.   name: string;
5.   icon: Resource;

6.   constructor(name: string, icon: Resource) {
7.     this.name = name;
8.     this.icon = icon;
9.   }
10. }

11. @Entry
12. @Component
13. struct SimpleContacts {
14.   private contacts: Array<object> = [
15.     new Contact('小明', $r("app.media.iconA")),
16.     new Contact('小红', $r("app.media.iconB")),
17.   ];

18.   build() {
19.     List() {
20.       ForEach(this.contacts, (item: Contact) => {
21.         ListItem() {
22.           Row() {
23.             Image(item.icon)
24.               .width(40)
25.               .height(40)
26.               .margin(10)
27.             Text(item.name).fontSize(20)
28.           }
29.           .width('100%')
30.           .justifyContent(FlexAlign.Start)
31.         }
32.       }, (item: Contact) => JSON.stringify(item))
33.     }
34.     .width('100%')
35.   }
36. }

在List组件中，ForEach除了可以用来循环渲染ListItem，也可以用来循环渲染ListItemGroup。ListItemGroup的循环渲染详细使用请参见[支持分组列表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list#%E6%94%AF%E6%8C%81%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8)。

## 自定义列表样式

### 设置内容间距

在初始化列表时，如需在列表项之间添加间距，可以使用[ListOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#listoptions18%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)的space参数。例如，在每个列表项之间沿主轴方向添加10vp的间距。

1. List({ space: 10 }) {
2.   // ...
3. }

### 添加分隔线

分隔线用来将界面元素隔开，使单个元素更加容易识别。以系统设置场景为例（如下图所示），列表项左侧为图标（如蓝牙图标），右侧为文字描述且分割线在文字下方。

**图13** 设置列表分隔线样式

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.89905704339194798146954661166935:50001231000000:2800:97841A3C071B97B678D646E18D104715EFA4BBFDDA2C9C856241D13220A5AD1A.png)

List提供了[divider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#divider)属性用于给列表项之间添加分隔线。在设置divider属性时，可以通过strokeWidth和color属性设置分隔线的粗细和颜色。

startMargin和endMargin属性分别用于设置分隔线距离列表侧边起始端的距离和距离列表侧边结束端的距离。

1. class DividerTmp {
2.   strokeWidth: Length = 1;
3.   startMargin: Length = 60;
4.   endMargin: Length = 10;
5.   color: ResourceColor = '#ffe9f0f0';

6.   constructor(strokeWidth: Length, startMargin: Length, endMargin: Length, color: ResourceColor) {
7.     this.strokeWidth = strokeWidth;
8.     this.startMargin = startMargin;
9.     this.endMargin = endMargin;
10.     this.color = color;
11.   }
12. }
13. @Entry
14. @Component
15. struct EgDivider {
16.   @State egDivider: DividerTmp = new DividerTmp(1, 60, 10, '#ffe9f0f0');
17.   build() {
18.     List() {
19.       // ...
20.     }
21.     .divider(this.egDivider)
22.   }
23. }

此示例表示从距离列表侧边起始端60vp开始到距离结束端10vp的位置，画一条粗细为1vp的分割线，可以实现图9设置列表分隔线的样式。

说明

1. 分隔线的宽度会使ListItem之间存在一定间隔，当List设置的内容间距小于分隔线宽度时，ListItem之间的间隔会使用分隔线的宽度。
    
2. 当List存在多列时，分割线的startMargin和endMargin作用于每一列上。
    
3. List组件的分隔线画在两个ListItem之间，第一个ListItem上方和最后一个ListItem下方不会绘制分隔线。
    

### 添加滚动条

当列表项高度（宽度）超出屏幕高度（宽度）时，列表可以沿垂直（水平）方向滚动。在页面内容很多时，若用户需快速定位，可拖拽滚动条，如下图所示。

**图14** 列表的滚动条

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.48067704706827218658523276280455:50001231000000:2800:D0E2CD252FC685914579B9F8EA1A793E8C303254858B130F40CC03ECE2BE1BAD.gif)

在使用List组件时，可通过scrollBar属性控制列表滚动条的显示。scrollBar的取值类型为[BarState](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#barstate)，当取值为BarState.Auto表示按需显示滚动条。此时，当触摸到滚动条区域时显示控件，可上下拖拽滚动条快速浏览内容，拖拽时会变粗。若不进行任何操作，2秒后滚动条自动消失。

scrollBar属性API version 9及以下版本默认值为BarState.Off，从API version 10版本开始默认值为BarState.Auto。

1. List() {
2.   // ...
3. }
4. .scrollBar(BarState.Auto)

## 添加外置滚动条

列表[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)可与[ScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar)组件配合使用，为列表添加外置滚动条。两者通过绑定同一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)滚动控制器对象实现联动。

1. 首先，需要创建一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)类型的对象listScroller。
    
    1. private listScroller: Scroller = new Scroller();
    
2. 然后，列表通过[scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#listoptions18%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)参数绑定滚动控制器。
    
    1. // listScroller初始化List组件的scroller参数，绑定listScroller与列表。
    2. List({ scroller: this.listScroller }) {
    3. // ...
    4. }
    
3. 最后，滚动条通过[scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar#scrollbaroptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)参数绑定滚动控制器。
    
    1. // listScroller初始化ScrollBar组件的scroller参数，绑定listScroller与列表。
    2. ScrollBar({ scroller: this.listScroller })
    

**图15** 列表的外置滚动条

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163915.96802402358435994106814887638148:50001231000000:2800:936B5CE04712F9550DF093E1DA4FE6ED4859DCEA376D003463611FA2CF0879FC.gif)

说明

- 滚动条组件[ScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar)，还可配合其他可滚动组件使用，如[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)、[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)、[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)、[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)。
- 在圆形屏幕设备上，[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)可以与弧形滚动条组件[ArcScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-arcscrollbar)配合使用为列表添加弧形外置滚动条，使用方式可参考[创建弧形列表 (ArcList)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-arclist)的[添加外置滚动条ArcScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-arclist#%E6%B7%BB%E5%8A%A0%E5%A4%96%E7%BD%AE%E6%BB%9A%E5%8A%A8%E6%9D%A1arcscrollbar)章节。

## 支持分组列表

在列表中支持数据的分组展示，可以使列表显示结构清晰，查找方便，从而提高使用效率。分组列表在实际应用中十分常见，如下图所示联系人列表。

**图16** 联系人分组列表

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.60719378849971030297410447088927:50001231000000:2800:6571858E3F998B5EB82A37B75E71E42485F0F0CA28EB32C04B18CBD596A8D85A.png)

在List组件中使用ListItemGroup对项目进行分组，可以构建二维列表。

在List组件中可以直接使用一个或者多个ListItemGroup组件，ListItemGroup的宽度默认充满List组件。在初始化ListItemGroup时，可通过header参数设置列表分组的头部组件。

1. @Entry
2. @Component
3. struct ContactsList {

4.   @Builder itemHead(text: string) {
5.     // 列表分组的头部组件，对应联系人分组A、B等位置的组件
6.     Text(text)
7.       .fontSize(20)
8.       .backgroundColor('#fff1f3f5')
9.       .width('100%')
10.       .padding(5)
11.   }

12.   build() {
13.     List() {
14.       ListItemGroup({ header: this.itemHead('A') }) {
15.         // 循环渲染分组A的ListItem
16.       }

17.       ListItemGroup({ header: this.itemHead('B') }) {
18.         // 循环渲染分组B的ListItem
19.       }
20.     }
21.   }
22. }

如果多个ListItemGroup结构类似，可以将多个分组的数据组成数组，然后使用ForEach对多个分组进行循环渲染。例如在联系人列表中，将每个分组的联系人数据contacts（可参考[迭代列表内容](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list#%E8%BF%AD%E4%BB%A3%E5%88%97%E8%A1%A8%E5%86%85%E5%AE%B9)章节）和对应分组的标题title数据进行组合，定义为数组contactsGroups。然后在ForEach中对contactsGroups进行循环渲染，即可实现多个分组的联系人列表。可参考[添加粘性标题](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list#%E6%B7%BB%E5%8A%A0%E7%B2%98%E6%80%A7%E6%A0%87%E9%A2%98)章节示例代码。

## 添加粘性标题

粘性标题是一种常见的标题模式，常用于定位字母列表的头部元素。如下图所示，在联系人列表中滚动A部分时，B部分开始的头部元素始终处于A的下方。而在开始滚动B部分时，B的头部会固定在屏幕顶部，直到所有B的项均完成滚动后，才被后面的头部替代。

粘性标题不仅有助于阐明列表中数据的表示形式和用途，还可以帮助用户在大量信息中进行数据定位，从而避免用户在标题所在的表的顶部与感兴趣区域之间反复滚动。

**图17** 粘性标题

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.42760517078036325226858352332605:50001231000000:2800:F0F9FAABBCED4EBE589B20A0B2D3336F1580C971153E706ECD69FB2AA40D376A.gif)

List组件的[sticky](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#sticky9)属性配合ListItemGroup组件使用，用于设置ListItemGroup中的头部组件是否呈现吸顶效果或者尾部组件是否呈现吸底效果。

通过给List组件设置sticky属性为StickyStyle.Header，即可实现列表的粘性标题效果。如果需要支持吸底效果，可以通过footer参数初始化ListItemGroup的底部组件，并将sticky属性设置为StickyStyle.Footer。

1. import { util } from '@kit.ArkTS';

2. class Contact {
3.   key: string = util.generateRandomUUID(true);
4.   name: string;
5.   icon: Resource;

6.   constructor(name: string, icon: Resource) {
7.     this.name = name;
8.     this.icon = icon;
9.   }
10. }
11. export class ContactsGroup {
12.   title: string = '';
13.   contacts: Array<object> | null = null;
14.   key: string = "";
15. }

16. export class ContactsGroupDataSource implements IDataSource {
17.   private list: object[] = [];

18.   constructor(list: object[]) {
19.     this.list = list;
20.   }

21.   totalCount(): number {
22.     return this.list.length;
23.   }

24.   getData(index: number): object {
25.     return this.list[index];
26.   }

27.   registerDataChangeListener(listener: DataChangeListener): void {
28.   }

29.   unregisterDataChangeListener(listener: DataChangeListener): void {
30.   }
31. }

32. export let contactsGroups: object[] = [
33.   {
34.     title: 'A',
35.     contacts: [
36.       new Contact('艾佳', $r('app.media.iconA')),
37.       new Contact('安安', $r('app.media.iconB')),
38.       new Contact('Angela', $r('app.media.iconC')),
39.     ],
40.     key: util.generateRandomUUID(true)
41.   } as ContactsGroup,
42.   {
43.     title: 'B',
44.     contacts: [
45.       new Contact('白叶', $r('app.media.iconD')),
46.       new Contact('伯明', $r('app.media.iconE')),
47.     ],
48.     key: util.generateRandomUUID(true)
49.   } as ContactsGroup,
50.   // ...
51. ]
52. export let contactsGroupsDataSource: ContactsGroupDataSource = new ContactsGroupDataSource(contactsGroups);

53. @Entry
54. @Component
55. struct ContactsList {
56.   // 定义分组联系人数据集合contactsGroups数组
57.   @Builder itemHead(text: string) {
58.     // 列表分组的头部组件，对应联系人分组A、B等位置的组件
59.     Text(text)
60.       .fontSize(20)
61.       .backgroundColor('#fff1f3f5')
62.       .width('100%')
63.       .padding(5)
64.   }
65.   build() {
66.     List() {
67.       // 懒加载ListItemGroup，contactsGroups为多个分组联系人contacts和标题title的数据集合
68.       LazyForEach(contactsGroupsDataSource, (itemGroup: ContactsGroup) => {
69.         ListItemGroup({ header: this.itemHead(itemGroup.title) }) {
70.           // 懒加载ListItem
71.           if (itemGroup.contacts) {
72.             LazyForEach(new ContactsGroupDataSource(itemGroup.contacts), (item: Contact) => {
73.               ListItem() {
74.                 // ...
75.               }
76.             }, (item: Contact) => JSON.stringify(item))
77.           }
78.         }
79.       }, (itemGroup: ContactsGroup) => JSON.stringify(itemGroup))
80.     }.sticky(StickyStyle.Header)  // 设置吸顶，实现粘性标题效果
81.   }
82. }

## 控制滚动位置

控制滚动位置在实际应用中十分常见，例如当新闻页列表项数量庞大，用户滚动列表到一定位置时，希望快速滚动到列表底部或返回列表顶部。此时，可以通过控制滚动位置来实现列表的快速定位，如下图所示。

**图18** 返回列表顶部

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.01634379956783676025307190238944:50001231000000:2800:952E83228CEADC5F3F5F3DA4F270B7BAE5DA7ECA5DE187C7909CE27E58FC847E.gif)

List组件初始化时，可以通过scroller参数绑定一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)对象，进行列表的滚动控制。例如，用户在新闻应用中，点击新闻页面底部的返回顶部按钮时，就可以通过Scroller对象的scrollToIndex方法使列表滚动到指定的列表项索引位置。

首先，需要创建一个Scroller的对象listScroller。

1. private listScroller: Scroller = new Scroller();

然后，通过将listScroller用于初始化List组件的scroller参数，完成listScroller与列表的绑定。在需要跳转的位置指定scrollToIndex的参数为0，表示返回列表顶部。

1. Stack({ alignContent: Alignment.Bottom }) {
2.   // 将listScroller用于初始化List组件的scroller参数，完成listScroller与列表的绑定。
3.   List({ space: 20, scroller: this.listScroller }) {
4.     // ...
5.   }

6.   Button() {
7.     // ...
8.   }
9.   .onClick(() => {
10.     // 点击按钮时，指定跳转位置，返回列表顶部
11.     this.listScroller.scrollToIndex(0);
12.   })
13. }

## 响应滚动位置

许多应用需要监听列表的滚动位置变化并作出响应。例如，在联系人列表滚动时，如果跨越了不同字母开头的分组，则侧边字母索引栏也需要更新到对应的字母位置。

除了字母索引之外，滚动列表结合多级分类索引在应用开发过程中也很常见，例如购物应用的商品分类页面，多级分类也需要监听列表的滚动位置。

**图19** 字母索引响应联系人列表滚动

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.74677073180038902888883455305813:50001231000000:2800:D62F2B4AAC90773E96323A0B94D160DC36F343BCFD704270E8BA848AFFC30A91.gif)

如上图所示，当联系人列表从A滚动到B时，右侧索引栏也需要同步从选中A状态变成选中B状态。此场景可以通过监听List组件的[onScrollIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#onscrollindex)事件来实现，右侧索引栏需要使用字母表索引组件[AlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-alphabet-indexer)。

在列表滚动时，根据列表此时所在的索引值位置firstIndex，重新计算字母索引栏对应字母的位置selectedIndex。由于AlphabetIndexer组件通过selected属性设置了选中项索引值，当selectedIndex变化时会触发AlphabetIndexer组件重新渲染，从而显示为选中对应字母的状态。

1. const alphabets = ['#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
2.   'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
3. @Entry
4. @Component
5. struct ContactsList {
6.   @State selectedIndex: number = 0;
7.   private listScroller: Scroller = new Scroller();

8.   build() {
9.     Stack({ alignContent: Alignment.End }) {
10.       List({ scroller: this.listScroller }) {}
11.       .onScrollIndex((firstIndex: number) => {
12.         // 根据列表滚动到的索引值，重新计算对应联系人索引栏的位置this.selectedIndex
13.       })

14.       // 字母表索引组件
15.       AlphabetIndexer({ arrayValue: alphabets, selected: 0 })
16.         .selected(this.selectedIndex)
17.         .onSelect((index: number) => {
18.           this.listScroller.scrollToIndex(index);
19.         })
20.     }
21.   }
22. }

说明

计算索引值时，ListItemGroup作为一个整体占一个索引值，不计算ListItemGroup内部ListItem的索引值。

## 响应列表项侧滑

侧滑菜单在许多应用中都很常见。例如，通讯类应用通常会给消息列表提供侧滑删除功能，即用户可以通过向左侧滑列表的某一项，再点击删除按钮删除消息，如下图所示。其中，列表项头像右上角标记设置参考[给列表项添加标记](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list#%E7%BB%99%E5%88%97%E8%A1%A8%E9%A1%B9%E6%B7%BB%E5%8A%A0%E6%A0%87%E8%AE%B0)。

**图20** 侧滑删除列表项

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.46779493484390758555544593579195:50001231000000:2800:A293422155A4F137BF5F0BC1593763E8E6CDBE0EE8BFCD884A34463718FA9866.gif)

ListItem的[swipeAction属性](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitem#swipeaction9)可用于实现列表项的左右滑动功能。swipeAction属性方法初始化时有必填参数SwipeActionOptions，其中，start参数表示设置列表项右滑时起始端滑出的组件，end参数表示设置列表项左滑时尾端滑出的组件。

在消息列表中，end参数表示设置ListItem左滑时尾端划出自定义组件，即删除按钮。在初始化end方法时，将滑动列表项的索引传入删除按钮组件，当用户点击删除按钮时，可以根据索引值来删除列表项对应的数据，从而实现侧滑删除功能。

1. 实现尾端滑出组件的构建。
    
    1. @Builder itemEnd(index: number) {
    2.   // 构建尾端滑出组件
    3.   Button({ type: ButtonType.Circle }) {
    4.     Image($r('app.media.ic_public_delete_filled'))
    5.       .width(20)
    6.       .height(20)
    7.   }
    8.   .onClick(() => {
    9.     // this.messages为列表数据源，可根据实际场景构造。点击后从数据源删除指定数据项。
    10.     this.messages.splice(index, 1);
    11.   })
    12. }
    
2. 绑定swipeAction属性到可左滑的ListItem上。
    
    1. // 构建List时，通过ForEach基于数据源this.messages循环渲染ListItem。
    2. ListItem() {
    3.   // ...
    4. }
    5. .swipeAction({
    6.   end: {
    7.     // index为该ListItem在List中的索引值。
    8.     builder: () => { this.itemEnd(index) },
    9.   }
    10. }) // 设置侧滑属性.
    

## 给列表项添加标记

添加标记是一种无干扰性且直观的方法，用于显示通知或将注意力集中到应用内的某个区域。例如，当消息列表接收到新消息时，通常对应的联系人头像的右上方会出现标记，提示有若干条未读消息，如下图所示。

**图21** 给列表项添加标记

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.64480446926444127805477235068402:50001231000000:2800:400D4186D37034B40F3256A41433809F65419A759E4D883388FBA9C70DED6F86.png)

在ListItem中使用[Badge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-badge)组件可实现给列表项添加标记功能。Badge是可以附加在单个组件上用于信息标记的容器组件。

在消息列表中，若希望在联系人头像右上角添加标记，可在实现消息列表项ListItem的联系人头像时，将头像Image组件作为Badge的子组件。

在Badge组件中，count和position参数用于设置需要展示的消息数量和提示点显示位置，还可以通过style参数灵活设置标记的样式。

1. ListItem() {
2.   Badge({
3.     count: 1,
4.     position: BadgePosition.RightTop,
5.     style: { badgeSize: 16, badgeColor: '#FA2A2D' }
6.   }) {
7.     // Image组件实现消息联系人头像
8.     // ...
9.   }
10. }

## 下拉刷新与上拉加载

页面的下拉刷新与上拉加载功能在移动应用中十分常见，例如，新闻页面的内容刷新和加载。这两种操作的原理都是通过响应用户的[触摸事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch)，在顶部或者底部显示一个刷新或加载视图，完成后再将此视图隐藏。

以下拉刷新为例，其实现主要分成三步：

1. 监听手指按下事件，记录其初始位置的值。
    
2. 监听手指按压移动事件，记录并计算当前移动的位置与初始值的差值，大于0表示向下移动，同时设置一个允许移动的最大值。
    
3. 监听手指抬起事件，若此时移动达到最大值，则触发数据加载并显示刷新视图，加载完成后将此视图隐藏。
    

说明

页面的下拉刷新操作推荐使用[Refresh](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-refresh)组件实现。

下拉刷新与上拉加载的具体实现可参考[新闻数据加载](https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/tutorials_NEXT-NewsDataArkTS)。

## 编辑列表

列表的编辑模式用途十分广泛，常见于待办事项管理、文件管理、备忘录的记录管理等应用场景。在列表的编辑模式下，新增和删除列表项是最基础的功能，其核心是对列表项对应的数据集合进行数据添加和删除。

下面以待办事项管理为例，介绍如何快速实现新增和删除列表项功能。

### 新增列表项

如下图所示，当用户点击添加按钮时，提供用户新增列表项内容选择或填写的交互界面，用户点击确定后，列表中新增对应的项目。

**图22** 新增待办

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.03934617475486746577065593716899:50001231000000:2800:2F6BCA6E6677872A8E43711820B7DDC901EE66E8E2C41FDAF857EBDBA1FD84C6.gif)

添加列表项功能实现主要流程如下：

1. 定义列表项数据结构，以待办事项管理为例，首先定义待办数据结构。
    
    1. //ToDo.ets
    2. import { util } from '@kit.ArkTS';
    
    3. export class ToDo {
    4.   key: string = util.generateRandomUUID(true);
    5.   name: string;
    
    6.   constructor(name: string) {
    7.     this.name = name;
    8.   }
    9. }
    
2. 构建列表整体布局和列表项。
    
    1. //ToDoListItem.ets
    2. import { ToDo } from './ToDo';
    
    3. @Component
    4. export struct ToDoListItem {
    5.   @Link isEditMode: boolean;
    6.   @Link selectedItems: ToDo[];
    7.   private toDoItem: ToDo = new ToDo("");
    
    8.   build() {
    9.    Flex({ justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {
    10.      // ...
    11.    }
    12.    .width('100%')
    13.    .height(80)
    14.    //.padding() 根据具体使用场景设置
    15.    .borderRadius(24)
    16.    //.linearGradient() 根据具体使用场景设置
    17.    .gesture(
    18.      GestureGroup(GestureMode.Exclusive,
    19.      LongPressGesture()
    20.        .onAction(() => {
    21.          // ...
    22.        })
    23.      )
    24.    )
    25.   }
    26. }
    
3. 初始化待办列表数据和可选事项，最后，构建列表布局和列表项。
    
    1. //ToDoList.ets
    2. import { ToDo } from './ToDo';
    3. import { ToDoListItem } from './ToDoListItem';
    
    4. @Entry
    5. @Component
    6. struct ToDoList {
    7.   @State toDoData: ToDo[] = [];
    8.   @Watch('onEditModeChange') @State isEditMode: boolean = false;
    9.   @State selectedItems: ToDo[] = [];
    10.  private availableThings: string[] = ['读书', '运动', '旅游', '听音乐', '看电影', '唱歌'];
    
    11.   onEditModeChange() {
    12.     if (!this.isEditMode) {
    13.       this.selectedItems = [];
    14.     }
    15.  }
    
    16.   build() {
    17.     Column() {
    18.       Row() {
    19.         if (this.isEditMode) {
    20.           Text('X')
    21.             .fontSize(20)
    22.             .onClick(() => {
    23.               this.isEditMode = false;
    24.             })
    25.             .margin({ left: 20, right: 20 })
    26.         } else {
    27.           Text('待办')
    28.             .fontSize(36)
    29.             .margin({ left: 40 })
    30.           Blank()
    31.           Text('+') //提供新增列表项入口，即给新增按钮添加点击事件
    32.             .onClick(() => {
    33.               this.getUIContext().showTextPickerDialog({
    34.                 range: this.availableThings,
    35.                 onAccept: (value: TextPickerResult) => {
    36.                   let arr = Array.isArray(value.index) ? value.index : [value.index];
    37.                   for (let i = 0; i < arr.length; i++) {
    38.                     this.toDoData.push(new ToDo(this.availableThings[arr[i]])); // 新增列表项数据toDoData(可选事项)
    39.                   }
    40.                 },
    41.               })
    42.             })
    43.         }
    44.         List({ space: 10 }) {
    45.           ForEach(this.toDoData, (toDoItem: ToDo) => {
    46.             ListItem() {
    47.               // 将toDoData的每个数据放入到以model的形式放进ListItem里
    48.               ToDoListItem({
    49.                 isEditMode: this.isEditMode,
    50.                 toDoItem: toDoItem,
    51.                 selectedItems: this.selectedItems })
    52.             }
    53.           }, (toDoItem: ToDo) => toDoItem.key.toString())
    54.         }
    55.       }
    56.     }
    57.   }
    58. }
    

### 删除列表项

如下图所示，当用户长按列表项进入删除模式时，提供用户删除列表项选择的交互界面，用户勾选完成后点击删除按钮，列表中删除对应的项目。

**图23** 长按删除待办事项

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.88125359394839311946877327150617:50001231000000:2800:8EF33A721083D43630E3132E2AA1D32F50B64ECD2B5396A0E9D6B89EA985119E.gif)

删除列表项功能实现主要流程如下：

1. 列表的删除功能一般进入编辑模式后才可使用，所以需要提供编辑模式的入口。
    
    以待办列表为例，通过监听列表项的长按事件，当用户长按列表项时，进入编辑模式。
    
    1. // 结构参考
    2. export class ToDo {
    3.   key: string = util.generateRandomUUID(true);
    4.   name: string;
    5.   toDoData: ToDo[] = [];
    
    6.   constructor(name: string) {
    7.     this.name = name;
    8.   }
    9. }
    
    10. // 实现参考
    11. Flex({ justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {
    12.   // ...
    13. }
    14. .gesture(
    15. GestureGroup(GestureMode.Exclusive,
    16.   LongPressGesture()
    17.     .onAction(() => {
    18.       if (!this.isEditMode) {
    19.         this.isEditMode = true; //进入编辑模式
    20.       }
    21.     })
    22.   )
    23. )
    
2. 需要响应用户的选择交互，记录要删除的列表项数据。
    
    在待办列表中，通过勾选框的勾选或取消勾选，响应用户勾选列表项变化，记录所有选择的列表项。
    
    1. // 结构参考
    2. import { util } from '@kit.ArkTS';
    
    3. export class ToDo {
    4.  key: string = util.generateRandomUUID(true);
    5.  name: string;
    6.  toDoData: ToDo[] = [];
    
    7.  constructor(name: string) {
    8.    this.name = name;
    9.  }
    10. }
    
    11. // 实现参考
    12. if (this.isEditMode) {
    13.   Checkbox()
    14.     .onChange((isSelected) => {
    15.       if (isSelected) {
    16.         this.selectedItems.push(toDoList.toDoItem); // this.selectedItems为勾选时，记录选中的列表项，可根据实际场景构造
    17.       } else {
    18.         let index = this.selectedItems.indexOf(toDoList.toDoItem);
    19.         if (index !== -1) {
    20.           this.selectedItems.splice(index, 1); // 取消勾选时，则将此项从selectedItems中删除
    21.         }
    22.       }
    23.     })
    24. }
    
3. 需要响应用户点击删除按钮事件，删除列表中对应的选项。
    
    1. // 结构参考
    2. import { util } from '@kit.ArkTS';
    
    3. export class ToDo {
    4.   key: string = util.generateRandomUUID(true);
    5.   name: string;
    6.   toDoData: ToDo[] = [];
    
    7.   constructor(name: string) {
    8.     this.name = name;
    9.   }
    10. }
    
    11. // 实现参考
    12. Button('删除')
    13.   .onClick(() => {
    14.     // this.toDoData为待办的列表项，可根据实际场景构造。点击后删除选中的列表项对应的toDoData数据
    15.     let leftData = this.toDoData.filter((item) => {
    16.       return !this.selectedItems.find((selectedItem) => selectedItem == item);
    17.     })
    18.     this.toDoData = leftData;
    19.     this.isEditMode = false;
    20.   })
    

## 长列表的处理

[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)适用于短列表，当构建具有大量列表项的长列表时，如果直接采用循环渲染方式，会一次性加载所有的列表元素，会导致页面启动时间过长，影响用户体验。因此，推荐使用[数据懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)（LazyForEach）方式实现按需迭代加载数据，从而提升列表性能。

关于长列表按需加载优化的具体实现可参考[数据懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)章节中的示例。

当使用懒加载方式渲染列表时，为了更好的列表滚动体验，减少列表滑动时出现白块，List组件提供了[cachedCount](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#cachedcount)参数用于设置列表项缓存数，懒加载方式只会预加载List显示区域外cachedCount的内容，而非懒加载会全部加载。无论懒加载还是非懒加载都只布局List显示区域+List显示区域外cachedCount的内容。

1. List() {
2.   // ...
3. }.cachedCount(3)

以垂直列表为例：

- List设置cachedCount后，显示区域外上下各会预加载并布局cachedCount行ListItem。计算ListItem行数时，会计算ListItemGroup内部的ListItem行数。如果ListItemGroup内没有ListItem，则整个ListItemGroup算一行。
    
- List下嵌套使用LazyForEach，并且LazyForEach下嵌套使用ListItemGroup时，LazyForEach会在List显示区域外上下各会创建cachedCount个ListItemGroup。
    

说明

1. cachedCount的增加会增大UI的CPU、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。
    
2. 列表使用数据懒加载时，除了显示区域的列表项和前后缓存的列表项，其他列表项会被销毁。
    

## 折叠与展开

列表项的折叠与展开用途广泛，常用于信息清单的展示、填写等应用场景。

**图24** 列表项的折叠与展开

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.15951795803400040700044585001638:50001231000000:2800:845BE69936C4CA919FCBC1030BDF015F5D796727E9B6D84292597A10A6F68B0B.gif)

列表项折叠与展开效果实现主要流程如下：

1. 定义列表项数据结构。
    
    1. import { curves } from '@kit.ArkUI';
    
    2. interface ItemInfo {
    3.   index: number,
    4.   name: string,
    5.   label: ResourceStr,
    6.   type?: string,
    7. }
    
    8. interface ItemGroupInfo extends ItemInfo {
    9.   children: ItemInfo[]
    10. }
    
2. 构造列表结构。
    
    1. @State routes: ItemGroupInfo[] = [
    2.   {
    3.     index: 0,
    4.     name: 'basicInfo',
    5.     label: '个人基本资料',
    6.     children: [
    7.       {
    8.         index: 0,
    9.         name: '昵称',
    10.         label: 'xxxx',
    11.         type: 'Text'
    12.       },
    13.       {
    14.         index: 1,
    15.         name: '头像',
    16.         label: $r('sys.media.ohos_user_auth_icon_face'),
    17.         type: 'Image'
    18.       },
    19.       {
    20.         index: 2,
    21.         name: '年龄',
    22.         label: 'xxxx',
    23.         type: 'Text'
    24.       },
    25.       {
    26.         index: 3,
    27.         name: '生日',
    28.         label: 'xxxxxxxxx',
    29.         type: 'Text'
    30.       },
    31.       {
    32.         index: 4,
    33.         name: '性别',
    34.         label: 'xxxxxxxx',
    35.         type: 'Text'
    36.       },
    37.     ]
    38.   },
    39.   {
    40.     index: 1,
    41.     name: 'equipInfo',
    42.     label: '设备信息',
    43.     children: []
    44.   },
    45.   {
    46.     index: 2,
    47.     name: 'appInfo',
    48.     label: '应用使用信息',
    49.     children: []
    50.   },
    51.   {
    52.     index: 3,
    53.     name: 'uploadInfo',
    54.     label: '您主动上传的数据',
    55.     children: []
    56.   },
    57.   {
    58.     index: 4,
    59.     name: 'tradeInfo',
    60.     label: '交易与资产信息',
    61.     children: []
    62.   },
    63.   {
    64.     index: 5,
    65.     name: 'otherInfo',
    66.     label: '其他资料',
    67.     children: []
    68.   },
    69. ];
    70. @State expandedItems: boolean[] = Array(this.routes.length).fill(false);
    71. @State selection: string | null = null;
    72. build() {
    73.   Column() {
    74.     // ...
    
    75.     List({ space: 10 }) {
    76.       ForEach(this.routes, (itemGroup: ItemGroupInfo) => {
    77.         ListItemGroup({
    78.           header: this.ListItemGroupHeader(itemGroup),
    79.           style: ListItemGroupStyle.CARD,
    80.         }) {
    81.           if (this.expandedItems[itemGroup.index] && itemGroup.children) {
    82.             ForEach(itemGroup.children, (item: ItemInfo) => {
    83.               ListItem({ style: ListItemStyle.CARD }) {
    84.                 Row() {
    85.                   Text(item.name)
    86.                   Blank()
    87.                   if (item.type === 'Image') {
    88.                     Image(item.label)
    89.                       .height(20)
    90.                       .width(20)
    91.                   } else {
    92.                     Text(item.label)
    93.                   }
    94.                   Image($r('sys.media.ohos_ic_public_arrow_right'))
    95.                     .fillColor($r('sys.color.ohos_id_color_fourth'))
    96.                     .height(30)
    97.                     .width(30)
    98.                 }
    99.                 .width("100%")
    100.               }
    101.               .width("100%")
    102.               .animation({ curve: curves.interpolatingSpring(0, 1, 528, 39) })
    103.             })
    104.           }
    105.         }.clip(true)
    106.       })
    107.     }
    108.     .width("100%")
    109.   }
    110.   .width('100%')
    111.   .height('100%')
    112.   .justifyContent(FlexAlign.Start)
    113.   .backgroundColor($r('sys.color.ohos_id_color_sub_background'))
    114. }
    
3. 通过改变ListItem的状态，来控制每个列表项是否展开，并通过[animation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty#animation)和[animateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#animateto)来实现展开与折叠过程中的动效效果。
    
    1. @Builder
    2. ListItemGroupHeader(itemGroup: ItemGroupInfo) {
    3.   Row() {
    4.     Text(itemGroup.label)
    5.     Blank()
    6.     Image($r('sys.media.ohos_ic_public_arrow_down'))
    7.       .fillColor($r('sys.color.ohos_id_color_fourth'))
    8.       .height(30)
    9.       .width(30)
    10.       .rotate({ angle: !!itemGroup.children.length ? (this.expandedItems[itemGroup.index] ? 0 : 180) : 180 })
    11.       .animation({ curve: curves.interpolatingSpring(0, 1, 228, 22) })
    12.   }
    13.   .width("100%")
    14.   .padding(10)
    15.   .animation({ curve: curves.interpolatingSpring(0, 1, 528, 39) })
    16.   .onClick(() => {
    17.     if (itemGroup.children.length) {
    18.       this.getUIContext()?.animateTo({ curve: curves.interpolatingSpring(0, 1, 528, 39) }, () => {
    19.         this.expandedItems[itemGroup.index] = !this.expandedItems[itemGroup.index];
    20.       })
    21.     }
    22.   })
    23. }
    

## 切换布局方向

部分业务场景需要列表底部插入数据时，自动向上滚动，把新插入的节点展示出来。例如，直播评论、即时聊天等应用场景。而List组件正常布局时, 在内容下方增加节点，内容是保持不变的。此时，可以通过切换布局方向来实现所需效果。

**图25** 实时消息滚动显示

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.59780183776175891902762283462301:50001231000000:2800:DA4AA8D92766DD8E24E8F83285D036873E7F9C71E1352ADB9F12E56D1CB2B694.gif)

1. 定义列表项数据结构。
    
    1. interface Message {
    2.   id: number
    3.   content: string
    4.   sender: string
    5. }
    
2. 构造列表结构，同时把[stackFromEnd](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#stackfromend19)接口值设置为true，即可实现List列表在底部插入数据时，内容向上滚动。
    
    1. @State messages: Message[] = [
    2.     { id: 1, content: '欢迎来到直播间！', sender: '系统' },
    3.     { id: 2, content: '大家好啊~', sender: '主播' }
    4. ];
    5. build() {
    6.   Column() {
    7.     List({ space: 10 }) {
    8.       ForEach(this.messages, (item: Message) => {
    9.         ListItem() {
    10.           this.MessageItem(item)
    11.         }
    12.       }, (item: Message) => item.id.toString())
    13.     }
    14.     .stackFromEnd(true)
    15.     .layoutWeight(1)
    16.     .alignListItem(ListItemAlign.Center)
    17.     // ...
    18.   }
    19.   .width('100%')
    20.   .height('100%')
    21. }
    

## 支持滑动离手事件

从API version 20开始，滚动类组件（[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)、[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)、[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)、[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)）支持滑动离手事件回调功能，当用户手指离开屏幕时，会触发该事件并上报离手瞬间的滑动速度。开发者可利用此接口实现类似新闻浏览页面的自定义限位滚动效果，短新闻限位滚动，长新闻自由滚动。

**图26** 自定义限位滚动效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.92744041291573663938164177347915:50001231000000:2800:FB16F9AAE07A10BF403ED29547CD1DE342D82750D1E47EF13F6E159AB6748BF3.gif)

1. 定义新闻条目数据结构。
    
    1. // 结构参考
    2. class news {
    3.   public id: string;
    4.   public title: string;
    5.   public content: string;
    6.   public type: string;
    
    7.   constructor(id: string, title: string, content: string, type: string) {
    8.     this.id = id;
    9.     this.title = title;
    10.     this.content = content;
    11.     this.type = type;
    12.   }
    13. }
    
2. 构造新闻条目结构，通过type属性来区分长新闻，短新闻。
    
    1. // 实现参考
    2. @State newsData: Array<news> = [
    3.   new news('1', '新闻标题1', '这是第一条短新闻，内容较少，快速滑动切换', 'short'),
    4.   new news('2', '新闻标题2', '这是第一条短新闻，内容较少，快速滑动切换', 'short'),
    5.   new news('3', '新闻标题3', '这是第二条长新闻，内容较多，可以自由滑动查看完整内容。'.repeat(20), 'long'),
    6.   new news('4', '新闻标题4', '这是第三条短新闻，内容较少，快速滑动切换', 'short'),
    7.   new news('5', '新闻标题5', '这是第四条长新闻，内容较多，可以自由滑动查看完整内容。', 'long')
    8. ];
    
3. 滑动离手事件onWillStopDragging及新闻处理逻辑：
    
    - 上报离手瞬间滑动速度，支持正负方向速度检测，向上滑动为正，向下滑动为负。
        
        1. // 实现参考
        2. onWillStopDragging((velocity: number) => {
        3.   if (velocity < 0) {
        4.     // 向下滑动处理
        5.   } else {
        6.     // 向上滑动处理
        7.   }
        8. })
        
    - 通过[getItemRect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#getitemrect11)接口方法获取当前项位置信息。
        
        1. // 实现参考
        2. let rect = this.scrollerForList.getItemRect(this.currentIndex);
        
    - 处理短新闻：直接跳转相邻项。
        
        1. // 实现参考
        2. if (velocity > 10) {
        3.   this.scrollerForList.scrollToIndex(this.currentIndex, true, ScrollAlign.START);
        4. } else if (velocity < -10) {
        5.   this.scrollerForList.scrollToIndex(this.currentIndex + 1, true, ScrollAlign.START);
        6. }
        
    - 处理长新闻：计算剩余显示范围决定滚动终点。
        
        1. let rect = this.scrollerForList.getItemRect(this.currentIndex);
        2. if (velocity < -30) {
        3.   if (rect) {
        4.     // 当前节点在页面内的剩余显示范围
        5.     let leftRect = rect.y + rect.height;
        6.     //   终点位置
        7.     let mainPosition = -velocity * DEFAULT_FRICTION / FRICTION_SCALE;
        8.     if (leftRect + mainPosition > 0.75 * this.listHeight) {
        9.       this.scrollerForList.scrollToIndex(this.currentIndex + 1, true, ScrollAlign.START);
        10.       return;
        11.     } else if (leftRect + mainPosition < 0.25 * this.listHeight) {
        12.       this.scrollerForList.scrollToIndex(this.currentIndex, true, ScrollAlign.END,
        13.         { extraOffset: LengthMetrics.vp(this.listHeight * 0.3) })
        14.       return;
        15.     }
        16.   }
        17. } else if (velocity > 30) {
        18.   let leftRect = rect?.y + rect?.height;
        19.   let mainPosition = velocity * DEFAULT_FRICTION / FRICTION_SCALE;
        20.   if (leftRect + mainPosition > 0.75 * this.listHeight) {
        21.     this.scrollerForList.scrollToIndex(this.currentIndex, true, ScrollAlign.START);
        22.     return;
        23.   }
        24. }
        

## 设置边缘滑动效果

边缘滑动效果是指当用户滑动滚动组件至边缘后，继续滑动时触发的交互效果。当前List支持通过[edgeEffect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#edgeeffect)属性设置三种边缘滑动效果，分别为弹簧效果（即回弹效果）、阴影效果、无效果。具体效果说明请参见[EdgeEffect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#edgeeffect)的枚举说明。

当List组件的内容区大于等于一屏时，List的边缘滑动效果默认为回弹效果，如下图所示。

**图27** 边缘回弹效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.36829008302028039213534485292021:50001231000000:2800:E717EC8B11A9D28AD80B81D4C11E650E9DABA59C71DF7BC37F108DEA81FE8CB0.gif)

设置.edgeEffect(EdgeEffect.None)时，List无边缘滑动效果，如下图所示。

**图28** 无边缘滑动效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163916.85518475843578807370656315931907:50001231000000:2800:4B95EFC78F2F5D889E1C5EF4B535CD1331672F852907CB0BE0D0A80331C146D5.gif)

从API version 18开始，List还支持只设置单边的边缘滑动效果，如设置.edgeEffect(EdgeEffect.Spring, { alwaysEnabled: true, effectEdge: EffectEdge.START })来实现起始边有边缘回弹效果，末尾边无效果，如下图所示。

**图29** 单边边缘滑动效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163917.68089309987638479406097211752354:50001231000000:2800:D8E69436826A113264F33FC952BDC0E6E5E5E1B97FF94E6C6511D5857B5A0977.gif)

需要注意的是，当List组件的内容区小于一屏时，List默认无边缘滑动效果。若要启用边缘回弹效果，可以通过设置.edgeEffect(EdgeEffect.Spring, { alwaysEnabled: true })来实现。

## 示例代码

- [二维列表](https://gitcode.com/harmonyos_samples/two-dimension-list)
- [List组件嵌套滑动](https://gitcode.com/harmonyos_samples/nested-list)
- [列表编辑效果](https://gitcode.com/harmonyos_samples/list-item-edit)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-list-grid-development-overview "列表与网格概述")
# 弧形列表 (ArcList)（圆形屏幕推荐使用）

更新时间: 2025-12-16 16:39

从API version 18开始支持弧形列表。弧形列表是一种专为圆形屏幕设备设计的特殊列表，它能够以结构化、可滚动的形式高效展示信息。具体用法可参考[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)。

使用弧形列表可以通过在[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)组件中按垂直方向线性排列子组件[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)，可以为弧形列表中的每一项提供独立视图。此外，可以使用[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)来迭代一组列表项，或结合任意数量的单个视图与[ForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)结构，构建复杂的弧形列表。[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)组件支持多种[渲染控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-overview)方式，包括条件渲染、循环渲染和懒加载，以生成子组件。

## 创建弧形列表

[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)可通过调用以下接口来创建。

1. ArcList() {
2.   ArcListItem() {
3.     // ...
4.   }
5.   ArcListItem() {
6.     // ...
7.   }
8.   // ...
9. }

说明

[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)的子组件必须是[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)，[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)必须配合[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)来使用。

## 在弧形列表中显示数据

弧形列表视图垂直展示项目集合，当列表项超出屏幕范围时，提供滚动功能，这使得它非常适合展示大型数据集合。在最简单的弧形列表形式中，[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)静态创建其列表项[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)的内容。

1. // xxx.ets
2. import { ArcList, ArcListItem, ArcListAttribute, ArcListItemAttribute, LengthMetrics } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ArcListExample {
6.   build() {
7.     Stack() {
8.       ArcList({ initialIndex: 2 }) {
9.         ArcListItem() {
10.           Row() {
11.             Image($r("app.media.wlan")).width("99px").height("99px")
12.               .borderRadius("50px").margin({ left: 7 })
13.             Column() {
14.               Text("WLAN").fontSize("38px").fontColor("#FFFFFFFF")
15.               Text("已开启").fontSize("20px").fontColor("#FFFFFFFF")
16.             }.width("190px")

17.             Image($r("app.media.ic_settings_arrow")).width("92px").height("92px")
18.               .borderRadius("50px")
19.           }
20.         }
21.         .borderRadius("65px")
22.         .width("414px")
23.         .height("129px")
24.         .backgroundColor("#26FFFFFF")

25.         ArcListItem() {
26.           Row() {
27.             Image($r("app.media.blueTooth")).width("99px").height("99px")
28.               .borderRadius("50px").margin({ left: 7 })
29.             Column() {
30.               Text("蓝牙").fontSize("38px").fontColor("#FFFFFFFF")
31.               Text("已开启").fontSize("20px").fontColor("#FFFFFFFF")
32.             }.width("190px")

33.             Image($r("app.media.ic_settings_arrow")).width("92px").height("92px")
34.               .borderRadius("50px")
35.           }
36.         }
37.         .borderRadius("65px")
38.         .width("414px")
39.         .height("129px")
40.         .backgroundColor("#26FFFFFF")

41.         ArcListItem() {
42.           Row() {
43.             Image($r("app.media.mobileData")).width("99px").height("99px")
44.               .borderRadius("50px").margin({ left: 7 })
45.             Column() {
46.               Text("移动网络").fontSize("38px").fontColor("#FFFFFFFF")
47.             }.width("190px")

48.             Image($r("app.media.ic_settings_arrow")).width("92px").height("92px")
49.               .borderRadius("50px")
50.           }
51.         }
52.         .borderRadius("65px")
53.         .width("414px")
54.         .height("129px")
55.         .backgroundColor("#26FFFFFF")

56.         ArcListItem() {
57.           Row() {
58.             Image($r("app.media.ic_settings_more_connections")).width("99px").height("99px")
59.               .borderRadius("50px").margin({ left: 7 })
60.             Column() {
61.               Text("更多连接").fontSize("38px").fontColor("#FFFFFFFF")
62.             }.width("190px")

63.             Image($r("app.media.ic_settings_arrow")).width("92px").height("92px")
64.               .borderRadius("50px")
65.           }
66.         }
67.         .borderRadius("65px")
68.         .width("414px")
69.         .height("129px")
70.         .backgroundColor("#26FFFFFF")

71.         ArcListItem() {
72.           Row() {
73.             Image($r("app.media.displayAndBrightness")).width("99px").height("99px")
74.               .borderRadius("50px").margin({ left: 7 })
75.             Column() {
76.               Text("显示和亮度").fontSize("38px").fontColor("#FFFFFFFF")
77.             }.width("190px")

78.             Image($r("app.media.ic_settings_arrow")).width("92px").height("92px")
79.               .borderRadius("50px")
80.           }
81.         }
82.         .borderRadius("65px")
83.         .width("414px")
84.         .height("129px")
85.         .backgroundColor("#26FFFFFF")
86.       }
87.       .width("466px")
88.       .height("466px")
89.       .space(LengthMetrics.px(10))
90.       .borderRadius("233px")
91.       .backgroundColor(Color.Black)
92.     }
93.   }
94. }

**图1** 显示弧形列表数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.83454057335232376793352860867366:50001231000000:2800:5158320518C27C6D6AAA96E4FB4AC77CCACA03CF223F88DC36EF6ABD34497DCD.png)

## 迭代弧形列表内容

通常，应用会通过数据集合动态创建列表。采用[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)的方式，可以从数据源中迭代获取数据，在每次迭代过程中创建相应的组件，从而降低代码的复杂度。

ArkTS通过[ForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)提供了组件的循环渲染能力。以简单的联系人列表为例，将联系人名称和头像数据以Contact类结构存储到contacts数组中，使用[ForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)中嵌套的[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)来代替多个平铺的、内容相似的[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)，从而减少重复代码，使代码更加简洁高效。

1. // xxx.ets
2. import { ArcList, ArcListAttribute, ArcListItemAttribute, ArcListItem, LengthMetrics } from '@kit.ArkUI';
3. import { util } from '@kit.ArkTS';

4. class Contact {
5.   key: string = util.generateRandomUUID(true);
6.   name: string;
7.   icon: Resource;

8.   constructor(name: string, icon: Resource) {
9.     this.name = name;
10.     this.icon = icon;
11.   }
12. }

13. @Entry
14. @Component
15. struct SimpleContacts {
16.   @State private contacts: Array<object> = [
17.     new Contact('小红', $r("app.media.ic_contact")),
18.     new Contact('小兰', $r("app.media.ic_contact")),
19.     new Contact('小王', $r("app.media.ic_contact")),
20.     new Contact('小李', $r("app.media.ic_contact")),
21.     new Contact('小明', $r("app.media.ic_contact"))
22.   ];

23.   build() {
24.     Stack() {
25.       ArcList({ initialIndex: 2 }) {
26.         ForEach(this.contacts, (item: Contact) => {
27.           ArcListItem() {
28.             Row() {
29.               Image(item.icon)
30.                 .width(40)
31.                 .height(40)
32.                 .margin(10)
33.                 .backgroundColor("#FF9CC998")
34.                 .borderRadius(20)
35.               Text(item.name).fontSize("38px").fontColor("#FFFFFFFF")
36.             }
37.             .width('100%')
38.             .justifyContent(FlexAlign.Start)
39.           }
40.           .borderRadius("65px")
41.           .width("410px")
42.           .height('130px')
43.           .backgroundColor("#26FFFFFF")
44.         }, (item: Contact) => JSON.stringify(item))
45.       }
46.       .space(LengthMetrics.px(10))
47.       .width('466px')
48.       .height('466px')
49.       .borderRadius('233px')
50.       .backgroundColor(Color.Black)
51.     }
52.   }
53. }

**图2** 迭代弧形列表内容

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.48127971834436207121656436852160:50001231000000:2800:21C0EB6941A56F3614529CEC8622A31F63D23CFE3C4D05D539A7DFE581FE64AE.png)

## 自定义弧形列表样式

### 自定义弧形列表标题

可以通过[header](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#arklistoptions)参数为弧形列表添加自定义标题。

1. 首先，需要构造自定义标题组件customHeader。
    
    1. @Builder
    2. function customHeader() {
    3.   Column() {
    4.     Text("设置")
    5.       .fontColor("#FFFFFFFF")
    6.       .fontSize('19fp')
    7.   }
    8. }
    
2. 由于[header](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#arklistoptions)参数的类型是[ComponentContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-componentcontent)，所以需要对自定义标题组件进行封装。
    
    1. context: UIContext = this.getUIContext();
    2. arcListHeader: ComponentContent<Object> = new ComponentContent(this.context, wrapBuilder(customHeader));
    
3. 最后，通过[header](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#arklistoptions)参数将arcListHeader设置到弧形列表中。
    
    1. ArcList({header: this.arcListHeader}) {
    2.   ArcListItem() {
    3.     // ...
    4.   }
    5.   ArcListItem() {
    6.     // ...
    7.   }
    8.   // ...
    9. }
    

**图3** 自定义弧形列表标题

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.13260179405752955318424681525493:50001231000000:2800:D74D41841960B422921C87A9CF181D8B215389489B6FF7C0577ABB627C0211A3.png)

### 设置弧形列表项间距

在初始化列表时，若需在列表项之间添加间距，可以通过[space](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#space)属性实现。例如，为在每个列表项的垂直方向上增加30px的间距。

1. ArcList() {
2.   // ...
3. }
4. .space(LengthMetrics.px(30))

**图4** 设置弧形列表项间距

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.20140801052846355161713283819469:50001231000000:2800:C71A4268588857BF0465E2AB6B0F8B755281B03D53677E7817B1D12DB1FC870C.png)

### 列表项关闭自动缩放

在弧形列表中，列表项默认具有在接近上下两端时自动缩放的效果。然而，在某些情况下，可能不希望有这种缩放效果。此时，可以通过设置[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)的[autoScale](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem#autoscale)属性为false来禁用该效果。例如，如图5所示，“网络”和“显示”两个列表项，在关闭了自动缩放属性后，无论它们所处的位置如何，都不会出现缩放效果。

1. ArcListItem() {
2.   // ...
3. }
4. .autoScale(false)

**图5** 列表项关闭自动缩放

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.54891658114619266525373086840482:50001231000000:2800:4067677822B6AB197E398F4556916DCC7BFD786A26D9E8046535EB40BE6A754D.png)

### 添加内置滚动条

当列表项的高度超过屏幕高度时，弧形列表能够沿垂直方向滚动。若用户需要快速定位，可拖动滚动条以迅速滑动列表，如图6所示。

在使用[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)组件时，可以通过[scrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#scrollbar)属性来控制弧形列表滚动条的显示。scrollBar的取值类型为[BarState](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#barstate)，当设置为BarState.Auto时，表示滚动条将按需显示。在这种模式下，当用户触摸到滚动条区域时，滚动条会显示出来，支持上下拖拽以快速浏览内容，且在拖拽过程中滚动条会变粗。若用户不进行任何操作，滚动条将在2秒后自动消失。此外，还可以通过[scrollBarWidth](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#scrollbarwidth)属性来设置滚动条在按压状态下的宽度，以及通过[scrollBarColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#scrollbarcolor)属性来设置滚动条的颜色。

1. ArcList() {
2.   // ...
3. }
4. .scrollBar(BarState.Auto)
5. .scrollBarWidth(LengthMetrics.px(10))
6. .scrollBarColor(ColorMetrics.resourceColor(Color.White))

**图6** 弧形列表的内置滚动条

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.13001657303403975247646066761395:50001231000000:2800:8D6C0D05FD8F19B1FF6D72222481D54904FD866E2A33DFEE5A7617DA9FEB4C04.gif)

## 添加外置滚动条ArcScrollBar

弧形列表[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)可与[ArcScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-arcscrollbar)组件配合使用，为弧形列表添加外置滚动条。两者通过绑定同一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)滚动控制器对象实现联动。

1. 首先，需要创建一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)类型的对象arcListScroller。
    
    1. private arcListScroller: Scroller = new Scroller();
    
2. 然后，弧形列表通过[scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#arklistoptions)参数绑定滚动控制器。
    
    1. // 将arcListScroller用于初始化ArcList组件的scroller参数，完成arcListScroller与弧形列表的绑定。
    2. ArcList({ scroller: this.arcListScroller }) {
    3. // ...
    4. }
    
3. 最后，弧形滚动条通过[scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-arcscrollbar#arcscrollbaroptions)参数绑定滚动控制器。
    
    1. // 将arcListScroller用于初始化ArcScrollBar组件的scroller参数，完成arcListScroller与滚动条的绑定。
    2. ArcScrollBar({ scroller: this.arcListScroller })
    

**图7** 弧形列表的外置滚动条

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.46458791843358056494413713427061:50001231000000:2800:3BECD0775EEFE5BD4CA6EBD7A5A5228B92BA0ECEFE3A6276B3D72F2A4C58DBBD.gif)

说明

弧形滚动条组件[ArcScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-arcscrollbar)，还可配合其他可滚动组件使用，如[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)、[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)、[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)、[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)。

## 与弧形索引条ArcAlphabetIndexer联动

许多应用需要监测列表的滚动位置变动并作出响应，或通过调整滚动位置实现列表的快速定位。例如，在联系人列表滚动时，当列表滚动至不同首字母开头的联系人，外部索引条应更新至相应的字母位置。当用户选择外部索引条上的索引项时，列表应跳转至对应位置。为此，需使用弧形索引条组件[ArcAlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arc-alphabet-indexer)。

如图8所示，当列表从联系人A滚动到联系人B时，外侧索引条也需要同步从选中A状态变成选中B状态，此场景可以通过监听[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)组件的[onScrollIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#onscrollindex)事件来实现；当点击索引项C时，列表也需要跳转到联系人C，此场景可以通过监听[ArcAlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arc-alphabet-indexer)的[onSelect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arc-alphabet-indexer#onselect)事件来实现。

在列表滚动时，根据列表此时所在的索引值位置firstIndex，重新计算字母索引条对应字母的位置selectedIndex。由于[ArcAlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arc-alphabet-indexer)组件通过[selected](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arc-alphabet-indexer#selected)属性设置了选中项索引值，当selectedIndex变化时会触发[ArcAlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arc-alphabet-indexer)组件重新渲染，从而显示为选中对应字母的状态。

在选中索引项时，根据此时选中项的索引值index，重新计算列表联系人对应的位置，然后通过列表绑定的滚动控制器arcListScroller的[scrollToIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scrolltoindex)方法控制列表跳转到对应的联系人位置。弧形列表[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)可通过[scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#arklistoptions)参数绑定[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)（滚动控制器）。

1. import {
2.   ArcList,
3.   ArcListAttribute,
4.   ArcListItemAttribute,
5.   ArcListItem,
6.   ArcAlphabetIndexer,
7.   ArcAlphabetIndexerAttribute
8. } from '@kit.ArkUI';

9. const alphabets = ['#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K',
10.   'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
11. @Entry
12. @Component
13. struct ContactsArcList {
14.   // 索引条选中项索引
15.   @State selectedIndex: number = 0;
16.   // 列表绑定的滚动控制器
17.   private arcListScroller: Scroller = new Scroller();

18.   build() {
19.     Stack({ alignContent: Alignment.End }) {
20.       ArcList({ scroller: this.arcListScroller }) {
21.         // ...
22.       }
23.       .onScrollIndex((firstIndex: number) => {
24.         // 根据列表滚动到的索引值，重新计算对应索引条的位置this.selectedIndex
25.         this.selectedIndex = firstIndex + 1;
26.       })

27.       // 弧形索引条组件
28.       ArcAlphabetIndexer({ arrayValue: alphabets, selected: this.selectedIndex })
29.         .selected(this.selectedIndex)
30.         .onSelect((index: number) => {
31.           // 选中索引项后，列表跳转到相应位置
32.           this.selectedIndex = index;
33.           this.arcListScroller.scrollToIndex(this.selectedIndex - 1);
34.         })
35.     }
36.   }
37. }

**图8** 弧形列表与弧形索引条联动

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.81384680637637892582444238579580:50001231000000:2800:5A40BF64125C0C4E3EBB945F028773E534DFEB21FC5996BC8095E1FE53E7E4D5.gif)

## 响应列表项侧滑

[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)的[swipeAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem#swipeaction)属性可用于实现列表项的左右滑动功能。[swipeAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem#swipeaction)属性方法初始化时存在必填[SwipeActionOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitem#swipeactionoptions9%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)参数start和end。其中，start表示设置列表项右滑时起始端滑出的组件，end表示设置列表项左滑时尾端滑出的组件。

在联系人列表中，end参数表示设置[ArcListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem)左滑时尾端划出自定义组件，即删除按钮。在初始化end方法时，将滑动列表项的索引传入删除按钮组件，当用户点击删除按钮时，可以根据数据索引来删除列表项对应的数据，从而实现侧滑删除功能。

1. 首先，实现尾端滑出组件的构建。
    
    1. @Builder
    2. itemEnd(item: Contact) {
    3.   // 构建尾端滑出组件
    4.   Button({ type: ButtonType.Circle }) {
    5.     Image($r('app.media.ic_public_delete_filled'))
    6.       .width(20)
    7.       .height(20)
    8.   }
    9.   .backgroundColor(Color.Black)
    10.   .onClick(() => {
    11.     this.getUIContext()?.animateTo({
    12.       duration: 1000,
    13.       curve: Curve.Smooth,
    14.       iterations: 1,
    15.       playMode: PlayMode.Normal,
    16.     }, () => {
    17.       // this.contacts为列表数据源，可根据实际场景构造，indexOf方法可获取将被删除数据在数据源中的索引
    18.       let index = this.contacts.indexOf(item);
    19.       // 从数据源删除指定数据项
    20.       this.contacts.splice(index, 1);
    21.     })
    22.   })
    23. }
    
2. 然后，绑定[swipeAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclistitem#swipeaction)属性到可左滑的ArcListItem上。
    
    1. // 构建ArcList时，通过ForEach基于数据源this.contacts循环渲染ArcListItem
    2. ArcListItem() {
    3.   // ...
    4. }
    5. .swipeAction({
    6.   end: {
    7.     // item为该列表项在数据源this.contacts中对应的数据
    8.     builder: () => { this.itemEnd(item) }
    9.   }
    10. }) // 设置侧滑属性
    

**图9** 侧滑删除列表项

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.13576839123626328589878910480561:50001231000000:2800:649BB4EB3C14CD69F0C68AC796FD2BAEFA046C9F94CABA5461D43D2488219B82.gif)

## 处理长列表

[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)适用于短列表，当构建具有大量列表项的长列表时，如果直接采用循环渲染方式，会一次性加载所有的列表元素，会导致页面启动时间过长，影响用户体验。因此，推荐使用[数据懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)（LazyForEach）方式实现按需迭代加载数据，从而提升列表性能。关于长列表按需加载优化的具体实现可参考[数据懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)章节中的示例。

当使用懒加载方式渲染列表时，为了减少列表滑动时出现白块，[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)组件提供了[cachedCount](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#cachedcount)属性，该属性用于设置列表项缓存数，只在懒加载[LazyForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)中生效。

1. ArcList() {
2.   // ...
3. }.cachedCount(3)

说明

- cachedCount的增加会增大UI的CPU、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。
    
- 列表使用数据懒加载时，除了显示区域的列表项和前后缓存的列表项，其他列表项会被销毁。
    

## 响应旋转表冠

手表设备上弧形列表在获焦的情况下可对旋转表冠做出响应，用户可通过旋转表冠的操作滑动列表，浏览列表项数据。弧形列表可通过下列[焦点控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus)相关属性成为所在页面的默认焦点。

1. ArcList() {
2.   // ...
3. }
4. // 设置弧形列表支持获焦
5. .focusable(true)
6. // 设置弧形列表支持点击获焦
7. .focusOnTouch(true)
8. // 设置弧形列表为所在页面上的默认焦点
9. .defaultFocus(true)

还可以通过[digitalCrownSensitivity](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist#digitalcrownsensitivity)属性设置表冠响应事件的灵敏度，以应对不同量级的列表项数据。列表项数据较多时可以设置更高的响应事件灵敏度，数据较少时可以设置较低的响应事件灵敏度。

1. ArcList() {
2.   // ...
3. }
4. .digitalCrownSensitivity(CrownSensitivity.MEDIUM)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list "创建列表 (List)")
# 创建网格 (Grid/GridItem)

更新时间: 2025-12-16 16:39

## 概述

网格布局是由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。网格布局具有较强的页面均分能力，子组件占比控制能力，是一种重要自适应布局，其使用场景有九宫格图片展示、日历、计算器等。

ArkUI提供了[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)容器组件和子组件[GridItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-griditem)，用于构建网格布局。Grid用于设置网格布局相关参数，GridItem定义子组件相关特征。Grid组件支持使用[条件渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-ifelse)、[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)、[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)等方式生成子组件。

说明

本文仅展示关键代码片段可运行的完整代码请参考[创建网格代码](https://gitcode.com/HarmonyOS_Samples/guide-snippets/tree/master/ArkUIKit/ScrollableComponent/entry/src/main/ets/pages/grid)。。

## 布局与约束

Grid组件为网格容器，其中容器内各条目对应一个GridItem组件，如下图所示。

**图1** Grid与GridItem组件关系

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.24021314366550042154621768994156:50001231000000:2800:5E59644FFDE03DBD96B85B69F4F1A453FD9C0981ED5406E2542CCBB52791C292.png)

说明

Grid的子组件必须是GridItem组件。

网格布局是一种二维布局。Grid组件支持自定义行列数和每行每列尺寸占比、设置子组件横跨几行或者几列，同时提供了垂直和水平布局能力。当网格容器组件尺寸发生变化时，所有子组件以及间距会等比例调整，从而实现网格布局的自适应能力。根据Grid的这些布局能力，可以构建出不同样式的网格布局，如下图所示。

**图2** 网格布局

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.44485549436776276312238161979615:50001231000000:2800:79B89FECA960888FACBBB11B50832283663B8255E927809C996EAB95F52655A8.png)

如果Grid组件设置了宽高属性，则其尺寸为设置值。如果没有设置宽高属性，Grid组件的尺寸默认适应其父组件的尺寸。

Grid组件根据行列数量与占比属性的设置，可以分为三种布局情况：

- 行、列数量与占比同时设置：Grid只展示固定行列数的元素，其余元素不展示，且Grid不可滚动。（推荐使用该种布局方式）
    
- 只设置行、列数量与占比中的一个：元素按照设置的方向进行排布，超出的元素可通过滚动的方式展示。
    
- 行列数量与占比都不设置：元素在布局方向上排布，其行列数由布局方向、单个网格的宽高等多个属性共同决定。超出行列容纳范围的元素不展示，且Grid不可滚动。
    

## 设置排列方式

### 设置行列数量与占比

通过设置行列数量与尺寸占比可以确定网格布局的整体排列方式。Grid组件提供了[rowsTemplate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#rowstemplate)和[columnsTemplate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#columnstemplate)属性用于设置网格布局行列数量与尺寸占比。

rowsTemplate和columnsTemplate属性值是一个由多个空格和'数字+fr'间隔拼接的字符串，fr的个数即网格布局的行或列数，fr前面的数值大小，用于计算该行或列在网格布局宽度上的占比，最终决定该行或列宽度。

**图3** 行列数量占比示例

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.72200559373345464532915916815084:50001231000000:2800:27017A98E2565BAF11DA9D5B4869CFDA492929F4E940087CDD2CFBAF30DA6B03.png)

如上图所示，构建的是一个三行三列的网格布局，其在垂直方向上分为三等份，每行占一份；在水平方向上分为四等份，第一列占一份，第二列占两份，第三列占一份。

只要将rowsTemplate设置为'1fr 1fr 1fr'，同时将columnsTemplate设置为'1fr 2fr 1fr'，即可实现上述网格布局。

1. Grid() {
2.   // ...
3. }
4. .rowsTemplate('1fr 1fr 1fr')
5. .columnsTemplate('1fr 2fr 1fr')

说明

当Grid组件设置了rowsTemplate或columnsTemplate时，Grid的layoutDirection、maxCount、minCount、cellLength属性不生效，属性说明可参考[Grid-属性](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#%E5%B1%9E%E6%80%A7)。

### 设置子组件所占行列数

除了大小相同的等比例网格布局，由不同大小的网格组成不均匀分布的网格布局场景在实际应用中十分常见，如下图所示。在Grid组件中，可以通过创建Grid时传入合适的[GridLayoutOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#gridlayoutoptions10%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)实现如图所示的单个网格横跨多行或多列的场景，其中，irregularIndexes和onGetIrregularSizeByIndex可对仅设置rowsTemplate或columnsTemplate的Grid使用；onGetRectByIndex可对同时设置rowsTemplate和columnsTemplate的Grid使用。

**图4** 不均匀网格布局

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.99321552126163015355919108996718:50001231000000:2800:D14EA0A39E4876715212FAA6F7D824F14EBCD13DCDAA8A469119E0B8C206F028.png)

例如计算器的按键布局就是常见的不均匀网格布局场景。如下图，计算器中的按键“0”和“=”，按键“0”横跨第一、二两列，按键“=”横跨第五、六两行。使用Grid构建的网格布局，其行列标号从0开始，依次编号。

**图5** 计算器

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.63571698047524434578332543533868:50001231000000:2800:75E5DA57DC6C8E5C1F23BEC416481A8523878488D73ECE362625A1E75E5D61F5.png)

在网格中，可以通过onGetRectByIndex返回的[rowStart,columnStart,rowSpan,columnSpan]来实现跨行跨列布局，其中rowStart和columnStart属性表示指定当前元素起始行号和起始列号，rowSpan和columnSpan属性表示指定当前元素的占用行数和占用列数。

所以“0”按键横跨第一列和第二列，“=”按键横跨第五行和第六行，只要将“0”对应onGetRectByIndex的rowStart和columnStart设为6和0，rowSpan和columnSpan设为1和2，将“=”对应onGetRectByIndex的rowStart和columnStart设为5和3，rowSpan和columnSpan设为2和1即可。

1. layoutOptions: GridLayoutOptions = {
2.   regularSize: [1, 1],
3.   onGetRectByIndex: (index: number) => {
4.     if (index == key1) { // key1是“0”按键对应的index
5.       return [6, 0, 1, 2];
6.     } else if (index == key2) { // key2是“=”按键对应的index
7.       return [5, 3, 2, 1];
8.     }
9.     // ...
10.     // 这里需要根据具体布局返回其他item的位置
11.   }
12. }

13. Grid(undefined, this.layoutOptions) {
14.   // ...
15. }
16. .columnsTemplate('1fr 1fr 1fr 1fr')
17. .rowsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')

### 设置主轴方向

使用Grid构建网格布局时，若没有设置行列数量与占比，可以通过[layoutDirection](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#layoutdirection8)设置网格布局的主轴方向，决定子组件的排列方式。此时可以结合[minCount](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#mincount8)和[maxCount](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#maxcount8)属性来约束主轴方向上的网格数量。

**图6** 主轴方向示意图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.06094664440667810922798820612824:50001231000000:2800:596264CA70F8596794F1DF36B2FCE59C297777850E7FD9DD83E6117109AD16A4.png)

当前layoutDirection设置为Row时，先从左到右排列，排满一行再排下一行。当前layoutDirection设置为Column时，先从上到下排列，排满一列再排下一列，如上图所示。此时，将maxCount属性设为3，表示主轴方向上最大显示的网格单元数量为3。

1. Grid() {
2.   // ...
3. }
4. .maxCount(3)
5. .layoutDirection(GridDirection.Row)

说明

- layoutDirection属性仅在不设置rowsTemplate和columnsTemplate时生效，此时元素在layoutDirection方向上排列。
- 仅设置rowsTemplate时，Grid主轴为水平方向，交叉轴为垂直方向。
- 仅设置columnsTemplate时，Grid主轴为垂直方向，交叉轴为水平方向。

## 在网格布局中显示数据

网格布局采用二维布局的方式组织其内部元素，如下图所示。

**图7** 通用办公服务

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.43090971913835433566461880853281:50001231000000:2800:A05FE9901F0FEAF678431A9571EABA2B2F28D7C42BC609DF587D7F0247D7200F.png)

Grid组件可以通过二维布局的方式显示一组GridItem子组件。

1. Grid() {
2.   GridItem() {
3.     Text('会议')
4.       // ...
5.   }

6.   GridItem() {
7.     Text('签到')
8.       // ...
9.   }

10.   GridItem() {
11.     Text('投票')
12.       // ...
13.   }

14.   GridItem() {
15.     Text('打印')
16.       // ...
17.   }
18. }
19. .rowsTemplate('1fr 1fr')
20. .columnsTemplate('1fr 1fr')

对于内容结构相似的多个GridItem，通常更推荐使用ForEach语句中嵌套GridItem的形式，来减少重复代码。

1. @Entry
2. @Component
3. struct OfficeService {
4.   @State services: Array<string> = ['会议', '投票', '签到', '打印'];

5.   build() {
6.     Column() {
7.       Grid() {
8.         ForEach(this.services, (service:string) => {
9.           GridItem() {
10.             Text(service)
11.           }
12.         }, (service:string):string => service)
13.       }
14.       .rowsTemplate(('1fr 1fr') as string)
15.       .columnsTemplate(('1fr 1fr') as string)
16.     }
17.   }
18. }

## 设置行列间距

在两个网格单元之间的网格横向间距称为行间距，网格纵向间距称为列间距，如下图所示。

**图8** 网格的行列间距

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.94017644138234480849656205900857:50001231000000:2800:F5A9C0F646B224F9CF18E9CF6BA3FEC1B3E46C3D245B4A66F0EC4BC6061EF287.png)

通过Grid的[rowsGap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#rowsgap)和[columnsGap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#columnsgap)可以设置网格布局的行列间距。在图5所示的计算器中，行间距为15vp，列间距为10vp。

1. Grid() {
2.   // ...
3. }
4. .columnsGap(10)
5. .rowsGap(15)

## 构建可滚动的网格布局

可滚动的网格布局常用在文件管理、购物或视频列表等页面中，如下图所示。在设置Grid的行列数量与占比时，如果仅设置行、列数量与占比中的一个，即仅设置rowsTemplate或仅设置columnsTemplate属性，网格单元按照设置的方向排列，超出Grid显示区域后，Grid拥有可滚动能力。

**图9** 横向可滚动网格布局

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.81259213165450726624067176644883:50001231000000:2800:DD2E8D7092AAE3C9145BC36C061FC657459C8EC19427C75CDEE61EA50C85E96C.gif)

如果设置的是columnsTemplate，Grid的滚动方向为垂直方向；如果设置的是rowsTemplate，Grid的滚动方向为水平方向。

如上图所示的横向可滚动网格布局，只要设置rowsTemplate属性的值且不设置columnsTemplate属性，当内容超出Grid组件宽度时，Grid可横向滚动进行内容展示。

1. @Entry
2. @Component
3. struct Shopping {
4.   @State services: Array<string> = ['直播', '进口'];

5.   build() {
6.     Column({ space: 5 }) {
7.       Grid() {
8.         ForEach(this.services, (service: string, index) => {
9.           GridItem() {
10.           }
11.           .width('25%')
12.         }, (service:string):string => service)
13.       }
14.       .rowsTemplate('1fr 1fr') // 只设置rowsTemplate属性，当内容超出Grid区域时，可水平滚动。
15.       .rowsGap(15)
16.     }
17.   }
18. }

## 控制滚动位置

与新闻列表的返回顶部场景类似，控制滚动位置功能在网格布局中也很常用，例如下图所示日历的翻页功能。

**图10** 日历翻页

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.41970410649350482841621368532285:50001231000000:2800:25E5525F7FBA387004CFE1378272512BEACF32E55C4AFCEA97E33957285AD7EE.gif)

Grid组件初始化时，可以绑定一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)对象，用于进行滚动控制，例如通过Scroller对象的[scrollPage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scrollpage9)方法进行翻页。

1. private scroller: Scroller = new Scroller();

在日历页面中，用户在点击“下一页”按钮时，应用响应点击事件，通过指定scrollPage方法的参数next为true，滚动到下一页。

1. Column({ space: 5 }) {
2.   Grid(this.scroller) {
3.   }
4.   .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')

5.   Row({ space: 20 }) {
6.     Button('上一页')
7.       .onClick(() => {
8.         this.scroller.scrollPage({
9.           next: false
10.         });
11.       })

12.     Button('下一页')
13.       .onClick(() => {
14.         this.scroller.scrollPage({
15.           next: true
16.         });
17.       })
18.   }
19. }

## 添加外置滚动条

网格组件[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)可与[ScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar)组件配合使用，为网格添加外置滚动条。两者通过绑定同一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)滚动控制器对象实现联动。

1. 首先，需要创建一个[Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#scroller)类型的对象gridScroller。
    
    1. private gridScroller: Scroller = new Scroller();
    
2. 然后，通过[scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#%E6%8E%A5%E5%8F%A3)参数绑定滚动控制器。
    
    1. // gridScroller初始化Grid组件的scroller参数，绑定gridScroller与网格。
    2. Grid({ scroller: this.gridScroller }) {
    3. // ...
    4. }
    
3. 最后，滚动条通过[scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar#scrollbaroptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)参数绑定滚动控制器。
    
    1. // gridScroller初始化ScrollBar组件的scroller参数，绑定gridScroller与滚动条。
    2. ScrollBar({ scroller: this.gridScroller })
    

**图11** 网格的外置滚动条

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.07251619543163102019206742591312:50001231000000:2800:A816F4A3EA04DF198900EC6186097518477F943D31952F64A3BE9A778EAC9D86.gif)

说明

- 滚动条组件[ScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar)，还可配合其他可滚动组件使用，如[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)、[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)、[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)、[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)。
- 在圆形屏幕设备上，[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)可以与弧形滚动条组件[ArcScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-arcscrollbar)配合使用为网格添加弧形外置滚动条，使用方式可参考[创建弧形列表 (ArcList)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-arclist)的[添加外置滚动条ArcScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-arclist#%E6%B7%BB%E5%8A%A0%E5%A4%96%E7%BD%AE%E6%BB%9A%E5%8A%A8%E6%9D%A1arcscrollbar)章节。

## 性能优化

与[长列表的处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list#%E9%95%BF%E5%88%97%E8%A1%A8%E7%9A%84%E5%A4%84%E7%90%86)类似，[循环渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)适用于数据量较小的布局场景，当构建具有大量网格项的可滚动网格布局时，推荐使用[数据懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)方式实现按需迭代加载数据，从而提升网格性能。

关于按需加载优化的具体实现可参考[数据懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)章节中的示例。

当使用懒加载方式渲染网格时，为了更好的滚动体验，减少滑动时出现白块，Grid组件中也可通过[cachedCount](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid#cachedcount)属性设置GridItem的预加载数量，只在懒加载[LazyForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)中生效。

设置预加载数量后，会在Grid显示区域前后各缓存cachedCount*列数个GridItem，超出显示和缓存范围的GridItem会被释放。

1. Grid() {
2.   LazyForEach(this.dataSource, () => {
3.     GridItem() {
4.     }
5.   })
6. }
7. .cachedCount(3)

说明

cachedCount的增加会增大UI的CPU、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。

## 示例代码

- [基于Grid的嵌套混合布局](https://gitcode.com/harmonyos_samples/grid-hybrid)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-arclist "弧形列表 (ArcList)（圆形屏幕推荐使用）")
# 文本概述

更新时间: 2025-12-16 16:38

文本包含用户输入的信息、呈现的文本内容和小图标，这些元素共同构建了用户与系统间的交互界面，提升了操作的便捷性与信息展示的直观性。

开发者可根据实际应用场景选择合适的文本组件进行页面开发。

## 文本显示

主要用于显示静态文本。开发者可以使用Text组件配合Span组件创建文本节点，也可以使用属性字符串（[StyledString](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#styledstring)/[MutableStyledString](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#mutablestyledstring)）节点生成文本信息并接入Text组件。参考[文本显示 (Text/Span)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display)章节。

## 文本输入

当需要在单行输入框（TextInput）或多行输入框（TextArea）中输入纯文本时，应优先考虑使用此文本组件。参考[文本输入 (TextInput/TextArea/Search)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-input)章节。

## 富文本

当需要在编辑框内插入图片或者自定义图标等需求时，应优先考虑使用此文本组件。参考[富文本编辑 (RichEditor)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor)章节。

## 图标小符号

当需要显示小图标时，应优先考虑使用此图标组件。参考[图标小符号 (SymbolGlyph/SymbolSpan)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-symbol)章节。

## 属性字符串

当需要在字符或者段落级别设置文本样式，包括调整字号、添加字体颜色、使文本具备可点击性，以及通过自定义方式绘制文本等场景时，应优先考虑使用属性字符串。参考[属性字符串 (StyledString/MutableStyledString)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-styled-string)章节。

## 图文混排

当需要图片和文字混排的场景，可以使用Span和ImageSpan实现。若需要样式多样的混排效果，可以选择属性字符串实现。参考[图文混排](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-text-image-layout)章节。

## 管理软键盘

当需要控制文本输入组件的软键盘行为，包括弹出、收起键盘时，可以使用软键盘管理功能。参考[管理软键盘](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-manage-keyboard)章节。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-text "使用文本")
# 文本概述

更新时间: 2025-12-16 16:38

文本包含用户输入的信息、呈现的文本内容和小图标，这些元素共同构建了用户与系统间的交互界面，提升了操作的便捷性与信息展示的直观性。

开发者可根据实际应用场景选择合适的文本组件进行页面开发。

## 文本显示

主要用于显示静态文本。开发者可以使用Text组件配合Span组件创建文本节点，也可以使用属性字符串（[StyledString](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#styledstring)/[MutableStyledString](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#mutablestyledstring)）节点生成文本信息并接入Text组件。参考[文本显示 (Text/Span)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display)章节。

## 文本输入

当需要在单行输入框（TextInput）或多行输入框（TextArea）中输入纯文本时，应优先考虑使用此文本组件。参考[文本输入 (TextInput/TextArea/Search)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-input)章节。

## 富文本

当需要在编辑框内插入图片或者自定义图标等需求时，应优先考虑使用此文本组件。参考[富文本编辑 (RichEditor)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor)章节。

## 图标小符号

当需要显示小图标时，应优先考虑使用此图标组件。参考[图标小符号 (SymbolGlyph/SymbolSpan)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-symbol)章节。

## 属性字符串

当需要在字符或者段落级别设置文本样式，包括调整字号、添加字体颜色、使文本具备可点击性，以及通过自定义方式绘制文本等场景时，应优先考虑使用属性字符串。参考[属性字符串 (StyledString/MutableStyledString)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-styled-string)章节。

## 图文混排

当需要图片和文字混排的场景，可以使用Span和ImageSpan实现。若需要样式多样的混排效果，可以选择属性字符串实现。参考[图文混排](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-text-image-layout)章节。

## 管理软键盘

当需要控制文本输入组件的软键盘行为，包括弹出、收起键盘时，可以使用软键盘管理功能。参考[管理软键盘](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-manage-keyboard)章节。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-text "使用文本")
# 文本输入 (TextInput/TextArea/Search)

更新时间: 2025-12-16 16:39

TextInput、TextArea是输入框组件，用于响应用户输入，比如评论区的输入、聊天框的输入、表格的输入等，也可以结合其它组件构建功能页面，例如登录注册页面。具体用法请参考[TextInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput)、[TextArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea)。Search是特殊的输入框组件，称为搜索框，默认样式包含搜索图标。具体用法请参考[Search](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search)。

说明

仅支持单文本样式，若需实现富文本样式，建议使用[RichEditor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor)组件。

## 创建输入框

TextInput是单行输入框，TextArea是多行输入框，Search是搜索框。通过以下接口创建这些组件。

1. TextInput(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextInputController})

2. TextArea(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextAreaController})

3. Search(options?:{placeholder?: ResourceStr, value?: ResourceStr, controller?: SearchController, icon?: string})

- 单行输入框。
    
    1. TextInput()
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.49256247407432080082794518042739:50001231000000:2800:E01A87A8B2BF4EA1F68CEEAD6383AE08B0975DE0B813E2D38F9168AA4960A650.png)
    
- 多行输入框。
    
    1. TextArea()
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.82033875001981516158717025657648:50001231000000:2800:81E8A85607F76D93A81094CC28B831D58F3AC8C788AEB77F4627528345B43FFA.png)
    
- 多行输入框文字超出一行时会自动折行。
    
    1. TextArea({ text: "我是TextArea我是TextArea我是TextArea我是TextArea" }).width(300)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.32505034361648005834185572327259:50001231000000:2800:01560E509ABF648A18F187CD7A8873E3DA338245319E3E133BFDD48B9D2167C3.png)
    
- 搜索框。
    
    1. Search()
    2.   .searchButton('搜索')
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.00199553668056612770776905950448:50001231000000:2800:4FEBF2496798EDA64A3BC597E20B3FD6BB9309BB9E3196D030DCD10595A8A87F.png)
    

## 设置输入框类型

TextInput、TextArea和Search都支持设置输入框类型，通过type属性进行设置，但是各组件的枚举值略有不同。下面以单行输入框为例进行说明。

TextInput有以下类型可选择：Normal基本输入模式、Password密码输入模式、Email邮箱地址输入模式、Number纯数字输入模式、PhoneNumber电话号码输入模式、USER_NAME用户名输入模式、NEW_PASSWORD新密码输入模式、NUMBER_PASSWORD纯数字密码输入模式、NUMBER_DECIMAL带小数点的数字输入模式、带URL的输入模式。通过[type](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#type)属性进行设置：

### 基本输入模式（默认类型）

1. TextInput()
2.   .type(InputType.Normal)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.64350576780059065554081969301020:50001231000000:2800:BB8D59D84E3F212F080842CA8170149D88AEAC09B00B110A788BAFEC93E60C29.png)

### 密码模式

包括Password密码输入模式、NUMBER_PASSWORD纯数字密码模式、NEW_PASSWORD新密码输入模式。

以下示例是Password密码输入模式的输入框。

1. TextInput()
2.   .type(InputType.Password)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.20995608841212212462238294545702:50001231000000:2800:FDEF3AC6AC56F0024696085BE6345C579606A614D810CF19C5C06D09BD7BAD75.png)

### 邮箱地址输入模式

邮箱地址输入模式的输入框，只能存在一个@符号。

1. TextInput()
2.   .type(InputType.Email)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.40017960526834457016968009817214:50001231000000:2800:E4F574776758BD5025FC287582289FE485E0A5BE5AACFA0A4AE55481EECF2120.png)

### 纯数字输入模式

纯数字输入模式的输入框，只能输入数字[0-9]。

1. TextInput()
2.   .type(InputType.Number)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.52628745634416234036163555864035:50001231000000:2800:3DF1E0D0658612FC0B1284EA5E446EFE5E0DE792355DDC1272CB0B0FF3A3B999.png)

### 电话号码输入模式

电话号码输入模式的输入框，支持输入数字、空格、+ 、-、*、#、(、)，长度不限。

1. TextInput()
2.   .type(InputType.PhoneNumber)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.29895754731293128622280969369574:50001231000000:2800:F9DDD64D846E40FFBCF3FBCAB8C541AE0B3EE97C623BBBD14C31B44878755A19.png)

### 带小数点的数字输入模式

带小数点的数字输入模式的输入框，只能输入数字[0-9]和小数点，只能存在一个小数点。

1. TextInput()
2.   .type(InputType.NUMBER_DECIMAL)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.30014842432308313845241275779016:50001231000000:2800:0DC371045BBA503E4DF7F346860B3BAFA9CE57B6ACB4BF94390676E3CFC53933.png)

### 带URL的输入模式

带URL的输入模式，无特殊限制。

1. TextInput()
2.   .type(InputType.URL)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163939.74020395454810336731609631079244:50001231000000:2800:D700588839F6F62F6EFF3DE32497EB300B2FBDB3A9121C0B3409C7FD6AED8AA1.png)

## 设置输入框多态样式

TextInput、TextArea支持设置输入框多态样式，通过[style](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea#style10)属性进行设置。下面以多行输入框TextArea为例进行说明。

TextArea有以下2种类型可选择：默认风格，入参是TextContentStyle.DEFAULT；内联模式，也称内联输入风格，入参是TextContentStyle.INLINE。

### 默认风格

默认风格的输入框，在编辑态和非编辑态，样式没有区别。

1. TextArea()
2.   .style(TextContentStyle.DEFAULT)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.17503947013176001592574475468711:50001231000000:2800:B8405F297B01E34CD51AEFFBF0B93642CDF8ABDFE5294684EC8587C5F55B9181.gif)

### 内联模式

内联模式，也称内联输入风格。内联模式的输入框在编辑态和非编辑态样式有明显区分。

1. TextArea()
2.   .style(TextContentStyle.INLINE)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.29078487521650837268669964613553:50001231000000:2800:1E22AC3644CAD00E6CB54AB576A73577F8C3EA9D67C9272AF2E81FC8DC1A6396.gif)

## 自定义样式

- 设置无输入时的提示文本。
    
    1. TextInput({ placeholder: '我是提示文本' })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.21970069132746764314845813867371:50001231000000:2800:D59C6274FF20F66E9D730C9108FEEB938CE42F5B41E33428754B5CA2E9E20C94.png)
    
- 设置输入框当前的文本内容。
    
    1. TextInput({ placeholder: '我是提示文本', text: '我是当前文本内容' })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.22161395397803695097333096837442:50001231000000:2800:57E3E073D30382FE2E767DE99ACDF70AF4B4A47697A064C431C67455D495E6B5.png)
    
- 添加backgroundColor改变输入框的背景颜色。
    
    1. TextInput({ placeholder: '我是提示文本', text: '我是当前文本内容' })
    2.   .backgroundColor(Color.Pink)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.46605054176987391045033582102856:50001231000000:2800:306A7BE20D39D37146409C6E96B3C2B1ECF37EA892E9276F90E38CEBFC43C0F9.png)
    
    更丰富的样式可以结合[通用属性](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-component-general-attributes)实现。
    

## 添加事件

文本框主要用于获取用户输入的信息，并将信息处理成数据进行上传，绑定onChange事件可以获取输入框内改变的文本内容，绑定onSubmit事件可以获取回车提交的文本信息，绑定onTextSelectionChange事件可以获取文本选中时手柄的位置信息或者编辑时光标的位置信息等等。用户也可以使用通用事件进行相应的交互操作。

说明

在密码模式下，设置showPassword属性时，在onSecurityStateChange回调中，建议增加状态同步，具体详见如下示例。

onWillInsert、onDidInsert、onWillDelete、onDidDelete回调仅支持系统输入法的场景。

[onWillChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#onwillchange15)的回调时序晚于onWillInsert、onWillDelete，早于onDidInsert、onDidDelete。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State text: string = '';
6.   @State textStr1: string = '';
7.   @State textStr2: string = '';
8.   @State textStr3: string = '';
9.   @State textStr4: string = '';
10.   @State textStr5: string = '';
11.   @State textStr6: string = '';
12.   @State textStr7: string = '';
13.   @State textStr8: string = '';
14.   @State textStr9: string = '';
15.   @State passwordState: boolean = false;
16.   controller: TextInputController = new TextInputController();

17.   build() {
18.     Row() {
19.       Column() {
20.         Text(`${this.textStr1}\n${this.textStr2}\n${this.textStr3}
21.         \n${this.textStr4}\n${this.textStr5}\n${this.textStr6}
22.         \n${this.textStr7}\n${this.textStr8}\n${this.textStr9}`)
23.           .fontSize(20)
24.         TextInput({ text: this.text, placeholder: 'input your word...', controller: this.controller })
25.           .type(InputType.Password)
26.           .showPassword(this.passwordState)
27.           .onChange((value: string) => {
28.             // 文本内容发生变化时触发该回调
29.             console.info('onChange is triggering: ', value);
30.             this.textStr1 = `onChange is triggering: ${value}`;
31.           })
32.           .onSubmit((enterKey: EnterKeyType, event: SubmitEvent) => {
33.             // 按下输入法回车键时触发该回调
34.             console.info('onSubmit is triggering: ', enterKey, event.text);
35.             this.textStr2 = `onSubmit is triggering: ${enterKey} ${event.text}`;
36.           })
37.           .onTextSelectionChange((selectionStart: number, selectionEnd: number) => {
38.             // 文本选择的位置发生变化或编辑状态下光标位置发生变化时，触发该回调
39.             console.info('onTextSelectionChange is triggering: ', selectionStart, selectionEnd);
40.             this.textStr3 = `onTextSelectionChange is triggering: ${selectionStart} ${selectionEnd}`;
41.           })
42.           .onSecurityStateChange((isShowPassword: boolean) => {
43.             // 密码显隐状态切换时，触发该回调
44.             console.info('onSecurityStateChange is triggering: ', isShowPassword);
45.             this.passwordState = isShowPassword;
46.             this.textStr4 = `onSecurityStateChange is triggering: ${isShowPassword}`;
47.           })
48.           .onWillInsert((info: InsertValue) => {
49.             // 在将要输入时，触发该回调
50.             console.info('onWillInsert is triggering: ', info.insertValue, info.insertOffset);
51.             this.textStr5 = `onWillInsert is triggering: ${info.insertValue} ${info.insertOffset}`;
52.             return true;
53.           })
54.           .onDidInsert((info: InsertValue) => {
55.             // 在输入完成时，触发该回调
56.             console.info('onDidInsert is triggering: ', info.insertValue, info.insertOffset);
57.             this.textStr6 = `onDidInsert is triggering: ${info.insertValue} ${info.insertOffset}`;
58.           })
59.           .onWillDelete((info: DeleteValue) => {
60.             // 在将要删除时，触发该回调
61.             console.info('onWillDelete is triggering: ', info.deleteValue, info.deleteOffset);
62.             this.textStr7 = `onWillDelete is triggering: ${info.deleteValue} ${info.deleteOffset}`;
63.             return true;
64.           })
65.           .onDidDelete((info: DeleteValue) => {
66.             // 在删除完成时，触发该回调
67.             console.info('onDidDelete is triggering: ', info.deleteValue, info.deleteOffset);
68.             this.textStr8 = `onDidDelete is triggering: ${info.deleteValue} ${info.deleteOffset}`;
69.           })
70.           .onFocus(() => {
71.             // 绑定通用事件，输入框获焦时触发该回调
72.             console.info('onFocus is triggering')
73.             this.textStr9 = `onFocus is triggering`;
74.           })
75.       }.width('100%')
76.     }
77.     .height('100%')
78.   }
79. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.59307252392501740357168446213505:50001231000000:2800:ED0E52BAF39F29C5B03C17104E71AFBA36A99503B45FEE5C2D3F6EEE5AB4738A.gif)

## 选中菜单

输入框中的文字被选中时会弹出包含剪切、复制、翻译、分享的菜单。

TextInput:

1. TextInput({text : '这是一段文本，用来展示选中菜单'})

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.45200094163073815991436063178897:50001231000000:2800:3993E4CA36F1D9E92AC70B130B4E90754C2672A7CBB5A9CBF07BDC9E7B64E988.jpg)

TextArea:

1. TextArea({text : '这是一段文本，用来展示选中菜单'})

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.90835637805818678407694952524192:50001231000000:2800:4ABC25902C9DAC9A911CA2E78F788A93322BCD07FC1BBF6C7DBEE44B2FB18648.jpg)

## 禁用系统服务类菜单

从API version 20开始，支持使用[disableSystemServiceMenuItems](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-textmenucontroller#disablesystemservicemenuitems20)方法屏蔽文本选择菜单中的所有系统服务菜单项。

1. import { TextMenuController } from '@kit.ArkUI';

2. // xxx.ets
3. @Entry
4. @Component
5. struct Index {
6.   aboutToAppear(): void {
7.     // 禁用所有系统服务菜单项
8.     TextMenuController.disableSystemServiceMenuItems(true)
9.   }

10.   aboutToDisappear(): void {
11.     // 页面消失时恢复系统服务菜单项
12.     TextMenuController.disableSystemServiceMenuItems(false)
13.   }

14.   build() {
15.     Row() {
16.       Column() {
17.         TextInput({ text: "这是一个TextInput，长按弹出文本选择菜单" })
18.           .height(60)
19.           .fontStyle(FontStyle.Italic)
20.           .fontWeight(FontWeight.Bold)
21.           .textAlign(TextAlign.Center)
22.           .caretStyle({ width: '4vp' })
23.           .editMenuOptions({
24.             onCreateMenu: (menuItems: Array<TextMenuItem>) => {
25.               // menuItems不包含被屏蔽的系统菜单项
26.               return menuItems
27.             },
28.             onMenuItemClick: (menuItem: TextMenuItem, textRange: TextRange) => {
29.               return false
30.             }
31.           })
32.       }.width('100%')
33.     }
34.     .height('100%')
35.   }
36. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.33792302472739764054339061821890:50001231000000:2800:4A6D10558E50F9D46FBCF15718A91886BF05B86D0B2FBAFD48CAC89EA77B4AA1.gif)

从API version 20开始，支持使用[disableMenuItems](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-textmenucontroller#disablemenuitems20)方法屏蔽文本选择菜单中指定的系统服务菜单项。

1. import { TextMenuController } from '@kit.ArkUI';

2. // xxx.ets
3. @Entry
4. @Component
5. struct Index {
6.   aboutToAppear(): void {
7.     // 禁用搜索和翻译
8.     TextMenuController.disableMenuItems([TextMenuItemId.SEARCH, TextMenuItemId.TRANSLATE])
9.   }

10.   aboutToDisappear(): void {
11.     // 页面消失时恢复系统服务菜单项
12.     TextMenuController.disableMenuItems([])
13.   }

14.   build() {
15.     Row() {
16.       Column() {
17.         TextInput({ text: "这是一个TextInput，长按弹出文本选择菜单" })
18.           .height(60)
19.           .fontStyle(FontStyle.Italic)
20.           .fontWeight(FontWeight.Bold)
21.           .textAlign(TextAlign.Center)
22.           .caretStyle({ width: '4vp' })
23.           .editMenuOptions({
24.             onCreateMenu: (menuItems: Array<TextMenuItem>) => {
25.                 // menuItems不包含搜索和翻译
26.                 return menuItems;
27.             },
28.             onMenuItemClick: (menuItem: TextMenuItem, textRange: TextRange) => {
29.                 return false
30.             }
31.           })
32.       }.width('100%')
33.     }
34.     .height('100%')
35.   }
36. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.62868419598056400110642493247739:50001231000000:2800:76CE7E3DB3B93F4F8C48161A87A2F1C5ADAD734E061F72DAEBD6E652DFF32C16.gif)

## 自动填充

输入框可以通过[contentType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#contenttype12)属性设置自动填充类型。

支持的类型请参考[ContentType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#contenttype12%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)。

1. TextInput({ placeholder: '输入你的邮箱...' })
2.   .width('95%')
3.   .height(40)
4.   .margin(20)
5.   .contentType(ContentType.EMAIL_ADDRESS)

## 设置属性

- 设置省略属性。
    
    输入框可以通过[ellipsisMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#ellipsismode18)属性设置省略位置。
    
    ellipsisMode属性需要配合overflow设置为TextOverflow.Ellipsis使用，单独设置ellipsisMode属性不生效。
    
    1. TextInput({ text: '这是一段文本，用来展示省略模式'})
    2.   .textOverflow(TextOverflow.Ellipsis)
    3.   .ellipsisMode(EllipsisMode.END)
    4.   .style(TextInputStyle.Inline)
    5.   .fontSize(30)
    6.   .margin(30)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.47067179978884268199169087851752:50001231000000:2800:949E5A856E7C32F0B47A1B812D4F68C84C1A6491DAFBDBCD66DFD4006226BB87.jpg)
    
- 设置文本描边属性。
    
    从API version 20开始，输入框可以通过[strokeWidth](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#strokewidth20)和[strokeColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#strokecolor20)属性设置文本的描边宽度及颜色。
    
    1. TextInput({ text: 'Text with stroke' })
    2.   .width('100%')
    3.   .height(60)
    4.   .borderWidth(1)
    5.   .fontSize(40)
    6.   .strokeWidth(LengthMetrics.px(3.0))
    7.   .strokeColor(Color.Red)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.41753905676514721867130363094934:50001231000000:2800:4A4B42C7971DB33821ADDEFCAFBBBA87687DF7684011D31B9A778C7BE69BFA6D.jpg)
    

## 设置文本行间距

从API version 20开始，支持通过[lineSpacing](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#linespacing20)设置文本的行间距。如果不配置[LineSpacingOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-text-common#linespacingoptions20%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)时，首行上方和尾行下方默认会有行间距。如果onlyBetweenLines设置为true时，行间距仅适用于行与行之间，首行上方无额外行间距。

1. TextArea({
2.         text: 'The line spacing of this TextArea is set to 20_px, and the spacing is effective only between the lines.'
3.       })
4.         .fontSize(22)
5.         .lineSpacing(LengthMetrics.px(20), { onlyBetweenLines: true })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.86890763296991788076233715581655:50001231000000:2800:75FC425D75E166D2774F5E48E090929897C612FA272043986248B744AAA26D10.jpg)

## 键盘避让

键盘抬起后，具有滚动能力的容器组件在横竖屏切换时，才会生效键盘避让，若希望无滚动能力的容器组件也生效键盘避让，建议在组件外嵌套一层具有滚动能力的容器组件，比如[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)、[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)、[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   placeHolderArr: string[] = ['1', '2', '3', '4', '5', '6', '7'];

6.   build() {
7.     Scroll() {
8.       Column() {
9.         ForEach(this.placeHolderArr, (placeholder: string) => {
10.           TextInput({ placeholder: 'TextInput ' + placeholder })
11.             .margin(30)
12.         })
13.       }
14.     }
15.     .height('100%')
16.     .width('100%')
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163940.50180656258994685789465590774154:50001231000000:2800:06D14CC6164686076C2868DF1AC42091D23D3439B7B624D7EEF2D3FCFE9695B6.gif)

## 光标避让

[keyBoardAvoidMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-e#keyboardavoidmode11)枚举中的OFFSET和RESIZE在键盘抬起后，不支持二次避让。如果想要支持光标位置在点击或者通过接口设置变化后发生二次避让，可以考虑使用OFFSET_WITH_CARET和RESIZE_CARET替换原有的OFFSET和RESIZE模式。

对于滚动容器更推荐使用RESIZE_WITH_CARET，非滚动容器应该使用OFFSET_WITH_CARET。

1. // EntryAbility.ets
2. import { KeyboardAvoidMode } from '@kit.ArkUI';

3. // Used in UIAbility
4. onWindowStageCreate(windowStage: window.WindowStage) {
5.   // Main window is created, set main page for this ability
6.   hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

7.   windowStage.loadContent('pages/Index', (err, data) => {
8.     let keyboardAvoidMode = windowStage.getMainWindowSync().getUIContext().getKeyboardAvoidMode();
9.   windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET_WITH_CARET);
10.     if (err.code) {
11.       hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
12.       return;
13.     }
14.     hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
15.   });
16. }

17. // xxx.ets
18. @Entry
19. @Component
20. struct Index {
21.   @State caretPosition: number = 600;
22.   areaController: TextAreaController = new TextAreaController();
23.   text = "Most of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\
24.   So the best way to destroy happiness is to look at something and focus on even the smallest flaw. It is the smallest flaw that would make us complain. And it is the complaint that leads to us becoming unhappy.\
25.   If one chooses to be happy, he will be blessed; if he chooses to be unhappy, he will be cursed. Happiness is just what you think will make you happy.Most of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\
26.   ";

27.   build() {
28.     Scroll() {
29.       Column() {
30.         Row() {
31.           Button('CaretPosition++: ' + this.caretPosition).onClick(() => {
32.             this.caretPosition += 1;
33.           }).fontSize(10)
34.           Button('CaretPosition--: ' + this.caretPosition).onClick(() => {
35.             this.caretPosition -= 1;
36.           }).fontSize(10)
37.           Button('SetCaretPosition: ').onClick(() => {
38.             this.areaController.caretPosition(this.caretPosition);
39.           }).fontSize(10)
40.         }

41.         TextArea({ text: this.text, controller: this.areaController })
42.           .width('100%')
43.           .fontSize('20fp')
44.       }
45.     }.width('100%').height('100%')
46.   }
47. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163941.80474867746179708975851237479196:50001231000000:2800:ACF74C73DA98359C3851F0543CC3B8E6C9FE0822BC610F363A3DBAA2A1DAA780.gif)

## 常见问题

### 如何设置TextArea的文本最少展示行数并自适应高度

**问题现象**

设置TextArea的初始高度来控制最少文本展示行数，当输入文本超过初始高度时，TextArea的高度自适应。

**解决措施**

设置[minLines](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea#minlines20)（从API version 20开始），或者设置height为"auto"，并使用[constraintSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-size#constraintsize)自行计算高度。

1. import { MeasureUtils } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct TextExample {
5.   private textAreaPadding = 12;
6.   private setMaxLines = 3;
7.   @State fullText: string = "我是TextArea";
8.   @State originText: string = "我是TextArea";
9.   @State uiContext: UIContext = this.getUIContext();
10.   @State uiContextMeasure: MeasureUtils = this.uiContext.getMeasureUtils();
11.   textSize: SizeOptions = this.uiContextMeasure.measureTextSize({
12.     textContent: this.originText,
13.     fontSize: 18
14.   });

15.   build() {
16.     Column() {
17.       TextArea({ text: "minLines: " + this.fullText })
18.         .fontSize(18)
19.         .width(300)
20.         .minLines(3)

21.       Blank(50)

22.       TextArea({ text: "constraintSize: " + this.fullText })
23.         .fontSize(18)
24.         .padding({ top: this.textAreaPadding, bottom: this.textAreaPadding })
25.         .width(300)
26.         .height("auto")
27.         .constraintSize({
28.           // 结合padding计算，设置至少显示this.setMaxLines行文本
29.           // 若涉及适老化字号缩放，需要监听并调整高度
30.           minHeight: this.textAreaPadding * 2 +
31.             this.setMaxLines * this.getUIContext().px2vp(Number(this.textSize.height))
32.         })

33.       Blank(50)

34.       Button("增加输入")
35.         .onClick(() => {
36.           this.fullText += "我是TextArea";
37.         })
38.     }
39.     .justifyContent(FlexAlign.Center)
40.     .width('100%')
41.     .padding({ top: 30 })
42.   }
43. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163941.38843724245845841682054244841566:50001231000000:2800:FF7CDAE94FB92E64EE223DC4CCEBAEE1AB076F7A6690B2D9EC87600A831B80FE.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display "文本显示 (Text/Span)")
# 富文本编辑（RichEditor）

更新时间: 2025-12-16 16:39

RichEditor是支持图文混排和文本交互式编辑的组件，通常用于响应用户对图文混合内容的输入操作，例如可以输入图文的评论区。具体用法参考[RichEditor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor)。

对于仅需图文展示而不需要编辑的场景，推荐使用[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)组件。

对于需要大量展示Html格式内容的场景，推荐使用[RichText](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richtext)组件。

## 组件构成

下图展示了组件元素的构成。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.26152459925663928213938439615493:50001231000000:2800:13EEAF84A763DC0FC97488D0AA0F6B64F1FFB678A8265FB4B77BCB7F27C3C418.jpg)

组件的元素构成包括：

|元素|说明|
|:--|:--|
|内容区|内容可显示的区域。|
|光标|用于指明当前输入位置。|
|手柄|分为左手柄和右手柄，可分别进行拖动，用于调整文本选择区域范围。|
|菜单|选中内容后弹出，其中包含复制、粘贴等内容操作按钮。|

## 创建RichEditor组件

开发者可以[创建基于属性字符串进行内容管理的RichEditor组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%9A%84richeditor%E7%BB%84%E4%BB%B6)或[创建基于Span进行内容管理的RichEditor组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Espan%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%9A%84richeditor%E7%BB%84%E4%BB%B6)。

### 创建基于属性字符串进行内容管理的RichEditor组件

使用RichEditor(options: [RichEditorStyledStringOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorstyledstringoptions12))接口可以创建基于属性字符串（[StyledString/MutableStyledString](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-styled-string)）进行内容管理的RichEditor组件。这种构建方式开发者可以通过在应用侧持有属性字符串对象来管理数据，通过修改属性字符串对象的内容、样式，再传递给组件，即可实现对富文本组件内容的更新。

相比于使用controller提供的接口进行内容样式更新，使用起来更加灵活便捷。同时属性字符串对象可以设置到各类支持属性字符串的文本组件中，可以快速实现内容的迁移。

1. fontStyle: TextStyle = new TextStyle({
2.   fontColor: Color.Pink
3. });
4. // 定义字体样式对象

5. mutableStyledString: MutableStyledString = new MutableStyledString("创建使用属性字符串构建的RichEditor组件。",
6.   [{
7.     start: 0,
8.     length: 5,
9.     styledKey: StyledStringKey.FONT,
10.     styledValue: this.fontStyle
11.   }]);
12. // 创建属性字符串

13. controller: RichEditorStyledStringController = new RichEditorStyledStringController();
14. options: RichEditorStyledStringOptions = { controller: this.controller };

15. RichEditor(this.options)
16.   .onReady(() => {
17.     this.controller.setStyledString(this.mutableStyledString);
18.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.82419640226368923369194644039825:50001231000000:2800:CC991A311E7CC6E0AEFE0963A0A1BD06586B8D1D1E0578FF5EE6B1F1E8008DE4.gif)

### 创建基于Span进行内容管理的RichEditor组件

使用RichEditor(value: [RichEditorOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditoroptions))接口可以创建基于Span进行内容管理的RichEditor组件，通常用于复杂内容场景，开发者通过RichEditorController提供的接口实现内容、样式的管理。

1. @Entry
2. @Component
3. struct create_rich_editor {
4.   controller: RichEditorController = new RichEditorController();
5.   options: RichEditorOptions = { controller: this.controller };

6.   build() {
7.     Column() {
8.       Column() {
9.         RichEditor(this.options)
10.           .onReady(() => {
11.             this.controller.addTextSpan('创建不使用属性字符串构建的RichEditor组件。', {
12.               style: {
13.                 fontColor: Color.Black,
14.                 fontSize: 15
15.               }
16.             })
17.           })
18.       }.width('100%')
19.     }.height('100%')
20.   }
21. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.75240958404250269911738605755454:50001231000000:2800:FC394429B6F5FF7CA0F444B4C412208340515C262398FB6568EEA0906E06E185.gif)

## 添加内容

富文本组件可以通过不同的接口添加多种形式的内容。

### 添加文本内容

除了直接在组件内输入内容，也可以通过[addTextSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addtextspan)添加文本内容。

此接口可以实现文本样式多样化，例如创建混合样式文本。

如果组件是获焦状态并且光标在闪烁，那么通过addTextSpan添加文本内容后，光标位置会更新，在新添加文本内容的右侧闪烁。

1. @Entry
2. @Component
3. struct add_text_span {
4.   controller: RichEditorController = new RichEditorController();
5.   options: RichEditorOptions = { controller: this.controller };

6.   build() {
7.     Column() {
8.       RichEditor(this.options)
9.         .onReady(() => {
10.           this.controller.addTextSpan('点击按钮在此处添加text。', {
11.             style: {
12.               fontColor: Color.Black,
13.               fontSize: 15
14.             }
15.           })
16.         })
17.         .border({ width: 1, color: Color.Gray })
18.         .constraintSize({
19.           maxHeight: 100
20.         })
21.         .width(300)
22.         .margin(10)
23.       Button('addTextSpan', {
24.         buttonStyle: ButtonStyleMode.NORMAL
25.       })
26.         .height(30)
27.         .fontSize(13)
28.         .onClick(() => {
29.           this.controller.addTextSpan('新添加一段文字。')
30.         })
31.     }
32.   }
33. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.98861688495317793885499631189629:50001231000000:2800:7E179EA8BB86D8E284B50E682CA3C035274C3D23E0B418A0405864A0D0ED86F3.gif)

### 添加图片内容

通过[addImageSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addimagespan)添加图片内容。

此接口可用于内容丰富与可视化展示，例如在新闻中加入图片，在文档中加入数据可视化图形等。

如果组件是获焦状态并且光标在闪烁，那么通过addImageSpan添加图片内容后，光标位置会更新，在新添加图片内容的右侧闪烁。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮在此处添加image。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(100)
14. Button('addImageSpan', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.addImageSpan($r("app.media.startIcon"), {
21.       imageStyle: {
22.         size: ["57px", "57px"]
23.       }
24.     })
25.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.41414198914518650962732222472769:50001231000000:2800:94D6E315CFBA54E5094B9689723185A1569D660FF62487E53302970A2B06D135.gif)

### 添加@Builder装饰器修饰的内容

通过[addBuilderSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addbuilderspan11)添加@Builder装饰器修饰的内容。

此接口可用于自定义复杂组件的嵌入，例如在组件内加入自定义图表。

该接口内可通过[RichEditorBuilderSpanOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorbuilderspanoptions11)设置在组件中添加builder的位置，省略或者为异常值时，则添加builder到所有内容的最后位置。

1. private my_builder: CustomBuilder = undefined

2. @Builder
3. TextBuilder() {
4.   Row() {
5.     Image($r('app.media.startIcon')).width(50).height(50).margin(16)
6.     Column() {
7.       Text("文本文档.txt").fontWeight(FontWeight.Bold).fontSize(16)
8.       Text("123.45KB").fontColor('#8a8a8a').fontSize(12)
9.     }.alignItems(HorizontalAlign.Start)
10.   }.backgroundColor('#f4f4f4')
11.   .borderRadius("20")
12.   .width(220)
13. }

14. controller: RichEditorController = new RichEditorController();
15. options: RichEditorOptions = { controller: this.controller };

16. Button('addBuilderSpan', {
17.   buttonStyle: ButtonStyleMode.NORMAL
18. })
19.   .height(30)
20.   .fontSize(13)
21.   .onClick(() => {
22.     this.my_builder = () => {
23.       this.TextBuilder()
24.     }
25.     this.controller.addBuilderSpan(this.my_builder)
26.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.26402702766026237204146767501487:50001231000000:2800:A8F157C99411FC0509FBD035C7A0B340BD83D0FF2C421957E670430A95B638AF.gif)

### 添加SymbolSpan内容

可通过[addSymbolSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addsymbolspan11)添加Symbol内容。此接口可用于特殊符号的添加，例如在编辑学术论文时，此接口可用于添加各种数学符号。

添加Symbol内容时，如果组件是获焦状态并且光标在闪烁，那么添加Symbol后，光标将移动到新插入Symbol的右侧。

Symbol内容暂不支持手势、复制、拖拽处理。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮在此处添加symbol。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(100)
14. Button('addSymbolSpan', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.addSymbolSpan($r("sys.symbol.basketball_fill"), {
21.       style: {
22.         fontSize: 30
23.       }
24.     })
25.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.78332160712042792482973248045201:50001231000000:2800:310256CDC829867F61601176D1F3F8F9E13A543157F730E7718EB58C5C73A3F0.gif)

## 管理内容

富文本组件可以通过接口对内容进行管理，例如[获取组件内的图文信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%86%85%E5%9B%BE%E6%96%87%E4%BF%A1%E6%81%AF)、[设置无输入时的提示文本](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E8%AE%BE%E7%BD%AE%E6%97%A0%E8%BE%93%E5%85%A5%E6%97%B6%E7%9A%84%E6%8F%90%E7%A4%BA%E6%96%87%E6%9C%AC)或[设置组件内容的最大字符数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6)。

### 获取组件内图文信息

可通过[getSpans](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#getspans)获取组件内所有图文内容的信息，包括图文的内容、id、样式、位置等信息。获取内容位置信息后，可对指定范围内容进行样式的更新。

此接口适用于已有的内容样式获取与检查，例如在模板应用场景下，可利用此接口获取文本样式。此外，它还适用于内容解析与处理，例如在文本分析应用中，此接口能够获取特定范围内的文本信息。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller }
3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController }
5. // 创建两个富文本组件

6. RichEditor(this.options)
7.   .onReady(() => {
8.     this.controller.addTextSpan('点击按钮获取此处span信息。', {
9.       style: {
10.         fontColor: Color.Black,
11.         fontSize: 15
12.       }
13.     })
14.   })
15.   .width(300)
16.   .height(50)
17. Text('查看getSpans返回值：').fontSize(10).fontColor(Color.Gray).width(300)
18. RichEditor(this.infoShowOptions)
19.   .width(300)
20.   .height(50)
21. Button('getSpans', {
22.   buttonStyle: ButtonStyleMode.NORMAL
23. })
24.   .height(30)
25.   .fontSize(13)
26.   .onClick(() => {
27.     this.infoShowController.addTextSpan(JSON.stringify(this.controller.getSpans()), {
28.       style: {
29.         fontColor: Color.Gray,
30.         fontSize: 10
31.       }
32.     })
33.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.32869162833464656263234733086120:50001231000000:2800:91172C839B8FF5A6CF8BFE6646CB1DFB9E193AADB8E6CE4F37ED3F41EC6D9DC5.gif)

### 设置无输入时的提示文本

通过[placeholder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#placeholder12)设置无输入时的提示文本。

例如，在用户登录界面采用提示文本，有助于用户区分用户名与密码的输入框。又如，在文本编辑框中，使用提示文本明确输入要求，如“限输入100字以内”，以此指导用户正确操作。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .placeholder("此处为提示文本...", {
5.     fontColor: Color.Gray,
6.     font: {
7.       size: 15,
8.       weight: FontWeight.Normal,
9.       family: "HarmonyOS Sans",
10.       style: FontStyle.Normal
11.     }
12.   })
13.   .width(300)
14.   .height(50)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.71177851725325544863422739634388:50001231000000:2800:75BFC5AB3B20BDDF2A124A61B7B83391ABA5887B070754FE7E6CCDABA84500FA.gif)

### 设置最大长度

通过[maxLength](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#maxlength18)可以设置富文本的最大可输入字符数。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .placeholder('组件设置了最大字符数：7')
5.   .onReady(() => {})
6.   .maxLength(7)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.72698512129538117943096130734673:50001231000000:2800:732C59891B0D6E0716E95EC52C35F4C8F08A573C5EEF4F8518B4882A30292D42.gif)

## 事件回调

开发者可以通过注册事件回调，感知组件事件的触发。

### 添加图文变化前和图文变化后可触发的回调

通过[onWillChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#onwillchange12)添加图文变化前可触发的回调。此回调适用于用户实时数据校验与提醒，例如在用户输入文本时，可在回调内实现对输入内容的检测，若检测到敏感词汇，应立即弹出提示框。此外，它还适用于实时字数统计与限制，对于有字数限制的输入场景，可在回调中实时统计用户输入的字数，并在接近字数上限时提供相应的提示。

通过[onDidChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#ondidchange12)添加图文变化后可触发的回调。此回调适用于内容保存与同步，例如在用户完成内容编辑后，可使用该回调自动将最新内容保存至本地或同步至服务器。此外，它还适用于内容状态更新与渲染，例如在待办事项列表应用中，用户编辑富文本格式的待办事项描述后，可使用该回调更新待办事项在列表中的显示样式。

使用[RichEditorStyledStringOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorstyledstringoptions12)构建的RichEditor组件不支持上述两种回调。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('组件内图文变化前，触发回调。\n图文变化后，触发回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onWillChange((value: RichEditorChangeValue) => {
15.     this.infoShowController.addTextSpan('组件内图文变化前，触发回调：\n' + JSON.stringify(value), {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.     return true;
22.   })
23.   .onDidChange((rangeBefore: TextRange, rangeAfter: TextRange) => {
24.     this.infoShowController.addTextSpan('\n图文变化后，触发回调：\nrangeBefore:' + JSON.stringify(rangeBefore) +
25.       '\nrangeAfter: ' + JSON.stringify(rangeAfter), {
26.       style: {
27.         fontColor: Color.Gray,
28.         fontSize: 10
29.       }
30.     })
31.   })
32.   .width(300)
33.   .height(50)
34. Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
35. RichEditor(this.infoShowOptions)
36.   .width(300)
37.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.59225937210142774316379547766026:50001231000000:2800:13262E724119940275E44B120C5BF7D77FAB9A6C03EA206C76CA58B44AE81B4B.gif)

### 添加输入法输入内容前和完成输入后可触发的回调

添加输入法输入内容前和完成输入后可触发的回调。

在添加输入法输入内容前，可以通过[aboutToIMEInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#abouttoimeinput)触发回调。在输入法完成输入后，可以通过[onDidIMEInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#ondidimeinput12)触发回调。

这两种回调机制适用于文本上屏过程的业务逻辑处理。例如：在用户输入的文本上屏前，利用回调提供联想词汇，在用户完成输入后，执行自动化纠错或格式转换。两种回调的时序依次为：aboutToIMEInput、onDidIMEInput。

使用[RichEditorStyledStringOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorstyledstringoptions12)构建的组件不支持上述两种回调功能。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('输入法输入内容前，触发回调。\n输入法完成输入后，触发回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .aboutToIMEInput((value: RichEditorInsertValue) => {
15.     this.infoShowController.addTextSpan('输入法输入内容前，触发aboutToIMEInput回调：\n' + JSON.stringify(value), {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.     return true;
22.   })
23.   .onDidIMEInput((value: TextRange) => {
24.     this.infoShowController.addTextSpan('输入法完成输入后，触发onDidIMEInput回调：\n' + JSON.stringify(value), {
25.       style: {
26.         fontColor: Color.Gray,
27.         fontSize: 10
28.       }
29.     })
30.         })
31.   .width(300)
32.   .height(50)
33. Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
34. RichEditor(this.infoShowOptions)
35.   .width(300)
36.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.80083468219059045838555166696642:50001231000000:2800:8D044F47458940576AE23C7C475AE3BE7FF2B5A88D17AF5A25D903FA090139B6.gif)

### 添加完成粘贴前可触发的回调

通过[onPaste](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#onpaste11)回调，来添加粘贴前要处理的流程。

此回调适用于内容格式的处理。例如，当用户复制包含HTML标签的文本时，可在回调中编写代码，将其转换为富文本组件所支持的格式，同时剔除不必要的标签或仅保留纯文本内容。

由于组件默认的粘贴行为仅限于纯文本，无法处理图片粘贴，开发者可利用此方法实现图文并茂的粘贴功能，从而替代组件原有的粘贴行为。

1. import { BusinessError, pasteboard } from '@kit.BasicServicesKit';

2. @Entry
3. @Component
4. struct on_cut_copy_paste {
5.   controller: RichEditorController = new RichEditorController();
6.   options: RichEditorOptions = { controller: this.controller }
7.   infoShowController: RichEditorController = new RichEditorController();
8.   infoShowOptions: RichEditorOptions = { controller: this.infoShowController }

9.   popDataFromPasteboard() {
10.     let selection = this.controller.getSelection();
11.     let start = selection.selection[0];
12.     let end = selection.selection[1];
13.     if (start == end) {
14.       start = this.controller.getCaretOffset();
15.       end = start;
16.     }
17.     let moveOffset = 0;
18.     let sysBoard = pasteboard.getSystemPasteboard();
19.     sysBoard.getData((err, data) => {
20.       if (err) {
21.         return;
22.       }
23.       if (start != end) {
24.         this.controller.deleteSpans({ start: start, end: end })
25.       }
26.       let count = data.getRecordCount();
27.       for (let i = 0; i < count; i++) {
28.         const element = data.getRecord(i);
29.         if (element && element.plainText && element.mimeType === pasteboard.MIMETYPE_TEXT_PLAIN) {
30.           this.controller.addTextSpan(element.plainText,
31.             {
32.               style: { fontSize: 26, fontColor: Color.Red },
33.               offset: start + moveOffset
34.             }
35.           )
36.           moveOffset += element.plainText.length;
37.         }
38.       }
39.       this.controller.setCaretOffset(start + moveOffset)
40.     })
41.   }

42.   build() {
43.     Column() {
44.       Column({ space: 3 }) {
45.         RichEditor(this.options)
46.           .onReady(() => {
47.             this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。',
48.               { style: { fontColor: Color.Black, fontSize: 15 } })
49.           })
50.           .onPaste((event) => {
51.             this.infoShowController.addTextSpan('触发onPaste回调\n', { style: { fontColor: Color.Gray, fontSize: 10 } })
52.             if (event != undefined && event.preventDefault) {
53.               event.preventDefault();
54.             }
55.             console.info('RichEditor onPaste')
56.             this.popDataFromPasteboard()
57.           })
58.           .width(300)
59.           .height(70)
60.         Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
61.           .width(300)
62.           .height(70)
63.         RichEditor(this.infoShowOptions)
64.           .width(300)
65.           .height(70)
66.       }.width('100%').alignItems(HorizontalAlign.Start)
67.     }.height('100%')
68.   }
69. }

### 添加完成剪切前可触发的回调

通过[onCut](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#oncut12)回调，来添加剪切前要处理的流程。

此回调功能适用于数据处理与存储。例如，当用户从富文本组件中剪切内容时，可在回调中临时存储被剪切的内容，确保后续的粘贴操作能够准确无误地还原内容。

由于组件默认的剪切行为仅限于纯文本，无法处理图片剪切，开发者可利用此方法实现图文并茂的剪切功能，从而替代组件原有的剪切行为。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onCut(() => {
15.     this.infoShowController.addTextSpan('触发onCut回调\n', {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.   })
22.   .width(300)
23.   .height(70)
24. RichEditor(this.infoShowOptions)
25.   .width(300)
26.   .height(70)

### 添加完成复制前可触发的回调

通过[onCopy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#oncopy12)回调，来添加复制前要处理的流程。

此回调适用于内容的备份与共享，例如在用户复制内容时，可在回调中执行以下操作：将复制的内容及其格式信息保存至本地备份文件夹，或自动生成一段包含复制内容及产品购买链接的分享文案，以方便用户进行粘贴和分享。

组件默认的复制行为仅限于纯文本，无法处理图片。开发者可利用此方法实现图文并茂的复制功能，替代组件的默认行为。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onCopy(() => {
15.     this.infoShowController.addTextSpan('触发onCopy回调\n', {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.   })
22.   .width(300)
23.   .height(70)
24. RichEditor(this.infoShowOptions)
25.   .width(300)
26.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.69649416159876941814669660684129:50001231000000:2800:A5A68FD4EBE1D66861260589527D9158F9D598C22EEB4DC49F1676A9F872025F.gif)

更多事件使用请参考[RichEditor事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#%E4%BA%8B%E4%BB%B6)。

## 组件交互

可以通过接口配置交互元素属性，感知交互元素变化。

### 设置输入框光标和手柄的颜色

通过[caretColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#caretcolor12)设置输入框光标和手柄的颜色。

设置不同颜色的光标和手柄可以提高视觉辨识度，特别是在包含多个输入区域的复杂界面中，独特的光标颜色能帮助快速定位当前操作的输入区域。这一特性也可以提升用户体验，使光标颜色与应用页面整体的风格相协调。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('组件设置了光标手柄颜色。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .caretColor(Color.Orange)
13.   .width(300)
14.   .height(300)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.02709606588813599114350660370802:50001231000000:2800:4EA5772FFC0128DB8395D187F2E2BFE0D9139D19B134C654508CAB35A7C3A662.gif)

### 添加组件内容选择区域或编辑状态下光标位置改变时可触发的回调

通过[onSelectionChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#onselectionchange12)来添加组件内容选择区域或编辑状态下光标位置改变时可触发的回调。

该回调可用于实时监听组件内容选中区域变化，例如实现实时更新工具栏状态（显示字体、段落格式等）、统计选中内容长度或生成选中内容摘要。实时响应选中状态，动态联动交互元素，提升富文本编辑的操作反馈体验和功能的灵活性。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('改变内容选择区域或编辑状态下的光标位置，触发onSelectionChange回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onSelectionChange((value: RichEditorRange) => {
15.     this.infoShowController.addTextSpan("\n" + "触发了onSelectionChange回调，起始范围信息为：(" + value.start + "," +
16.     value.end + ")", {
17.       style: {
18.         fontColor: Color.Gray,
19.         fontSize: 10
20.       }
21.     })
22.   })
23.   .width(300)
24.   .height(50)
25. Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
26. RichEditor(this.infoShowOptions)
27.   .width(300)
28.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.22477634202009476841531137947912:50001231000000:2800:E3EBA0197D1D97D027104F7757325FFDAA78DAE2DDD7046F7EB3284BDF3BAD0C.gif)

### 设置内容选中区范围

通过[setSelection](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#setselection11)设置组件内的内容选中时部分背板高亮。

此接口可用于实现文本聚焦效果，例如当用户点击某个文本段落的标题或摘要时，可通过该接口自动选中并高亮出对应正文内容。

当组件内未获焦出现光标时，调用该接口不产生选中效果。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮在此处选中0-2位置的文本。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(60)
14. Button('setSelection(0,2)', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.setSelection(0, 2)
21.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.76854429153226445559536947632978:50001231000000:2800:09E4C914A18BCA24320E7DD3CEC89042C6BC876E62FE1FC618E43373CECFB9E7.gif)

## 菜单配置

通过接口可以对文本选择菜单进行配置。

### 管理选中菜单项

当富文本选择区域变化后显示菜单之前触发[onPrepareMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-text-common#%E5%B1%9E%E6%80%A7-1)回调，可在该回调中进行菜单数据设置。

1. // xxx.ets
2. @Entry
3. @Component
4. struct RichEditorExample {
5.   controller: RichEditorController = new RichEditorController();
6.   options: RichEditorOptions = { controller: this.controller };
7.   @State endIndex: number | undefined = 0;
8.   onCreateMenu = (menuItems: Array<TextMenuItem>) => {
9.     const idsToFilter = [
10.       TextMenuItemId.TRANSLATE,
11.       TextMenuItemId.SHARE,
12.       TextMenuItemId.SEARCH,
13.       TextMenuItemId.AI_WRITER
14.     ]
15.     const items = menuItems.filter(item => !idsToFilter.some(id => id.equals(item.id)))
16.     let item1: TextMenuItem = {
17.       content: 'create1',
18.       icon: $r('app.media.startIcon'),
19.       id: TextMenuItemId.of('create1'),
20.     };
21.     let item2: TextMenuItem = {
22.       content: 'create2',
23.       id: TextMenuItemId.of('create2'),
24.       icon: $r('app.media.startIcon'),
25.     };
26.     items.push(item1);
27.     items.unshift(item2);
28.     return items;
29.   }
30.   onMenuItemClick = (menuItem: TextMenuItem, textRange: TextRange) => {
31.     if (menuItem.id.equals(TextMenuItemId.of("create2"))) {
32.       console.info("拦截 id: create2 start:" + textRange.start + "; end:" + textRange.end);
33.       return true;
34.     }
35.     if (menuItem.id.equals(TextMenuItemId.of("prepare1"))) {
36.       console.info("拦截 id: prepare1 start:" + textRange.start + "; end:" + textRange.end);
37.       return true;
38.     }
39.     if (menuItem.id.equals(TextMenuItemId.COPY)) {
40.       console.info("拦截 COPY start:" + textRange.start + "; end:" + textRange.end);
41.       return true;
42.     }
43.     if (menuItem.id.equals(TextMenuItemId.SELECT_ALL)) {
44.       console.info("不拦截 SELECT_ALL start:" + textRange.start + "; end:" + textRange.end);
45.       return false;
46.     }
47.     return false;
48.   }
49.   onPrepareMenu = (menuItems: Array<TextMenuItem>) => {
50.     let item1: TextMenuItem = {
51.       content: 'prepare1_' + this.endIndex,
52.       icon: $r('app.media.startIcon'),
53.       id: TextMenuItemId.of('prepare1'),
54.     };
55.     menuItems.unshift(item1);
56.     return menuItems;
57.   }
58.   @State editMenuOptions: EditMenuOptions = {
59.     onCreateMenu: this.onCreateMenu,
60.     onMenuItemClick: this.onMenuItemClick,
61.     onPrepareMenu: this.onPrepareMenu
62.   };

63.   build() {
64.     Column() {
65.       RichEditor(this.options)
66.         .onReady(() => {
67.           this.controller.addTextSpan("RichEditor editMenuOptions");
68.         })
69.         .editMenuOptions(this.editMenuOptions)
70.         .onSelectionChange((range: RichEditorRange) => {
71.           console.info("onSelectionChange, (" + range.start + "," + range.end + ")");
72.           this.endIndex = range.end;
73.         })
74.         .height(50)
75.         .margin({ top: 100 })
76.         .borderWidth(1)
77.         .borderColor(Color.Red)
78.     }
79.     .width("90%")
80.     .margin("5%")
81.   }
82. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.81154245976791285240875393407222:50001231000000:2800:6BC0DBCCADED107011A7D669D945B151CB834CE3CDF9910753B6B0E83EECE754.gif)

### 屏蔽系统服务类菜单项

通过[disableSystemServiceMenuItems](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-textmenucontroller#disablesystemservicemenuitems20)屏蔽富文本选择菜单内所有系统服务菜单项。

此接口保护内容安全，适用于限制文本操作的场景，例如展示保密内容或禁止复制的版权文本。屏蔽系统服务菜单项，防止用户通过系统服务菜单复制、分享文本，降低内容泄露风险。

1. import { TextMenuController } from '@kit.ArkUI';

2. // xxx.ets
3. @Entry
4. @Component
5. struct Index {
6.   controller: RichEditorController = new RichEditorController();
7.   options: RichEditorOptions = { controller: this.controller };

8.   aboutToAppear(): void {
9.     // 禁用所有系统服务菜单
10.     TextMenuController.disableSystemServiceMenuItems(true);
11.   }

12.   aboutToDisappear(): void {
13.     // 页面消失恢复系统服务菜单
14.     TextMenuController.disableSystemServiceMenuItems(false);
15.   }

16.   build() {
17.     Row() {
18.       Column() {
19.         RichEditor(this.options).onReady(() => {
20.           this.controller.addTextSpan("这是一个RichEditor",
21.             {
22.               style:
23.               {
24.                 fontSize: 30
25.               }
26.             })
27.         })
28.           .height(60)
29.           .editMenuOptions({
30.             onCreateMenu: (menuItems: Array<TextMenuItem>) => {
31.               // menuItems不包含被屏蔽的系统菜单项
32.               return menuItems;
33.             },
34.             onMenuItemClick: (menuItem: TextMenuItem, textRange: TextRange) => {
35.               return false;
36.             }
37.           })
38.       }.width('100%')
39.     }
40.     .height('100%')
41.   }
42. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.15098890658719497553143114757167:50001231000000:2800:17B98A131612F8791D6CCF4326CDF7AF5BAC231B0C766D44030CD1DAEDBC64CA.gif)

通过[disableMenuItems](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-textmenucontroller#disablemenuitems20)可以屏蔽富文本选择菜单内指定的系统服务菜单项。

此接口可精确屏蔽指定的系统服务菜单项，保留应用所需的系统菜单功能，使菜单更贴合实际交互设计。

1. import { TextMenuController } from '@kit.ArkUI';

2. // xxx.ets
3. @Entry
4. @Component
5. struct Index {
6.   controller: RichEditorController = new RichEditorController();
7.   options: RichEditorOptions = { controller: this.controller };

8.   aboutToAppear(): void {
9.     // 禁用搜索和翻译菜单
10.     TextMenuController.disableMenuItems([TextMenuItemId.SEARCH, TextMenuItemId.TRANSLATE])
11.   }

12.   aboutToDisappear(): void {
13.     // 恢复系统服务菜单
14.     TextMenuController.disableMenuItems([])
15.   }

16.   build() {
17.     Row() {
18.       Column() {
19.         RichEditor(this.options).onReady(() => {
20.           this.controller.addTextSpan("这是一个RichEditor",
21.             {
22.               style:
23.               {
24.                 fontSize: 30
25.               }
26.             })
27.         })
28.           .height(60)
29.           .editMenuOptions({
30.             onCreateMenu: (menuItems: Array<TextMenuItem>) => {
31.               // menuItems不包含搜索和翻译
32.               return menuItems;
33.             },
34.             onMenuItemClick: (menuItem: TextMenuItem, textRange: TextRange) => {
35.               return false
36.             }
37.           })
38.       }.width('100%')
39.     }
40.     .height('100%')
41.   }
42. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.47584500119680478696360500880096:50001231000000:2800:6ABADA91229F12A032E0C86EBF5C50774FF7B17C232943915CD6F916A254858C.gif)

### 设置自定义选择菜单

通过[bindSelectionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#bindselectionmenu)设置自定义选择菜单。

组件原本具有默认的文本选择菜单，包含复制、剪切和全选的功能。用户可使用该属性设定自定义菜单，例如翻译英文、加粗字体等丰富的菜单功能。

当自定义菜单超长时，建议内部嵌套Scroll组件使用，避免键盘被遮挡。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('组件设置了自定义菜单，长按可触发。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 18
9.       }
10.     })
11.   })
12.   .bindSelectionMenu(RichEditorSpanType.TEXT, this.SystemMenu, ResponseType.LongPress, {
13.     onDisappear: () => {
14.       this.sliderShow = false
15.     }
16.   })
17. // 绑定自定义菜单
18.   .width(300)
19.   .height(300)

20. @Builder
21. SystemMenu() {
22.   Column() {
23.     Menu() {
24.       if (this.controller) {
25.         MenuItemGroup() {
26.           MenuItem({
27.             startIcon: $r("sys.media.ohos_ic_public_cut"),
28.             content: "剪切",
29.             labelInfo: "Ctrl+X"
30.           })
31.           MenuItem({
32.             startIcon: $r("sys.media.ohos_ic_public_copy"),
33.             content: "复制",
34.             labelInfo: "Ctrl+C"
35.           })
36.           MenuItem({
37.             startIcon: $r("sys.media.ohos_ic_public_paste"),
38.             content: "粘贴",
39.             labelInfo: "Ctrl+V"
40.           })
41.         }
42.       }
43.     }
44.     .radius(this.theme.containerBorderRadius)
45.     .clip(true)
46.     .backgroundColor(Color.White)
47.     .width(this.theme.defaultMenuWidth)
48.   }
49.   .width(this.theme.defaultMenuWidth)
50. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.62530249341230143972311226966346:50001231000000:2800:F6727CC1BE7715535A3FBB973E7390D6E5353CA3C14D85FBB49C63F7A5D4053F.gif)

## 布局配置

组件支持通过接口配置布局规则，开发者可以根据业务场景定制合适的布局规则。

### 设置最大行数

通过[maxLines](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#maxlines18)可以设置富文本组件内可显示文本的最大行数。

此接口控制组件内文本的显示范围，防止文本过长影响页面布局，确保不同设备和场景下的文本显示效果一致，提升界面兼容性和美观度。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('组件设置了最大行数\n超出内容将会以滚动显示\n超出1行\n超出2行\n超出3行\n超出4行', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .maxLines(2)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.20365454967939530885198396865485:50001231000000:2800:827E9DA540B9E6C0D1E3A669CB2D719E8F133ACC61280E2EB22F95A8AFD59F0D.gif)

## 样式设置

组件支持对内容设置复杂的样式。

### 设置用户预设的文本样式

通过[setTypingStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#settypingstyle11)可以设置用户预设的文本样式。

此接口可用于个性化的写作体验，例如可以使用此接口让输入的不同层级标题自动应用相应格式（如一级、二级标题）。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮，改变预设文本样式。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(60)
14. Button('setTypingStyle', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.setTypingStyle({
21.       fontWeight: 'medium',
22.       fontColor: Color.Pink,
23.       fontSize: 15,
24.       fontStyle: FontStyle.Italic,
25.       decoration: {
26.         type: TextDecorationType.Underline,
27.         color: Color.Gray
28.       }
29.     })
30.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.82924623536956070034580800619554:50001231000000:2800:8D847231F2A0420BB5F85A26F0CDBE18F52334829C800A5CAFA3C56F2D210A75.gif)

### 设置装饰线

通过[decoration](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span#decoration)设置富文本组件中文本装饰线的样式、颜色和粗细。

设置文本装饰线可突出关键信息、区分文本状态、增强视觉层次。例如，为重要标题或关键词添加装饰线，帮助用户快速获取信息。

1. private controller: RichEditorController = new RichEditorController();
2. RichEditor({ controller: this.controller })
3.   .onReady(() => {
4.     this.controller.addTextSpan('一段预置的文本', {
5.       style: {
6.         fontSize: 25,
7.         decoration: {
8.           type: TextDecorationType.LineThrough,
9.           color: Color.Blue,
10.           // 设置装饰线粗细比例为6
11.           thicknessScale: 6
12.         }
13.       }
14.     })
15.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.61612407330926760150674765469908:50001231000000:2800:778C898148FB7384AB16231FC9C87B15E38E556E9AA2AAD18CB44CA9109033F9.jpg)

通过[DecorationOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#decorationoptions20)中的enableMultiType设置多装饰线，比如同时设置下划线和中划线。

此接口适用于复杂业务场景，满足文本装饰的多样化需求。在文档协作过程中，多人编辑时，可以通过使用不同的装饰线组合来区分文本状态，从而提高协作效率。

1. RichEditor({ controller: this.styledStringController })
2. Button('多装饰线文本')
3.   .fontSize(20)
4.   .onClick(() => {
5.     let mutString: MutableStyledString = new MutableStyledString('设置富文本多装饰线', [
6.       {
7.         start: 0,
8.         length: 9,
9.         styledKey: StyledStringKey.FONT,
10.         styledValue: new TextStyle({ fontSize: LengthMetrics.vp(25) })
11.       },
12.       {
13.         start: 0,
14.         length: 5,
15.         styledKey: StyledStringKey.DECORATION,
16.         styledValue: new DecorationStyle(
17.           {
18.             type: TextDecorationType.Underline,
19.           },
20.           {
21.             // 开启多装饰线
22.             enableMultiType: true
23.           }
24.         )
25.       },
26.       {
27.         start: 2,
28.         length: 4,
29.         styledKey: StyledStringKey.DECORATION,
30.         styledValue: new DecorationStyle(
31.          {
32.             type: TextDecorationType.LineThrough,
33.           },
34.           {
35.             // 开启多装饰线
36.             enableMultiType: true
37.           }
38.         )
39.       },
40.     ])
41.     this.styledStringController.setStyledString(mutString);
42.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.13418674398875496151348244258199:50001231000000:2800:169442A45FFE9C85E75D6F1CE68E08613A0DB1D9911625E5C398E5A906AFF136.jpg)

### 设置垂直居中

通过[textVerticalAlign](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textverticalalign20)设置文本段落在垂直方向的对齐方式。

此接口优化多元素排版，使组件内容与图片、图标等在垂直方向对齐时，整体布局更协调。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. Column({ space: 5 }) {
4.   RichEditor(this.options)
5.     .onReady(() => {
6.       this.controller.addImageSpan($r('app.media.startIcon'), {
7.         imageStyle: {
8.           size: [100, 100]
9.         }
10.       })
11.       this.controller.addTextSpan("这是一段富文本，展示了文本垂直居中的效果。", {
12.         style: {
13.           fontColor: Color.Pink,
14.           fontSize: "32"
15.         },
16.         paragraphStyle: {
17.           textAlign: TextAlign.Start,
18.           textVerticalAlign: TextVerticalAlign.CENTER,
19.           leadingMargin: 16
20.         }
21.       })
22.     })
23. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.32552010679202799600238259374059:50001231000000:2800:D54E9549783D432171690E9CBCF2C44F56D4AC95D6959FECE62664B27A4338D9.jpg)

### 设置中西文自动间距

通过[enableAutoSpacing](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#enableautospacing20)设置是否开启中文与西文的自动间距。

此接口优化文本排版，提升组件内文本的可读性。设置自动间距后，中文与西文间产生适当空隙，便于区分不同语种，减少视觉干扰。

1. Column() {
2.   RichEditor(this.options)
3.     .onReady(() => {
4.       this.controller.addTextSpan("中西文Auto Spacing自动间距",
5.         {
6.           style:
7.           {
8.             fontColor: Color.Orange,
9.             fontSize: 20
10.           }
11.         })
12.     })
13.     .enableAutoSpacing(this.enableAutoSpace)
14. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.74784800717275437832931484151499:50001231000000:2800:F922BEEFA71F1B9E2EE5AD7F0ACA893DE30C74849396335A332F7B80736E9D35.gif)

## 示例代码

- [内容发布器](https://gitcode.com/harmonyos_samples/content-publisher)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-input "文本输入 (TextInput/TextArea/Search)")
# 富文本编辑（RichEditor）

更新时间: 2025-12-16 16:39

RichEditor是支持图文混排和文本交互式编辑的组件，通常用于响应用户对图文混合内容的输入操作，例如可以输入图文的评论区。具体用法参考[RichEditor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor)。

对于仅需图文展示而不需要编辑的场景，推荐使用[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)组件。

对于需要大量展示Html格式内容的场景，推荐使用[RichText](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richtext)组件。

## 组件构成

下图展示了组件元素的构成。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.26152459925663928213938439615493:50001231000000:2800:13EEAF84A763DC0FC97488D0AA0F6B64F1FFB678A8265FB4B77BCB7F27C3C418.jpg)

组件的元素构成包括：

|元素|说明|
|:--|:--|
|内容区|内容可显示的区域。|
|光标|用于指明当前输入位置。|
|手柄|分为左手柄和右手柄，可分别进行拖动，用于调整文本选择区域范围。|
|菜单|选中内容后弹出，其中包含复制、粘贴等内容操作按钮。|

## 创建RichEditor组件

开发者可以[创建基于属性字符串进行内容管理的RichEditor组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%9A%84richeditor%E7%BB%84%E4%BB%B6)或[创建基于Span进行内容管理的RichEditor组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Espan%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%9A%84richeditor%E7%BB%84%E4%BB%B6)。

### 创建基于属性字符串进行内容管理的RichEditor组件

使用RichEditor(options: [RichEditorStyledStringOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorstyledstringoptions12))接口可以创建基于属性字符串（[StyledString/MutableStyledString](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-styled-string)）进行内容管理的RichEditor组件。这种构建方式开发者可以通过在应用侧持有属性字符串对象来管理数据，通过修改属性字符串对象的内容、样式，再传递给组件，即可实现对富文本组件内容的更新。

相比于使用controller提供的接口进行内容样式更新，使用起来更加灵活便捷。同时属性字符串对象可以设置到各类支持属性字符串的文本组件中，可以快速实现内容的迁移。

1. fontStyle: TextStyle = new TextStyle({
2.   fontColor: Color.Pink
3. });
4. // 定义字体样式对象

5. mutableStyledString: MutableStyledString = new MutableStyledString("创建使用属性字符串构建的RichEditor组件。",
6.   [{
7.     start: 0,
8.     length: 5,
9.     styledKey: StyledStringKey.FONT,
10.     styledValue: this.fontStyle
11.   }]);
12. // 创建属性字符串

13. controller: RichEditorStyledStringController = new RichEditorStyledStringController();
14. options: RichEditorStyledStringOptions = { controller: this.controller };

15. RichEditor(this.options)
16.   .onReady(() => {
17.     this.controller.setStyledString(this.mutableStyledString);
18.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.82419640226368923369194644039825:50001231000000:2800:CC991A311E7CC6E0AEFE0963A0A1BD06586B8D1D1E0578FF5EE6B1F1E8008DE4.gif)

### 创建基于Span进行内容管理的RichEditor组件

使用RichEditor(value: [RichEditorOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditoroptions))接口可以创建基于Span进行内容管理的RichEditor组件，通常用于复杂内容场景，开发者通过RichEditorController提供的接口实现内容、样式的管理。

1. @Entry
2. @Component
3. struct create_rich_editor {
4.   controller: RichEditorController = new RichEditorController();
5.   options: RichEditorOptions = { controller: this.controller };

6.   build() {
7.     Column() {
8.       Column() {
9.         RichEditor(this.options)
10.           .onReady(() => {
11.             this.controller.addTextSpan('创建不使用属性字符串构建的RichEditor组件。', {
12.               style: {
13.                 fontColor: Color.Black,
14.                 fontSize: 15
15.               }
16.             })
17.           })
18.       }.width('100%')
19.     }.height('100%')
20.   }
21. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.75240958404250269911738605755454:50001231000000:2800:FC394429B6F5FF7CA0F444B4C412208340515C262398FB6568EEA0906E06E185.gif)

## 添加内容

富文本组件可以通过不同的接口添加多种形式的内容。

### 添加文本内容

除了直接在组件内输入内容，也可以通过[addTextSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addtextspan)添加文本内容。

此接口可以实现文本样式多样化，例如创建混合样式文本。

如果组件是获焦状态并且光标在闪烁，那么通过addTextSpan添加文本内容后，光标位置会更新，在新添加文本内容的右侧闪烁。

1. @Entry
2. @Component
3. struct add_text_span {
4.   controller: RichEditorController = new RichEditorController();
5.   options: RichEditorOptions = { controller: this.controller };

6.   build() {
7.     Column() {
8.       RichEditor(this.options)
9.         .onReady(() => {
10.           this.controller.addTextSpan('点击按钮在此处添加text。', {
11.             style: {
12.               fontColor: Color.Black,
13.               fontSize: 15
14.             }
15.           })
16.         })
17.         .border({ width: 1, color: Color.Gray })
18.         .constraintSize({
19.           maxHeight: 100
20.         })
21.         .width(300)
22.         .margin(10)
23.       Button('addTextSpan', {
24.         buttonStyle: ButtonStyleMode.NORMAL
25.       })
26.         .height(30)
27.         .fontSize(13)
28.         .onClick(() => {
29.           this.controller.addTextSpan('新添加一段文字。')
30.         })
31.     }
32.   }
33. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.98861688495317793885499631189629:50001231000000:2800:7E179EA8BB86D8E284B50E682CA3C035274C3D23E0B418A0405864A0D0ED86F3.gif)

### 添加图片内容

通过[addImageSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addimagespan)添加图片内容。

此接口可用于内容丰富与可视化展示，例如在新闻中加入图片，在文档中加入数据可视化图形等。

如果组件是获焦状态并且光标在闪烁，那么通过addImageSpan添加图片内容后，光标位置会更新，在新添加图片内容的右侧闪烁。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮在此处添加image。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(100)
14. Button('addImageSpan', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.addImageSpan($r("app.media.startIcon"), {
21.       imageStyle: {
22.         size: ["57px", "57px"]
23.       }
24.     })
25.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.41414198914518650962732222472769:50001231000000:2800:94D6E315CFBA54E5094B9689723185A1569D660FF62487E53302970A2B06D135.gif)

### 添加@Builder装饰器修饰的内容

通过[addBuilderSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addbuilderspan11)添加@Builder装饰器修饰的内容。

此接口可用于自定义复杂组件的嵌入，例如在组件内加入自定义图表。

该接口内可通过[RichEditorBuilderSpanOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorbuilderspanoptions11)设置在组件中添加builder的位置，省略或者为异常值时，则添加builder到所有内容的最后位置。

1. private my_builder: CustomBuilder = undefined

2. @Builder
3. TextBuilder() {
4.   Row() {
5.     Image($r('app.media.startIcon')).width(50).height(50).margin(16)
6.     Column() {
7.       Text("文本文档.txt").fontWeight(FontWeight.Bold).fontSize(16)
8.       Text("123.45KB").fontColor('#8a8a8a').fontSize(12)
9.     }.alignItems(HorizontalAlign.Start)
10.   }.backgroundColor('#f4f4f4')
11.   .borderRadius("20")
12.   .width(220)
13. }

14. controller: RichEditorController = new RichEditorController();
15. options: RichEditorOptions = { controller: this.controller };

16. Button('addBuilderSpan', {
17.   buttonStyle: ButtonStyleMode.NORMAL
18. })
19.   .height(30)
20.   .fontSize(13)
21.   .onClick(() => {
22.     this.my_builder = () => {
23.       this.TextBuilder()
24.     }
25.     this.controller.addBuilderSpan(this.my_builder)
26.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.26402702766026237204146767501487:50001231000000:2800:A8F157C99411FC0509FBD035C7A0B340BD83D0FF2C421957E670430A95B638AF.gif)

### 添加SymbolSpan内容

可通过[addSymbolSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addsymbolspan11)添加Symbol内容。此接口可用于特殊符号的添加，例如在编辑学术论文时，此接口可用于添加各种数学符号。

添加Symbol内容时，如果组件是获焦状态并且光标在闪烁，那么添加Symbol后，光标将移动到新插入Symbol的右侧。

Symbol内容暂不支持手势、复制、拖拽处理。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮在此处添加symbol。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(100)
14. Button('addSymbolSpan', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.addSymbolSpan($r("sys.symbol.basketball_fill"), {
21.       style: {
22.         fontSize: 30
23.       }
24.     })
25.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.78332160712042792482973248045201:50001231000000:2800:310256CDC829867F61601176D1F3F8F9E13A543157F730E7718EB58C5C73A3F0.gif)

## 管理内容

富文本组件可以通过接口对内容进行管理，例如[获取组件内的图文信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%86%85%E5%9B%BE%E6%96%87%E4%BF%A1%E6%81%AF)、[设置无输入时的提示文本](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E8%AE%BE%E7%BD%AE%E6%97%A0%E8%BE%93%E5%85%A5%E6%97%B6%E7%9A%84%E6%8F%90%E7%A4%BA%E6%96%87%E6%9C%AC)或[设置组件内容的最大字符数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor#%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6)。

### 获取组件内图文信息

可通过[getSpans](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#getspans)获取组件内所有图文内容的信息，包括图文的内容、id、样式、位置等信息。获取内容位置信息后，可对指定范围内容进行样式的更新。

此接口适用于已有的内容样式获取与检查，例如在模板应用场景下，可利用此接口获取文本样式。此外，它还适用于内容解析与处理，例如在文本分析应用中，此接口能够获取特定范围内的文本信息。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller }
3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController }
5. // 创建两个富文本组件

6. RichEditor(this.options)
7.   .onReady(() => {
8.     this.controller.addTextSpan('点击按钮获取此处span信息。', {
9.       style: {
10.         fontColor: Color.Black,
11.         fontSize: 15
12.       }
13.     })
14.   })
15.   .width(300)
16.   .height(50)
17. Text('查看getSpans返回值：').fontSize(10).fontColor(Color.Gray).width(300)
18. RichEditor(this.infoShowOptions)
19.   .width(300)
20.   .height(50)
21. Button('getSpans', {
22.   buttonStyle: ButtonStyleMode.NORMAL
23. })
24.   .height(30)
25.   .fontSize(13)
26.   .onClick(() => {
27.     this.infoShowController.addTextSpan(JSON.stringify(this.controller.getSpans()), {
28.       style: {
29.         fontColor: Color.Gray,
30.         fontSize: 10
31.       }
32.     })
33.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.32869162833464656263234733086120:50001231000000:2800:91172C839B8FF5A6CF8BFE6646CB1DFB9E193AADB8E6CE4F37ED3F41EC6D9DC5.gif)

### 设置无输入时的提示文本

通过[placeholder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#placeholder12)设置无输入时的提示文本。

例如，在用户登录界面采用提示文本，有助于用户区分用户名与密码的输入框。又如，在文本编辑框中，使用提示文本明确输入要求，如“限输入100字以内”，以此指导用户正确操作。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .placeholder("此处为提示文本...", {
5.     fontColor: Color.Gray,
6.     font: {
7.       size: 15,
8.       weight: FontWeight.Normal,
9.       family: "HarmonyOS Sans",
10.       style: FontStyle.Normal
11.     }
12.   })
13.   .width(300)
14.   .height(50)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163948.71177851725325544863422739634388:50001231000000:2800:75BFC5AB3B20BDDF2A124A61B7B83391ABA5887B070754FE7E6CCDABA84500FA.gif)

### 设置最大长度

通过[maxLength](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#maxlength18)可以设置富文本的最大可输入字符数。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .placeholder('组件设置了最大字符数：7')
5.   .onReady(() => {})
6.   .maxLength(7)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.72698512129538117943096130734673:50001231000000:2800:732C59891B0D6E0716E95EC52C35F4C8F08A573C5EEF4F8518B4882A30292D42.gif)

## 事件回调

开发者可以通过注册事件回调，感知组件事件的触发。

### 添加图文变化前和图文变化后可触发的回调

通过[onWillChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#onwillchange12)添加图文变化前可触发的回调。此回调适用于用户实时数据校验与提醒，例如在用户输入文本时，可在回调内实现对输入内容的检测，若检测到敏感词汇，应立即弹出提示框。此外，它还适用于实时字数统计与限制，对于有字数限制的输入场景，可在回调中实时统计用户输入的字数，并在接近字数上限时提供相应的提示。

通过[onDidChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#ondidchange12)添加图文变化后可触发的回调。此回调适用于内容保存与同步，例如在用户完成内容编辑后，可使用该回调自动将最新内容保存至本地或同步至服务器。此外，它还适用于内容状态更新与渲染，例如在待办事项列表应用中，用户编辑富文本格式的待办事项描述后，可使用该回调更新待办事项在列表中的显示样式。

使用[RichEditorStyledStringOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorstyledstringoptions12)构建的RichEditor组件不支持上述两种回调。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('组件内图文变化前，触发回调。\n图文变化后，触发回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onWillChange((value: RichEditorChangeValue) => {
15.     this.infoShowController.addTextSpan('组件内图文变化前，触发回调：\n' + JSON.stringify(value), {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.     return true;
22.   })
23.   .onDidChange((rangeBefore: TextRange, rangeAfter: TextRange) => {
24.     this.infoShowController.addTextSpan('\n图文变化后，触发回调：\nrangeBefore:' + JSON.stringify(rangeBefore) +
25.       '\nrangeAfter: ' + JSON.stringify(rangeAfter), {
26.       style: {
27.         fontColor: Color.Gray,
28.         fontSize: 10
29.       }
30.     })
31.   })
32.   .width(300)
33.   .height(50)
34. Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
35. RichEditor(this.infoShowOptions)
36.   .width(300)
37.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.59225937210142774316379547766026:50001231000000:2800:13262E724119940275E44B120C5BF7D77FAB9A6C03EA206C76CA58B44AE81B4B.gif)

### 添加输入法输入内容前和完成输入后可触发的回调

添加输入法输入内容前和完成输入后可触发的回调。

在添加输入法输入内容前，可以通过[aboutToIMEInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#abouttoimeinput)触发回调。在输入法完成输入后，可以通过[onDidIMEInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#ondidimeinput12)触发回调。

这两种回调机制适用于文本上屏过程的业务逻辑处理。例如：在用户输入的文本上屏前，利用回调提供联想词汇，在用户完成输入后，执行自动化纠错或格式转换。两种回调的时序依次为：aboutToIMEInput、onDidIMEInput。

使用[RichEditorStyledStringOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#richeditorstyledstringoptions12)构建的组件不支持上述两种回调功能。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('输入法输入内容前，触发回调。\n输入法完成输入后，触发回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .aboutToIMEInput((value: RichEditorInsertValue) => {
15.     this.infoShowController.addTextSpan('输入法输入内容前，触发aboutToIMEInput回调：\n' + JSON.stringify(value), {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.     return true;
22.   })
23.   .onDidIMEInput((value: TextRange) => {
24.     this.infoShowController.addTextSpan('输入法完成输入后，触发onDidIMEInput回调：\n' + JSON.stringify(value), {
25.       style: {
26.         fontColor: Color.Gray,
27.         fontSize: 10
28.       }
29.     })
30.         })
31.   .width(300)
32.   .height(50)
33. Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
34. RichEditor(this.infoShowOptions)
35.   .width(300)
36.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.80083468219059045838555166696642:50001231000000:2800:8D044F47458940576AE23C7C475AE3BE7FF2B5A88D17AF5A25D903FA090139B6.gif)

### 添加完成粘贴前可触发的回调

通过[onPaste](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#onpaste11)回调，来添加粘贴前要处理的流程。

此回调适用于内容格式的处理。例如，当用户复制包含HTML标签的文本时，可在回调中编写代码，将其转换为富文本组件所支持的格式，同时剔除不必要的标签或仅保留纯文本内容。

由于组件默认的粘贴行为仅限于纯文本，无法处理图片粘贴，开发者可利用此方法实现图文并茂的粘贴功能，从而替代组件原有的粘贴行为。

1. import { BusinessError, pasteboard } from '@kit.BasicServicesKit';

2. @Entry
3. @Component
4. struct on_cut_copy_paste {
5.   controller: RichEditorController = new RichEditorController();
6.   options: RichEditorOptions = { controller: this.controller }
7.   infoShowController: RichEditorController = new RichEditorController();
8.   infoShowOptions: RichEditorOptions = { controller: this.infoShowController }

9.   popDataFromPasteboard() {
10.     let selection = this.controller.getSelection();
11.     let start = selection.selection[0];
12.     let end = selection.selection[1];
13.     if (start == end) {
14.       start = this.controller.getCaretOffset();
15.       end = start;
16.     }
17.     let moveOffset = 0;
18.     let sysBoard = pasteboard.getSystemPasteboard();
19.     sysBoard.getData((err, data) => {
20.       if (err) {
21.         return;
22.       }
23.       if (start != end) {
24.         this.controller.deleteSpans({ start: start, end: end })
25.       }
26.       let count = data.getRecordCount();
27.       for (let i = 0; i < count; i++) {
28.         const element = data.getRecord(i);
29.         if (element && element.plainText && element.mimeType === pasteboard.MIMETYPE_TEXT_PLAIN) {
30.           this.controller.addTextSpan(element.plainText,
31.             {
32.               style: { fontSize: 26, fontColor: Color.Red },
33.               offset: start + moveOffset
34.             }
35.           )
36.           moveOffset += element.plainText.length;
37.         }
38.       }
39.       this.controller.setCaretOffset(start + moveOffset)
40.     })
41.   }

42.   build() {
43.     Column() {
44.       Column({ space: 3 }) {
45.         RichEditor(this.options)
46.           .onReady(() => {
47.             this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。',
48.               { style: { fontColor: Color.Black, fontSize: 15 } })
49.           })
50.           .onPaste((event) => {
51.             this.infoShowController.addTextSpan('触发onPaste回调\n', { style: { fontColor: Color.Gray, fontSize: 10 } })
52.             if (event != undefined && event.preventDefault) {
53.               event.preventDefault();
54.             }
55.             console.info('RichEditor onPaste')
56.             this.popDataFromPasteboard()
57.           })
58.           .width(300)
59.           .height(70)
60.         Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
61.           .width(300)
62.           .height(70)
63.         RichEditor(this.infoShowOptions)
64.           .width(300)
65.           .height(70)
66.       }.width('100%').alignItems(HorizontalAlign.Start)
67.     }.height('100%')
68.   }
69. }

### 添加完成剪切前可触发的回调

通过[onCut](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#oncut12)回调，来添加剪切前要处理的流程。

此回调功能适用于数据处理与存储。例如，当用户从富文本组件中剪切内容时，可在回调中临时存储被剪切的内容，确保后续的粘贴操作能够准确无误地还原内容。

由于组件默认的剪切行为仅限于纯文本，无法处理图片剪切，开发者可利用此方法实现图文并茂的剪切功能，从而替代组件原有的剪切行为。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onCut(() => {
15.     this.infoShowController.addTextSpan('触发onCut回调\n', {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.   })
22.   .width(300)
23.   .height(70)
24. RichEditor(this.infoShowOptions)
25.   .width(300)
26.   .height(70)

### 添加完成复制前可触发的回调

通过[onCopy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#oncopy12)回调，来添加复制前要处理的流程。

此回调适用于内容的备份与共享，例如在用户复制内容时，可在回调中执行以下操作：将复制的内容及其格式信息保存至本地备份文件夹，或自动生成一段包含复制内容及产品购买链接的分享文案，以方便用户进行粘贴和分享。

组件默认的复制行为仅限于纯文本，无法处理图片。开发者可利用此方法实现图文并茂的复制功能，替代组件的默认行为。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onCopy(() => {
15.     this.infoShowController.addTextSpan('触发onCopy回调\n', {
16.       style: {
17.         fontColor: Color.Gray,
18.         fontSize: 10
19.       }
20.     })
21.   })
22.   .width(300)
23.   .height(70)
24. RichEditor(this.infoShowOptions)
25.   .width(300)
26.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.69649416159876941814669660684129:50001231000000:2800:A5A68FD4EBE1D66861260589527D9158F9D598C22EEB4DC49F1676A9F872025F.gif)

更多事件使用请参考[RichEditor事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#%E4%BA%8B%E4%BB%B6)。

## 组件交互

可以通过接口配置交互元素属性，感知交互元素变化。

### 设置输入框光标和手柄的颜色

通过[caretColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#caretcolor12)设置输入框光标和手柄的颜色。

设置不同颜色的光标和手柄可以提高视觉辨识度，特别是在包含多个输入区域的复杂界面中，独特的光标颜色能帮助快速定位当前操作的输入区域。这一特性也可以提升用户体验，使光标颜色与应用页面整体的风格相协调。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('组件设置了光标手柄颜色。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .caretColor(Color.Orange)
13.   .width(300)
14.   .height(300)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.02709606588813599114350660370802:50001231000000:2800:4EA5772FFC0128DB8395D187F2E2BFE0D9139D19B134C654508CAB35A7C3A662.gif)

### 添加组件内容选择区域或编辑状态下光标位置改变时可触发的回调

通过[onSelectionChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#onselectionchange12)来添加组件内容选择区域或编辑状态下光标位置改变时可触发的回调。

该回调可用于实时监听组件内容选中区域变化，例如实现实时更新工具栏状态（显示字体、段落格式等）、统计选中内容长度或生成选中内容摘要。实时响应选中状态，动态联动交互元素，提升富文本编辑的操作反馈体验和功能的灵活性。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. infoShowController: RichEditorController = new RichEditorController();
4. infoShowOptions: RichEditorOptions = { controller: this.infoShowController };

5. RichEditor(this.options)
6.   .onReady(() => {
7.     this.controller.addTextSpan('改变内容选择区域或编辑状态下的光标位置，触发onSelectionChange回调。', {
8.       style: {
9.         fontColor: Color.Black,
10.         fontSize: 15
11.       }
12.     })
13.   })
14.   .onSelectionChange((value: RichEditorRange) => {
15.     this.infoShowController.addTextSpan("\n" + "触发了onSelectionChange回调，起始范围信息为：(" + value.start + "," +
16.     value.end + ")", {
17.       style: {
18.         fontColor: Color.Gray,
19.         fontSize: 10
20.       }
21.     })
22.   })
23.   .width(300)
24.   .height(50)
25. Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
26. RichEditor(this.infoShowOptions)
27.   .width(300)
28.   .height(70)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.22477634202009476841531137947912:50001231000000:2800:E3EBA0197D1D97D027104F7757325FFDAA78DAE2DDD7046F7EB3284BDF3BAD0C.gif)

### 设置内容选中区范围

通过[setSelection](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#setselection11)设置组件内的内容选中时部分背板高亮。

此接口可用于实现文本聚焦效果，例如当用户点击某个文本段落的标题或摘要时，可通过该接口自动选中并高亮出对应正文内容。

当组件内未获焦出现光标时，调用该接口不产生选中效果。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮在此处选中0-2位置的文本。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(60)
14. Button('setSelection(0,2)', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.setSelection(0, 2)
21.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.76854429153226445559536947632978:50001231000000:2800:09E4C914A18BCA24320E7DD3CEC89042C6BC876E62FE1FC618E43373CECFB9E7.gif)

## 菜单配置

通过接口可以对文本选择菜单进行配置。

### 管理选中菜单项

当富文本选择区域变化后显示菜单之前触发[onPrepareMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-text-common#%E5%B1%9E%E6%80%A7-1)回调，可在该回调中进行菜单数据设置。

1. // xxx.ets
2. @Entry
3. @Component
4. struct RichEditorExample {
5.   controller: RichEditorController = new RichEditorController();
6.   options: RichEditorOptions = { controller: this.controller };
7.   @State endIndex: number | undefined = 0;
8.   onCreateMenu = (menuItems: Array<TextMenuItem>) => {
9.     const idsToFilter = [
10.       TextMenuItemId.TRANSLATE,
11.       TextMenuItemId.SHARE,
12.       TextMenuItemId.SEARCH,
13.       TextMenuItemId.AI_WRITER
14.     ]
15.     const items = menuItems.filter(item => !idsToFilter.some(id => id.equals(item.id)))
16.     let item1: TextMenuItem = {
17.       content: 'create1',
18.       icon: $r('app.media.startIcon'),
19.       id: TextMenuItemId.of('create1'),
20.     };
21.     let item2: TextMenuItem = {
22.       content: 'create2',
23.       id: TextMenuItemId.of('create2'),
24.       icon: $r('app.media.startIcon'),
25.     };
26.     items.push(item1);
27.     items.unshift(item2);
28.     return items;
29.   }
30.   onMenuItemClick = (menuItem: TextMenuItem, textRange: TextRange) => {
31.     if (menuItem.id.equals(TextMenuItemId.of("create2"))) {
32.       console.info("拦截 id: create2 start:" + textRange.start + "; end:" + textRange.end);
33.       return true;
34.     }
35.     if (menuItem.id.equals(TextMenuItemId.of("prepare1"))) {
36.       console.info("拦截 id: prepare1 start:" + textRange.start + "; end:" + textRange.end);
37.       return true;
38.     }
39.     if (menuItem.id.equals(TextMenuItemId.COPY)) {
40.       console.info("拦截 COPY start:" + textRange.start + "; end:" + textRange.end);
41.       return true;
42.     }
43.     if (menuItem.id.equals(TextMenuItemId.SELECT_ALL)) {
44.       console.info("不拦截 SELECT_ALL start:" + textRange.start + "; end:" + textRange.end);
45.       return false;
46.     }
47.     return false;
48.   }
49.   onPrepareMenu = (menuItems: Array<TextMenuItem>) => {
50.     let item1: TextMenuItem = {
51.       content: 'prepare1_' + this.endIndex,
52.       icon: $r('app.media.startIcon'),
53.       id: TextMenuItemId.of('prepare1'),
54.     };
55.     menuItems.unshift(item1);
56.     return menuItems;
57.   }
58.   @State editMenuOptions: EditMenuOptions = {
59.     onCreateMenu: this.onCreateMenu,
60.     onMenuItemClick: this.onMenuItemClick,
61.     onPrepareMenu: this.onPrepareMenu
62.   };

63.   build() {
64.     Column() {
65.       RichEditor(this.options)
66.         .onReady(() => {
67.           this.controller.addTextSpan("RichEditor editMenuOptions");
68.         })
69.         .editMenuOptions(this.editMenuOptions)
70.         .onSelectionChange((range: RichEditorRange) => {
71.           console.info("onSelectionChange, (" + range.start + "," + range.end + ")");
72.           this.endIndex = range.end;
73.         })
74.         .height(50)
75.         .margin({ top: 100 })
76.         .borderWidth(1)
77.         .borderColor(Color.Red)
78.     }
79.     .width("90%")
80.     .margin("5%")
81.   }
82. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.81154245976791285240875393407222:50001231000000:2800:6BC0DBCCADED107011A7D669D945B151CB834CE3CDF9910753B6B0E83EECE754.gif)

### 屏蔽系统服务类菜单项

通过[disableSystemServiceMenuItems](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-textmenucontroller#disablesystemservicemenuitems20)屏蔽富文本选择菜单内所有系统服务菜单项。

此接口保护内容安全，适用于限制文本操作的场景，例如展示保密内容或禁止复制的版权文本。屏蔽系统服务菜单项，防止用户通过系统服务菜单复制、分享文本，降低内容泄露风险。

1. import { TextMenuController } from '@kit.ArkUI';

2. // xxx.ets
3. @Entry
4. @Component
5. struct Index {
6.   controller: RichEditorController = new RichEditorController();
7.   options: RichEditorOptions = { controller: this.controller };

8.   aboutToAppear(): void {
9.     // 禁用所有系统服务菜单
10.     TextMenuController.disableSystemServiceMenuItems(true);
11.   }

12.   aboutToDisappear(): void {
13.     // 页面消失恢复系统服务菜单
14.     TextMenuController.disableSystemServiceMenuItems(false);
15.   }

16.   build() {
17.     Row() {
18.       Column() {
19.         RichEditor(this.options).onReady(() => {
20.           this.controller.addTextSpan("这是一个RichEditor",
21.             {
22.               style:
23.               {
24.                 fontSize: 30
25.               }
26.             })
27.         })
28.           .height(60)
29.           .editMenuOptions({
30.             onCreateMenu: (menuItems: Array<TextMenuItem>) => {
31.               // menuItems不包含被屏蔽的系统菜单项
32.               return menuItems;
33.             },
34.             onMenuItemClick: (menuItem: TextMenuItem, textRange: TextRange) => {
35.               return false;
36.             }
37.           })
38.       }.width('100%')
39.     }
40.     .height('100%')
41.   }
42. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.15098890658719497553143114757167:50001231000000:2800:17B98A131612F8791D6CCF4326CDF7AF5BAC231B0C766D44030CD1DAEDBC64CA.gif)

通过[disableMenuItems](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-textmenucontroller#disablemenuitems20)可以屏蔽富文本选择菜单内指定的系统服务菜单项。

此接口可精确屏蔽指定的系统服务菜单项，保留应用所需的系统菜单功能，使菜单更贴合实际交互设计。

1. import { TextMenuController } from '@kit.ArkUI';

2. // xxx.ets
3. @Entry
4. @Component
5. struct Index {
6.   controller: RichEditorController = new RichEditorController();
7.   options: RichEditorOptions = { controller: this.controller };

8.   aboutToAppear(): void {
9.     // 禁用搜索和翻译菜单
10.     TextMenuController.disableMenuItems([TextMenuItemId.SEARCH, TextMenuItemId.TRANSLATE])
11.   }

12.   aboutToDisappear(): void {
13.     // 恢复系统服务菜单
14.     TextMenuController.disableMenuItems([])
15.   }

16.   build() {
17.     Row() {
18.       Column() {
19.         RichEditor(this.options).onReady(() => {
20.           this.controller.addTextSpan("这是一个RichEditor",
21.             {
22.               style:
23.               {
24.                 fontSize: 30
25.               }
26.             })
27.         })
28.           .height(60)
29.           .editMenuOptions({
30.             onCreateMenu: (menuItems: Array<TextMenuItem>) => {
31.               // menuItems不包含搜索和翻译
32.               return menuItems;
33.             },
34.             onMenuItemClick: (menuItem: TextMenuItem, textRange: TextRange) => {
35.               return false
36.             }
37.           })
38.       }.width('100%')
39.     }
40.     .height('100%')
41.   }
42. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.47584500119680478696360500880096:50001231000000:2800:6ABADA91229F12A032E0C86EBF5C50774FF7B17C232943915CD6F916A254858C.gif)

### 设置自定义选择菜单

通过[bindSelectionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#bindselectionmenu)设置自定义选择菜单。

组件原本具有默认的文本选择菜单，包含复制、剪切和全选的功能。用户可使用该属性设定自定义菜单，例如翻译英文、加粗字体等丰富的菜单功能。

当自定义菜单超长时，建议内部嵌套Scroll组件使用，避免键盘被遮挡。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('组件设置了自定义菜单，长按可触发。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 18
9.       }
10.     })
11.   })
12.   .bindSelectionMenu(RichEditorSpanType.TEXT, this.SystemMenu, ResponseType.LongPress, {
13.     onDisappear: () => {
14.       this.sliderShow = false
15.     }
16.   })
17. // 绑定自定义菜单
18.   .width(300)
19.   .height(300)

20. @Builder
21. SystemMenu() {
22.   Column() {
23.     Menu() {
24.       if (this.controller) {
25.         MenuItemGroup() {
26.           MenuItem({
27.             startIcon: $r("sys.media.ohos_ic_public_cut"),
28.             content: "剪切",
29.             labelInfo: "Ctrl+X"
30.           })
31.           MenuItem({
32.             startIcon: $r("sys.media.ohos_ic_public_copy"),
33.             content: "复制",
34.             labelInfo: "Ctrl+C"
35.           })
36.           MenuItem({
37.             startIcon: $r("sys.media.ohos_ic_public_paste"),
38.             content: "粘贴",
39.             labelInfo: "Ctrl+V"
40.           })
41.         }
42.       }
43.     }
44.     .radius(this.theme.containerBorderRadius)
45.     .clip(true)
46.     .backgroundColor(Color.White)
47.     .width(this.theme.defaultMenuWidth)
48.   }
49.   .width(this.theme.defaultMenuWidth)
50. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.62530249341230143972311226966346:50001231000000:2800:F6727CC1BE7715535A3FBB973E7390D6E5353CA3C14D85FBB49C63F7A5D4053F.gif)

## 布局配置

组件支持通过接口配置布局规则，开发者可以根据业务场景定制合适的布局规则。

### 设置最大行数

通过[maxLines](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#maxlines18)可以设置富文本组件内可显示文本的最大行数。

此接口控制组件内文本的显示范围，防止文本过长影响页面布局，确保不同设备和场景下的文本显示效果一致，提升界面兼容性和美观度。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('组件设置了最大行数\n超出内容将会以滚动显示\n超出1行\n超出2行\n超出3行\n超出4行', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .maxLines(2)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.20365454967939530885198396865485:50001231000000:2800:827E9DA540B9E6C0D1E3A669CB2D719E8F133ACC61280E2EB22F95A8AFD59F0D.gif)

## 样式设置

组件支持对内容设置复杂的样式。

### 设置用户预设的文本样式

通过[setTypingStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#settypingstyle11)可以设置用户预设的文本样式。

此接口可用于个性化的写作体验，例如可以使用此接口让输入的不同层级标题自动应用相应格式（如一级、二级标题）。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. RichEditor(this.options)
4.   .onReady(() => {
5.     this.controller.addTextSpan('点击按钮，改变预设文本样式。', {
6.       style: {
7.         fontColor: Color.Black,
8.         fontSize: 15
9.       }
10.     })
11.   })
12.   .width(300)
13.   .height(60)
14. Button('setTypingStyle', {
15.   buttonStyle: ButtonStyleMode.NORMAL
16. })
17.   .height(30)
18.   .fontSize(13)
19.   .onClick(() => {
20.     this.controller.setTypingStyle({
21.       fontWeight: 'medium',
22.       fontColor: Color.Pink,
23.       fontSize: 15,
24.       fontStyle: FontStyle.Italic,
25.       decoration: {
26.         type: TextDecorationType.Underline,
27.         color: Color.Gray
28.       }
29.     })
30.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.82924623536956070034580800619554:50001231000000:2800:8D847231F2A0420BB5F85A26F0CDBE18F52334829C800A5CAFA3C56F2D210A75.gif)

### 设置装饰线

通过[decoration](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span#decoration)设置富文本组件中文本装饰线的样式、颜色和粗细。

设置文本装饰线可突出关键信息、区分文本状态、增强视觉层次。例如，为重要标题或关键词添加装饰线，帮助用户快速获取信息。

1. private controller: RichEditorController = new RichEditorController();
2. RichEditor({ controller: this.controller })
3.   .onReady(() => {
4.     this.controller.addTextSpan('一段预置的文本', {
5.       style: {
6.         fontSize: 25,
7.         decoration: {
8.           type: TextDecorationType.LineThrough,
9.           color: Color.Blue,
10.           // 设置装饰线粗细比例为6
11.           thicknessScale: 6
12.         }
13.       }
14.     })
15.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.61612407330926760150674765469908:50001231000000:2800:778C898148FB7384AB16231FC9C87B15E38E556E9AA2AAD18CB44CA9109033F9.jpg)

通过[DecorationOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#decorationoptions20)中的enableMultiType设置多装饰线，比如同时设置下划线和中划线。

此接口适用于复杂业务场景，满足文本装饰的多样化需求。在文档协作过程中，多人编辑时，可以通过使用不同的装饰线组合来区分文本状态，从而提高协作效率。

1. RichEditor({ controller: this.styledStringController })
2. Button('多装饰线文本')
3.   .fontSize(20)
4.   .onClick(() => {
5.     let mutString: MutableStyledString = new MutableStyledString('设置富文本多装饰线', [
6.       {
7.         start: 0,
8.         length: 9,
9.         styledKey: StyledStringKey.FONT,
10.         styledValue: new TextStyle({ fontSize: LengthMetrics.vp(25) })
11.       },
12.       {
13.         start: 0,
14.         length: 5,
15.         styledKey: StyledStringKey.DECORATION,
16.         styledValue: new DecorationStyle(
17.           {
18.             type: TextDecorationType.Underline,
19.           },
20.           {
21.             // 开启多装饰线
22.             enableMultiType: true
23.           }
24.         )
25.       },
26.       {
27.         start: 2,
28.         length: 4,
29.         styledKey: StyledStringKey.DECORATION,
30.         styledValue: new DecorationStyle(
31.          {
32.             type: TextDecorationType.LineThrough,
33.           },
34.           {
35.             // 开启多装饰线
36.             enableMultiType: true
37.           }
38.         )
39.       },
40.     ])
41.     this.styledStringController.setStyledString(mutString);
42.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.13418674398875496151348244258199:50001231000000:2800:169442A45FFE9C85E75D6F1CE68E08613A0DB1D9911625E5C398E5A906AFF136.jpg)

### 设置垂直居中

通过[textVerticalAlign](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textverticalalign20)设置文本段落在垂直方向的对齐方式。

此接口优化多元素排版，使组件内容与图片、图标等在垂直方向对齐时，整体布局更协调。

1. controller: RichEditorController = new RichEditorController();
2. options: RichEditorOptions = { controller: this.controller };

3. Column({ space: 5 }) {
4.   RichEditor(this.options)
5.     .onReady(() => {
6.       this.controller.addImageSpan($r('app.media.startIcon'), {
7.         imageStyle: {
8.           size: [100, 100]
9.         }
10.       })
11.       this.controller.addTextSpan("这是一段富文本，展示了文本垂直居中的效果。", {
12.         style: {
13.           fontColor: Color.Pink,
14.           fontSize: "32"
15.         },
16.         paragraphStyle: {
17.           textAlign: TextAlign.Start,
18.           textVerticalAlign: TextVerticalAlign.CENTER,
19.           leadingMargin: 16
20.         }
21.       })
22.     })
23. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.32552010679202799600238259374059:50001231000000:2800:D54E9549783D432171690E9CBCF2C44F56D4AC95D6959FECE62664B27A4338D9.jpg)

### 设置中西文自动间距

通过[enableAutoSpacing](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#enableautospacing20)设置是否开启中文与西文的自动间距。

此接口优化文本排版，提升组件内文本的可读性。设置自动间距后，中文与西文间产生适当空隙，便于区分不同语种，减少视觉干扰。

1. Column() {
2.   RichEditor(this.options)
3.     .onReady(() => {
4.       this.controller.addTextSpan("中西文Auto Spacing自动间距",
5.         {
6.           style:
7.           {
8.             fontColor: Color.Orange,
9.             fontSize: 20
10.           }
11.         })
12.     })
13.     .enableAutoSpacing(this.enableAutoSpace)
14. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163949.74784800717275437832931484151499:50001231000000:2800:F922BEEFA71F1B9E2EE5AD7F0ACA893DE30C74849396335A332F7B80736E9D35.gif)

## 示例代码

- [内容发布器](https://gitcode.com/harmonyos_samples/content-publisher)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-input "文本输入 (TextInput/TextArea/Search)")
# 图标小符号 (SymbolGlyph/SymbolSpan)

更新时间: 2025-12-16 16:39

SymbolGlyph是图标小符号组件，便于使用精美的图标，如渲染多色图标和使用动效图标。SymbolSpan作为Text组件的子组件，可在文本中穿插显示图标小符号。具体用法请参考[SymbolGlyph](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph)和[SymbolSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan)组件的文档。

## 创建图标

SymbolGlyph通过$r引用Resource资源来创建，目前仅支持系统预置的Symbol资源名。

相关资源可参考[系统图标](https://developer.huawei.com/consumer/cn/doc/design-guides/system-icons-0000001929854962)。

1. SymbolGlyph($r('sys.symbol.ohos_folder_badge_plus'))
2.   .fontSize(96)
3.   .renderingStrategy(SymbolRenderingStrategy.SINGLE)
4.   .fontColor([Color.Black, Color.Green, Color.White])

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163955.76225455402595115780317426558320:50001231000000:2800:2866BE6C6A78501DE2B1519B9D96FAC42E6E32FEB5DBBCCD9955105B75E769DC.png)

## 添加到文本中

[SymbolSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan)可作为[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)的子组件用于显示图标小符号。可以在一个Text组件内添加多个SymbolSpan，从而展示一串连续的图标。

- 创建SymbolSpan。
    
    SymbolSpan组件需嵌入在Text组件中才能显示，单独使用不会呈现任何内容。
    
    1. Text() {
    2.   SymbolSpan($r('sys.symbol.ohos_trash'))
    3.     .fontWeight(FontWeight.Normal)
    4.     .fontSize(96)
    5. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.17266018666327839027945752150705:50001231000000:2800:C9B64AC5E13D98AC8253167451DEF2A7CFB74488E34F569BDF64DB5B3F5BD8A8.png)
    
- 通过[fontSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan#fontsize)属性设置SymbolSpan的大小。
    
    1. Row() {
    2.   Column() {
    3.     Text("48")
    4.     Text() {
    5.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    6.         .fontSize(48)
    7.         .renderingStrategy(SymbolRenderingStrategy.SINGLE)
    8.         .fontColor([Color.Black, Color.Green, Color.White])
    9.     }
    10.   }
    
    11.   Column() {
    12.     Text("72")
    13.     Text() {
    14.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    15.         .fontSize(72)
    16.         .renderingStrategy(SymbolRenderingStrategy.SINGLE)
    17.         .fontColor([Color.Black, Color.Green, Color.White])
    18.     }
    19.   }
    
    20.   Column() {
    21.     Text("96")
    22.     Text() {
    23.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    24.         .fontSize(96)
    25.         .renderingStrategy(SymbolRenderingStrategy.SINGLE)
    26.         .fontColor([Color.Black, Color.Green, Color.White])
    27.     }
    28.   }
    29. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.69694372990504995574888036340499:50001231000000:2800:D13B99BC9C8C5392CD11A31684829001B3366BF43BCD3B6DE6380FA250754D62.png)
    
- 通过[fontWeight](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan#fontweight)属性设置SymbolSpan组件的粗细。
    
    1. Row() {
    2.   Column() {
    3.     Text("Light")
    4.     Text() {
    5.       SymbolSpan($r('sys.symbol.ohos_trash'))
    6.         .fontWeight(FontWeight.Lighter)
    7.         .fontSize(96)
    8.     }
    9.   }
    
    10.   Column() {
    11.     Text("Normal")
    12.     Text() {
    13.       SymbolSpan($r('sys.symbol.ohos_trash'))
    14.         .fontWeight(FontWeight.Normal)
    15.         .fontSize(96)
    16.     }
    17.   }
    
    18.   Column() {
    19.     Text("Bold")
    20.     Text() {
    21.       SymbolSpan($r('sys.symbol.ohos_trash'))
    22.         .fontWeight(FontWeight.Bold)
    23.         .fontSize(96)
    24.     }
    25.   }
    26. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.66142343045282286018770834718923:50001231000000:2800:48B97F4295771C2795C536D79A0E218EC94D2806585884DCAEE1CD44F2E02BC9.png)
    
- 通过[fontColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan#fontcolor)属性设置SymbolSpan的颜色。
    
    1. Row() {
    2.   Column() {
    3.     Text("Black")
    4.     Text() {
    5.         SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    6.           .fontSize(96)
    7.           .fontColor([Color.Black])
    8.     }
    9.   }
    
    10.   Column() {
    11.     Text("Green")
    12.     Text() {
    13.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    14.         .fontSize(96)
    15.         .fontColor([Color.Green])
    16.     }
    17.   }
    
    18.   Column() {
    19.     Text("Pink")
    20.     Text() {
    21.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    22.         .fontSize(96)
    23.         .fontColor([Color.Pink])
    24.     }
    25.   }
    26. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.44383585849945119156062297891246:50001231000000:2800:2DEA624A571593AAE05E38413442694968592B39E3F05F3F9E458685B02F9DF1.png)
    
- 通过[renderingStrategy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan#renderingstrategy)属性设置SymbolSpan的渲染策略。
    
    1. Row() {
    2.   Column() {
    3.     Text("单色")
    4.     Text() {
    5.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    6.         .fontSize(96)
    7.         .renderingStrategy(SymbolRenderingStrategy.SINGLE)
    8.         .fontColor([Color.Black, Color.Green, Color.White])
    9.     }
    10.   }
    
    11.   Column() {
    12.     Text("多色")
    13.     Text() {
    14.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    15.         .fontSize(96)
    16.         .renderingStrategy(SymbolRenderingStrategy.MULTIPLE_COLOR)
    17.         .fontColor([Color.Black, Color.Green, Color.White])
    18.     }
    19.   }
    
    20.   Column() {
    21.     Text("分层")
    22.     Text() {
    23.       SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
    24.         .fontSize(96)
    25.         .renderingStrategy(SymbolRenderingStrategy.MULTIPLE_OPACITY)
    26.         .fontColor([Color.Black, Color.Green, Color.White])
    27.     }
    28.   }
    29. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.65817991175923140562260966454113:50001231000000:2800:418D16DAAD78A33E6D3C0186E88D29EDEDE1957C2B6CC7BE3C27CD4FBAA74A76.png)
    
- 通过[effectStrategy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan#effectstrategy)属性设置SymbolSpan的动效策略。
    
    1. Row() {
    2.   Column() {
    3.     Text("无动效")
    4.     Text() {
    5.       SymbolSpan($r('sys.symbol.ohos_wifi'))
    6.         .fontSize(96)
    7.         .effectStrategy(SymbolEffectStrategy.NONE)
    8.     }
    9.   }
    
    10.   Column() {
    11.     Text("整体缩放动效")
    12.     Text() {
    13.       SymbolSpan($r('sys.symbol.ohos_wifi'))
    14.         .fontSize(96)
    15.         .effectStrategy(SymbolEffectStrategy.SCALE)
    16.     }
    17.   }
    
    18.   Column() {
    19.     Text("层级动效")
    20.     Text() {
    21.       SymbolSpan($r('sys.symbol.ohos_wifi'))
    22.         .fontSize(96)
    23.         .effectStrategy(SymbolEffectStrategy.HIERARCHICAL)
    24.     }
    25.   }
    26. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.99867489871797938024001160279692:50001231000000:2800:BA74732116800F43AC23BB8111B703F5246DCFDA6E1C4BC633F3DB1A5E26AFC8.gif)
    
- SymbolSpan不支持通用事件。
    

## 自定义图标动效

相较于effectStrategy属性在启动时即触发动效，可以通过以下两种方式来控制动效的播放状态，以及选择更多样化的动效策略。

关于effectStrategy属性与symbolEffect属性的多种动态属性使用及生效原则，详情请参阅[SymbolGlyph.symbolEffect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph#symboleffect12-1)属性的说明。

- 通过设置SymbolEffect属性，可以同时配置SymbolGlyph的动效策略和播放状态。
    
    1. @State isActive: boolean = true;
    2. Column() {
    3.   Text("可变颜色动效")
    4.   SymbolGlyph($r('sys.symbol.ohos_wifi'))
    5.     .fontSize(96)
    6.     .symbolEffect(new HierarchicalSymbolEffect(EffectFillStyle.ITERATIVE), this.isActive)
    7.   Button(this.isActive ? '关闭' : '播放').onClick(() => {
    8.     this.isActive = !this.isActive;
    9.   })
    10. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.67656854545659741962630983672159:50001231000000:2800:A9D6F65C953C6C8CA7D873A822F685BC5CCB9BF6213E855EA8C8453083524E41.gif)
    
- 通过设置SymbolEffect属性，可以同时指定SymbolGlyph的动画效果策略及其播放触发条件。
    
    1. @State triggerValueReplace: number = 0;
    2. Column() {
    3.   Text("弹跳动效")
    4.   SymbolGlyph($r('sys.symbol.ellipsis_message_1'))
    5.     .fontSize(96)
    6.     .fontColor([Color.Gray])
    7.     .symbolEffect(new BounceSymbolEffect(EffectScope.WHOLE, EffectDirection.UP), this.triggerValueReplace)
    8.   Button('trigger').onClick(() => {
    9.     this.triggerValueReplace = this.triggerValueReplace + 1;
    10.   })
    11. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.26107538680198257297043215154572:50001231000000:2800:ADAEB8F02BAF5639F07357F77F41771CFB7E0C8237F5DE5C0CEAA3793B096EA0.gif)
    
- 从API version 20开始，支持通过设置SymbolEffect属性为[ReplaceSymbolEffect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph#replacesymboleffect12)，设置[ReplaceEffectType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph#replaceeffecttype20%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)为ReplaceEffectType.SLASH_OVERLAY，可以指定SymbolGlyph的禁用动画效果及其播放触发条件。
    
    1. @State triggerValueReplace: number = 0;
    2. @State renderMode: number = 1;
    3. replaceFlag: boolean = true;
    
    4. Column() {
    5.   Text("禁用动效")
    6.   SymbolGlyph(this.replaceFlag ? $r('sys.symbol.eye_slash') : $r('sys.symbol.eye'))
    7.     .fontSize(96)
    8.     .renderingStrategy(this.renderMode)
    9.     .symbolEffect(new ReplaceSymbolEffect(EffectScope.LAYER, ReplaceEffectType.SLASH_OVERLAY), this.triggerValueReplace)
    10.   Button('trigger').onClick(() => {
    11.     this.replaceFlag = !this.replaceFlag;
    12.     this.triggerValueReplace = this.triggerValueReplace + 1;
    13.   })
    14. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.18780159429131457959348567089729:50001231000000:2800:D3335FEDB7B96EA2E2ECCEF931C3290095E957BAC3B3ECEEBA72F93181717218.gif)
    
- 从API version 20开始，支持通过设置SymbolEffect属性为[ReplaceSymbolEffect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph#replacesymboleffect12)，设置[ReplaceEffectType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph#replaceeffecttype20%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)为ReplaceEffectType.CROSS_FADE，可以指定SymbolGlyph的快速替换动画效果及其播放触发条件。
    
    1. @State triggerValueReplace: number = 0;
    2. replaceFlag: boolean = true;
    
    3. Column() {
    4.   Text("快速替换动效")
    5.   SymbolGlyph(this.replaceFlag ? $r('sys.symbol.checkmark_circle') : $r('sys.symbol.repeat_1'))
    6.     .fontSize(96)
    7.     .symbolEffect(new ReplaceSymbolEffect(EffectScope.WHOLE, ReplaceEffectType.CROSS_FADE), this.triggerValueReplace)
    8.   Button('trigger').onClick(() => {
    9.     this.replaceFlag = !this.replaceFlag;
    10.     this.triggerValueReplace = this.triggerValueReplace + 1;
    11.   })
    12. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.62549489754489187156580435524497:50001231000000:2800:F36A9906A36124ACB476C75FD3FF073F504FD71CF2AFCFA34F4D9C0ED49E2E91.gif)
    

## 设置阴影和渐变色

- 从API version 20开始，支持通过[symbolShadow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph#symbolshadow20)接口实现了symbolGlyph组件显示阴影效果。
    
    1. @State isActive: boolean = true;
    
    2. options: ShadowOptions = {
    3.   radius: 10.0,
    4.   color: Color.Blue,
    5.   offsetX: 10,
    6.   offsetY: 10,
    7. };
    
    8. Column() {
    9.   Text("阴影能力")
    10.   SymbolGlyph($r('sys.symbol.ohos_wifi'))
    11.     .fontSize(96)
    12.     .symbolEffect(new HierarchicalSymbolEffect(EffectFillStyle.ITERATIVE), !this.isActive)
    13.     .symbolShadow(this.options)
    14.   Button(!this.isActive ? '关闭' : '播放').onClick(() => {
    15.     this.isActive = !this.isActive;
    16.   })
    17. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.86948777556241292999759430102637:50001231000000:2800:57054593B94C3D237841E0005FA51E0D9ACF49A8D6ABD073D4E5025A76F2CC7A.gif)
    
- 从API version 20开始，支持通过[shaderStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph#shaderstyle20)接口实现了symbolGlyph组件显示渐变色效果。
    
    1. radialGradientOptions: RadialGradientOptions = {
    2.   center: ["50%", "50%"],
    3.   radius: "20%",
    4.   colors: [[Color.Red, 0.0], [Color.Blue, 0.3], [Color.Green, 0.5]],
    5.   repeating: true,
    6. };
    
    7. Column() {
    8.   Text('径向渐变')
    9.     .fontSize(18)
    10.     .fontColor(0xCCCCCC)
    11.     .textAlign(TextAlign.Center)
    12.   SymbolGlyph($r('sys.symbol.ohos_folder_badge_plus'))
    13.     .fontSize(96)
    14.     .shaderStyle([new RadialGradientStyle(this.radialGradientOptions)])
    15. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.69769713784112302865551447891431:50001231000000:2800:16956EE693E5CFFF9A193D2CCFAE41E3943093D30C3C8140AC542DCB8D6AFEF8.jpg)
    

## 添加事件

SymbolGlyph组件可以添加通用事件，例如绑定[onClick](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-click#onclick)、[onTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#ontouch)等事件来响应操作。

1. @State wifiColor: ResourceColor = Color.Black;
2. SymbolGlyph($r('sys.symbol.ohos_wifi'))
3.   .fontSize(96)
4.   .fontColor([this.wifiColor])
5.   .onClick(() => {
6.     this.wifiColor = Color.Gray;
7.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.36552836852589526967820113337607:50001231000000:2800:3411558CABE3D690E303EB12E31CBF138446430B8DF01AB420A94E79C03D9F27.gif)

## 场景示例

该示例通过symbolEffect、fontSize、fontColor属性展示了播放列表的效果。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State triggerValueReplace: number = 0;
6.   @State symbolSources: Resource[] =
7.     [$r('sys.symbol.repeat'), $r('sys.symbol.repeat_1'), $r('sys.symbol.arrow_left_arrow_right')];
8.   @State symbolSourcesIndex: number = 0;
9.   @State symbolText: string[] = ['顺序播放', '单曲循环', '随机播放'];
10.   @State symbolTextIndex: number = 0;
11.   @State fontColorValue: ResourceColor = Color.Grey;
12.   @State fontColorValue1: ResourceColor = '#E8E8E8';

13.   build() {
14.     Column({ space: 10 }) {
15.       Row() {
16.         Text() {
17.           Span('当前播放列表')
18.             .fontSize(20)
19.             .fontWeight(FontWeight.Bolder)
20.           Span('（101）')
21.         }
22.       }

23.       Row() {
24.         Row({ space: 5 }) {
25.           SymbolGlyph(this.symbolSources[this.symbolSourcesIndex])
26.             .symbolEffect(new ReplaceSymbolEffect(EffectScope.WHOLE), this.triggerValueReplace)
27.             .fontSize(20)
28.             .fontColor([this.fontColorValue])
29.           Text(this.symbolText[this.symbolTextIndex])
30.             .fontColor(this.fontColorValue)
31.         }
32.         .onClick(() => {
33.           this.symbolTextIndex++;
34.           this.symbolSourcesIndex++;
35.           this.triggerValueReplace++;
36.           if (this.symbolSourcesIndex > (this.symbolSources.length - 1)) {
37.             this.symbolSourcesIndex = 0;
38.             this.triggerValueReplace = 0;
39.           }
40.           if (this.symbolTextIndex > (this.symbolText.length - 1)) {
41.             this.symbolTextIndex = 0;
42.           }
43.         })
44.         .width('75%')

45.         Row({ space: 5 }) {
46.           Text() {
47.             SymbolSpan($r('sys.symbol.arrow_down_circle_badge_vip_circle_filled'))
48.               .fontColor([this.fontColorValue])
49.               .fontSize(20)
50.           }

51.           Text() {
52.             SymbolSpan($r('sys.symbol.heart_badge_plus'))
53.               .fontColor([this.fontColorValue])
54.               .fontSize(20)
55.           }

56.           Text() {
57.             SymbolSpan($r('sys.symbol.ohos_trash'))
58.               .fontColor([this.fontColorValue])
59.               .fontSize(20)
60.           }
61.         }
62.         .width('25%')
63.       }

64.       Divider().width(5).color(this.fontColorValue1).width('98%')
65.       Row() {
66.         Row() {
67.           Text("歌曲一")
68.         }.width('82%')

69.         Row({ space: 5 }) {
70.           SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
71.             .fontColor([this.fontColorValue])
72.             .fontSize(20)
73.           SymbolGlyph($r('sys.symbol.trash'))
74.             .fontColor([this.fontColorValue])
75.             .fontSize(20)
76.         }
77.       }

78.       Divider().width(5).color(this.fontColorValue1).width('98%')
79.       Row() {
80.         Row() {
81.           Text("歌曲二")
82.         }.width('82%')

83.         Row({ space: 5 }) {
84.           SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
85.             .fontColor([this.fontColorValue])
86.             .fontSize(20)
87.           SymbolGlyph($r('sys.symbol.trash'))
88.             .fontColor([this.fontColorValue])
89.             .fontSize(20)
90.         }
91.       }

92.       Divider().width(5).color(this.fontColorValue1).width('98%')
93.       Row() {
94.         Row() {
95.           Text("歌曲三")
96.         }.width('82%')

97.         Row({ space: 5 }) {
98.           SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
99.             .fontColor([this.fontColorValue])
100.             .fontSize(20)
101.           SymbolGlyph($r('sys.symbol.trash'))
102.             .fontColor([this.fontColorValue])
103.             .fontSize(20)
104.         }
105.       }

106.       Divider().width(5).color(this.fontColorValue1).width('98%')
107.       Row() {
108.         Row() {
109.           Text("歌曲四")
110.         }.width('82%')

111.         Row({ space: 5 }) {
112.           SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
113.             .fontColor([this.fontColorValue])
114.             .fontSize(20)
115.           SymbolGlyph($r('sys.symbol.trash'))
116.             .fontColor([this.fontColorValue])
117.             .fontSize(20)
118.         }
119.       }

120.       Divider().width(5).color(this.fontColorValue1).width('98%')
121.       Row() {
122.         Row() {
123.           Text("歌曲五")
124.         }.width('82%')

125.         Row({ space: 5 }) {
126.           SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
127.             .fontColor([this.fontColorValue])
128.             .fontSize(20)
129.           SymbolGlyph($r('sys.symbol.trash'))
130.             .fontColor([this.fontColorValue])
131.             .fontSize(20)
132.         }
133.       }

134.       Divider().width(5).color(this.fontColorValue1).width('98%')
135.       Row() {
136.         Row() {
137.           Text("歌曲六")
138.         }.width('82%')

139.         Row({ space: 5 }) {
140.           SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
141.             .fontColor([this.fontColorValue])
142.             .fontSize(20)
143.           SymbolGlyph($r('sys.symbol.trash'))
144.             .fontColor([this.fontColorValue])
145.             .fontSize(20)
146.         }
147.       }

148.       Divider().width(5).color(this.fontColorValue1).width('98%')
149.       Row() {
150.         Row() {
151.           Text("歌曲七")
152.         }.width('82%')

153.         Row({ space: 5 }) {
154.           SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
155.             .fontColor([this.fontColorValue])
156.             .fontSize(20)
157.           SymbolGlyph($r('sys.symbol.trash'))
158.             .fontColor([this.fontColorValue])
159.             .fontSize(20)
160.         }
161.       }

162.       Divider().width(5).color(this.fontColorValue1).width('98%')
163.       Column() {
164.         Text("关闭")
165.       }
166.       .alignItems(HorizontalAlign.Center)
167.       .width('98%')
168.     }
169.     .alignItems(HorizontalAlign.Start)
170.     .width('100%')
171.     .height(400)
172.     .padding({
173.       left: 10,
174.       top: 10
175.     })
176.   }
177. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.03311118461282997360591273985401:50001231000000:2800:359C4392E34E6D5FD70E5E1603F099B31BE9FB172863C85954C4FD1CEF175668.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor "富文本编辑（RichEditor）")
# 图文混排

更新时间: 2025-12-16 16:40

图文混排是指图片与文字混合排列，文字可展示于图片四周。此排列方式能够直观呈现页面信息，增强视觉冲击力，使页面展示效果更加多样化。

## 使用Span和ImageSpan实现图文混排

通过Text组件设置[textVerticalAlign](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textverticalalign20)属性和ImageSpan设置verticalAlign为ImageSpanAlignment.FOLLOW_PARAGRAPH，实现商品价格优惠信息展示的应用场景。

1. Text() {
2.   ImageSpan($r('app.media.hot_sale'))
3.     .width(50)
4.     .height(30)
5.     .borderRadius(5)
6.     .verticalAlign(ImageSpanAlignment.FOLLOW_PARAGRAPH)
7.   Span('惊喜价 ￥1299')
8.     .fontSize(25)
9.     .fontColor(Color.Red)
10.   Span('1599')
11.     .decoration({
12.     type: TextDecorationType.LineThrough,
13.     color: Color.Grey,
14.     style: TextDecorationStyle.SOLID
15.     })
16.     .fontSize(16)
17. }.textVerticalAlign(TextVerticalAlign.CENTER)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.40405375487915213799603230143117:50001231000000:2800:9C4CE79070A1D31FCE14B38CDE30D9AAD36F666D5739CB51463ABF4CBB98FE8D.png)

## 使用属性字符串实现图文混排

通过[ImageAttachment](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#imageattachment)添加图片，[TextStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#textstyle)设置多种文本样式，实现商品详情信息展示的应用场景。

1. // xxx.ets
2. import { image } from '@kit.ImageKit';
3. import { LengthMetrics } from '@kit.ArkUI';

4. @Entry
5. @Component
6. struct styled_string_demo {
7.   @State message: string = 'Hello World';
8.   imagePixelMap: image.PixelMap | undefined = undefined;
9.   @State imagePixelMap3: image.PixelMap | undefined = undefined;
10.   mutableStr: MutableStyledString = new MutableStyledString('123');
11.   controller: TextController = new TextController();
12.   mutableStr2: MutableStyledString = new MutableStyledString('This is set decoration line style to the mutableStr2', [{
13.     start: 0,
14.     length: 15,
15.     styledKey: StyledStringKey.DECORATION,
16.     styledValue: new DecorationStyle({
17.       type: TextDecorationType.Overline,
18.       color: Color.Orange,
19.       style: TextDecorationStyle.DOUBLE
20.     })
21.   }]);

22.   async aboutToAppear() {
23.     console.info("aboutToAppear initial imagePixelMap");
24.     this.imagePixelMap = await this.getPixmapFromMedia($r('app.media.sky'));
25.   }

26.   private async getPixmapFromMedia(resource: Resource) {
27.     let unit8Array = await this.getUIContext().getHostContext()?.resourceManager?.getMediaContent(resource.id);
28.     let imageSource = image.createImageSource(unit8Array?.buffer?.slice(0, unit8Array?.buffer?.byteLength));
29.     let createPixelMap: image.PixelMap = await imageSource.createPixelMap({
30.       desiredPixelFormat: image.PixelMapFormat.RGBA_8888
31.     });
32.     await imageSource.release();
33.     return createPixelMap;
34.   }

35.   leadingMarginValue: ParagraphStyle = new ParagraphStyle({
36.     leadingMargin: LengthMetrics.vp(5),
37.     maxLines: 2,
38.     overflow: TextOverflow.Ellipsis,
39.     textVerticalAlign: TextVerticalAlign.BASELINE
40.   });
41.   //行高样式对象
42.   lineHeightStyle1: LineHeightStyle = new LineHeightStyle(new LengthMetrics(24));
43.   //Bold样式
44.   boldTextStyle: TextStyle = new TextStyle({ fontWeight: FontWeight.Bold });
45.   //创建含段落样式的对象paragraphStyledString1
46.   paragraphStyledString1: MutableStyledString =
47.     new MutableStyledString("\n高质量冲洗照片，高清冲印3/4/5/6寸包邮塑封，品质保证，", [
48.       {
49.         start: 0,
50.         length: 28,
51.         styledKey: StyledStringKey.PARAGRAPH_STYLE,
52.         styledValue: this.leadingMarginValue
53.       },
54.       {
55.         start: 11,
56.         length: 4,
57.         styledKey: StyledStringKey.LINE_HEIGHT,
58.         styledValue: this.lineHeightStyle1
59.       }
60.     ]);
61.   paragraphStyledString2: MutableStyledString = new MutableStyledString("\n限时直降5.15元 限量增送", [
62.     {
63.       start: 0,
64.       length: 5,
65.       styledKey: StyledStringKey.PARAGRAPH_STYLE,
66.       styledValue: this.leadingMarginValue
67.     },
68.     {
69.       start: 0,
70.       length: 4,
71.       styledKey: StyledStringKey.LINE_HEIGHT,
72.       styledValue: new LineHeightStyle(new LengthMetrics(40))
73.     },
74.     {
75.       start: 0,
76.       length: 9,
77.       styledKey: StyledStringKey.FONT,
78.       styledValue: this.boldTextStyle
79.     },
80.     {
81.       start: 1,
82.       length: 9,
83.       styledKey: StyledStringKey.FONT,
84.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(20), fontColor: Color.Red })
85.     },
86.     {
87.       start: 11,
88.       length: 4,
89.       styledKey: StyledStringKey.FONT,
90.       styledValue: new TextStyle({ fontColor: Color.Grey, fontSize: LengthMetrics.vp(14) })
91.     }
92.   ]);
93.   paragraphStyledString3: MutableStyledString = new MutableStyledString("\n￥22.50 销量400万+", [
94.     {
95.       start: 0,
96.       length: 15,
97.       styledKey: StyledStringKey.PARAGRAPH_STYLE,
98.       styledValue: this.leadingMarginValue
99.     },
100.     {
101.       start: 0,
102.       length: 7,
103.       styledKey: StyledStringKey.LINE_HEIGHT,
104.       styledValue: new LineHeightStyle(new LengthMetrics(40))
105.     },
106.     {
107.       start: 0,
108.       length: 7,
109.       styledKey: StyledStringKey.FONT,
110.       styledValue: this.boldTextStyle
111.     },
112.     {
113.       start: 1,
114.       length: 1,
115.       styledKey: StyledStringKey.FONT,
116.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(18), fontColor: Color.Red })
117.     },
118.     {
119.       start: 2,
120.       length: 2,
121.       styledKey: StyledStringKey.FONT,
122.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(36), fontColor: Color.Red })
123.     },
124.     {
125.       start: 4,
126.       length: 3,
127.       styledKey: StyledStringKey.FONT,
128.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(20), fontColor: Color.Red })
129.     },
130.     {
131.       start: 7,
132.       length: 9,
133.       styledKey: StyledStringKey.FONT,
134.       styledValue: new TextStyle({ fontColor: Color.Grey, fontSize: LengthMetrics.vp(14) })
135.     }
136.   ]);

137.   build() {
138.     Row() {
139.       Column({ space: 10 }) {
140.         Text(undefined, { controller: this.controller })
141.           .copyOption(CopyOptions.InApp)
142.           .draggable(true)
143.           .backgroundColor('#FFFFFF')
144.           .borderRadius(5)
145.           .width(210)

146.         Button('点击查看商品详情')
147.           .onClick(() => {
148.             if (this.imagePixelMap !== undefined) {
149.               this.mutableStr = new MutableStyledString(new ImageAttachment({
150.                 value: this.imagePixelMap,
151.                 size: { width: 210, height: 190 },
152.                 verticalAlign: ImageSpanAlignment.BASELINE,
153.                 objectFit: ImageFit.Fill,
154.                 layoutStyle: {
155.                   borderRadius: LengthMetrics.vp(5)
156.                 }
157.               }));
158.               this.paragraphStyledString1.appendStyledString(this.paragraphStyledString2);
159.               this.paragraphStyledString1.appendStyledString(this.paragraphStyledString3);
160.               this.mutableStr.appendStyledString(this.paragraphStyledString1);
161.               this.controller.setStyledString(this.mutableStr);
162.             }
163.           })
164.       }
165.       .width('100%')
166.     }
167.     .height('100%')
168.     .backgroundColor('#F8F8FF')
169.   }
170. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.06277020123838261849416888155517:50001231000000:2800:77AF38F148FAEB500B58E8CE118599413343A60C660E7E46AB27EB9E0258AD6E.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-styled-string "属性字符串（StyledString/MutableStyledString）")
# 图文混排

更新时间: 2025-12-16 16:40

图文混排是指图片与文字混合排列，文字可展示于图片四周。此排列方式能够直观呈现页面信息，增强视觉冲击力，使页面展示效果更加多样化。

## 使用Span和ImageSpan实现图文混排

通过Text组件设置[textVerticalAlign](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textverticalalign20)属性和ImageSpan设置verticalAlign为ImageSpanAlignment.FOLLOW_PARAGRAPH，实现商品价格优惠信息展示的应用场景。

1. Text() {
2.   ImageSpan($r('app.media.hot_sale'))
3.     .width(50)
4.     .height(30)
5.     .borderRadius(5)
6.     .verticalAlign(ImageSpanAlignment.FOLLOW_PARAGRAPH)
7.   Span('惊喜价 ￥1299')
8.     .fontSize(25)
9.     .fontColor(Color.Red)
10.   Span('1599')
11.     .decoration({
12.     type: TextDecorationType.LineThrough,
13.     color: Color.Grey,
14.     style: TextDecorationStyle.SOLID
15.     })
16.     .fontSize(16)
17. }.textVerticalAlign(TextVerticalAlign.CENTER)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.40405375487915213799603230143117:50001231000000:2800:9C4CE79070A1D31FCE14B38CDE30D9AAD36F666D5739CB51463ABF4CBB98FE8D.png)

## 使用属性字符串实现图文混排

通过[ImageAttachment](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#imageattachment)添加图片，[TextStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-styled-string#textstyle)设置多种文本样式，实现商品详情信息展示的应用场景。

1. // xxx.ets
2. import { image } from '@kit.ImageKit';
3. import { LengthMetrics } from '@kit.ArkUI';

4. @Entry
5. @Component
6. struct styled_string_demo {
7.   @State message: string = 'Hello World';
8.   imagePixelMap: image.PixelMap | undefined = undefined;
9.   @State imagePixelMap3: image.PixelMap | undefined = undefined;
10.   mutableStr: MutableStyledString = new MutableStyledString('123');
11.   controller: TextController = new TextController();
12.   mutableStr2: MutableStyledString = new MutableStyledString('This is set decoration line style to the mutableStr2', [{
13.     start: 0,
14.     length: 15,
15.     styledKey: StyledStringKey.DECORATION,
16.     styledValue: new DecorationStyle({
17.       type: TextDecorationType.Overline,
18.       color: Color.Orange,
19.       style: TextDecorationStyle.DOUBLE
20.     })
21.   }]);

22.   async aboutToAppear() {
23.     console.info("aboutToAppear initial imagePixelMap");
24.     this.imagePixelMap = await this.getPixmapFromMedia($r('app.media.sky'));
25.   }

26.   private async getPixmapFromMedia(resource: Resource) {
27.     let unit8Array = await this.getUIContext().getHostContext()?.resourceManager?.getMediaContent(resource.id);
28.     let imageSource = image.createImageSource(unit8Array?.buffer?.slice(0, unit8Array?.buffer?.byteLength));
29.     let createPixelMap: image.PixelMap = await imageSource.createPixelMap({
30.       desiredPixelFormat: image.PixelMapFormat.RGBA_8888
31.     });
32.     await imageSource.release();
33.     return createPixelMap;
34.   }

35.   leadingMarginValue: ParagraphStyle = new ParagraphStyle({
36.     leadingMargin: LengthMetrics.vp(5),
37.     maxLines: 2,
38.     overflow: TextOverflow.Ellipsis,
39.     textVerticalAlign: TextVerticalAlign.BASELINE
40.   });
41.   //行高样式对象
42.   lineHeightStyle1: LineHeightStyle = new LineHeightStyle(new LengthMetrics(24));
43.   //Bold样式
44.   boldTextStyle: TextStyle = new TextStyle({ fontWeight: FontWeight.Bold });
45.   //创建含段落样式的对象paragraphStyledString1
46.   paragraphStyledString1: MutableStyledString =
47.     new MutableStyledString("\n高质量冲洗照片，高清冲印3/4/5/6寸包邮塑封，品质保证，", [
48.       {
49.         start: 0,
50.         length: 28,
51.         styledKey: StyledStringKey.PARAGRAPH_STYLE,
52.         styledValue: this.leadingMarginValue
53.       },
54.       {
55.         start: 11,
56.         length: 4,
57.         styledKey: StyledStringKey.LINE_HEIGHT,
58.         styledValue: this.lineHeightStyle1
59.       }
60.     ]);
61.   paragraphStyledString2: MutableStyledString = new MutableStyledString("\n限时直降5.15元 限量增送", [
62.     {
63.       start: 0,
64.       length: 5,
65.       styledKey: StyledStringKey.PARAGRAPH_STYLE,
66.       styledValue: this.leadingMarginValue
67.     },
68.     {
69.       start: 0,
70.       length: 4,
71.       styledKey: StyledStringKey.LINE_HEIGHT,
72.       styledValue: new LineHeightStyle(new LengthMetrics(40))
73.     },
74.     {
75.       start: 0,
76.       length: 9,
77.       styledKey: StyledStringKey.FONT,
78.       styledValue: this.boldTextStyle
79.     },
80.     {
81.       start: 1,
82.       length: 9,
83.       styledKey: StyledStringKey.FONT,
84.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(20), fontColor: Color.Red })
85.     },
86.     {
87.       start: 11,
88.       length: 4,
89.       styledKey: StyledStringKey.FONT,
90.       styledValue: new TextStyle({ fontColor: Color.Grey, fontSize: LengthMetrics.vp(14) })
91.     }
92.   ]);
93.   paragraphStyledString3: MutableStyledString = new MutableStyledString("\n￥22.50 销量400万+", [
94.     {
95.       start: 0,
96.       length: 15,
97.       styledKey: StyledStringKey.PARAGRAPH_STYLE,
98.       styledValue: this.leadingMarginValue
99.     },
100.     {
101.       start: 0,
102.       length: 7,
103.       styledKey: StyledStringKey.LINE_HEIGHT,
104.       styledValue: new LineHeightStyle(new LengthMetrics(40))
105.     },
106.     {
107.       start: 0,
108.       length: 7,
109.       styledKey: StyledStringKey.FONT,
110.       styledValue: this.boldTextStyle
111.     },
112.     {
113.       start: 1,
114.       length: 1,
115.       styledKey: StyledStringKey.FONT,
116.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(18), fontColor: Color.Red })
117.     },
118.     {
119.       start: 2,
120.       length: 2,
121.       styledKey: StyledStringKey.FONT,
122.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(36), fontColor: Color.Red })
123.     },
124.     {
125.       start: 4,
126.       length: 3,
127.       styledKey: StyledStringKey.FONT,
128.       styledValue: new TextStyle({ fontSize: LengthMetrics.vp(20), fontColor: Color.Red })
129.     },
130.     {
131.       start: 7,
132.       length: 9,
133.       styledKey: StyledStringKey.FONT,
134.       styledValue: new TextStyle({ fontColor: Color.Grey, fontSize: LengthMetrics.vp(14) })
135.     }
136.   ]);

137.   build() {
138.     Row() {
139.       Column({ space: 10 }) {
140.         Text(undefined, { controller: this.controller })
141.           .copyOption(CopyOptions.InApp)
142.           .draggable(true)
143.           .backgroundColor('#FFFFFF')
144.           .borderRadius(5)
145.           .width(210)

146.         Button('点击查看商品详情')
147.           .onClick(() => {
148.             if (this.imagePixelMap !== undefined) {
149.               this.mutableStr = new MutableStyledString(new ImageAttachment({
150.                 value: this.imagePixelMap,
151.                 size: { width: 210, height: 190 },
152.                 verticalAlign: ImageSpanAlignment.BASELINE,
153.                 objectFit: ImageFit.Fill,
154.                 layoutStyle: {
155.                   borderRadius: LengthMetrics.vp(5)
156.                 }
157.               }));
158.               this.paragraphStyledString1.appendStyledString(this.paragraphStyledString2);
159.               this.paragraphStyledString1.appendStyledString(this.paragraphStyledString3);
160.               this.mutableStr.appendStyledString(this.paragraphStyledString1);
161.               this.controller.setStyledString(this.mutableStr);
162.             }
163.           })
164.       }
165.       .width('100%')
166.     }
167.     .height('100%')
168.     .backgroundColor('#F8F8FF')
169.   }
170. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.06277020123838261849416888155517:50001231000000:2800:77AF38F148FAEB500B58E8CE118599413343A60C660E7E46AB27EB9E0258AD6E.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-styled-string "属性字符串（StyledString/MutableStyledString）")
# 管理软键盘

更新时间: 2025-12-16 16:40

软键盘是用户交互的重要途径，提供文本输入功能。本文介绍在使用系统输入框组件（[TextInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput)、[TextArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea)、[Search](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search)、[RichEditor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor)）时，如何控制软键盘的弹出和收起。

## 弹出软键盘

默认情况下，当焦点转移到输入框时，软键盘将自动弹出。

焦点转移到输入框的方法主要有：

1. 人机交互获得焦点，例如：单击、双击、长按输入框。
    
2. 通过代码设置焦点，例如：使用[requestFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#requestfocus9)或[defaultFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#defaultfocus9)方法，将焦点转移到输入框。
    
3. 使用外接键盘的按键走焦，例如：Tab键、Shift+Tab键、方向键，按下后可以转移焦点。外接键盘时输入框获焦，不会弹出系统软键盘，会显示物理键盘悬浮栏。
    

软键盘分为系统软键盘和自定义键盘。输入框的[enableKeyboardOnFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea#enablekeyboardonfocus10)属性会影响系统软键盘弹出。当enableKeyboardOnFocus属性设置为false时，只有通过点击、按键走焦才能弹出系统软键盘。enableKeyboardOnFocus属性对自定义键盘的弹出无影响。外接物理键盘会阻止弹出系统软键盘，对自定义键盘无影响。

### 人机交互获得焦点

以下示例展示了单击、双击和长按输入框时，软键盘弹出效果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.34731289924059422298832039113718:50001231000000:2800:C118C3CB0A5A2B8EFCEED2EC725183636E8138FB9557EC2A747698034BB2BD4B.gif)

### 通过代码请求焦点

可以通过代码控制将焦点转移到输入框，包括使用[defaultFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#defaultfocus9)和[requestFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#requestfocus9)方法。更多细节请参见[支持焦点处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event)。

以下示例展示了点击按钮时，焦点转移到输入框并弹出软键盘的方法。

1. @Entry
2. @Component
3. struct demo {
4.   controller: TextInputController = new TextInputController();
5.   @State inputValue: string = "";

6.   build() {
7.     Column({ space: 20 }) {
8.       Button('输入框请求焦点').onClick(() => {
9.         this.getUIContext().getFocusController().requestFocus("textInput1")
10.       })
11.       TextInput({ controller: this.controller, text: this.inputValue })
12.         .id("textInput1")
13.     }
14.     .height('100%')
15.     .width('80%')
16.     .margin('10%')
17.     .justifyContent(FlexAlign.Center)
18.   }
19. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.38008556848384188399998368026324:50001231000000:2800:A23A3B6396F5D39E92EC1EE1F1699F577EA1B9B52048551C0C022B784FDDE5D0.gif)

### 使用外接键盘的按键走焦

外接物理键盘时，按下物理键盘的Tab键、Shift+Tab键、方向键可以转移焦点。按键走焦到输入框时，显示物理键盘悬浮栏。更多细节请参见[支持焦点处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)。

以下示例展示了外接键盘时，多次按下Tab键，焦点转移到TextInput并弹出软键盘的场景。当按下Tab键时，焦点在页面中的三个组件之间转移，可以从Text的蓝色边框或者TextInput中闪烁的光标观察到焦点转移。当TextInput获焦时，显示光标，同时显示物理键盘悬浮栏。

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Column({ space: 20 }) {
6.       Text('Text.focusable(true)')
7.         .focusable(true)

8.       TextInput({ placeholder: "TextInput" })

9.       TextInput({ placeholder: "TextInput" })
10.     }
11.     .height('100%')
12.     .width('80%')
13.     .margin('10%')
14.     .justifyContent(FlexAlign.Center)
15.   }
16. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.99493073230344459853189575465773:50001231000000:2800:29DD28E93CD83E974E8132D50ECB783B49BD24CDB9A805BF85B61952454824E9.gif)

## 收起软键盘

当输入框获得焦点时，软键盘会弹出；然而，当输入框失焦时，软键盘不会自动收起，而是由下一个获得焦点的组件决定是否收起软键盘。如果该组件需要使用软键盘，软键盘将继续显示；如果该组件不需要软键盘，则软键盘将被收起。通常情况下，除输入框外的其他组件不需要软键盘。

收起软键盘的常见场景如下所示，下列场景都会将焦点转移到不需要软键盘的组件上并收起软键盘。

1. 用户主动点击软键盘的关闭按钮。
    
2. 用户正在拖拽文本。
    
3. 输入框接收到了侧滑手势。
    
4. 页面发生切换。
    
5. 通过输入框的[TextInputController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#textinputcontroller8)退出编辑态。
    
6. 焦点从输入框转移到另一个不需要软键盘的组件。
    

### 点击软键盘的关闭按钮

软键盘自带关闭按钮，用户点击该按钮时，软键盘将被收起。

以下示例展示了用户主动点击软键盘关闭按钮的场景。

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Column({ space: 20 }) {
6.       Blank()
7.         .height(350)
8.       Flex({ direction: FlexDirection.Row }) {
9.         TextInput({ placeholder: 'TextInput' })
10.       }
11.       .width(250)
12.     }
13.     .height('100%')
14.     .width('90%')
15.     .padding('5%')
16.   }
17. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.22719004401344068882674411314841:50001231000000:2800:962980824D174080C85EE2359889204CB05717385E68FCC9ADC2B323759538E3.gif)

### 拖拽文本

用户主动拖拽输入框的文本，开始拖拽时，软键盘将收起。更多细节请参见[支持统一拖拽](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-drag-event)。

以下示例展示了用户主动拖拽文本时，软键盘被收起的场景。

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Column({ space: 20 }) {
6.       Blank()
7.         .height(350)
8.       Flex({ direction: FlexDirection.Row }) {
9.         TextInput({ text: '用户主动拖拽文本' })
10.           .selectAll(true)
11.           .defaultFocus(true)
12.       }
13.       .width(250)
14.     }
15.     .height('100%')
16.     .width('90%')
17.     .padding('5%')
18.   }
19. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.47038183688495567663373119764377:50001231000000:2800:85785F95C2B3C9E58D2A5686C71DD2C9BBFC00F1F4815D655035520397DEE764.gif)

### 接收侧滑手势

下面的动图展示了“用户侧滑时软键盘收起”的场景。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.96524383027947374164097391929955:50001231000000:2800:E5E155A373CC5CDD6A2FDD543FE98B67C8D514658B4C13D388A0B9E3F01B7299.gif)

### 页面发生切换

以下示例展示了页面切换过程中，软键盘收起的场景。

页面跳转写法请参考[组件导航(Navigation) (推荐)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation)。

跳转前的页面

1. // Index.ets
2. @Entry
3. @Component
4. struct Index {
5.   // 创建一个导航控制器对象并传入Navigation
6.   pathStack: NavPathStack = new NavPathStack()

7.   build() {
8.     Navigation(this.pathStack) {
9.       Column({ space: 30 }) {
10.         Blank().height(150)
11.         TextInput({ placeholder: 'TextInput' })
12.         Button('跳转到下一个页面')
13.           .onClick(() => {
14.             this.pathStack.pushPath({ name: 'demo_text_1' })
15.           })
16.       }
17.       .height('100%')
18.       .width('80%')
19.       .margin('10%')
20.     }
21.     .title('用Navigation实现页面跳转')
22.   }
23. }

跳转后的页面

1. // demo_text_1.ets
2. @Builder
3. export function demo_text_1_Builder() {
4.   demo_text_1()
5. }

6. @Component
7. struct demo_text_1 {
8.   pathStack: NavPathStack = new NavPathStack()
9.   // 跳转后的页面
10.   build() {
11.     NavDestination() {
12.       Column({ space: 20 }) {
13.         Text('跳转后的页面没有需要键盘的组件')
14.       }
15.       .width('100%')
16.       .height('100%')
17.       .justifyContent(FlexAlign.Center)
18.     }
19.     .onReady((context: NavDestinationContext) => {
20.       this.pathStack = context.pathStack
21.     })
22.   }
23. }

系统路由表配置

在跳转目标模块的配置文件module.json5添加路由表配置

1. {
2.   "module": {
3.     //...
4.     "routerMap": "$profile:route_map",
5.     //...
6.   }
7. }

在工程resources/base/profile中创建route_map.json文件。添加如下配置信息

1. // route_map.json
2. {
3.   "routerMap": [
4.     {
5.       "name": "demo_text_1",
6.       "pageSourceFile": "src/main/ets/pages/demo_text_1.ets",
7.       "buildFunction": "demo_text_1_Builder"
8.     }
9.   ]
10. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.58031814467384180412549446404853:50001231000000:2800:4B2D0C45D563A8F3FFEF0672C4268F1AAD24EAAF9115039424851849DFDD9743.gif)

### 通过输入框的controller退出编辑态

通过输入框的[TextInputController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#textinputcontroller8)调用[stopEditing](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#stopediting10)方法后，软键盘会自动收起。

以下示例展示了如何通过[TextInputController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#textinputcontroller8)收起软键盘。

1. @Entry
2. @Component
3. struct demo {
4.   controller: TextInputController = new TextInputController();
5.   @State inputValue: string = "";

6.   build() {
7.     Column({ space: 30 }) {
8.       Button('关闭键盘').onClick(() => {
9.         this.controller.stopEditing()
10.       })
11.       TextInput({ controller: this.controller, text: this.inputValue })
12.     }
13.     .width('80%')
14.     .height('100%')
15.     .margin('10%')
16.     .justifyContent(FlexAlign.Center)
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.92555426775023996079723800983153:50001231000000:2800:B3065AA5C674C3F1E6394F962961EE8F093399D1E90693C5C78EBD83DD07B11B.gif)

### 焦点转移到不需要软键盘的组件

焦点转移到不需要软键盘的组件时，软键盘会自动收起。

代码控制焦点转移的方法，包括[requestFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#requestfocus9)、[clearFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#clearfocus12)。更多细节请参见[支持焦点处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event)。

与通过输入框的controller退出编辑态方法相比，焦点转移到不需要软键盘的组件方法的优势在于，页面包含多个输入框时，开发者无需为每个输入框设置controller、再通过controller收起软键盘。

以下示例展示了点击按钮时，调用[requestFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#requestfocus9)方法，焦点从输入框转移到按钮上，软键盘收起的场景。

1. @Entry
2. @Component
3. struct TextInputExample {
4.   controller: TextInputController = new TextInputController();
5.   @State inputValue: string = "";

6.   build() {
7.     Column({ space: 20 }) {
8.       Button('change focus').onClick(() => {
9.         this.getUIContext().getFocusController().requestFocus("button")
10.       }).id("button")
11.       TextInput({ controller: this.controller, text: this.inputValue })
12.     }
13.     .justifyContent(FlexAlign.Center)
14.     .height('100%')
15.     .width('80%')
16.     .margin('10%')
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.66444941733156948829738963811489:50001231000000:2800:E15371974EA730AA63157848123FF098DAC84C77CEFA11EAAB46428041C245BE.gif)

以下示例展示了滚动容器在开始滚动时收起键盘的场景。[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)开始滚动时，调用[clearFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#clearfocus12)方法清理焦点，焦点转移到页面根容器节点，页面根容器节点不需要软键盘，从而收起软键盘。

1. @Entry
2. @Component
3. struct Index {
4.   private arr: number[] = Array.from<number, number>(
5.     { length: 100 } as ArrayLike<number>,
6.     (_, i: number) => i + 1
7.   );

8.   build() {
9.     Column() {
10.       List({ space: 20, initialIndex: 0 }) {
11.         ForEach(this.arr, (item: number, index?: number) => {
12.           ListItem() {
13.             Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Center }) {
14.               TextInput({ placeholder: 'TextInput ' + item })
15.             }
16.           }
17.         }, (item: string) => item)
18.       }
19.       .onScrollStart(() => {
20.         // List开始滚动时清理焦点，达成收起键盘的目的
21.         this.getUIContext().getFocusController().clearFocus()
22.       })
23.       .width('80%')
24.       .height('80%')
25.       .margin('10%')
26.     }
27.     .justifyContent(FlexAlign.Center)
28.   }
29. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.39450651142366630148288513553246:50001231000000:2800:AC3CD601498175D44E0AA35E53D87372272E9E7C9A1306054072F7FD74E60CE7.gif)

## 常见问题

在软键盘的实际应用中，开发者可能会遇到一些特殊的使用场景或个性化需求。本节将针对这些常见问题提供相应的解决方案，帮助开发者更好地控制软键盘的行为。

### 获得焦点时阻止弹出软键盘

**问题现象**

如何实现点击输入框时，不弹出软键盘？

**原因分析**

默认情况下，点击输入框后，输入框获得焦点，会自动弹出系统软键盘。通过[customKeyboard](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#customkeyboard10)设置自定义键盘之后，输入框获焦时不会弹出系统软键盘，改为弹出自定义键盘。

**解决措施**

设置自定义键盘后，系统键盘不会弹出。利用此特性，设置一个空的自定义键盘，实现“点击输入框时不显示软键盘”的效果。

示例如下，单击输入框，拉起空的自定义键盘。

1. @Entry
2. @Component
3. struct demo {
4.   controller: TextInputController = new TextInputController();
5.   @State inputValue: string = "";

6.   // 自定义键盘组件
7.   @Builder
8.   CustomKeyboardBuilder() {
9.     Column() {
10.     }
11.   }

12.   build() {
13.     Column() {
14.       TextInput({ placeholder: 'TextInput', controller: this.controller, text: this.inputValue })// 绑定自定义键盘
15.         .customKeyboard(this.CustomKeyboardBuilder())
16.     }
17.     .justifyContent(FlexAlign.Center)
18.     .width('80%')
19.     .margin('10%')
20.     .height('100%')
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.94727176514973302776740683846174:50001231000000:2800:28EC6C21CF631A9568846D32197A90A6D737477BC7739972240FCFC3BE686319.gif)

### 点击发送按钮后不收起键盘

**问题现象**

如何实现点击软键盘发送按钮之后，软键盘不收起？

**原因分析**

软键盘的[enterKeyType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea#enterkeytype11)可以设置输入法回车键类型，包括发送样式。按下发送按钮实际上是按下回车键，非TV设备按下回车键时，输入框默认会失焦并且收起键盘。

**解决措施**

软键盘的[enterKeyType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea#enterkeytype11)可以设置输入法回车键类型。除EnterKeyType.NEW_LINE外，enterKeyType设置其他的枚举值时，按下软键盘输入法回车键都会触发[onSubmit](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea#onsubmit14)事件。可以在TextArea的onSubmit回调中，通过调用[keepEditableState](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#keepeditablestate11)接口保持输入框编辑态，使得点击回车键后不收起键盘。

示例如下，软键盘的回车键显示为发送样式。按下发送之后，键盘不会收起。

1. @Entry
2. @Component
3. struct demo {
4.   build() {
5.     Column({ space: 20 }) {
6.       TextArea({ placeholder: '点击发送收起键盘' })
7.         .enterKeyType(EnterKeyType.Send)

8.       TextArea({ placeholder: 'onSubmit中设置keepEditableState，点击发送不收起键盘' })
9.         .enterKeyType(EnterKeyType.Send)
10.         .onSubmit((enterKey: EnterKeyType, event: SubmitEvent) => {
11.           // 调用keepEditableState方法，输入框保持编辑态
12.           event.keepEditableState();
13.         })
14.     }
15.     .justifyContent(FlexAlign.Center)
16.     .height('100%')
17.     .width('80%')
18.     .margin('10%')
19.   }
20. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164006.03097869458622449756490045941624:50001231000000:2800:8D8D142CEE59C4857F88CC3A274AED4F8FCA1102B2B1F263FBEC409211E80C78.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-text-image-layout "图文混排")
# 创建弧形轮播 (ArcSwiper)（圆形屏幕推荐使用）

更新时间: 2025-12-16 16:39

ArcSwiper是弧形轮播组件，在圆形屏幕场景下使用，提供弧形轮播显示能力。具体用法请参考[ArcSwiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper)。

在使用ArcSwiper组件之前，需要在代码中先导入ArcSwiper模块。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute,
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

## 设置导航点样式

ArcSwiper提供了默认的弧形导航点样式，导航点默认显示在ArcSwiper下方居中位置，开发者也可以通过[indicator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#indicator)属性自定义弧形导航点的样式。

通过indicator属性，开发者可以设置弧形导航点的方向，同时也可以设置导航点和被选中导航点的颜色。

- 导航点使用默认样式
    
    1. ArcSwiper() {
    2.   Text('0')
    3.     .width(233)
    4.     .height(233)
    5.     .backgroundColor(Color.Gray)
    6.     .textAlign(TextAlign.Center)
    7.     .fontSize(30)
    
    8.   Text('1')
    9.     .width(233)
    10.     .height(233)
    11.     .backgroundColor(Color.Green)
    12.     .textAlign(TextAlign.Center)
    13.     .fontSize(30)
    
    14.   Text('2')
    15.     .width(233)
    16.     .height(233)
    17.     .backgroundColor(Color.Pink)
    18.     .textAlign(TextAlign.Center)
    19.     .fontSize(30)
    20. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.08287910507627852339891396267932:50001231000000:2800:327DE56CE5ECB95E510926F2C292A4FBDC9C44AE6D9A56AFD4283A34E21A1C9F.png)
    
- 自定义导航点样式
    
    导航点位于ArcSwiper组件6点钟方向，导航点颜色设为红色，被选中导航点颜色为蓝色。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(
    5.   new ArcDotIndicator()
    6.     .arcDirection(ArcDirection.SIX_CLOCK_DIRECTION) // 设置导航点位于6点钟方向
    7.     .itemColor(Color.Red) // 设置导航点颜色为红色
    8.     .selectedItemColor(Color.Blue) // 设置选中导航点颜色为蓝色
    9. )
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.75428405718522185974368471552153:50001231000000:2800:B3371A008E542910AA10478653D7770E49072CDFC693D5FF853D34404F429B87.png)
    

## 控制页面切换方式

ArcSwiper支持滑动手指、点击导航点、旋转表冠和控制控制器四种方式切换页面。以下示例展示通过控制控制器和旋转表冠翻页的方法。

- 控制控制器翻页。
    
    1. // 导入ArcButton和ArcSwiper模块
    2. import {
    3.   ArcButton,
    4.   ArcButtonOptions,
    5.   ArcButtonStatus,
    6.   ArcButtonStyleMode,
    7.   ArcButtonPosition,
    8.   ArcSwiper,
    9.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
    10.   ArcSwiperController
    11. } from '@kit.ArkUI';
    
    12. @Entry
    13. @Component
    14. struct SwiperCustomAnimationExample {
    15.   private wearableSwiperController: ArcSwiperController = new ArcSwiperController();
    
    16.   build() {
    17.     Column() {
    18.       Stack() {
    19.         ArcSwiper(this.wearableSwiperController) {
    20.           // ...
    21.         }
    22.         .vertical(true)
    23.         .indicator(false)
    
    24.         Column() {
    25.           ArcButton({
    26.             options: new ArcButtonOptions({
    27.               label: 'previous',
    28.               position: ArcButtonPosition.TOP_EDGE,
    29.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    30.               onClick: () => {
    31.                 this.wearableSwiperController.showPrevious(); // 通过controller切换到前一页
    32.               }
    33.             })
    34.           })
    
    35.           Blank()
    
    36.           ArcButton({
    37.             options: new ArcButtonOptions({
    38.               label: 'next',
    39.               position: ArcButtonPosition.BOTTOM_EDGE,
    40.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    41.               onClick: () => {
    42.                 this.wearableSwiperController.showNext(); // 通过controller切换到后一页
    43.               }
    44.             })
    45.           })
    46.         }.width('100%').height('100%')
    47.       }
    48.     }
    49.   }
    50. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.44334249917447347995041272018783:50001231000000:2800:666FE8E11983A9F7295A0C9F732F6B9EBD3BB8B7D7C2164E48D7B6870CEC354A.gif)
    
- 旋转表冠翻页。
    
    ArcSwiper在获得焦点时能够响应旋转表冠的操作，用户可以通过旋转表冠来滑动ArcSwiper，从而浏览数据。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .focusable(true)
    5. .focusOnTouch(true)
    6. .defaultFocus(true)
    
    还可以通过设置[digitalCrownSensitivity](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#digitalcrownsensitivity)属性来调整表冠对事件响应的灵敏度，以适应不同规模的数据处理。在处理大量数据时，可以提高响应事件的灵敏度；而在处理少量数据时，则可以降低灵敏度设置。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .digitalCrownSensitivity(CrownSensitivity.MEDIUM)
    

## 设置轮播方向

ArcSwiper支持水平和垂直方向上进行轮播，主要通过[vertical](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#vertical)属性控制。

当vertical为true时，表示在垂直方向上进行轮播；为false时，表示在水平方向上进行轮播。vertical默认值为false。

- 设置水平方向上轮播。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(true)
    5. .vertical(false)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.67938448770526248148022347353380:50001231000000:2800:0AB804AAEB0F5E70F03729F2D28F3F1944318EE38BBF5C5FB66FB42B2ACFC42A.png)
    
- 设置垂直方向轮播，导航点设为3点钟方向。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(new ArcDotIndicator()
    5.     .arcDirection(ArcDirection.THREE_CLOCK_DIRECTION))
    6. .vertical(true)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.61706389477444896030515026055025:50001231000000:2800:40F336B0B6985A1E5C6E7D338C5E37761776387698AC90F6FB9D09FB8855ACEC.png)
    

## 自定义切换动画

ArcSwiper支持通过[customContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#customcontenttransition)设置自定义切换动画，可以在回调中对视窗内所有页面逐帧设置透明度、缩放比例、位移、渲染层级等属性，从而实现自定义切换动画效果。

1. import { Decimal } from '@kit.ArkTS';
2. import {
3.   ArcSwiper,
4.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
5.   ArcDotIndicator,
6.   ArcDirection,
7.   ArcSwiperController
8. } from '@kit.ArkUI';

9. @Entry
10. @Component
11. struct SwiperCustomAnimationExample {
12.   private MIN_SCALE: number = 0.1;
13.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
14.   @State opacityList: number[] = [];
15.   @State scaleList: number[] = [];

16.   aboutToAppear(): void {
17.     for (let i = 0; i < this.backgroundColors.length; i++) {
18.       this.opacityList.push(1.0);
19.       this.scaleList.push(1.0);
20.     }
21.   }

22.   build() {
23.     Column() {
24.       ArcSwiper() {
25.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
26.           Text(index.toString())
27.             .width(233)
28.             .height(233)
29.             .fontSize(50)
30.             .textAlign(TextAlign.Center)
31.             .backgroundColor(backgroundColor)
32.             .opacity(this.opacityList[index])
33.             .scale({ x: this.scaleList[index], y: this.scaleList[index] })
34.         })
35.       }
36.       .customContentTransition({
37.         timeout: 1000,
38.         transition: (proxy: SwiperContentTransitionProxy) => {
39.           if (proxy.position <= -1 || proxy.position >= 1) {
40.             // 页面完全滑出视窗外时，重置属性值
41.             this.opacityList[proxy.index] = 1.0;
42.             this.scaleList[proxy.index] = 1.0;
43.           } else {
44.             let position: number = Decimal.abs(proxy.position).toNumber();
45.             this.opacityList[proxy.index] = 1 - position;
46.             this.scaleList[proxy.index] =
47.               this.MIN_SCALE + (1 - this.MIN_SCALE) * (1 - position);
48.           }
49.         }
50.       })
51.     }.width('100%')
52.   }
53. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.59226198675329244915092191083061:50001231000000:2800:F4A1B77195AE25CC1016BE69896827EEB8D5AB5BD8C384ADC0B15985C16EB40C.gif)

## 实现侧滑返回

ArcSwiper的滑动事件会与侧滑返回冲突，可以通过[手势拦截](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin)去判断ArcSwiper是否滑动到开头去拦截ArcSwiper的滑动手势，实现再次左滑返回上一页的功能。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

8. @Entry
9. @Component
10. struct SwiperCustomAnimationExample {
11.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
12.   innerSelectedIndex: number = 0;

13.   build() {
14.     Column() {
15.       ArcSwiper() {
16.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
17.           Text(index.toString())
18.             .width(233)
19.             .height(233)
20.             .fontSize(50)
21.             .textAlign(TextAlign.Center)
22.             .backgroundColor(backgroundColor)
23.         })
24.       }
25.       .onAnimationStart((index: number, targetIndex: number) => {
26.         this.innerSelectedIndex = targetIndex;
27.       })
28.       .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer,
29.         others: Array<GestureRecognizer>): GestureJudgeResult => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
30.         if (current) {
31.           let target = current.getEventTargetInfo();
32.           if (target && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
33.             let swiperTarget = target as ScrollableTargetInfo;
34.             if (swiperTarget instanceof ScrollableTargetInfo &&
35.               (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) { // 此处判断swiperTarget.isBegin()或innerSelectedIndex === 0，表明ArcSwiper滑动到开头
36.               let panEvent = event as PanGestureEvent;
37.               if (panEvent && panEvent.offsetX > 0 && (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) {
38.                 return GestureJudgeResult.REJECT;
39.               }
40.             }
41.           }
42.         }
43.         return GestureJudgeResult.CONTINUE;
44.       })
45.     }.width('100%')
46.   }
47. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-looping "创建轮播 (Swiper)")
# 创建弧形轮播 (ArcSwiper)（圆形屏幕推荐使用）

更新时间: 2025-12-16 16:39

ArcSwiper是弧形轮播组件，在圆形屏幕场景下使用，提供弧形轮播显示能力。具体用法请参考[ArcSwiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper)。

在使用ArcSwiper组件之前，需要在代码中先导入ArcSwiper模块。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute,
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

## 设置导航点样式

ArcSwiper提供了默认的弧形导航点样式，导航点默认显示在ArcSwiper下方居中位置，开发者也可以通过[indicator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#indicator)属性自定义弧形导航点的样式。

通过indicator属性，开发者可以设置弧形导航点的方向，同时也可以设置导航点和被选中导航点的颜色。

- 导航点使用默认样式
    
    1. ArcSwiper() {
    2.   Text('0')
    3.     .width(233)
    4.     .height(233)
    5.     .backgroundColor(Color.Gray)
    6.     .textAlign(TextAlign.Center)
    7.     .fontSize(30)
    
    8.   Text('1')
    9.     .width(233)
    10.     .height(233)
    11.     .backgroundColor(Color.Green)
    12.     .textAlign(TextAlign.Center)
    13.     .fontSize(30)
    
    14.   Text('2')
    15.     .width(233)
    16.     .height(233)
    17.     .backgroundColor(Color.Pink)
    18.     .textAlign(TextAlign.Center)
    19.     .fontSize(30)
    20. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.08287910507627852339891396267932:50001231000000:2800:327DE56CE5ECB95E510926F2C292A4FBDC9C44AE6D9A56AFD4283A34E21A1C9F.png)
    
- 自定义导航点样式
    
    导航点位于ArcSwiper组件6点钟方向，导航点颜色设为红色，被选中导航点颜色为蓝色。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(
    5.   new ArcDotIndicator()
    6.     .arcDirection(ArcDirection.SIX_CLOCK_DIRECTION) // 设置导航点位于6点钟方向
    7.     .itemColor(Color.Red) // 设置导航点颜色为红色
    8.     .selectedItemColor(Color.Blue) // 设置选中导航点颜色为蓝色
    9. )
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.75428405718522185974368471552153:50001231000000:2800:B3371A008E542910AA10478653D7770E49072CDFC693D5FF853D34404F429B87.png)
    

## 控制页面切换方式

ArcSwiper支持滑动手指、点击导航点、旋转表冠和控制控制器四种方式切换页面。以下示例展示通过控制控制器和旋转表冠翻页的方法。

- 控制控制器翻页。
    
    1. // 导入ArcButton和ArcSwiper模块
    2. import {
    3.   ArcButton,
    4.   ArcButtonOptions,
    5.   ArcButtonStatus,
    6.   ArcButtonStyleMode,
    7.   ArcButtonPosition,
    8.   ArcSwiper,
    9.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
    10.   ArcSwiperController
    11. } from '@kit.ArkUI';
    
    12. @Entry
    13. @Component
    14. struct SwiperCustomAnimationExample {
    15.   private wearableSwiperController: ArcSwiperController = new ArcSwiperController();
    
    16.   build() {
    17.     Column() {
    18.       Stack() {
    19.         ArcSwiper(this.wearableSwiperController) {
    20.           // ...
    21.         }
    22.         .vertical(true)
    23.         .indicator(false)
    
    24.         Column() {
    25.           ArcButton({
    26.             options: new ArcButtonOptions({
    27.               label: 'previous',
    28.               position: ArcButtonPosition.TOP_EDGE,
    29.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    30.               onClick: () => {
    31.                 this.wearableSwiperController.showPrevious(); // 通过controller切换到前一页
    32.               }
    33.             })
    34.           })
    
    35.           Blank()
    
    36.           ArcButton({
    37.             options: new ArcButtonOptions({
    38.               label: 'next',
    39.               position: ArcButtonPosition.BOTTOM_EDGE,
    40.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    41.               onClick: () => {
    42.                 this.wearableSwiperController.showNext(); // 通过controller切换到后一页
    43.               }
    44.             })
    45.           })
    46.         }.width('100%').height('100%')
    47.       }
    48.     }
    49.   }
    50. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.44334249917447347995041272018783:50001231000000:2800:666FE8E11983A9F7295A0C9F732F6B9EBD3BB8B7D7C2164E48D7B6870CEC354A.gif)
    
- 旋转表冠翻页。
    
    ArcSwiper在获得焦点时能够响应旋转表冠的操作，用户可以通过旋转表冠来滑动ArcSwiper，从而浏览数据。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .focusable(true)
    5. .focusOnTouch(true)
    6. .defaultFocus(true)
    
    还可以通过设置[digitalCrownSensitivity](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#digitalcrownsensitivity)属性来调整表冠对事件响应的灵敏度，以适应不同规模的数据处理。在处理大量数据时，可以提高响应事件的灵敏度；而在处理少量数据时，则可以降低灵敏度设置。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .digitalCrownSensitivity(CrownSensitivity.MEDIUM)
    

## 设置轮播方向

ArcSwiper支持水平和垂直方向上进行轮播，主要通过[vertical](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#vertical)属性控制。

当vertical为true时，表示在垂直方向上进行轮播；为false时，表示在水平方向上进行轮播。vertical默认值为false。

- 设置水平方向上轮播。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(true)
    5. .vertical(false)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.67938448770526248148022347353380:50001231000000:2800:0AB804AAEB0F5E70F03729F2D28F3F1944318EE38BBF5C5FB66FB42B2ACFC42A.png)
    
- 设置垂直方向轮播，导航点设为3点钟方向。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(new ArcDotIndicator()
    5.     .arcDirection(ArcDirection.THREE_CLOCK_DIRECTION))
    6. .vertical(true)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.61706389477444896030515026055025:50001231000000:2800:40F336B0B6985A1E5C6E7D338C5E37761776387698AC90F6FB9D09FB8855ACEC.png)
    

## 自定义切换动画

ArcSwiper支持通过[customContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#customcontenttransition)设置自定义切换动画，可以在回调中对视窗内所有页面逐帧设置透明度、缩放比例、位移、渲染层级等属性，从而实现自定义切换动画效果。

1. import { Decimal } from '@kit.ArkTS';
2. import {
3.   ArcSwiper,
4.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
5.   ArcDotIndicator,
6.   ArcDirection,
7.   ArcSwiperController
8. } from '@kit.ArkUI';

9. @Entry
10. @Component
11. struct SwiperCustomAnimationExample {
12.   private MIN_SCALE: number = 0.1;
13.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
14.   @State opacityList: number[] = [];
15.   @State scaleList: number[] = [];

16.   aboutToAppear(): void {
17.     for (let i = 0; i < this.backgroundColors.length; i++) {
18.       this.opacityList.push(1.0);
19.       this.scaleList.push(1.0);
20.     }
21.   }

22.   build() {
23.     Column() {
24.       ArcSwiper() {
25.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
26.           Text(index.toString())
27.             .width(233)
28.             .height(233)
29.             .fontSize(50)
30.             .textAlign(TextAlign.Center)
31.             .backgroundColor(backgroundColor)
32.             .opacity(this.opacityList[index])
33.             .scale({ x: this.scaleList[index], y: this.scaleList[index] })
34.         })
35.       }
36.       .customContentTransition({
37.         timeout: 1000,
38.         transition: (proxy: SwiperContentTransitionProxy) => {
39.           if (proxy.position <= -1 || proxy.position >= 1) {
40.             // 页面完全滑出视窗外时，重置属性值
41.             this.opacityList[proxy.index] = 1.0;
42.             this.scaleList[proxy.index] = 1.0;
43.           } else {
44.             let position: number = Decimal.abs(proxy.position).toNumber();
45.             this.opacityList[proxy.index] = 1 - position;
46.             this.scaleList[proxy.index] =
47.               this.MIN_SCALE + (1 - this.MIN_SCALE) * (1 - position);
48.           }
49.         }
50.       })
51.     }.width('100%')
52.   }
53. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.59226198675329244915092191083061:50001231000000:2800:F4A1B77195AE25CC1016BE69896827EEB8D5AB5BD8C384ADC0B15985C16EB40C.gif)

## 实现侧滑返回

ArcSwiper的滑动事件会与侧滑返回冲突，可以通过[手势拦截](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin)去判断ArcSwiper是否滑动到开头去拦截ArcSwiper的滑动手势，实现再次左滑返回上一页的功能。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

8. @Entry
9. @Component
10. struct SwiperCustomAnimationExample {
11.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
12.   innerSelectedIndex: number = 0;

13.   build() {
14.     Column() {
15.       ArcSwiper() {
16.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
17.           Text(index.toString())
18.             .width(233)
19.             .height(233)
20.             .fontSize(50)
21.             .textAlign(TextAlign.Center)
22.             .backgroundColor(backgroundColor)
23.         })
24.       }
25.       .onAnimationStart((index: number, targetIndex: number) => {
26.         this.innerSelectedIndex = targetIndex;
27.       })
28.       .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer,
29.         others: Array<GestureRecognizer>): GestureJudgeResult => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
30.         if (current) {
31.           let target = current.getEventTargetInfo();
32.           if (target && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
33.             let swiperTarget = target as ScrollableTargetInfo;
34.             if (swiperTarget instanceof ScrollableTargetInfo &&
35.               (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) { // 此处判断swiperTarget.isBegin()或innerSelectedIndex === 0，表明ArcSwiper滑动到开头
36.               let panEvent = event as PanGestureEvent;
37.               if (panEvent && panEvent.offsetX > 0 && (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) {
38.                 return GestureJudgeResult.REJECT;
39.               }
40.             }
41.           }
42.         }
43.         return GestureJudgeResult.CONTINUE;
44.       })
45.     }.width('100%')
46.   }
47. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-looping "创建轮播 (Swiper)")
# 创建弧形轮播 (ArcSwiper)（圆形屏幕推荐使用）

更新时间: 2025-12-16 16:39

ArcSwiper是弧形轮播组件，在圆形屏幕场景下使用，提供弧形轮播显示能力。具体用法请参考[ArcSwiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper)。

在使用ArcSwiper组件之前，需要在代码中先导入ArcSwiper模块。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute,
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

## 设置导航点样式

ArcSwiper提供了默认的弧形导航点样式，导航点默认显示在ArcSwiper下方居中位置，开发者也可以通过[indicator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#indicator)属性自定义弧形导航点的样式。

通过indicator属性，开发者可以设置弧形导航点的方向，同时也可以设置导航点和被选中导航点的颜色。

- 导航点使用默认样式
    
    1. ArcSwiper() {
    2.   Text('0')
    3.     .width(233)
    4.     .height(233)
    5.     .backgroundColor(Color.Gray)
    6.     .textAlign(TextAlign.Center)
    7.     .fontSize(30)
    
    8.   Text('1')
    9.     .width(233)
    10.     .height(233)
    11.     .backgroundColor(Color.Green)
    12.     .textAlign(TextAlign.Center)
    13.     .fontSize(30)
    
    14.   Text('2')
    15.     .width(233)
    16.     .height(233)
    17.     .backgroundColor(Color.Pink)
    18.     .textAlign(TextAlign.Center)
    19.     .fontSize(30)
    20. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.08287910507627852339891396267932:50001231000000:2800:327DE56CE5ECB95E510926F2C292A4FBDC9C44AE6D9A56AFD4283A34E21A1C9F.png)
    
- 自定义导航点样式
    
    导航点位于ArcSwiper组件6点钟方向，导航点颜色设为红色，被选中导航点颜色为蓝色。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(
    5.   new ArcDotIndicator()
    6.     .arcDirection(ArcDirection.SIX_CLOCK_DIRECTION) // 设置导航点位于6点钟方向
    7.     .itemColor(Color.Red) // 设置导航点颜色为红色
    8.     .selectedItemColor(Color.Blue) // 设置选中导航点颜色为蓝色
    9. )
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.75428405718522185974368471552153:50001231000000:2800:B3371A008E542910AA10478653D7770E49072CDFC693D5FF853D34404F429B87.png)
    

## 控制页面切换方式

ArcSwiper支持滑动手指、点击导航点、旋转表冠和控制控制器四种方式切换页面。以下示例展示通过控制控制器和旋转表冠翻页的方法。

- 控制控制器翻页。
    
    1. // 导入ArcButton和ArcSwiper模块
    2. import {
    3.   ArcButton,
    4.   ArcButtonOptions,
    5.   ArcButtonStatus,
    6.   ArcButtonStyleMode,
    7.   ArcButtonPosition,
    8.   ArcSwiper,
    9.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
    10.   ArcSwiperController
    11. } from '@kit.ArkUI';
    
    12. @Entry
    13. @Component
    14. struct SwiperCustomAnimationExample {
    15.   private wearableSwiperController: ArcSwiperController = new ArcSwiperController();
    
    16.   build() {
    17.     Column() {
    18.       Stack() {
    19.         ArcSwiper(this.wearableSwiperController) {
    20.           // ...
    21.         }
    22.         .vertical(true)
    23.         .indicator(false)
    
    24.         Column() {
    25.           ArcButton({
    26.             options: new ArcButtonOptions({
    27.               label: 'previous',
    28.               position: ArcButtonPosition.TOP_EDGE,
    29.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    30.               onClick: () => {
    31.                 this.wearableSwiperController.showPrevious(); // 通过controller切换到前一页
    32.               }
    33.             })
    34.           })
    
    35.           Blank()
    
    36.           ArcButton({
    37.             options: new ArcButtonOptions({
    38.               label: 'next',
    39.               position: ArcButtonPosition.BOTTOM_EDGE,
    40.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    41.               onClick: () => {
    42.                 this.wearableSwiperController.showNext(); // 通过controller切换到后一页
    43.               }
    44.             })
    45.           })
    46.         }.width('100%').height('100%')
    47.       }
    48.     }
    49.   }
    50. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.44334249917447347995041272018783:50001231000000:2800:666FE8E11983A9F7295A0C9F732F6B9EBD3BB8B7D7C2164E48D7B6870CEC354A.gif)
    
- 旋转表冠翻页。
    
    ArcSwiper在获得焦点时能够响应旋转表冠的操作，用户可以通过旋转表冠来滑动ArcSwiper，从而浏览数据。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .focusable(true)
    5. .focusOnTouch(true)
    6. .defaultFocus(true)
    
    还可以通过设置[digitalCrownSensitivity](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#digitalcrownsensitivity)属性来调整表冠对事件响应的灵敏度，以适应不同规模的数据处理。在处理大量数据时，可以提高响应事件的灵敏度；而在处理少量数据时，则可以降低灵敏度设置。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .digitalCrownSensitivity(CrownSensitivity.MEDIUM)
    

## 设置轮播方向

ArcSwiper支持水平和垂直方向上进行轮播，主要通过[vertical](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#vertical)属性控制。

当vertical为true时，表示在垂直方向上进行轮播；为false时，表示在水平方向上进行轮播。vertical默认值为false。

- 设置水平方向上轮播。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(true)
    5. .vertical(false)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.67938448770526248148022347353380:50001231000000:2800:0AB804AAEB0F5E70F03729F2D28F3F1944318EE38BBF5C5FB66FB42B2ACFC42A.png)
    
- 设置垂直方向轮播，导航点设为3点钟方向。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(new ArcDotIndicator()
    5.     .arcDirection(ArcDirection.THREE_CLOCK_DIRECTION))
    6. .vertical(true)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.61706389477444896030515026055025:50001231000000:2800:40F336B0B6985A1E5C6E7D338C5E37761776387698AC90F6FB9D09FB8855ACEC.png)
    

## 自定义切换动画

ArcSwiper支持通过[customContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#customcontenttransition)设置自定义切换动画，可以在回调中对视窗内所有页面逐帧设置透明度、缩放比例、位移、渲染层级等属性，从而实现自定义切换动画效果。

1. import { Decimal } from '@kit.ArkTS';
2. import {
3.   ArcSwiper,
4.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
5.   ArcDotIndicator,
6.   ArcDirection,
7.   ArcSwiperController
8. } from '@kit.ArkUI';

9. @Entry
10. @Component
11. struct SwiperCustomAnimationExample {
12.   private MIN_SCALE: number = 0.1;
13.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
14.   @State opacityList: number[] = [];
15.   @State scaleList: number[] = [];

16.   aboutToAppear(): void {
17.     for (let i = 0; i < this.backgroundColors.length; i++) {
18.       this.opacityList.push(1.0);
19.       this.scaleList.push(1.0);
20.     }
21.   }

22.   build() {
23.     Column() {
24.       ArcSwiper() {
25.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
26.           Text(index.toString())
27.             .width(233)
28.             .height(233)
29.             .fontSize(50)
30.             .textAlign(TextAlign.Center)
31.             .backgroundColor(backgroundColor)
32.             .opacity(this.opacityList[index])
33.             .scale({ x: this.scaleList[index], y: this.scaleList[index] })
34.         })
35.       }
36.       .customContentTransition({
37.         timeout: 1000,
38.         transition: (proxy: SwiperContentTransitionProxy) => {
39.           if (proxy.position <= -1 || proxy.position >= 1) {
40.             // 页面完全滑出视窗外时，重置属性值
41.             this.opacityList[proxy.index] = 1.0;
42.             this.scaleList[proxy.index] = 1.0;
43.           } else {
44.             let position: number = Decimal.abs(proxy.position).toNumber();
45.             this.opacityList[proxy.index] = 1 - position;
46.             this.scaleList[proxy.index] =
47.               this.MIN_SCALE + (1 - this.MIN_SCALE) * (1 - position);
48.           }
49.         }
50.       })
51.     }.width('100%')
52.   }
53. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.59226198675329244915092191083061:50001231000000:2800:F4A1B77195AE25CC1016BE69896827EEB8D5AB5BD8C384ADC0B15985C16EB40C.gif)

## 实现侧滑返回

ArcSwiper的滑动事件会与侧滑返回冲突，可以通过[手势拦截](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin)去判断ArcSwiper是否滑动到开头去拦截ArcSwiper的滑动手势，实现再次左滑返回上一页的功能。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

8. @Entry
9. @Component
10. struct SwiperCustomAnimationExample {
11.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
12.   innerSelectedIndex: number = 0;

13.   build() {
14.     Column() {
15.       ArcSwiper() {
16.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
17.           Text(index.toString())
18.             .width(233)
19.             .height(233)
20.             .fontSize(50)
21.             .textAlign(TextAlign.Center)
22.             .backgroundColor(backgroundColor)
23.         })
24.       }
25.       .onAnimationStart((index: number, targetIndex: number) => {
26.         this.innerSelectedIndex = targetIndex;
27.       })
28.       .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer,
29.         others: Array<GestureRecognizer>): GestureJudgeResult => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
30.         if (current) {
31.           let target = current.getEventTargetInfo();
32.           if (target && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
33.             let swiperTarget = target as ScrollableTargetInfo;
34.             if (swiperTarget instanceof ScrollableTargetInfo &&
35.               (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) { // 此处判断swiperTarget.isBegin()或innerSelectedIndex === 0，表明ArcSwiper滑动到开头
36.               let panEvent = event as PanGestureEvent;
37.               if (panEvent && panEvent.offsetX > 0 && (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) {
38.                 return GestureJudgeResult.REJECT;
39.               }
40.             }
41.           }
42.         }
43.         return GestureJudgeResult.CONTINUE;
44.       })
45.     }.width('100%')
46.   }
47. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-looping "创建轮播 (Swiper)")
# 创建弧形轮播 (ArcSwiper)（圆形屏幕推荐使用）

更新时间: 2025-12-16 16:39

ArcSwiper是弧形轮播组件，在圆形屏幕场景下使用，提供弧形轮播显示能力。具体用法请参考[ArcSwiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper)。

在使用ArcSwiper组件之前，需要在代码中先导入ArcSwiper模块。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute,
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

## 设置导航点样式

ArcSwiper提供了默认的弧形导航点样式，导航点默认显示在ArcSwiper下方居中位置，开发者也可以通过[indicator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#indicator)属性自定义弧形导航点的样式。

通过indicator属性，开发者可以设置弧形导航点的方向，同时也可以设置导航点和被选中导航点的颜色。

- 导航点使用默认样式
    
    1. ArcSwiper() {
    2.   Text('0')
    3.     .width(233)
    4.     .height(233)
    5.     .backgroundColor(Color.Gray)
    6.     .textAlign(TextAlign.Center)
    7.     .fontSize(30)
    
    8.   Text('1')
    9.     .width(233)
    10.     .height(233)
    11.     .backgroundColor(Color.Green)
    12.     .textAlign(TextAlign.Center)
    13.     .fontSize(30)
    
    14.   Text('2')
    15.     .width(233)
    16.     .height(233)
    17.     .backgroundColor(Color.Pink)
    18.     .textAlign(TextAlign.Center)
    19.     .fontSize(30)
    20. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.08287910507627852339891396267932:50001231000000:2800:327DE56CE5ECB95E510926F2C292A4FBDC9C44AE6D9A56AFD4283A34E21A1C9F.png)
    
- 自定义导航点样式
    
    导航点位于ArcSwiper组件6点钟方向，导航点颜色设为红色，被选中导航点颜色为蓝色。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(
    5.   new ArcDotIndicator()
    6.     .arcDirection(ArcDirection.SIX_CLOCK_DIRECTION) // 设置导航点位于6点钟方向
    7.     .itemColor(Color.Red) // 设置导航点颜色为红色
    8.     .selectedItemColor(Color.Blue) // 设置选中导航点颜色为蓝色
    9. )
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.75428405718522185974368471552153:50001231000000:2800:B3371A008E542910AA10478653D7770E49072CDFC693D5FF853D34404F429B87.png)
    

## 控制页面切换方式

ArcSwiper支持滑动手指、点击导航点、旋转表冠和控制控制器四种方式切换页面。以下示例展示通过控制控制器和旋转表冠翻页的方法。

- 控制控制器翻页。
    
    1. // 导入ArcButton和ArcSwiper模块
    2. import {
    3.   ArcButton,
    4.   ArcButtonOptions,
    5.   ArcButtonStatus,
    6.   ArcButtonStyleMode,
    7.   ArcButtonPosition,
    8.   ArcSwiper,
    9.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
    10.   ArcSwiperController
    11. } from '@kit.ArkUI';
    
    12. @Entry
    13. @Component
    14. struct SwiperCustomAnimationExample {
    15.   private wearableSwiperController: ArcSwiperController = new ArcSwiperController();
    
    16.   build() {
    17.     Column() {
    18.       Stack() {
    19.         ArcSwiper(this.wearableSwiperController) {
    20.           // ...
    21.         }
    22.         .vertical(true)
    23.         .indicator(false)
    
    24.         Column() {
    25.           ArcButton({
    26.             options: new ArcButtonOptions({
    27.               label: 'previous',
    28.               position: ArcButtonPosition.TOP_EDGE,
    29.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    30.               onClick: () => {
    31.                 this.wearableSwiperController.showPrevious(); // 通过controller切换到前一页
    32.               }
    33.             })
    34.           })
    
    35.           Blank()
    
    36.           ArcButton({
    37.             options: new ArcButtonOptions({
    38.               label: 'next',
    39.               position: ArcButtonPosition.BOTTOM_EDGE,
    40.               styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
    41.               onClick: () => {
    42.                 this.wearableSwiperController.showNext(); // 通过controller切换到后一页
    43.               }
    44.             })
    45.           })
    46.         }.width('100%').height('100%')
    47.       }
    48.     }
    49.   }
    50. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.44334249917447347995041272018783:50001231000000:2800:666FE8E11983A9F7295A0C9F732F6B9EBD3BB8B7D7C2164E48D7B6870CEC354A.gif)
    
- 旋转表冠翻页。
    
    ArcSwiper在获得焦点时能够响应旋转表冠的操作，用户可以通过旋转表冠来滑动ArcSwiper，从而浏览数据。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .focusable(true)
    5. .focusOnTouch(true)
    6. .defaultFocus(true)
    
    还可以通过设置[digitalCrownSensitivity](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#digitalcrownsensitivity)属性来调整表冠对事件响应的灵敏度，以适应不同规模的数据处理。在处理大量数据时，可以提高响应事件的灵敏度；而在处理少量数据时，则可以降低灵敏度设置。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .digitalCrownSensitivity(CrownSensitivity.MEDIUM)
    

## 设置轮播方向

ArcSwiper支持水平和垂直方向上进行轮播，主要通过[vertical](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#vertical)属性控制。

当vertical为true时，表示在垂直方向上进行轮播；为false时，表示在水平方向上进行轮播。vertical默认值为false。

- 设置水平方向上轮播。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(true)
    5. .vertical(false)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.67938448770526248148022347353380:50001231000000:2800:0AB804AAEB0F5E70F03729F2D28F3F1944318EE38BBF5C5FB66FB42B2ACFC42A.png)
    
- 设置垂直方向轮播，导航点设为3点钟方向。
    
    1. ArcSwiper() {
    2.   // ...
    3. }
    4. .indicator(new ArcDotIndicator()
    5.     .arcDirection(ArcDirection.THREE_CLOCK_DIRECTION))
    6. .vertical(true)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.61706389477444896030515026055025:50001231000000:2800:40F336B0B6985A1E5C6E7D338C5E37761776387698AC90F6FB9D09FB8855ACEC.png)
    

## 自定义切换动画

ArcSwiper支持通过[customContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arcswiper#customcontenttransition)设置自定义切换动画，可以在回调中对视窗内所有页面逐帧设置透明度、缩放比例、位移、渲染层级等属性，从而实现自定义切换动画效果。

1. import { Decimal } from '@kit.ArkTS';
2. import {
3.   ArcSwiper,
4.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
5.   ArcDotIndicator,
6.   ArcDirection,
7.   ArcSwiperController
8. } from '@kit.ArkUI';

9. @Entry
10. @Component
11. struct SwiperCustomAnimationExample {
12.   private MIN_SCALE: number = 0.1;
13.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
14.   @State opacityList: number[] = [];
15.   @State scaleList: number[] = [];

16.   aboutToAppear(): void {
17.     for (let i = 0; i < this.backgroundColors.length; i++) {
18.       this.opacityList.push(1.0);
19.       this.scaleList.push(1.0);
20.     }
21.   }

22.   build() {
23.     Column() {
24.       ArcSwiper() {
25.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
26.           Text(index.toString())
27.             .width(233)
28.             .height(233)
29.             .fontSize(50)
30.             .textAlign(TextAlign.Center)
31.             .backgroundColor(backgroundColor)
32.             .opacity(this.opacityList[index])
33.             .scale({ x: this.scaleList[index], y: this.scaleList[index] })
34.         })
35.       }
36.       .customContentTransition({
37.         timeout: 1000,
38.         transition: (proxy: SwiperContentTransitionProxy) => {
39.           if (proxy.position <= -1 || proxy.position >= 1) {
40.             // 页面完全滑出视窗外时，重置属性值
41.             this.opacityList[proxy.index] = 1.0;
42.             this.scaleList[proxy.index] = 1.0;
43.           } else {
44.             let position: number = Decimal.abs(proxy.position).toNumber();
45.             this.opacityList[proxy.index] = 1 - position;
46.             this.scaleList[proxy.index] =
47.               this.MIN_SCALE + (1 - this.MIN_SCALE) * (1 - position);
48.           }
49.         }
50.       })
51.     }.width('100%')
52.   }
53. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.59226198675329244915092191083061:50001231000000:2800:F4A1B77195AE25CC1016BE69896827EEB8D5AB5BD8C384ADC0B15985C16EB40C.gif)

## 实现侧滑返回

ArcSwiper的滑动事件会与侧滑返回冲突，可以通过[手势拦截](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin)去判断ArcSwiper是否滑动到开头去拦截ArcSwiper的滑动手势，实现再次左滑返回上一页的功能。

1. import {
2.   ArcSwiper,
3.   ArcSwiperAttribute, // ArcSwiper的属性依赖ArcSwiperAttribute对象导入，不建议删除该对象的引入。
4.   ArcDotIndicator,
5.   ArcDirection,
6.   ArcSwiperController
7. } from '@kit.ArkUI';

8. @Entry
9. @Component
10. struct SwiperCustomAnimationExample {
11.   @State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange];
12.   innerSelectedIndex: number = 0;

13.   build() {
14.     Column() {
15.       ArcSwiper() {
16.         ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
17.           Text(index.toString())
18.             .width(233)
19.             .height(233)
20.             .fontSize(50)
21.             .textAlign(TextAlign.Center)
22.             .backgroundColor(backgroundColor)
23.         })
24.       }
25.       .onAnimationStart((index: number, targetIndex: number) => {
26.         this.innerSelectedIndex = targetIndex;
27.       })
28.       .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer,
29.         others: Array<GestureRecognizer>): GestureJudgeResult => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
30.         if (current) {
31.           let target = current.getEventTargetInfo();
32.           if (target && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
33.             let swiperTarget = target as ScrollableTargetInfo;
34.             if (swiperTarget instanceof ScrollableTargetInfo &&
35.               (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) { // 此处判断swiperTarget.isBegin()或innerSelectedIndex === 0，表明ArcSwiper滑动到开头
36.               let panEvent = event as PanGestureEvent;
37.               if (panEvent && panEvent.offsetX > 0 && (swiperTarget.isBegin() || this.innerSelectedIndex === 0)) {
38.                 return GestureJudgeResult.REJECT;
39.               }
40.             }
41.           }
42.         }
43.         return GestureJudgeResult.CONTINUE;
44.       })
45.     }.width('100%')
46.   }
47. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-looping "创建轮播 (Swiper)")
