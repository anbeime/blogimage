# 交互响应概述

更新时间: 2025-12-16 16:39

ArkUI框架提供了丰富的交互功能，支持直接处理基础输入事件，以及由这些事件驱动的手势系统，同时支持拖拽、焦点切换等复杂交互。

## 基础输入事件

当用户操作输入设备（例如触摸屏、键盘、鼠标、触控板）时，底层设备驱动会产生操作信号。系统捕捉这些信号并传递给应用程序，这些信号即为基础事件。

根据基础事件特点总体上分为两类，**指向性**与**非指向性**事件。

### 指向性事件

指向性事件是指包含事件发生位置信息的事件，此类事件以此次交互的第一个事件（Down/Begin类型）发生时所命中的组件来确定派发目标。

包括：[触摸事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch)，[鼠标事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-mouse-key)，[轴事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-axis)。

### 非指向性事件

非指向性事件是指没有具体位置信息的事件，即事件的发生不依赖于特定的操作位置信息。此类事件以当前焦点组件为派发目标。

包括：[按键事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key)，[表冠事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-crown)，[焦点轴事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-focus_axis)。

### 其他说明

基础事件通常以一个标志开始的事件作为起始，以一个标志结束的事件作为结尾。在两者之间，会持续上报众多移动或更新事件。例如，触控事件的序列通常为Down, Move, Move..., Up；鼠标滚轮操作产生的轴事件的序列为Begin, Update, Update, ... End。

部分基础事件不具备此类特征，例如按键事件，仅存在Down和Up两种状态，且Down状态可在持续按压时不间断地上报。

对于指向性事件，系统会尽可能保证参与响应的组件可以得到完整的序列，这可以帮助你掌握处理开始与结束的时机；但对于非指向事件，系统并没有这样的保障，由于焦点的变化，开始与结束可能被分发到不同的组件上。

## 手势系统

手势是一系列基础事件不断上报积累后，达成一定特点时所被识别成的交互结果，如点击：按下并在较短时间内抬起。

如果使用ArkUI系统组件，系统会自动识别和响应这些组件上的手势，如按钮、列表，也可以在组件上绑定处理手势。一个组件上可绑定多个手势，这些手势可以由组件内置默认绑定，也可以由应用显式绑定。这些手势会在用户按下时，通过命中测试被收集上来，由系统统一管理，所有手势都会持续接收到输入事件，直到有一个手势满足条件，在这之后，就只有这一个手势可以继续接收和处理输入事件。

如果希望两个手势非此即彼，则可以考虑使用互斥手势，如果希望两个手势互不影响，则可以考虑使用并行手势，请参考[组合手势](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures)；

如果希望在用户按下时，才动态决定哪些手势能够参与处理，请参考[手势冲突处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-gesture-judge)。

## 统一拖拽

请参考[支持统一拖拽](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-drag-event)。

## 焦点系统

请参考[支持焦点处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-overview "添加交互响应")
# 交互基础机制说明

更新时间: 2025-12-16 16:39

对于[触摸事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch)、[鼠标事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-mouse-key)、[轴事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-axis)等指向性事件的交互，交互框架基于坐标信息进行命中测试确定事件和手势的响应目标，即收集形成响应链，系统会根据触控事件的坐标、类型等信息，结合UI布局，将事件发送给对应UI组件。多个事件可以组合触发手势或其他功能，如长按、点击、拖拽。

## 事件交互流程

事件交互流程是指当ArkUI接收上游发送的Touch类触控事件或Mouse类触控事件后，根据开发者设定的各类参数，收集事件响应链并分发至各组件以触发回调的整个过程。该流程可以概括为以下三个步骤：

1. 事件产生
    
    硬件输入设备通过驱动、多模等模块，将事件上报至目标的ArkUI实例。ArkUI在渲染管线中进行统一处理。
    
2. 收集事件响应链并分发事件
    
    事件响应链是事件交互流程的核心，管线在接收事件后，将通过触摸测试建立事件响应链，通过响应链决策事件分发以及手势合成。
    
    （1）触摸测试
    
    当管线接收到起始触控事件后，将根据起始触控事件的坐标和组件位置进行触摸测试，最终建立事件响应链。开发者可以通过设置属性影响事件响应链的形成。
    
    （2）分发事件至Touch事件响应链
    
    构建事件响应链后，触控事件将根据Touch事件响应链分发至目标组件。
    
    （3）分发事件至手势响应链并进行手势识别
    
    各组件上设置的手势在通过触摸测试后，还会形成手势响应链。触控事件送入手势响应链后会与其它事件组合产生手势，手势之间再经过竞争，最终触发符合条件的手势回调。
    
    （4）事件拦截
    
    事件响应链建立前，开发者可以配置触摸测试属性从而影响到事件响应链的形成。当事件响应链建立后，开发者可以通过设置接口实现事件拦截，从而改变事件分发的流程。
    
    当分发事件至Touch事件响应链时，开发者可以通过设置触摸事件拦截，防止触摸事件继续传递给响应链的后续节点。
    
    当分发事件至手势响应链时，开发者可以通过设置手势拦截阻止手势响应。
    
3. 触发回调
    
    在收集事件响应链时，开发者绑定的回调函数将被同步收集。完成事件响应链的收集及事件分发后，符合触发条件的事件和手势对应的回调函数将被触发。
    

## 事件响应链

ArkUI事件响应链通过触摸测试进行收集，遵循右子树（按组件布局的先后层级）优先的后序遍历。

事件响应链收集举例：按下图的组件树，hitTestBehavior属性均为默认，用户点按的动作如果发生在组件5上，则最终收集到的响应链，以及先后关系是5，3，1。

因为组件3的hitTestBehavior属性为Default，收集到事件后会阻塞兄弟节点，所以没有收集组件1的左子树。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163921.24011007247908179611316543839160:50001231000000:2800:B6EA3C365D09CEC70C4027B0763B97245F609E77EAF9AA891AEC9EE53ED542F5.png)

## 触摸测试

触摸测试即touch test，也称为命中测试（hit test），是在用户交互开始前，系统确定哪些组件上的事件或手势能够参与此次交互响应的过程。

### 实现原理

对于指向性基础事件的派发，系统不会直接从页面根节点递归遍历所有组件节点，而是在首次事件发生时确定能够响应此次交互的组件范围，即识别用户点击的组件。对于未被点击的组件，在此次交互中将不会有任何响应。这一过程称为命中测试（hit test/touch test）。系统依据组件响应热区是否包含事件坐标来判定是否被点击。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163922.74122439965308424571898387580778:50001231000000:2800:0FD341291BCAAC35DDC57A0B4E9CBCB98662CBB2DF2E3CE9676871F8E6C062C6.png)

当用户触发按下事件时，系统将自上而下、自右向左遍历组件树，收集每个组件上绑定的手势和事件，然后将这些信息逐级向上冒泡至父组件进行整合，最终构建完整的事件响应链。

假设T点为用户按下的位置（Touch Down），则A、B、D组件将被判定为命中，这些组件组成的链条被称为本次交互的响应链。基础事件将在该响应链上进行传递，首先传递给叶子节点，随后传递给父节点，逐层向上传递，这一过程称为事件冒泡。

以下是描述命中测试过程的流程图：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163922.27247580066085731960472468205012:50001231000000:2800:495F9466E267A079EE512292660F34531C7C969253E7EAC77580FE7585BF2812.png)

如图所示，当起始事件被分发至组件时，组件会收集自身绑定的手势与事件，随后将收集结果传递给父组件，直至达到根节点。若组件透明、已从组件树中移除，或事件坐标不在组件响应热区范围内，将不会触发收集过程，父组件接收的反馈为空。除此之外，所有组件均会执行手势与事件的收集，并将结果反馈给父组件。

### 干预命中

应用可以通过以下几种方式对命中结果进行干预，从而影响最终的响应范围，即控制哪些组件能够被收集到。

|干预方式|功能描述|对应接口|说明|
|:--|:--|:--|:--|
|触摸热区设置|设置组件能够响应用户交互的热区范围。|[responseRegion](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-touch-target#responseregion)|1.热区会被用来识别用户手指落下的位置是否在热区范围内，只有在范围内的才会被收集；<br><br>3. 热区也会影响一些手势的判定，比如点击，只有当在热区范围抬手时才会被触发。|
|触摸测试控制|干预自身及其他组件收集结果。|[hitTestBehavior](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior#hittestbehavior)|与onTouchIntercept效果相同，但是hitTestBehavior是静态配置。|
|自定义事件拦截|干预自身及其他组件收集结果。|[onTouchIntercept](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-on-touch-intercept#ontouchintercept)|当用户触发按下事件时，系统开始收集当前位置下所有需要参与事件处理的组件时触发，应用可通过该回调返回一个HitTestMode值，进而影响系统收集子节点或兄弟节点的行为。可以通过该回调达到动态控制交互响应的效果，如某些组件，根据业务状态的变化，可能有时候需要参与交互，有时候不需要参与交互。<br><br>与hitTestBehavior效果相同，但是onTouchIntercept是动态回调。|

1. 触摸热区设置
    
    默认情况下，组件的响应热区即为组件自身的位置和大小，这与用户看到的范围相一致，从而最大程度地保证用户操作的手眼一致性。在极少数情况下，应用需调整热区大小以限制或扩大组件响应的操作范围，这一功能通过组件的responseRegion接口实现。
    
    响应热区影响指向性事件的派发，通过与组件自身区域的相对关系进行指定，可以指定一个或多个区域，将组件的响应热区分割为多个部分。
    
    说明
    
    x和y可以设置正负值百分比。当x设置为'100%'时表示热区往右偏移组件本身宽度大小，当x设置为'-100%'时表示热区往左偏移组件本身宽度大小。当y设置为'100%'时表示热区往下偏移组件本身高度大小，当y设置为'-100%'时表示热区往上偏移组件本身高度大小。
    
    width和height只能设置正值百分比。width：'100%'表示热区宽度设置为该组件本身的宽度。比如组件本身宽度是100vp，那么'100%'表示热区宽度也为100vp。height：'100%'表示热区高度设置为该组件本身的高度。
    
    百分比相对于组件自身宽高进行计算。
    
    以下是一个绑定多个热区范围的示例：
    
    1. Button("按钮")
    2.   .responseRegion([
    3.      { x: 0, y: 0, width: '30%', height: '100%' },      // 第一个热区为按钮的左侧1/3区域
    4.      { x: '70%', y: 0, width: '30%', height: '100%' },  // 第二个热区为按钮的右侧1/3区域
    5.    ])
    
    上面的代码可以将按钮切分成了3部分，中间40%的区域不响应点击，而两侧的剩下部分可响应。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163922.27255406993765125514796325949809:50001231000000:2800:29208D9184224D360213D05E300274ECA038FF38B9B5C308A2B97AE12DBB8B13.png)
    
2. 触摸测试控制
    
    在组件上绑定[触摸测试控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior)时，可能影响兄弟节点和父子节点的触摸测试。子组件对父组件的触摸测试影响程度取决于最后一个未被阻塞触摸测试的子组件状态。
    
    开发者可以通过配置触摸测试控制，来实现阻塞组件自身或其他组件的触摸测试。
    
    - HitTestMode.Default：默认不配hitTestBehavior属性，自身如果命中会阻塞兄弟组件，但是不阻塞子组件。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163922.54014618200640820524892754033686:50001231000000:2800:98D5FE5463932B72831DF0FCF3B7B07DCCF86A7A20D044778C662AED1BF056B3.png)
        
    - HitTestMode.None：自身不接收事件，但不会阻塞兄弟组件或子组件继续做触摸测试。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163922.78140473307605467279625418964223:50001231000000:2800:06A2B126FA3E5713359C148C0D5123868B26E4510538DA66B57E392B2965E32E.png)
        
    - HitTestMode.Block：阻塞子组件的触摸测试，如果自身触摸测试命中，会阻塞兄弟组件及父组件的触摸测试。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163922.82291289191973633724792468134688:50001231000000:2800:8EE047C4EED24AAA3615C6D76C4EA9BB34D42C2B188AEA6EE641ADE25198ED2E.png)
        
    - HitTestMode.Transparent：自身进行触摸测试，同时不阻塞兄弟组件及父组件。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163922.03265919329647264061679793490186:50001231000000:2800:B4CC5DC65A3A14625DFF971E8E7BC5437159C6FCCEB88F850EEB9F5113CBC15A.png)
        
    - HitTestMode.BLOCK_HIERARCHY（从API version 20开始支持）: 自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163923.37085216375404553576785041793350:50001231000000:2800:BE594D3424BFE39CA2909887FFD4E59CA89E44C25B9D3A55B833B77D3F0E07E9.png)
        
    - HitTestMode.BLOCK_DESCENDANTS（从API version 20开始支持）: 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163923.84758520093952948722272398159722:50001231000000:2800:5F0AB278DE707A8AEF0FAFACAB643D24E8D0F0C3A8A5A540CFD4AD6EC18BCA67.png)
        
3. 自定义事件拦截
    
    当用户执行按下操作时，将触发组件上绑定的[自定义事件拦截](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-on-touch-intercept)的回调。开发者可根据应用状态，动态调整组件的hitTestBehavior属性，进而影响触控测试的流程。
    

## 禁用控制

设置了[禁用控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-enable)的组件及其子组件不会发起触摸测试过程，而是直接返回组件的父组件继续触摸测试。

## 安全组件

ArkUI包含的安全组件有：[使用粘贴控件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pastebutton)、[使用保存控件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/savebutton)等。

安全组件当前对触摸测试影响：如果有组件的[z序](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-z-order)比安全组件的z序靠前，且遮盖安全组件，则安全组件事件直接返回到父节点继续触摸测试。

## 事件冒泡

基础事件在响应链上的传递遵循冒泡机制，即最内层组件优先处理，再逐层往父组件传递该事件，任意一层组件可主动终止本次事件的继续传递，即终止冒泡。但需要注意的是，终止冒泡并不会中断父组件对手势的响应处理。

stopPropagation可终止冒泡。如下图所示，以Touch事件为例，当一个Touch事件传递至C节点时，如果调用了该事件上的stopPropagation接口，则B节点和root节点将不再接收到此事件，但B节点上的手势对象仍能接收和处理该Touch事件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163923.64433419396686156929758799690460:50001231000000:2800:669B442CCF30F93B0EABE2EB437DBCB9FC911634E58CA1AB5D872F7CDB67C80A.png)

说明

stopPropagation干预事件冒泡时，应注意对同一事件的不同类型（如Down/Move/Up）采用一致的规则，避免上层节点仅接收到部分类型事件，导致事件不闭环的情况，例如B节点仅接收到Down事件，而未接收到Up事件，这会影响B节点上的事件完整性（对于指向性按下操作类交互产生的事件，确保事件的完整性是必要的）。

## Cancel事件

当处理基础事件时，会发现存在多种具有Cancel类型的事件，如[TouchType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#touchtype).Cancel、[MouseAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#mouseaction8).CANCEL等。系统在特定场景下发送此类事件，例如在拖拽操作中，当通过手指或鼠标拖动一个支持拖拽（onDragStart）的对象时，由于拖拽动作需达到一定位移阈值才能触发，因此在触发[onDragStart](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragstart)之前，应用将正常接收到Touch或Mouse事件。一旦拖拽动作开始，系统将发送Cancel事件，告知应用普通基础事件已结束。

Cancel的含义与Up相同，均表示事件处理结束。若在处理Up/Release的场景中，亦应同时处理Cancel。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-capability-overview "交互响应概述")
# 支持触屏输入事件

更新时间: 2025-12-16 16:40

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164012.40423883973407140764328917264639:50001231000000:2800:4F72D7A889EDB4656E2F67DC29B9308C8F992F5C7C5E287DB06AA836360C6C03.png)

触屏设备是最常见的输入设备，几乎所有手持类终端设备都支持用户通过触控操作。触摸事件也是应用开发者最常处理的事件类型之一。

需要注意的是，对于其他类型的输入设备上的类似触控行为的操作，系统为了交互一致性，也会将其转换为触摸事件派发给应用，如按下**鼠标**左键点击、滑动，既可以接收到Touch事件，也可以接收到鼠标事件。如果要将其与触屏设备产生的触摸事件进行区分，可以通过事件中的[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-settings#sourcetype%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E8)进行判断。

## 触摸事件

触摸事件可以通过通用属性[onTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#ontouch)在组件上接收，该回调响应遵循命中测试规则

触摸事件的上报频率会由系统降采样到与屏幕刷新率一致，详见[重采样与历史点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-touch-screen#%E9%87%8D%E9%87%87%E6%A0%B7%E4%B8%8E%E5%8E%86%E5%8F%B2%E7%82%B9)章节。

对于支持多点触控的输入设备，使用多根手指同时操作可以产生多个触点，全部的触点信息可以通过[touches](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#touchevent%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)成员得到，而changedTouches会给出当前事件上报时，是哪些触点在产生变化。

其他更多的事件信息可以从[TouchEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#touchevent%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)的基类[BaseEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#baseevent8)中获得。

## 阻止冒泡

参考[事件冒泡](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-basic-principles#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1)了解冒泡机制，以下是一个简单示例，实现了只要点击在子组件区域内，就阻止父组件接收触摸事件：

1. @Entry
2. @ComponentV2
3. struct Index {

4.   build() {
5.     RelativeContainer() {
6.       Column() { // 父组件
7.         Text("  如果点中了我，就阻止父组件收到触摸事件  ")
8.           .fontColor(Color.White)
9.           .height("40%")
10.           .width("80%")
11.           .backgroundColor(Color.Brown)
12.           .alignSelf(ItemAlign.Center)
13.           .padding(10)
14.           .margin(20)
15.           .onTouch((event:TouchEvent)=>{
16.             event.stopPropagation() // 子组件优先接收到触摸事件后，阻止父组件接收事件
17.           })
18.       }
19.       .justifyContent(FlexAlign.End)
20.       .backgroundColor(Color.Green)
21.       .height('100%')
22.       .width('100%')
23.       .onTouch((event:TouchEvent)=>{
24.         console.info("touch event received on parent")
25.       })
26.     }
27.     .height('100%')
28.     .width('100%')
29.   }
30. }

说明

对事件的冒泡进行控制不会影响手势对触摸事件的接收与处理，因此需要分别考虑这两者。

## 重采样与历史点

基础事件的上报频率与具体的输入设备类型有关，但一般频率都是非常高的，如触屏一般每5~7ms即上报一个点，而对于一些高精度鼠标，上报频率最高可达到每1ms上报一次。由于对输入事件的响应是为了UI界面的变化来产生对用户操作的响应，因此将如此之高的基础事件上报给应用，多数情况下是冗余的，为此系统会对两帧之间所收到的基础事件进行重采样，只在帧内上报一次给应用，重采样是针对每个触点单独进行的，不同触点会单独进行重采样。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164012.27429423304578546485940357091166:50001231000000:2800:0A2045326EB48F3218E0FA6A3DFFC4CA12566814D71274E6B5F839D6B3A8AE26.png)

- 按下时产生的事件会立即上报给应用；
- 帧内的move报点并不会立即下发，而是会在送显帧到来时重采样合并后上报；
- 抬起时产生的事件会立即上报给应用，并在上报之前先将还未处理的move事件上报；

重采样会合并同一个触点在同一帧内多次上报的move事件，并通过算法尽可能计算出一个合适的坐标上报给应用，因此经过重采样后的坐标信息，与底层设备真实上报的点会存在细微的差异，这些差异是有益的，经过重采样后的点通常具备更好的平顺性。

重采样之前的所有原始点信息也都保留下来上报给了应用，如果需要直接处理它们，则可通过getHistoricalPoints(): Array来获取。

以下是一个简单示例：

1. @Entry
2. @ComponentV2
3. struct Index {
4.   build() {
5.     RelativeContainer() {
6.       Column()
7.         .backgroundColor(Color.Green)
8.         .height('100%')
9.         .width('100%')
10.         .onTouch((event: TouchEvent) => {
11.           // 从event中获取历史点
12.           let allHistoricalPoints = event.getHistoricalPoints();
13.           if (allHistoricalPoints.length != 0) {
14.             for (const point of allHistoricalPoints) {
15.               console.info("historical point: [" + point.touchObject.windowX + ", " + point.touchObject.windowY + "]")
16.             }
17.           }
18.         })
19.     }
20.     .height('100%')
21.     .width('100%')
22.   }
23. }

## 多指信息

在支持多指触控的触屏设备上，上报的事件中同时包含了窗口所有按压手指的信息，可以通过**touches**获取，如下：

1. @Entry
2. @ComponentV2
3. struct Index {
4.   private currentFingerCount: number = 0
5.   private allFingerIds: number[] = []

6.   build() {
7.     RelativeContainer() {
8.       Column()
9.         .backgroundColor(Color.Green)
10.         .height('100%')
11.         .width('100%')
12.         .onTouch((event: TouchEvent) => {
13.           if (event.source != SourceType.TouchScreen) {
14.             return;
15.           }
16.           // clear数组
17.           this.allFingerIds.splice(0, this.allFingerIds.length)
18.           // 从event中获取所有触点信息
19.           let allFingers = event.touches;
20.           if (allFingers.length > 0 && this.currentFingerCount == 0) {
21.             // 第1根手指按下
22.             console.info("fingers start to press down")
23.             this.currentFingerCount = allFingers.length
24.           }
25.           if (allFingers.length != 0) {
26.             for (const finger of allFingers) {
27.               this.allFingerIds.push(finger.id)
28.             }
29.             console.info("current all fingers : " + this.allFingerIds.toString())
30.           }
31.           if (event.type == TouchType.Up && event.touches.length == 1) {
32.             // 所有手指都已抬起
33.             console.info("all fingers already up")
34.             this.currentFingerCount = 0
35.           }
36.         })
37.     }
38.     .height('100%')
39.     .width('100%')
40.   }
41. }

不同触点通过id区分，id按照接触屏幕的顺序依次递增，与物理上的触点（手指）并无严格顺序对应关系。并且这些触点在**touches**数组中并非按照编号大小顺序排列，请不要依赖顺序进行访问，另外，直到所有触点全部离开屏幕之前，期间抬起的触点对应的编号，会在有触点按下时自动复用。

以下是上面的示例在如下操作序列时产生的日志输出情况：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164012.75029834861296829414520078564813:50001231000000:2800:AE091FF536549609029FFA33592054A9F19A1BCC2A7B52CCF300BFB04EF76438.png)

按下手指① -> 按下手指② -> 按下手指③ -> 抬起手指② -> 抬起手指③ -> 按下手指② -> 抬起手指① -> 抬起手指③

1.   fingers start to press down   // 按下手指①
2.   current all fingers: 0
3.   ... ...
4.   current all fingers: 0,1      // 按下手指②
5.   ... ...
6.   current all fingers: 0,1,2    // 按下手指③
7.   ... ...
8.   current all fingers: 0,2      // 抬起手指②
9.   ... ...
10.   current all fingers: 0        // 抬起手指③
11.   ... ...
12.   current all fingers: 0,1      // 按下手指③
13.   ... ...
14.   current all fingers: 1        // 抬起手指①
15.   ... ...
16.   all fingers already up        // 抬起手指③

## 触控笔

触控笔操作触摸屏与通过手指操作类似，都会产生触摸事件，可以通过sourceTool进行区分。而对于一些主动式电容笔，上报的触摸事件中，还会包含笔接触屏幕时的夹角信息，可参考[BaseEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#baseevent8)。

- tiltX：触控笔在设备平面上的投影与设备平面X轴的夹角。
- tiltY：触控笔在设备平面上的投影与设备平面Y轴的夹角。
- rollAngle：触控笔与设备平面的夹角。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/rkts-interaction-development-guide-raw-input-event "输入设备与事件")
# 支持鼠标输入事件

更新时间: 2025-12-16 16:40

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.41624739832661282154635774635709:50001231000000:2800:D090F1D7D776B878F1E3E1BB6A092CE19404F069C07B4BC3809E611E4DF2B80C.png)

鼠标设备是2in1类型设备必不可少的输入设备，其特点是可以通过按键达成点击或滑动操作，也可以通过滚轮触发滑动，另外还有一些按键，这些分别通过MouseEvent及AxisEvent上报给应用。

说明

所有单指可响应的触摸事件/手势事件，均可通过鼠标左键来操作和响应。

- 例如当我们需要开发单击Button跳转页面的功能、且需要支持手指点击和鼠标左键点击，那么只绑定一个点击事件（onClick）就可以实现该效果；
- 若需要针对手指和鼠标左键的点击实现不一样的效果，可以在onClick回调中，使用回调参数中的source字段判断当前触发事件的来源是手指还是鼠标。

## 处理鼠标移动

鼠标事件通过[onMouse](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-mouse-key#onmouse)接口注册一个回调来接收，当鼠标事件发生时，会按照鼠标光标所在位置下的组件进行派发，派发过程同样遵循事件冒泡机制。

### onMouse

1. onMouse(event: (event?: MouseEvent) => void)

鼠标事件回调。每当鼠标指针在绑定该API的组件内产生行为（MouseAction）时，触发事件回调，参数为[MouseEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-mouse-key#mouseevent%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)对象，表示触发此次的鼠标事件。该事件支持自定义冒泡设置，默认父子冒泡。常用于开发者自定义的鼠标行为逻辑处理。

开发者可以通过回调中的MouseEvent对象获取触发事件的坐标（displayX/displayY/windowX/windowY/x/y）、按键（[MouseButton](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#mousebutton8)）、行为（[MouseAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#mouseaction8)）、时间戳（[timestamp](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#baseevent8)）、交互组件的区域（[EventTarget](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-click#eventtarget8)）、事件来源（[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-settings#sourcetype%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E8)）等。MouseEvent的回调函数stopPropagation用于设置当前事件是否阻止冒泡。

说明

按键（MouseButton）的值：Left/Right/Middle/Back/Forward 均对应鼠标上的实体按键，当这些按键被按下或松开时触发这些按键的事件。None表示无按键，会出现在鼠标没有按键按下或松开的状态下，移动鼠标所触发的事件中。

1. // xxx.ets
2. @Entry
3. @Component
4. struct MouseExample {
5.   @State buttonText: string = '';
6.   @State columnText: string = '';
7.   @State text: string = 'OnMouse Sample Button';
8.   @State Color: Color = Color.Gray;

9.   build() {
10.     Column() {
11.       Button(this.text, { type: ButtonType.Capsule })
12.         .width(200)
13.         .height(100)
14.         .backgroundColor(this.Color)
15.         .onMouse((event?: MouseEvent) => { // 设置Button的onMouse回调
16.           if (event) {
17.             this.buttonText = 'Button onMouse:\n' + '' +
18.               'button = ' + event.button + '\n' +
19.               'action = ' + event.action + '\n' +
20.               'x,y = ' + '\n' + '(' + event.x + ',' + event.y + ')' + '\n' +
21.               'windowXY=' + '\n' + '(' + event.windowX + ',' + event.windowY + ')';
22.           }
23.         })
24.       Column() {
25.         Divider()
26.         Text(this.buttonText).fontColor(Color.Green).padding(5)
27.         Divider()
28.         Text(this.columnText).fontColor(Color.Red).padding(5)
29.       }
30.       .width('100%')
31.       .alignItems(HorizontalAlign.Start)
32.     }
33.     .width('100%')
34.     .height('100%')
35.     .justifyContent(FlexAlign.Center)
36.     .borderWidth(2)
37.     .borderColor(Color.Red)
38.     .onMouse((event?: MouseEvent) => { // Set the onMouse callback for the column.
39.       if (event) {
40.         this.columnText = 'Column onMouse:\n' + '' +
41.           'button = ' + event.button + '\n' +
42.           'action = ' + event.action + '\n' +
43.           'x,y = ' + '\n' + '(' + event.x + ',' + event.y + ')' + '\n' +
44.           'windowXY=' + '\n' + '(' + event.windowX + ',' + event.windowY + ')';
45.       }
46.     })
47.   }
48. }

上面的示例中给Button绑定onMouse接口。在回调中，打印出鼠标事件的button/action等回调参数值。同时，在外层的Column容器上，也做相同的设置。整个过程可以分为以下两个动作：

1. 移动鼠标：在鼠标从Button外部移入Button内部前，仅触发了Column的onMouse回调；当鼠标移入到Button内部后，由于onMouse事件默认是冒泡的，所以此时会同时响应Column的onMouse回调和Button的onMouse回调。此过程中，由于鼠标仅有移动动作而没有点击动作，因此打印信息中的button均为0（MouseButton.None的枚举值）、action均为3（MouseAction.Move的枚举值）。
    
2. 点击鼠标：鼠标进入Button后进行了2次点击，分别是左键点击和右键点击。
    
    左键点击时：button = 1（MouseButton.Left的枚举值），按下时：action = 1（MouseAction.Press的枚举值），抬起时：action = 2（MouseAction.Release的枚举值）。
    
    右键点击时：button = 2（MouseButton.Right的枚举值），按下时：action = 1（MouseAction.Press的枚举值），抬起时：action = 2（MouseAction.Release的枚举值）。
    

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.52607370158893302526621471830267:50001231000000:2800:2C349C42AECD32D524C68D6D3D80090DC6BDBDA54AEF990273C4B174EAB4DECF.gif)

如果需要阻止鼠标事件冒泡，可以通过调用stopPropagation方法进行设置。

1. // xxx.ets
2. @Entry
3. @Component
4. struct MouseExample {
5.   @State buttonText: string = '';
6.   @State columnText: string = '';
7.   @State text: string = 'OnMouse Sample Button';
8.   @State Color: Color = Color.Gray;

9.   build() {
10.     Column() {
11.       Button(this.text, { type: ButtonType.Capsule })
12.         .width(200)
13.         .height(100)
14.         .backgroundColor(this.Color)
15.         .onMouse((event?: MouseEvent) => { // 设置Button的onMouse回调
16.           if (event) {
17.             event.stopPropagation(); // 在Button的onMouse事件中设置阻止冒泡
18.             this.buttonText = 'Button onMouse:\n' + '' +
19.               'button = ' + event.button + '\n' +
20.               'action = ' + event.action + '\n' +
21.               'x,y = ' + '\n' + '(' + event.x + ',' + event.y + ')' + '\n' +
22.               'windowXY=' + '\n' + '(' + event.windowX + ',' + event.windowY + ')';
23.           }
24.         })
25.       Column() {
26.         Divider()
27.         Text(this.buttonText).fontColor(Color.Green).padding(5)
28.         Divider()
29.         Text(this.columnText).fontColor(Color.Red).padding(5)
30.       }
31.       .width('100%')
32.       .alignItems(HorizontalAlign.Start)
33.     }
34.     .width('100%')
35.     .height('100%')
36.     .justifyContent(FlexAlign.Center)
37.     .borderWidth(2)
38.     .borderColor(Color.Red)
39.     .onMouse((event?: MouseEvent) => { // 设置Column的onMouse回调
40.       if (event) {
41.         this.columnText = 'Column onMouse:\n' + '' +
42.           'button = ' + event.button + '\n' +
43.           'action = ' + event.action + '\n' +
44.           'x,y = ' + '\n' + '(' + event.x + ',' + event.y + ')' + '\n' +
45.           'windowXY=' + '\n' + '(' + event.windowX + ',' + event.windowY + ')';
46.       }
47.     })
48.   }
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.16823629662487172378515183704729:50001231000000:2800:B0FCCD3C0F092A0AE0F4A6850260323E98AC4FDDF03EAE55EE3E769AFA75CD21.gif)

在子组件（Button）的onMouse中，通过回调参数event调用stopPropagation回调方法（如上）即可阻止Button子组件的鼠标事件冒泡到父组件Column上。

### onHover

如果需要感知鼠标移入或移出控件范围，建议直接使用高级事件[onHover](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-hover#onhover)，建议避免直接处理鼠标move事件，以保持代码简洁。

1. onHover(event: (isHover: boolean) => void)

悬浮事件回调。参数isHover类型为boolean，表示鼠标进入组件或离开组件。该事件支持自定义冒泡设置，默认父子冒泡。

若组件绑定了该接口，当鼠标指针从组件外部进入到该组件的瞬间会触发事件回调，参数isHover等于true；鼠标指针离开组件的瞬间也会触发该事件回调，参数isHover等于false。

1. // xxx.ets
2. @Entry
3. @Component
4. struct MouseExample {
5.   @State hoverText: string = 'Not Hover';
6.   @State Color: Color = Color.Gray;

7.   build() {
8.     Column() {
9.       Button(this.hoverText)
10.         .width(200).height(100)
11.         .backgroundColor(this.Color)
12.         .onHover((isHover?: boolean) => { // 使用onHover接口监听鼠标是否悬浮在Button组件上
13.           if (isHover) {
14.             this.hoverText = 'Hovered!';
15.             this.Color = Color.Green;
16.           }
17.           else {
18.             this.hoverText = 'Not Hover';
19.             this.Color = Color.Gray;
20.           }
21.         })
22.     }.width('100%').height('100%').justifyContent(FlexAlign.Center)
23.   }
24. }

该示例创建了一个Button组件，初始背景色为灰色，内容为“Not Hover”。示例中的Button组件绑定了onHover回调，在该回调中将this.isHovered变量置为回调参数：isHover。

当鼠标从Button外移动到Button内的瞬间，回调响应，isHover值等于true，isHovered的值变为true，将组件的背景色改成Color.Green，内容变为“Hovered!”。

当鼠标从Button内移动到Button外的瞬间，回调响应，isHover值等于false，又将组件变成了初始的样式。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.66100447776677168289297500549949:50001231000000:2800:EF8973ADC88BDCF6E0966FF754EE6F234371D86F1CD3FBA8DBC63CB632F49E9C.gif)

## 处理鼠标按键

当用户按下鼠标上的按键时，会产生鼠标按下事件，可以通过[MouseEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-mouse-key#mouseevent%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)访问事件的一些重要信息，如发生时间，鼠标按键(MouseButton: 左键/右键等)，也可以通过[**getModifierKeyState**](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#getmodifierkeystate12)接口获取到用户在使用鼠标时，物理键盘上的**ctrl/alt/shift**这几个修饰键的按下状态，可以通过组合判断它们的状态来实现一些便捷操作。

以下是一个通过处理鼠标按键实现快速多选的示例：

1. class ListDataSource implements IDataSource {
2.   private list: number[] = [];
3.   private listeners: DataChangeListener[] = [];

4.   constructor(list: number[]) {
5.     this.list = list;
6.   }

7.   totalCount(): number {
8.     return this.list.length;
9.   }

10.   getData(index: number): number {
11.     return this.list[index];
12.   }

13.   registerDataChangeListener(listener: DataChangeListener): void {
14.     if (this.listeners.indexOf(listener) < 0) {
15.       this.listeners.push(listener);
16.     }
17.   }

18.   unregisterDataChangeListener(listener: DataChangeListener): void {
19.     const pos = this.listeners.indexOf(listener);
20.     if (pos >= 0) {
21.       this.listeners.splice(pos, 1);
22.     }
23.   }

24.   // 通知控制器数据删除
25.   notifyDataDelete(index: number): void {
26.     this.listeners.forEach(listener => {
27.       listener.onDataDelete(index);
28.     });
29.   }

30.   // 在指定索引位置删除一个元素
31.   public deleteItem(index: number): void {
32.     this.list.splice(index, 1);
33.     this.notifyDataDelete(index);
34.   }
35. }

36. @Entry
37. @Component
38. struct ListExample {
39.   private arr: ListDataSource = new ListDataSource([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
40.   private allSelectedItems: Array<number> = [];
41.   @State isSelected: boolean[] = [];

42.   @Styles
43.   selectedStyle(): void {
44.     .backgroundColor(Color.Blue);
45.   }

46.   isItemSelected(item: number): boolean {
47.     for (let i = 0; i < this.allSelectedItems.length; i++) {
48.       if (this.allSelectedItems[i] === item) {
49.         this.isSelected[item] = true;
50.         return true;
51.       }
52.     }
53.     this.isSelected[item] = false;
54.     return false;
55.   }

56.   build() {
57.     Column() {
58.       List({ space: 10, initialIndex: 0 }) {
59.         LazyForEach(this.arr, (index: number) => {
60.           ListItem() {
61.             Text('' + index)
62.               .width('100%')
63.               .height(100)
64.               .fontSize(16)
65.               .fontColor(this.isSelected[index] ? Color.White : Color.Black)
66.               .textAlign(TextAlign.Center)
67.           }
68.           .backgroundColor(Color.White)
69.           .selectable(true)
70.           .selected(this.isSelected[index])
71.           .stateStyles({
72.             selected: this.selectedStyle
73.           })
74.           .onMouse((event: MouseEvent) => {
75.             // 判断是否按下鼠标左键
76.             if (event.button == MouseButton.Left && event.action == MouseAction.Press) {
77.               // 判断之前是否已经是选中状态
78.               let isSelected: boolean = this.isItemSelected(index)
79.               // 判断修饰键状态
80.               let isCtrlPressing: boolean = false;
81.               if (event.getModifierKeyState) {
82.                 isCtrlPressing = event.getModifierKeyState(['Ctrl']);
83.               }
84.               // 如果没有按着ctrl键点鼠标，则强制清理掉其他选中的条目并只让当前条目选中
85.               if (!isCtrlPressing) {
86.                 this.allSelectedItems = [];
87.                 for (let i = 0; i < this.isSelected.length; i++) {
88.                   this.isSelected[i] = false;
89.                 }
90.               }
91.               if (isSelected) {
92.                 this.allSelectedItems.filter(item => item !== index);
93.                 this.isSelected[index] = false;
94.               } else {
95.                 this.allSelectedItems.push(index);
96.                 this.isSelected[index] = true;
97.               }
98.             }
99.           })
100.         }, (item: string) => item)
101.       }
102.       .listDirection(Axis.Vertical)
103.       .scrollBar(BarState.Off)
104.       .friction(0.6)
105.       .edgeEffect(EdgeEffect.Spring)
106.       .width('90%')
107.     }
108.     .width('100%')
109.     .height('100%')
110.     .backgroundColor(0xDCDCDC)
111.     .padding({ top: 5 })
112.   }
113. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.32634631010292275671077551768221:50001231000000:2800:13DB566546BCF607DF9C95D34DCE5377D8F9C2AB3F5747D7DAB1D600C2058C97.gif)

## 处理滚轮

鼠标的滚轮是一种可以产生纵向滚动量的输入设备，当用户滚动鼠标滚轮时，系统会产生纵向[轴事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-axis)上报，应用可在组件上通过[onAxisEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-axis#onaxisevent)接口接收轴事件，轴事件中上报的坐标，为鼠标光标所在的位置，而滚轮上报的角度变化可从[BaseEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#baseevent8)的axisVertical获得。

鼠标滚轮轴事件的上报，每次都以[AxisAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#axisaction17).BEGIN类型开始，当停止滚动时以[AxisAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#axisaction17).End结束，慢速滚动时，会产生多段的BEGIN、END上报。当你处理axisVertical时，应确保理解它的数值含义与单位，其有以下特点：

- 上报的数值单位为角度，为单次变化量，非总量。
- 上报数值大小受系统设置中对滚轮放大倍数设置的影响。
- 系统设置中的放大倍数通过AxisEvent中的scrollStep告知。
- 向前滚动，上报数值为负，向后滚动，上报数值为正。

如果使用滚动类组件，对于滚轮的响应，系统内部已实现，不需要额外处理。

如果使用[PanGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pangesture)，对于滚轮的响应，此时向前滚动，offsetY的上报数值为正，向后滚动，offsetY的上报数值为负。

说明

1. 滚轮产生的纵向轴值，一般情况下只能触发纵向滚动手势，无法触发横向滚动。
2. 系统会在发现鼠标指针下只有能够响应横向滚动的组件时，也可以触发横向滚动。
3. 但只要指针下有一个可以响应纵向滚动，则会优先处理纵向，不再处理横向。

以下是纵向和横向的List响应滚轮的示例：

1. // ListDataSource.ets
2. export class ListDataSource implements IDataSource {
3.   private list: number[] = [];
4.   private listeners: DataChangeListener[] = [];

5.   constructor(list: number[]) {
6.     this.list = list;
7.   }

8.   totalCount(): number {
9.     return this.list.length;
10.   }

11.   getData(index: number): number {
12.     return this.list[index];
13.   }

14.   registerDataChangeListener(listener: DataChangeListener): void {
15.     if (this.listeners.indexOf(listener) < 0) {
16.       this.listeners.push(listener);
17.     }
18.   }

19.   unregisterDataChangeListener(listener: DataChangeListener): void {
20.     const pos = this.listeners.indexOf(listener);
21.     if (pos >= 0) {
22.       this.listeners.splice(pos, 1);
23.     }
24.   }

25.   // 通知控制器数据删除
26.   notifyDataDelete(index: number): void {
27.     this.listeners.forEach(listener => {
28.       listener.onDataDelete(index);
29.     });
30.   }

31.   // 通知控制器添加数据
32.   notifyDataAdd(index: number): void {
33.     this.listeners.forEach(listener => {
34.       listener.onDataAdd(index);
35.     });
36.   }

37.   // 在指定索引位置删除一个元素
38.   public deleteItem(index: number): void {
39.     this.list.splice(index, 1);
40.     this.notifyDataDelete(index);
41.   }

42.   // 在指定索引位置插入一个元素
43.   public insertItem(index: number, data: number): void {
44.     this.list.splice(index, 0, data);
45.     this.notifyDataAdd(index);
46.   }
47. }

48. import { ListDataSource } from './ListDataSource';

49. @Entry
50. @Component
51. struct ListExample {
52.   private arr: ListDataSource = new ListDataSource([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
53.   @State dir1: Axis = Axis.Vertical;

54.   build() {
55.     Column() {
56.       Button('Click to Change ListDirection')
57.         .margin(20)
58.         .onClick(() => {
59.           if (this.dir1 == Axis.Vertical) {
60.             this.dir1 = Axis.Horizontal
61.           } else {
62.             this.dir1 = Axis.Vertical
63.           }
64.         })
65.       List({ space: 20, initialIndex: 0 }) {
66.         LazyForEach(this.arr, (item: number) => {
67.           ListItem() {
68.             Text('' + item)
69.               .width('100%')
70.               .height(100)
71.               .fontSize(16)
72.               .textAlign(TextAlign.Center)
73.               .borderRadius(10)
74.               .backgroundColor(0xFFFFFF)
75.           }
76.           .margin(20)
77.           // 为ListItem绑定滑动手势，当在ListItem上滚动鼠标滚轮时，会优先触发ListItem的滑动手势
78.           .gesture(PanGesture({ direction: PanDirection.Vertical })
79.             .onActionStart(() => {
80.               console.info('Vertical PanGesture start is called');
81.             })
82.             .onActionUpdate(() => {
83.               console.info('Vertical PanGesture update is called');
84.             }))
85.         }, (item: number) => item.toString())
86.       }
87.       .borderWidth(1)
88.       .listDirection(this.dir1) // 排列方向
89.       .scrollBar(BarState.Off)
90.       .friction(0.6)
91.       .divider({
92.         strokeWidth: 2,
93.         color: 0xFFFFFF,
94.         startMargin: 20,
95.         endMargin: 20
96.       }) // 每行之间的分界线
97.       .edgeEffect(EdgeEffect.Spring) // 边缘效果设置为Spring
98.       .width('90%')
99.     }
100.     .width('100%')
101.     .height('100%')
102.     .backgroundColor(0xDCDCDC)
103.     .padding(20)
104.   }
105. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.08157891025360300587822774362054:50001231000000:2800:285F0C7DC0A14D286F0D1CC6C8EC268D236A4A7B07DD11BE52D6DEADA7324C37.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-touch-screen "支持触屏输入事件")
# 支持触控板输入事件

更新时间: 2025-12-16 16:40

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164037.44676518646006587497698055217998:50001231000000:2800:81201A5888D553C166C1BC616C606F57568B9E606534F196FC7C3AC11F0538A4.png)

当用户使用触控板时，会根据不同的操作方式生成相应的事件。单指点触会产生鼠标左键点击事件，单指轻触移动会产生不按键的鼠标移动事件；双指点触会产生鼠标右键点击事件，双指轻触移动会产生轴事件。

说明

需要注意的是，与触屏不同，触控板上的多指操作并不会体现在上报的事件中，应用无法获取手指信息。

## 单指操作

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.48799492592263525925042374496935:50001231000000:2800:19A12B382F5AFF0D4FFF1E8A83096320BA34F9B156000E6EB1AFAF8B1191FA83.png)

单指操作触控板与操作鼠标的方式相同。例如，轻触后滑动会产生鼠标移动事件，而重按则会产生鼠标左键按下事件。若需判断鼠标事件是来自触控板还是鼠标设备，可以通过[sourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-settings#sourcetype%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E8)和[sourceTool](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-settings#sourcetool%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E9)信息进行区分。

对该种操作产生的事件的处理，请参考[处理鼠标移动](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-mouse#%E5%A4%84%E7%90%86%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8)章节。

## 双指滑动

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.92061916503557867870571914430501:50001231000000:2800:3185A690429B218B60B1B7D94273B9C4A9E1EBB92C0B4B70DB1461BDF2DDFC03.png)

与鼠标滚轮不同，触控板上双指滑动产生的轴事件上报的数值单位并非角度，而是位移像素，为了区分该点，在处理轴值之前，可以通过sourceType及sourceTool来区分。

当用户使用双指横滑时，可从[axisHorizontal](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#%E5%B1%9E%E6%80%A7)中获取横向轴值（位移像素），向右滑动时，上报数值为负，向左滑动时，上报数值为正。使用双指竖滑时，可从[axisVertical](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#%E5%B1%9E%E6%80%A7)获取到纵向轴值（位移像素），向上滑动时，上报数值为正，向下滑动时，上报数值为负。

同滚轮一样，产生的轴事件可以驱动滑动手势的触发。向右滑动时，上报offsetX数值为正，向左滑动时，上报offsetX数值为负。向上滑动时，上报offsetY数值为负，向下滑动时，上报offsetY数值为正。

说明

只有在开始滚动操作的那一刻光标所在位置下的组件上的手势会被收集。

## 双指捏合

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.10245338448604922545568646885686:50001231000000:2800:2217C29C03B4DB21E3D48E3EFCE603A50B984CE0B3C6A05F96049A7C4FB58485.png)

在触控板上通过双指捏合，可以产生捏合缩放值上报。该值表示一个相对缩放比例，可用于实现UI缩放效果。系统上报的数值为一个scale比例，其以双指开始捏合的那一刻（此时为1.0）为基准参考。当双指往外扩张时，scale逐渐从1.0增大；当双指往内合并时，scale逐渐减小。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-mouse "支持鼠标输入事件")
# 支持键盘输入事件

更新时间: 2025-12-16 16:40

物理按键产生的按键事件为非指向性事件，与触摸等指向性事件不同，其事件并没有坐标位置信息，所以其会按照一定次序向获焦组件进行派发，大多数文字输入场景下，按键事件都会优先派发给输入法进行处理，以便其处理文字的联想和候选词，应用可以通过[onKeyPreIme](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key#onkeypreime12)提前感知事件。

说明

一些系统按键产生的事件并不会传递给UI组件，如电源键。

## 按键事件数据流

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.13329480400583041357219612232975:50001231000000:2800:10A07CB117E9806FE8EA8EF1956D53AF31E202F50D8E325E44B3722568057C34.png)

按键事件由外设键盘等设备触发，经驱动和多模处理转换后发送给当前获焦的窗口，窗口获取到事件后，会尝试分发三次事件。三次分发的优先顺序如下，一旦事件被消费，则跳过后续分发流程。

1. 首先分发给ArkUI框架用于触发获焦组件绑定的[onKeyPreIme](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key#onkeypreime12)回调和页面快捷键。
2. 再向输入法分发，输入法会消费按键用作输入。
3. 再次将事件发给ArkUI框架，用于响应[onKeyEventDispatch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key#onkeyeventdispatch15)事件、获焦组件绑定的[onKeyEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key#onkeyevent)回调以及走焦。

因此，当某输入框组件获焦，且打开了输入法，此时大部分按键事件均会被输入法消费。例如字母键会被输入法用来往输入框中输入对应字母字符、方向键会被输入法用来切换选中备选词。如果在此基础上给输入框组件绑定了快捷键，那么快捷键会优先响应事件，事件也不再会被输入法消费。

按键事件到ArkUI框架之后，会先找到完整的节点获焦链。从叶子节点到根节点，逐一发送按键事件，若有子组件可以处理则优先给子组件处理，若子组件无法处理，则进行冒泡寻找父组件进行处理。

Web组件的KeyEvent流程与上述过程有所不同。在[onKeyPreIme](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key#onkeypreime12)返回false时，Web组件不会匹配快捷键。而在第三次按键派发过程中，Web组件会将未消费的[KeyEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key#keyevent%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)通过ReDispatch重新派发回ArkUI，在ReDispatch中再执行匹配快捷键等操作。

## onKeyEvent & onKeyPreIme

1. onKeyEvent(event: (event: KeyEvent) => void): T
2. onKeyEvent(event: Callback<KeyEvent, boolean>): T
3. onKeyPreIme(event: Callback<KeyEvent, boolean>): T
4. onKeyEventDispatch(event: Callback<KeyEvent, boolean>): T

上述四种方法的区别仅在于触发的时机（见[按键事件数据流](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-keyboard#%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%B5%81)）。其中onKeyPreIme的返回值决定了该按键事件后续是否会被继续分发给页面快捷键、输入法、onKeyEventDispatch和onKeyEvent。

当绑定方法的组件处于获焦状态下，外设键盘的按键事件会触发该方法，回调参数为[KeyEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key#keyevent%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)，可由该参数获得当前按键事件的按键行为（[KeyType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#keytype)）、键码（[keyCode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-keycode#keycode)）、按键英文名称（keyText）、事件来源设备类型（[KeySource](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#keysource)）、事件来源设备id（deviceId）、元键按压状态（metaKey）、时间戳（timestamp）、阻止冒泡设置（stopPropagation）。

1. // xxx.ets
2. @Entry
3. @Component
4. struct KeyEventExample {
5.   @State buttonText: string = '';
6.   @State buttonType: string = '';
7.   @State columnText: string = '';
8.   @State columnType: string = '';

9.   build() {
10.     Column() {
11.       Button('onKeyEvent')
12.         .defaultFocus(true)
13.         .width(140).height(70)
14.         .onKeyEvent((event?: KeyEvent) => { // 给Button设置onKeyEvent事件
15.           if(event){
16.             if (event.type === KeyType.Down) {
17.               this.buttonType = 'Down';
18.             }
19.             if (event.type === KeyType.Up) {
20.               this.buttonType = 'Up';
21.             }
22.             this.buttonText = 'Button: \n' +
23.             'KeyType:' + this.buttonType + '\n' +
24.             'KeyCode:' + event.keyCode + '\n' +
25.             'KeyText:' + event.keyText;
26.           }
27.         })

28.       Divider()
29.       Text(this.buttonText).fontColor(Color.Green)

30.       Divider()
31.       Text(this.columnText).fontColor(Color.Red)
32.     }.width('100%').height('100%').justifyContent(FlexAlign.Center)
33.     .onKeyEvent((event?: KeyEvent) => { // 给父组件Column设置onKeyEvent事件
34.       if(event){
35.         if (event.type === KeyType.Down) {
36.           this.columnType = 'Down';
37.         }
38.         if (event.type === KeyType.Up) {
39.           this.columnType = 'Up';
40.         }
41.         this.columnText = 'Column: \n' +
42.         'KeyType:' + this.columnType + '\n' +
43.         'KeyCode:' + event.keyCode + '\n' +
44.         'KeyText:' + event.keyText;
45.       }
46.     })
47.   }
48. }

上述示例中给组件Button和其父容器Column绑定onKeyEvent。应用打开页面加载后，组件树上第一个可获焦的非容器组件自动获焦，设置Button为当前页面的默认焦点，由于Button是Column的子节点，Button获焦也同时意味着Column获焦。获焦机制见[焦点事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.45340751815990031833931841850605:50001231000000:2800:F7A9034D72CF510EDE55D3C8E2C0FD07E268536542AE1D4862C4973FA49CD231.gif)

打开应用后，依次在键盘上按这些按键：空格、回车、左Ctrl、左Shift、字母A、字母Z。

1. 由于onKeyEvent事件默认是冒泡的，所以Button和Column的onKeyEvent都可以响应。
    
2. 每个按键都有2次回调，分别对应KeyType.Down和KeyType.Up，表示按键被按下、然后抬起。
    

如果要阻止冒泡，即仅Button响应键盘事件，Column不响应，在Button的onKeyEvent回调中加入event.stopPropagation()方法即可，如下：

1. @Entry
2. @Component
3. struct KeyEventExample {
4.   @State buttonText: string = '';
5.   @State buttonType: string = '';
6.   @State columnText: string = '';
7.   @State columnType: string = '';

8.   build() {
9.     Column() {
10.       Button('onKeyEvent')
11.         .defaultFocus(true)
12.         .width(140).height(70)
13.         .onKeyEvent((event?: KeyEvent) => {
14.           // 通过stopPropagation阻止事件冒泡
15.           if(event){
16.             if(event.stopPropagation){
17.               event.stopPropagation();
18.             }
19.             if (event.type === KeyType.Down) {
20.               this.buttonType = 'Down';
21.             }
22.             if (event.type === KeyType.Up) {
23.               this.buttonType = 'Up';
24.             }
25.             this.buttonText = 'Button: \n' +
26.               'KeyType:' + this.buttonType + '\n' +
27.               'KeyCode:' + event.keyCode + '\n' +
28.               'KeyText:' + event.keyText;
29.           }
30.         })

31.       Divider()
32.       Text(this.buttonText).fontColor(Color.Green)

33.       Divider()
34.       Text(this.columnText).fontColor(Color.Red)
35.     }.width('100%').height('100%').justifyContent(FlexAlign.Center)
36.     .onKeyEvent((event?: KeyEvent) => { // 给父组件Column设置onKeyEvent事件
37.       if(event){
38.         if (event.type === KeyType.Down) {
39.           this.columnType = 'Down';
40.         }
41.         if (event.type === KeyType.Up) {
42.           this.columnType = 'Up';
43.         }
44.         this.columnText = 'Column: \n' +
45.           'KeyType:' + this.columnType + '\n' +
46.           'KeyCode:' + event.keyCode + '\n' +
47.           'KeyText:' + event.keyText;
48.       }
49.     })
50.   }
51. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.99408296282470992409826915684952:50001231000000:2800:C84A977F136C3B3EDD5522D6012EFB9C2DA635C9225AC96D6340EA4E0FB8FAA1.gif)

使用OnKeyPreIme屏蔽在输入框中使用方向左键。

1. import { KeyCode } from '@kit.InputKit';

2. @Entry
3. @Component
4. struct PreImeEventExample {
5.   @State buttonText: string = '';
6.   @State buttonType: string = '';
7.   @State columnText: string = '';
8.   @State columnType: string = '';

9.   build() {
10.     Column() {
11.       Search({
12.         placeholder: "Search..."
13.       })
14.         .width("80%")
15.         .height("40vp")
16.         .border({ radius:"20vp" })
17.         .onKeyPreIme((event:KeyEvent) => {
18.           if (event.keyCode == KeyCode.KEYCODE_DPAD_LEFT) {
19.             return true;
20.           }
21.           return false;
22.         })
23.     }
24.   }
25. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.31639800262387106090580892661093:50001231000000:2800:50A8A2E231AD7E1C73F76DB08A1B2F36C0B5AE60E531E2C27C1F1D2B54DA625D.gif)

使用onKeyEventDispatch分发按键事件到子组件，子组件使用onKeyEvent。

1. import { hilog } from '@kit.PerformanceAnalysisKit';

2. const TAG = '[Sample_Eventproject]';
3. const DOMAIN = 0xF811;
4. const BUNDLE = 'Eventproject_';

5. @Entry
6. @Component
7. struct Index {
8.   build() {
9.     Row() {
10.       Row() {
11.         Button('button1')
12.           .id('button1')
13.           .margin({ left: 70, right: 30 })
14.           .onKeyEvent((event) => {
15.             hilog.info(DOMAIN, TAG, BUNDLE + 'button1');
16.             return true;
17.           })
18.         Button('button2')
19.           .id('button2')
20.           .onKeyEvent((event) => {
21.             hilog.info(DOMAIN, TAG, BUNDLE + 'button2');
22.             return true;
23.           })
24.       }
25.       .width('100%')
26.       .height('100%')
27.       .id('Row1')
28.       .onKeyEventDispatch((event) => {
29.         let context = this.getUIContext();
30.         context.getFocusController().requestFocus('button1');
31.         return context.dispatchKeyEvent('button1', event);
32.       })

33.     }
34.     .height('100%')
35.     .width('100%')
36.     .onKeyEventDispatch((event) => {
37.       if (event.type == KeyType.Down) {
38.         let context = this.getUIContext();
39.         context.getFocusController().requestFocus('Row1');
40.         return context.dispatchKeyEvent('Row1', event);
41.       }
42.       return true;
43.     })
44.   }
45. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.48224047939367369025654538959419:50001231000000:2800:76E5BDAEFFAAFBC0E4B5CA86CF2ADADBFECE80BE84378E23FC47569866069BC7.jpg)

使用OnKeyPreIme实现回车提交（建议使用物理键盘）。

1. @Entry
2. @Component
3. struct TextAreaDemo {
4.   @State content: string = '';
5.   @State text: string = '';
6.   controller: TextAreaController = new TextAreaController();

7.   build() {
8.     Column() {
9.       Text('Submissions: ' + this.content)
10.       TextArea({ controller: this.controller, text: this.text })
11.         .onKeyPreIme((event: KeyEvent) => {
12.           console.info(`${JSON.stringify(event)}`);
13.           if (event.keyCode === 2054 && event.type === KeyType.Down) { // 回车键物理码
14.             const hasCtrl = event?.getModifierKeyState?.(['Ctrl']);
15.             if (hasCtrl) {
16.               console.info('Line break');
17.             } else {
18.               console.info('Submissions：' + this.text);
19.               this.content = this.text;
20.               this.text = '';
21.               event.stopPropagation();
22.             }
23.             return true;
24.           }
25.           return false;
26.         })
27.         .onChange((value: string) => {
28.           this.text = value
29.         })
30.     }
31.   }
32. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.71257453265043270525626082773062:50001231000000:2800:4B95A208FD01E3478C8557D8B8E3C0A16DFDD2FFBBEF362946D639ED08B26F71.png)

在输入框中输入内容后回车。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.38157523873143735120376135354298:50001231000000:2800:1FE35F340F090906F833DD739365743F93F5B7FB6086244A67FF71F16D2EE5A6.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-touchpad "支持触控板输入事件")
# 支持表冠输入事件

更新时间: 2025-12-16 16:40

表冠事件从API version 18开始支持，是指通过旋转表冠触发的事件，通过硬件采样频率上报旋转角度的变化。

表冠事件分发依赖于应用内组件焦点，只有拥有焦点的组件才能接收到该事件，因此，接收此事件的组件必须管理好其焦点状态，并通过[onFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-focus-event#onfocus)和[onBlur](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-focus-event#onblur)接口关注自身焦点状态变化，当正在接收表冠事件的组件失焦时，接下来的表冠事件都不会再发送给这个组件。

目前，系统中一些组件已默认支持与表冠的交互，例如，旋转手表表冠后，滚动条会根据表冠的旋转方向滚动。

当前，默认支持表冠事件的组件包括： [Slider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-slider)、[DatePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datepicker)、[TextPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textpicker)、 [TimePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker)、[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)、[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)、[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)、[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)、[ArcList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-arclist)、[Refresh](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-refresh)和[Swiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper)。

此外，应用也可以自行通过[onDigitalCrown](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-crown#ondigitalcrown)接口感知表冠事件的上报。

其中，event参数提供表冠事件的时间戳、旋转角速度、旋转角度和[表冠动作](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#crownaction18)。

说明

- 当前仅Wearable设备支持表冠事件。
- 组件对表冠事件的接收受自身获焦状态影响，接收到BEGIN后，如果失焦，则无法继续再接收到后续的UPDATE和END。

当组件需要获取旋转角度等信息时，可以通过onDigitalCrown接收表冠事件来获得上报信息。以下以Text组件为例，介绍表冠事件开发的基本步骤及开发过程中需要注意的事项。

1. 组件获焦
    
    确保接收事件的组件获得焦点，可以通过使用[focusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focusable)、[defaultFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#defaultfocus9)、[focusOnTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focusontouch9)等方法来实现。如需更详细的焦点控制信息，请参考[焦点事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus)文档。
    
    1. Text(this.message)
    2.   .fontSize(20)
    3.   .fontColor(Color.White)
    4.   .backgroundColor("#262626")
    5.   .textAlign(TextAlign.Center)
    6.   .focusable(true)
    7.   .focusOnTouch(true)
    8.   .defaultFocus(true)
    
2. 注册事件回调
    
    接收表冠事件需要注册表冠事件回调，当触发表冠事件时会执行回调函数。
    
    1. .onDigitalCrown((event: CrownEvent) => {})
    
3. 事件字段的含义
    
    表冠事件提供了时间戳，旋转角速度，旋转角度和表冠动作。此外表冠事件会触发事件冒泡，可通过[stopPropagation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-crown#crownevent%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)阻止事件冒泡。
    
    1. event.stopPropagation();
    2. this.message = "CrownEvent\n\n" + JSON.stringify(event);
    3. console.debug("action:%d, angularVelocity:%f, degree:%f, timestamp:%f",
    4. event.action, event.angularVelocity, event.degree, event.timestamp);
    

**完整示例：**

1. // xxx.ets
2. @Entry
3. @Component
4. struct CityList {
5.   @State message: string = "onDigitalCrown";

6.   build() {
7.     Column() {
8.       Row(){
9.         Stack() {
10.           Text(this.message)
11.             .fontSize(20)
12.             .fontColor(Color.White)
13.             .backgroundColor("#262626")
14.             .textAlign(TextAlign.Center)
15.             .focusable(true)
16.             .focusOnTouch(true)
17.             .defaultFocus(true)
18.             .borderWidth(2)
19.             .width(223).height(223)
20.             .borderRadius(110)
21.             .onDigitalCrown((event: CrownEvent) => {
22.               event.stopPropagation();
23.               this.message = "CrownEvent\n\n" + JSON.stringify(event);
24.               console.debug("action:%d, angularVelocity:%f, degree:%f, timestamp:%f",
25.                 event.action, event.angularVelocity, event.degree, event.timestamp);
26.             })
27.         }.width("100%").height("100%")
28.       }.width("100%").height("100%")
29.     }
30.   }
31. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164053.17740504841163344938789568253387:50001231000000:2800:2CE048596B145287B4C570C584F9A675DD6C5532EF5C6B80CD443F3B3DF9F8E3.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-keyboard "支持键盘输入事件")
# 添加手势响应

更新时间: 2025-12-16 16:39

当用户的操作符合某个手势的特征时，系统会将其识别为该手势，这一过程称为手势识别。为了响应某一个手势，需在组件上添加对应的手势对象，以便系统可以收集并进行处理。

## 基本手势及特点

|手势|操作特征|触发方式举例|
|:--|:--|:--|
|[TapGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-tapgesture)|点击（按下在较短时间内抬起，默认300ms）|手指或触控笔点击触屏；按下鼠标左键并松开、单指点击触控板。|
|[LongPressGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-longpressgesture)|长按（按下后维持一段时间）|手指或触控笔长按触屏、长按鼠标左键、单指长按触控板。|
|[PanGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pangesture)|滑动（按下后开始移动）|手指或触控笔点击触屏后移动、按下鼠标左键后移动、单指点击触控板后移动、鼠标指针指向可滑动组件后滚动鼠标滚轮、双指并拢在触控板上滑动。|
|[PinchGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pinchgesture)|捏合（双指按下后向内捏合或向外扩大）|双指在触屏上捏合、双指在触控板上捏合、鼠标指针指向可响应捏合手势的组件时，按下物理键盘ctrl键的同时，滚动鼠标滚轮。|
|[RotationGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-rotationgesture)|旋转（双指按下后旋转双指）|双指在触屏上旋转。|
|[SwipeGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-swipegesture)|快滑，与Pan的区别：swipe手势是以离手时的速度为判定条件；而pan是以位移距离为判定条件，跟手触发；|单指在触屏上快速滑动、双指在触控板上快速滑动、快速滑动鼠标滚轮。|

## 手势响应规则

基本规则：

- 基于从点下那一刻的位置所命中的控件上收集到的手势为基础。
- 同等条件的手势子组件优先于父组件得到响应。
- 不同条件的手势，先成功（条件达成）的先响应。
- 如果不存在并行手势，则当有一个手势成功时，其他手势在本次操作过程中都不会再有成功的机会。
- 并行的手势在子组件上的同类型手势成功时，父组件上的同类型手势也会成功。
- 组件内置手势（系统默认绑定）的响应优先级高于开发者绑定的同类型手势，除非开发者使用priority绑定方式。

以下通过几个场景来说明上述规则。

**场景1:**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.62862880188660671409319152390168:50001231000000:2800:51D53E9F2B2A2D3E7A6C0A2924C2943382A27E89BAF3D598747D863FDC62B87C.png)

Pan A与Pan B为相同阈值条件的滑动手势，Pan B为子组件上的，因此优先级高于父组件上的Pan A，Pan B优先响应成功；

**场景2:**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.50266233951574845398730854146791:50001231000000:2800:975000B2BFBBD61E27CD419954E27D94CAFAF65A954F6A2B97EDFD23E01D9B5D.png)

Pan A与 Pan B为不同阈值条件的滑动手势，Pan B为子组件上的，优先级高于父组件上的Pan A，但由于Pan A的阈值小，因此在相同的报点序列情况下，Pan A会优先判定成功；但要注意的是，如果移动速度特别快，那么同一个报点的间距可能都可以使Pan A和Pan B成功，那么这时候就会是Pan B竞争成功，因为是B先处理报点。

**场景3:**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.19900985265171115659102357373853:50001231000000:2800:FB97A3C1A5983887FB9E0FFB1ACAC90DEE296C8050B5BC7FCC323A9B220EA27F.png)

以实际操作能够响应的手势为准；

比如，如果用户在未达成Pan手势的阈值范围内抬手，则Tap成功；

## 干预手势处理

手势框架基于上述原则处理各组件绑定的手势识别，但在许多场景中，应用需要动态控制手势识别过程：即通过干预手势处理逻辑，在满足响应规则的前提下实现预期识别结果。

系统对手势的识别仍然是以[触摸测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-basic-principles#%E8%A7%A6%E6%91%B8%E6%B5%8B%E8%AF%95)为前提，因此对于可用于干预基础事件处理的方式，都可以应用到对手势处理的干预上，除此之外还可以使用以下方式：

|方式|功能|对应API|说明|
|:--|:--|:--|:--|
|自定义手势判定|在系统判定手势要成功时，给与应用对这个手势是否能成功的裁决机会|[onGestureJudgeBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#ongesturejudgebegin)|所绑定的组件上某个手势将要被系统判定为成功时，系统会回调该方法，给与应用机会来自主决定，该手势能不能成功，如果应用通过该方法返回拒绝，那么系统将会判定该手势失败，进而可以留给其他手势成功的机会。|
|自定义手势判定增强|在系统判定手势要成功时，给与应用对这个手势是否能成功的裁决机会。|[onGestureRecognizerJudgeBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin13)|1. 同onGestureJudgeBegin，都是当所绑定的组件上某个手势将要被系统判定为成功时触发。<br><br>2. 该回调的优先级高于onGestureJudgeBegin，当绑定该方法时，onGestureJudgeBegin的绑定会失效。|
|手势并行动态控制|控制父子(祖先与子孙)组件之间的PAN手势的联动关系，实现嵌套滚动。|[shouldBuiltInRecognizerParallelWith](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#shouldbuiltinrecognizerparallelwith)|1. 当用户按下，系统开始收集当前位置下所有需要参与手势处理的手势对象时触发。<br><br>2. 回调触发时，会将当前组件上的内置系统手势（当前只支持pan手势），以及系统在当前组件之前所已经收集到的同类型的手势对象（Pan手势），这些手势是一个数组，这些手势一般来自于子组件，因此其得到响应的优先级是比当前组件上的同类型手势要高的。普通情况下，当前组件上的手势是竞争不过子组件的手势的。<br><br>3. 而这个回调方法，就是给与应用机会，让应用可以强制指定自己身上的这个低优先级的同类别手势（pan手势）与子组件上的高优先级的同类别手势进行并行，也就是子组件上的同类别高优先级手势成功的时候，当前组件的手势也能被成功触发，从而得到响应。<br><br>4. 返回的手势对象中提供了控制手势响应使能的接口，因此在手势产生了并行之后，应用就可以自主控制两个并行手势的响应行为，从而达成嵌套滚动的效果（一个先滑，滑动到底部再触发另一个继续滑）。<br><br>**说明：**<br><br>在使用时，要注意所绑定的组件是具有系统内置手势（如List，Swiper），否则使用该方法并没有作用，也没有意义。|
|阻止手势参与识别|在手势未识别之前，主动禁止某个手势参与本次交互识别。|[preventBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-common#preventbegin20)|1. 当用户按下，系统收集完当前位置下所有能够参与本次处理的手势对象后触发组件上绑定的[onTouchTestDone](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ontouchtestdone20)回调。<br><br>2. 回调触发时，会将按下时收集到的所有手势识别器对象都返回给开发者。<br><br>3. 应用可以在回调中根据每个手势识别器的信息，挑选出不希望哪些手势识别器参与本次处理，调用识别器对象上的preventBegin方法，从而避免手势冲突。<br><br>从API version 20开始，支持阻止手势参与识别的能力。|

更详细的使用指南请参考[手势冲突处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-gesture-judge)章节。

- **[绑定手势方法](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-binding)**  
    
- **[单一手势](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-single-gesture)**  
    
- **[组合手势](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures)**  
    
- **[多层级手势事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-multi-level-gesture)**  
    
- **[手势冲突处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-gesture-judge)**  
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-crown-event "支持表冠输入事件")
# 单一手势

更新时间: 2025-12-16 16:40

## 点击事件（onClick）

单击作为常用的手势，可以方便地使用[onClick](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-click#onclick)接口实现。尽管被称为事件，它实际上是基本手势类型，等同于将count配置为1的TapGesture，即单击手势。

onClick与其他手势类型相同，也会参与命中测试、响应链收集等过程。可以使用[干预手势处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/rkts-interaction-development-guide-support-gesture#%E5%B9%B2%E9%A2%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86)机制对onClick的响应进行动态决策。

1. @Entry
2. @ComponentV2
3. struct Index {
4.   private judgeCount: number = 0

5.   increaseJudgeGuard(): void {
6.     this.judgeCount++
7.   }

8.   build() {
9.     Column() {
10.       Column() {
11.         Column()
12.           .width('60%')
13.           .height('50%')
14.           .backgroundColor(Color.Grey)
15.           .onClick(() => { // 1. 子组件上注册了点击事件，正常情况下点击在子组件上时，优先得到响应
16.             console.info('Clicked on child')
17.             this.increaseJudgeGuard()
18.           })
19.           .onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {
20.             // 3. 当数字增长为5的倍数时禁用子组件上的点击手势，这样父组件上的点击可以得到响应
21.             if (this.judgeCount % 5 == 0 && gestureInfo.type == GestureControl.GestureType.CLICK) {
22.               return GestureJudgeResult.REJECT
23.             } else {
24.               return GestureJudgeResult.CONTINUE
25.             }
26.           })
27.       }
28.       .width('80%')
29.       .height('80%')
30.       .justifyContent(FlexAlign.Center)
31.       .backgroundColor(Color.Green)
32.       .gesture(
33.         TapGesture() // 2. 父组件上注册了点击手势，正常情况下点击在子组件区域时，父组件上的手势优先级低于子组件
34.           .onAction(() => {
35.             console.info('Clicked on parent')
36.             this.increaseJudgeGuard()
37.           }))
38.     }
39.     .height('100%')
40.     .width('100%')
41.     .justifyContent(FlexAlign.Center)
42.   }
43. }

示例中，每点击5次，子组件的点击事件将临时禁用1次，确保父组件点击优先响应。

## 点击手势（TapGesture）

1. TapGesture(value?: TapGestureParameters)

点击手势支持单次点击和多次点击，参数定义参考[TapGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-tapgesture)。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State value: string = "";

6.   build() {
7.     Column() {
8.       Text('Click twice').fontSize(28)
9.         .gesture(
10.           // 绑定count为2的TapGesture
11.           TapGesture({ count: 2 })
12.             .onAction((event: GestureEvent|undefined) => {
13.             if(event){
14.               this.value = JSON.stringify(event.fingerList[0]);
15.             }
16.             }))
17.       Text(this.value)
18.     }
19.     .height(200)
20.     .width(250)
21.     .padding(20)
22.     .border({ width: 3 })
23.     .margin(30)
24.   }
25. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.89810370172105399890811829929964:50001231000000:2800:1F01A06F79EBFA002A3F68E2A22AB4ED6774B4E010E91D578A75A3376FC95458.gif)

## 长按手势（LongPressGesture）

1. LongPressGesture(value?:{fingers?:number, repeat?:boolean, duration?:number})

长按手势用于触发长按手势事件，参数定义参考[LongPressGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-longpressgesture)。

以在Text组件上绑定可以重复触发的长按手势为例：

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State count: number = 0;

6.   build() {
7.     Column() {
8.       Text('LongPress OnAction:' + this.count).fontSize(28)
9.         .gesture(
10.           // 绑定可以重复触发的LongPressGesture
11.           LongPressGesture({ repeat: true })
12.            .onAction((event: GestureEvent|undefined) => {
13.               if(event){
14.                 if (event.repeat) {
15.                   this.count++;
16.                 }
17.               }
18.             })
19.             .onActionEnd(() => {
20.               this.count = 0;
21.             })
22.         )
23.     }
24.     .height(200)
25.     .width(250)
26.     .padding(20)
27.     .border({ width: 3 })
28.     .margin(30)
29.   }
30. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.43536255521305891161384888480105:50001231000000:2800:A16099B25B14BC9E516D9616E794A54BA4FD4599FED6AB697BD25CDE284B68E4.gif)

## 滑动手势（PanGesture）

1. PanGesture(value?: { fingers?: number; direction?: PanDirection; distance?: number } | PanGestureOptions)

滑动手势用于触发滑动手势事件，滑动达到最小滑动距离（默认值为5vp）时滑动手势识别成功，参数定义参考[PanGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pangesture)。

以下以实现一个简单的音量控制为例，可以通过滑动手势的回调函数处理多种不同的输入情况下的音量值增减的逻辑。

支持以下五种操作方式：

1、单指上下滑动；

2、按住鼠标左键上下滑动；

3、鼠标滚轮滚动；

4、单指按住触控板上下滑动；

5、使用触控板双指滑动。

1. // xxx.ets
2. @Entry
3. @Component
4. struct VolumeControlDemo {
5.   @State currentVolume: number = 50;
6.   private readonly MAX_VOLUME: number = 100;
7.   private readonly MIN_VOLUME: number = 0;

8.   private handlePanUpdate(event: GestureEvent) {
9.     const volumeChange = -event.offsetY * 0.1;
10.     this.handleVolumeChange(volumeChange);
11.   }

12.   private handleWheelEvent(event: GestureEvent) {
13.     const volumeChange = event.offsetY * 0.1;
14.     this.handleVolumeChange(volumeChange);
15.   }

16.   private handleTouchPadScroll(event: GestureEvent) {
17.     const volumeChange = -event.offsetY * 0.02;
18.     this.handleVolumeChange(volumeChange);
19.   }

20.   private handleVolumeChange(delta: number) {
21.     this.currentVolume = Math.min(
22.       this.MAX_VOLUME,
23.       Math.max(this.MIN_VOLUME, this.currentVolume + delta)
24.     )

25.   }

26.   build() {
27.     Column() {
28.       // 状态显示
29.       Row() {
30.         Text(`音量： ${this.currentVolume}`).fontSize(20)
31.       }.margin(10)

32.       // 手势识别区域
33.       Column()
34.         .width('100%')
35.         .height(250)
36.         .backgroundColor('#F5F5F5')
37.         .borderRadius(12)
38.         .gesture(
39.           PanGesture()
40.             .onActionStart(() => {
41.               console.info("Pan start");
42.             })
43.             .onActionUpdate((event: GestureEvent) => {
44.               // 单指上下滑动
45.               if (event.source === SourceType.TouchScreen) {
46.                 console.info("finger move triggered PanGesture");
47.                 this.handlePanUpdate(event);
48.               }
49.               if (event.source === SourceType.Mouse && event.sourceTool === SourceTool.MOUSE) {
50.                 // 鼠标左键按住上下滑动或者触控板单指按住上下滑动
51.                 if (event.axisHorizontal === 0 && event.axisVertical === 0) {
52.                   console.info("mouse move with left button pressed triggered PanGesture");
53.                   this.handlePanUpdate(event);
54.                 } else { // 鼠标滚轮滚动
55.                   console.info("mouse wheel triggered PanGesture");
56.                   this.handleWheelEvent(event);
57.                 }
58.               }
59.               if (event.sourceTool === SourceTool.TOUCHPAD && (event.axisHorizontal !== 0 || event.axisVertical !== 0)) {
60.                 console.info("touchpad double finger move triggered PanGesture");
61.                 this.handleTouchPadScroll(event);
62.               }
63.             })
64.         )
65.     }
66.     .width('100%')
67.     .height('100%')
68.     .padding(20)
69.   }
70. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.63627100858889592011600384164203:50001231000000:2800:6F9C59A5590C8D1E7FABD3B8C15A047E41D4DE2482155A85247CF03EB8AEA47F.gif)

说明

大部分可滑动组件，如List、Grid、Scroll、Tab等组件是通过PanGesture实现滑动，在组件内部的子组件绑定[滑动手势（PanGesture）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-single-gesture#%E6%BB%91%E5%8A%A8%E6%89%8B%E5%8A%BFpangesture)或者[滑动手势（SwipeGesture）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-single-gesture#%E5%BF%AB%E6%BB%91%E6%89%8B%E5%8A%BFswipegesture)会导致手势竞争。

当在子组件绑定PanGesture时，在子组件区域进行滑动仅触发子组件的PanGesture。如果需要父组件响应，需要通过修改手势绑定方法或者子组件向父组件传递消息进行实现，或者通过修改父子组件的PanGesture参数distance使得滑动更灵敏。当子组件绑定SwipeGesture时，由于PanGesture和SwipeGesture触发条件不同，需要修改PanGesture和SwipeGesture的参数以达到所需效果。

不合理的阈值设置会导致滑动不跟手（响应时延慢）的问题。

## 捏合手势（PinchGesture）

1. PinchGesture(value?: { fingers?: number; distance?: number })

捏合手势用于触发捏合手势事件，参数定义参考[PinchGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pinchgesture)。

以在Column组件上绑定三指捏合手势为例，可以通过在捏合手势的函数回调中获取缩放比例，实现对组件的缩小或放大：

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State scaleValue: number = 1;
6.   @State pinchValue: number = 1;
7.   @State pinchX: number = 0;
8.   @State pinchY: number = 0;

9.   build() {
10.     Column() {
11.       Column() {
12.         Text('PinchGesture scale:\n' + this.scaleValue)
13.         Text('PinchGesture center:\n(' + this.pinchX + ',' + this.pinchY + ')')
14.       }
15.       .height(200)
16.       .width(300)
17.       .border({ width: 3 })
18.       .margin({ top: 100 })
19.       // 在组件上绑定缩放比例，可以通过修改缩放比例来实现组件的缩小或者放大
20.       .scale({ x: this.scaleValue, y: this.scaleValue, z: 1 })
21.       .gesture(
22.         // 在组件上绑定三指触发的捏合手势
23.         PinchGesture({ fingers: 3 })
24.           .onActionStart((event: GestureEvent|undefined) => {
25.             console.info('Pinch start');
26.           })
27.             // 当捏合手势触发时，可以通过回调函数获取缩放比例，从而修改组件的缩放比例
28.           .onActionUpdate((event: GestureEvent|undefined) => {
29.             if(event){
30.               this.scaleValue = this.pinchValue * event.scale;
31.               this.pinchX = event.pinchCenterX;
32.               this.pinchY = event.pinchCenterY;
33.             }
34.           })
35.           .onActionEnd(() => {
36.             this.pinchValue = this.scaleValue;
37.             console.info('Pinch end');
38.           })
39.       )
40.     }
41.   }
42. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.24723219635803037729121410609615:50001231000000:2800:2B100A5373261B89A205F9154060273A1C4DC61662D6D4E054A1B6D150A1514E.png)

## 旋转手势（RotationGesture）

1. RotationGesture(value?: { fingers?: number; angle?: number })

旋转手势用于触发旋转手势事件，参数定义参考[RotationGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-rotationgesture)。

以在Text组件上绑定旋转手势实现组件的旋转为例，可以通过在旋转手势的回调函数中获取旋转角度，从而实现组件的旋转：

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State angle: number = 0;
6.   @State rotateValue: number = 0;

7.   build() {
8.     Column() {
9.       Text('RotationGesture angle:' + this.angle).fontSize(28)
10.         // 在组件上绑定旋转布局，可以通过修改旋转角度来实现组件的旋转
11.         .rotate({ angle: this.angle })
12.         .gesture(
13.           RotationGesture()
14.            .onActionStart((event: GestureEvent|undefined) => {
15.               console.info('RotationGesture is onActionStart');
16.             })
17.               // 当旋转手势生效时，通过旋转手势的回调函数获取旋转角度，从而修改组件的旋转角度
18.             .onActionUpdate((event: GestureEvent|undefined) => {
19.               if(event){
20.                 this.angle = this.rotateValue + event.angle;
21.               }
22.               console.info('RotationGesture is onActionUpdate');
23.             })
24.               // 当旋转结束抬手时，固定组件在旋转结束时的角度
25.             .onActionEnd(() => {
26.               this.rotateValue = this.angle;
27.               console.info('RotationGesture is onActionEnd');
28.             })
29.             .onActionCancel(() => {
30.               console.info('RotationGesture is onActionCancel');
31.             })
32.         )
33.         .height(200)
34.         .width(300)
35.         .padding(20)
36.         .border({ width: 3 })
37.         .margin(100)
38.     }
39.   }
40. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.93554320965453576925429132643782:50001231000000:2800:D6E0545D5B51E052CD08C7FEAAAC3BF5B31E46E1CFAD0546385C2A85C16D9AF0.png)

## 快滑手势（SwipeGesture）

1. SwipeGesture(value?: { fingers?: number; direction?: SwipeDirection; speed?: number })

快滑手势用于触发快滑事件，当滑动速度大于100vp/s时可以识别成功，参数定义参考[SwipeGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-swipegesture)。

以在Column组件上绑定快滑手势实现组件的旋转为例：

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State rotateAngle: number = 0;
6.   @State speed: number = 1;

7.   build() {
8.     Column() {
9.       Column() {
10.         Text("SwipeGesture speed\n" + this.speed)
11.         Text("SwipeGesture angle\n" + this.rotateAngle)
12.       }
13.       .border({ width: 3 })
14.       .width(300)
15.       .height(200)
16.       .margin(100)
17.       // 在Column组件上绑定旋转，通过快滑手势的滑动速度和角度修改旋转的角度
18.       .rotate({ angle: this.rotateAngle })
19.       .gesture(
20.         // 绑定快滑手势且限制仅在竖直方向滑动时触发
21.         SwipeGesture({ direction: SwipeDirection.Vertical })
22.           // 当快滑手势触发时，获取滑动的速度和角度，实现对组件的布局参数的修改
23.           .onAction((event: GestureEvent|undefined) => {
24.             if(event){
25.               this.speed = event.speed;
26.               this.rotateAngle = event.angle;
27.             }
28.           })
29.       )
30.     }
31.   }
32. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164026.29761233355562794996850066402115:50001231000000:2800:C882EF5B344622FFE26458115E7358E521147044B6DA35C6852EA47696BEC260.gif)

说明

当SwipeGesture和PanGesture同时绑定时，若二者是以默认方式或者互斥方式进行绑定时，会发生竞争。SwipeGesture的触发条件为滑动速度达到100vp/s，PanGesture的触发条件为滑动距离达到5vp，先达到触发条件的手势触发。可以通过修改SwipeGesture和PanGesture的参数以达到不同的效果。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-binding "绑定手势方法")
# 组合手势

更新时间: 2025-12-16 16:40

组合手势由多种单一手势组合而成，通过在GestureGroup中使用不同的[GestureMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-combined-gestures#gesturemode%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)来声明该组合手势的类型，支持[顺序识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#%E9%A1%BA%E5%BA%8F%E8%AF%86%E5%88%AB)、[并行识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#%E5%B9%B6%E8%A1%8C%E8%AF%86%E5%88%AB)和[互斥识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#%E4%BA%92%E6%96%A5%E8%AF%86%E5%88%AB)三种类型。

1. GestureGroup(mode:GestureMode, gesture:GestureType[])

- mode：为GestureMode枚举类。用于声明该组合手势的类型。
    
- gesture：由多个手势组合而成的数组。用于声明该组合手势的各个手势。
    

## 顺序识别

顺序识别组合手势对应的GestureMode为Sequence。顺序识别组合手势将按照手势的注册顺序识别手势，直到所有的手势识别成功。当顺序识别组合手势中有一个手势识别失败时，后续手势识别均失败。顺序识别手势中仅有最后一个手势可以响应onActionEnd。

以一个由长按手势和滑动手势组合而成的顺序识别手势为例：

在一个Column组件上绑定了[translate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-transformation#translate)属性，通过修改该属性可以设置组件的位置移动。然后在该组件上绑定[LongPressGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-longpressgesture)和[PanGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pangesture)组合而成的Sequence组合手势。当触发LongPressGesture时，更新显示的数字。当长按后进行拖动时，根据滑动手势的回调函数，实现组件的拖动。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State offsetX: number = 0;
6.   @State offsetY: number = 0;
7.   @State count: number = 0;
8.   @State positionX: number = 0;
9.   @State positionY: number = 0;
10.   @State borderStyles: BorderStyle = BorderStyle.Solid;

11.   build() {
12.     Column() {
13.       Text('sequence gesture\n' + 'LongPress onAction:' + this.count + '\nPanGesture offset:\nX: ' + this.offsetX + '\n' + 'Y: ' + this.offsetY)
14.         .fontSize(28)
15.     }.margin(10)
16.     .borderWidth(1)
17.     // 绑定translate属性可以实现组件的位置移动
18.     .translate({ x: this.offsetX, y: this.offsetY, z: 0 })
19.     .height(250)
20.     .width(300)
21.     //以下组合手势为顺序识别，当长按手势事件未正常触发时不会触发滑动手势事件
22.     .gesture(
23.       // 声明该组合手势的类型为Sequence类型
24.       GestureGroup(GestureMode.Sequence,
25.         // 该组合手势第一个触发的手势为长按手势，且长按手势可多次响应
26.         LongPressGesture({ repeat: true })
27.           // 当长按手势识别成功，增加Text组件上显示的count次数
28.           .onAction((event: GestureEvent|undefined) => {
29.             if(event){
30.               if (event.repeat) {
31.                 this.count++;
32.               }
33.             }
34.             console.info('LongPress onAction');
35.           })
36.           .onActionEnd(() => {
37.             console.info('LongPress end');
38.           }),
39.         // 当长按之后进行拖动，PanGesture手势被触发
40.         PanGesture()
41.           .onActionStart(() => {
42.             this.borderStyles = BorderStyle.Dashed;
43.             console.info('pan start');
44.           })
45.             // 当该手势被触发时，根据回调获得拖动的距离，修改该组件的位移距离从而实现组件的移动
46.           .onActionUpdate((event: GestureEvent|undefined) => {
47.             if(event){
48.               this.offsetX = (this.positionX + event.offsetX);
49.               this.offsetY = this.positionY + event.offsetY;
50.             }
51.             console.info('pan update');
52.           })
53.           .onActionEnd(() => {
54.             this.positionX = this.offsetX;
55.             this.positionY = this.offsetY;
56.             this.borderStyles = BorderStyle.Solid;
57.           })
58.       )
59.       .onCancel(() => {
60.         console.info("sequence gesture canceled")
61.       })
62.     )
63.   }
64. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.53971641912349519725711133890494:50001231000000:2800:DB1C58DF5CD259C577700D441108AE7814F16E778D26A154A63C6AACFD6A578A.gif)

说明

拖拽事件是一种典型的顺序识别组合手势事件，由长按手势事件和滑动手势事件组合而成。只有先长按达到长按手势事件预设置的时间后进行滑动才会触发拖拽事件。如果长按事件未达到或者长按后未进行滑动，拖拽事件均识别失败。

## 并行识别

并行识别组合手势对应的GestureMode为Parallel。并行识别组合手势中注册的手势将同时进行识别，直到所有手势识别结束。并行识别手势组合中的手势进行识别时互不影响。

以在一个Column组件上绑定点击手势和双击手势组成的并行识别手势为例，由于单击手势和双击手势是并行识别，因此两个手势可以同时进行识别，二者互不干涉。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State count1: number = 0;
6.   @State count2: number = 0;

7.   build() {
8.     Column() {
9.       Text('Parallel gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')
10.         .fontSize(28)
11.     }
12.     .height(200)
13.     .width('100%')
14.     // 以下组合手势为并行识别，单击手势识别成功后，若在规定时间内再次点击，双击手势也会识别成功
15.     .gesture(
16.       GestureGroup(GestureMode.Parallel,
17.         TapGesture({ count: 1 })
18.           .onAction(() => {
19.             this.count1++;
20.           }),
21.         TapGesture({ count: 2 })
22.           .onAction(() => {
23.             this.count2++;
24.           })
25.       )
26.     )
27.   }
28. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.83950394551539414537687651511304:50001231000000:2800:223073E77A08A252C10E363EC3027E42169A3AFFC570377DBBE7A7B4F3F2B91E.gif)

说明

当由单击手势和双击手势组成一个并行识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。

当只有单次点击时，单击手势识别成功，双击手势识别失败。

当有两次点击时，若两次点击相距时间在规定时间内（默认规定时间为300毫秒），触发两次单击事件和一次双击事件。

当有两次点击时，若两次点击相距时间超出规定时间，触发两次单击事件不触发双击事件。

## 互斥识别

互斥识别组合手势对应的GestureMode为Exclusive。互斥识别组合手势中注册的手势将同时进行识别，若有一个手势识别成功，则结束手势识别，其他所有手势识别失败。

以在一个Column组件上绑定单击手势和双击手势组合而成的互斥识别组合手势为例。若先绑定单击手势后绑定双击手势，由于单击手势只需要一次点击即可触发而双击手势需要两次，每次的点击事件均被单击手势消费而不能积累成双击手势，所以双击手势无法触发。若先绑定双击手势后绑定单击手势，则触发双击手势不触发单击手势。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State count1: number = 0;
6.   @State count2: number = 0;

7.   build() {
8.     Column() {
9.       Text('Exclusive gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')
10.         .fontSize(28)
11.     }
12.     .height(200)
13.     .width('100%')
14.     //以下组合手势为互斥识别，单击手势识别成功后，双击手势会识别失败
15.     .gesture(
16.       GestureGroup(GestureMode.Exclusive,
17.         TapGesture({ count: 1 })
18.           .onAction(() => {
19.             this.count1++;
20.           }),
21.         TapGesture({ count: 2 })
22.           .onAction(() => {
23.             this.count2++;
24.           })
25.       )
26.     )
27.   }
28. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.28920284594620436124610667732333:50001231000000:2800:F3D950DD38DA403EC2F98310E958BF7701770BD6EE5BE0FB26A84C21BA25C78A.gif)

说明

当由单击手势和双击手势组成一个互斥识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。

当只有单次点击时，单击手势识别成功，双击手势识别失败。

当有两次点击时，手势响应取决于绑定手势的顺序。若先绑定单击手势后绑定双击手势，单击手势在第一次点击时即宣告识别成功，此时双击手势已经失败。即使在规定时间内进行了第二次点击，双击手势事件也不会进行响应，此时会触发单击手势事件的第二次识别成功。若先绑定双击手势后绑定单击手势，则会响应双击手势而不响应单击手势。

## 场景示例

以下示例实现了子组件绑定长按和滑动手势，长按手势和滑动手势可以同时触发，但是在长按手势未成功时，需要让父组件Swiper的内置滑动手势触发功能。由于子组件的滑动手势和父组件的内置滑动手势是竞争关系，且子组件的滑动手势的优先级更高，因此需要通过动态控制子组件的滑动手势是否触发。

1. // xxx.ets
2. import { PromptAction } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct CombinedGestureDemo {
6.   @State isLongPress: boolean = false;
7.   promptAction: PromptAction = this.getUIContext().getPromptAction();

8.   build() {
9.     Swiper() {
10.       // 页面1
11.       Row()
12.         .width('100%')
13.         .height('100%')
14.         .backgroundColor(Color.Grey)
15.         .borderRadius(12)
16.         // 通过自定义手势判定回调，判断在长按手势未成功时，拒绝子组件的滑动手势，从而让父组件Swiper的滑动手势成功
17.         .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>)=>{
18.           if (current.getType() !== GestureControl.GestureType.PAN_GESTURE) {
19.             return GestureJudgeResult.CONTINUE;
20.           }
21.           if (this.isLongPress) {
22.             return GestureJudgeResult.CONTINUE;
23.           }
24.           return GestureJudgeResult.REJECT;
25.         })
26.         .gesture(
27.           // 绑定并行手势组，实现长按手势和滑动手势可以同时触发
28.           GestureGroup(GestureMode.Parallel,
29.             LongPressGesture()
30.               .onAction(() => {
31.                 this.isLongPress = true;
32.                 this.promptAction.showToast({ message: "LongPress trigger" })
33.               })
34.               .onActionEnd(() => {
35.                 this.isLongPress = false;
36.               })
37.             ,
38.             PanGesture()
39.               .onActionStart(() => {
40.                 this.promptAction.showToast({ message: "child pan start" })
41.               })
42.           )
43.         )
44.       // 页面2
45.       Row()
46.         .width('100%')
47.         .height('100%')
48.         .backgroundColor(Color.Pink)
49.         .borderRadius(12)
50.     }
51.     .borderWidth(2)
52.     .width('100%')
53.     .height(300)
54.     .padding(20)
55.   }
56. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.97592107640715524779719237272210:50001231000000:2800:37CD20D7F50C83E6D87A07D360C3BFF0DA820BAF6C7EF631289F14946E1B91D3.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-single-gesture "单一手势")
# 组合手势

更新时间: 2025-12-16 16:40

组合手势由多种单一手势组合而成，通过在GestureGroup中使用不同的[GestureMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-combined-gestures#gesturemode%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)来声明该组合手势的类型，支持[顺序识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#%E9%A1%BA%E5%BA%8F%E8%AF%86%E5%88%AB)、[并行识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#%E5%B9%B6%E8%A1%8C%E8%AF%86%E5%88%AB)和[互斥识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#%E4%BA%92%E6%96%A5%E8%AF%86%E5%88%AB)三种类型。

1. GestureGroup(mode:GestureMode, gesture:GestureType[])

- mode：为GestureMode枚举类。用于声明该组合手势的类型。
    
- gesture：由多个手势组合而成的数组。用于声明该组合手势的各个手势。
    

## 顺序识别

顺序识别组合手势对应的GestureMode为Sequence。顺序识别组合手势将按照手势的注册顺序识别手势，直到所有的手势识别成功。当顺序识别组合手势中有一个手势识别失败时，后续手势识别均失败。顺序识别手势中仅有最后一个手势可以响应onActionEnd。

以一个由长按手势和滑动手势组合而成的顺序识别手势为例：

在一个Column组件上绑定了[translate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-transformation#translate)属性，通过修改该属性可以设置组件的位置移动。然后在该组件上绑定[LongPressGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-longpressgesture)和[PanGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pangesture)组合而成的Sequence组合手势。当触发LongPressGesture时，更新显示的数字。当长按后进行拖动时，根据滑动手势的回调函数，实现组件的拖动。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State offsetX: number = 0;
6.   @State offsetY: number = 0;
7.   @State count: number = 0;
8.   @State positionX: number = 0;
9.   @State positionY: number = 0;
10.   @State borderStyles: BorderStyle = BorderStyle.Solid;

11.   build() {
12.     Column() {
13.       Text('sequence gesture\n' + 'LongPress onAction:' + this.count + '\nPanGesture offset:\nX: ' + this.offsetX + '\n' + 'Y: ' + this.offsetY)
14.         .fontSize(28)
15.     }.margin(10)
16.     .borderWidth(1)
17.     // 绑定translate属性可以实现组件的位置移动
18.     .translate({ x: this.offsetX, y: this.offsetY, z: 0 })
19.     .height(250)
20.     .width(300)
21.     //以下组合手势为顺序识别，当长按手势事件未正常触发时不会触发滑动手势事件
22.     .gesture(
23.       // 声明该组合手势的类型为Sequence类型
24.       GestureGroup(GestureMode.Sequence,
25.         // 该组合手势第一个触发的手势为长按手势，且长按手势可多次响应
26.         LongPressGesture({ repeat: true })
27.           // 当长按手势识别成功，增加Text组件上显示的count次数
28.           .onAction((event: GestureEvent|undefined) => {
29.             if(event){
30.               if (event.repeat) {
31.                 this.count++;
32.               }
33.             }
34.             console.info('LongPress onAction');
35.           })
36.           .onActionEnd(() => {
37.             console.info('LongPress end');
38.           }),
39.         // 当长按之后进行拖动，PanGesture手势被触发
40.         PanGesture()
41.           .onActionStart(() => {
42.             this.borderStyles = BorderStyle.Dashed;
43.             console.info('pan start');
44.           })
45.             // 当该手势被触发时，根据回调获得拖动的距离，修改该组件的位移距离从而实现组件的移动
46.           .onActionUpdate((event: GestureEvent|undefined) => {
47.             if(event){
48.               this.offsetX = (this.positionX + event.offsetX);
49.               this.offsetY = this.positionY + event.offsetY;
50.             }
51.             console.info('pan update');
52.           })
53.           .onActionEnd(() => {
54.             this.positionX = this.offsetX;
55.             this.positionY = this.offsetY;
56.             this.borderStyles = BorderStyle.Solid;
57.           })
58.       )
59.       .onCancel(() => {
60.         console.info("sequence gesture canceled")
61.       })
62.     )
63.   }
64. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.53971641912349519725711133890494:50001231000000:2800:DB1C58DF5CD259C577700D441108AE7814F16E778D26A154A63C6AACFD6A578A.gif)

说明

拖拽事件是一种典型的顺序识别组合手势事件，由长按手势事件和滑动手势事件组合而成。只有先长按达到长按手势事件预设置的时间后进行滑动才会触发拖拽事件。如果长按事件未达到或者长按后未进行滑动，拖拽事件均识别失败。

## 并行识别

并行识别组合手势对应的GestureMode为Parallel。并行识别组合手势中注册的手势将同时进行识别，直到所有手势识别结束。并行识别手势组合中的手势进行识别时互不影响。

以在一个Column组件上绑定点击手势和双击手势组成的并行识别手势为例，由于单击手势和双击手势是并行识别，因此两个手势可以同时进行识别，二者互不干涉。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State count1: number = 0;
6.   @State count2: number = 0;

7.   build() {
8.     Column() {
9.       Text('Parallel gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')
10.         .fontSize(28)
11.     }
12.     .height(200)
13.     .width('100%')
14.     // 以下组合手势为并行识别，单击手势识别成功后，若在规定时间内再次点击，双击手势也会识别成功
15.     .gesture(
16.       GestureGroup(GestureMode.Parallel,
17.         TapGesture({ count: 1 })
18.           .onAction(() => {
19.             this.count1++;
20.           }),
21.         TapGesture({ count: 2 })
22.           .onAction(() => {
23.             this.count2++;
24.           })
25.       )
26.     )
27.   }
28. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.83950394551539414537687651511304:50001231000000:2800:223073E77A08A252C10E363EC3027E42169A3AFFC570377DBBE7A7B4F3F2B91E.gif)

说明

当由单击手势和双击手势组成一个并行识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。

当只有单次点击时，单击手势识别成功，双击手势识别失败。

当有两次点击时，若两次点击相距时间在规定时间内（默认规定时间为300毫秒），触发两次单击事件和一次双击事件。

当有两次点击时，若两次点击相距时间超出规定时间，触发两次单击事件不触发双击事件。

## 互斥识别

互斥识别组合手势对应的GestureMode为Exclusive。互斥识别组合手势中注册的手势将同时进行识别，若有一个手势识别成功，则结束手势识别，其他所有手势识别失败。

以在一个Column组件上绑定单击手势和双击手势组合而成的互斥识别组合手势为例。若先绑定单击手势后绑定双击手势，由于单击手势只需要一次点击即可触发而双击手势需要两次，每次的点击事件均被单击手势消费而不能积累成双击手势，所以双击手势无法触发。若先绑定双击手势后绑定单击手势，则触发双击手势不触发单击手势。

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   @State count1: number = 0;
6.   @State count2: number = 0;

7.   build() {
8.     Column() {
9.       Text('Exclusive gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')
10.         .fontSize(28)
11.     }
12.     .height(200)
13.     .width('100%')
14.     //以下组合手势为互斥识别，单击手势识别成功后，双击手势会识别失败
15.     .gesture(
16.       GestureGroup(GestureMode.Exclusive,
17.         TapGesture({ count: 1 })
18.           .onAction(() => {
19.             this.count1++;
20.           }),
21.         TapGesture({ count: 2 })
22.           .onAction(() => {
23.             this.count2++;
24.           })
25.       )
26.     )
27.   }
28. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.28920284594620436124610667732333:50001231000000:2800:F3D950DD38DA403EC2F98310E958BF7701770BD6EE5BE0FB26A84C21BA25C78A.gif)

说明

当由单击手势和双击手势组成一个互斥识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。

当只有单次点击时，单击手势识别成功，双击手势识别失败。

当有两次点击时，手势响应取决于绑定手势的顺序。若先绑定单击手势后绑定双击手势，单击手势在第一次点击时即宣告识别成功，此时双击手势已经失败。即使在规定时间内进行了第二次点击，双击手势事件也不会进行响应，此时会触发单击手势事件的第二次识别成功。若先绑定双击手势后绑定单击手势，则会响应双击手势而不响应单击手势。

## 场景示例

以下示例实现了子组件绑定长按和滑动手势，长按手势和滑动手势可以同时触发，但是在长按手势未成功时，需要让父组件Swiper的内置滑动手势触发功能。由于子组件的滑动手势和父组件的内置滑动手势是竞争关系，且子组件的滑动手势的优先级更高，因此需要通过动态控制子组件的滑动手势是否触发。

1. // xxx.ets
2. import { PromptAction } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct CombinedGestureDemo {
6.   @State isLongPress: boolean = false;
7.   promptAction: PromptAction = this.getUIContext().getPromptAction();

8.   build() {
9.     Swiper() {
10.       // 页面1
11.       Row()
12.         .width('100%')
13.         .height('100%')
14.         .backgroundColor(Color.Grey)
15.         .borderRadius(12)
16.         // 通过自定义手势判定回调，判断在长按手势未成功时，拒绝子组件的滑动手势，从而让父组件Swiper的滑动手势成功
17.         .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>)=>{
18.           if (current.getType() !== GestureControl.GestureType.PAN_GESTURE) {
19.             return GestureJudgeResult.CONTINUE;
20.           }
21.           if (this.isLongPress) {
22.             return GestureJudgeResult.CONTINUE;
23.           }
24.           return GestureJudgeResult.REJECT;
25.         })
26.         .gesture(
27.           // 绑定并行手势组，实现长按手势和滑动手势可以同时触发
28.           GestureGroup(GestureMode.Parallel,
29.             LongPressGesture()
30.               .onAction(() => {
31.                 this.isLongPress = true;
32.                 this.promptAction.showToast({ message: "LongPress trigger" })
33.               })
34.               .onActionEnd(() => {
35.                 this.isLongPress = false;
36.               })
37.             ,
38.             PanGesture()
39.               .onActionStart(() => {
40.                 this.promptAction.showToast({ message: "child pan start" })
41.               })
42.           )
43.         )
44.       // 页面2
45.       Row()
46.         .width('100%')
47.         .height('100%')
48.         .backgroundColor(Color.Pink)
49.         .borderRadius(12)
50.     }
51.     .borderWidth(2)
52.     .width('100%')
53.     .height(300)
54.     .padding(20)
55.   }
56. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.97592107640715524779719237272210:50001231000000:2800:37CD20D7F50C83E6D87A07D360C3BFF0DA820BAF6C7EF631289F14946E1B91D3.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-single-gesture "单一手势")
# 多层级手势事件

更新时间: 2025-12-16 16:40

多层级手势事件指父子组件嵌套时，父子组件均绑定了手势或事件。在该场景下，手势或者事件的响应受到多个因素的影响，相互之间发生传递和竞争，容易出现预期外的响应。

本章主要介绍了多层级手势事件的默认响应顺序，以及如何通过设置相关属性影响多层级手势事件的响应顺序。

## 默认多层级手势事件

### 触摸事件

[触摸事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch)（onTouch事件）是所有手势组成的基础，有Down，Move，Up，Cancel四种。手势均由触摸事件组成，例如，点击为Down+Up，滑动为Down+一系列Move+Up。触摸事件具有最特殊性：

1.监听了onTouch事件的组件。在手指落下被触摸时均会收到onTouch事件的回调，被触摸受到触摸热区和触摸控制影响。

2.onTouch事件的回调是闭环的。若一个组件收到了手指Id为0的Down事件，后续也会收到手指Id为0的Move事件和Up事件。

3.onTouch事件的回调是一致的。若一个组件收到了手指Id为0的Down事件，但未收到手指Id为1的Down事件，则后续只会收到手指Id为0的touch事件，不会收到手指Id为1的后续touch事件。

对于一般的容器组件（例如：Column），父子组件之间onTouch事件能够同时触发，兄弟组件之间onTouch事件根据布局进行触发。

1. ComponentA() {
2.     ComponentB().onTouch(() => {})
3.     ComponentC().onTouch(() => {})
4. }.onTouch(() => {})

组件B和组件C作为组件A的子组件，当触摸到组件B或者组件C时，组件A也会被触摸到。onTouch事件允许多个组件同时触发，

因此，当触摸组件B时，会触发组件A和组件B的onTouch回调，不会触发组件C的onTouch回调。

当触摸组件C时，会触发组件A和组件C的onTouch回调，不触发组件B的回调。

特殊的容器组件，如Stack等组件，由于子组件之间存在着堆叠关系，子组件的布局也存在相互遮盖关系。

所以，父子组件之间onTouch事件能够同时触发，兄弟组件之间onTouch事件会存在遮盖关系。

1. Stack A() {
2.     ComponentB().onTouch(() => {})
3.     ComponentC().onTouch(() => {})
4. }.onTouch(() => {})

组件B和组件C作为Stack A的子组件，组件C覆盖在组件B上。当触摸到组件B或者组件C时，Stack A也会被触摸到。onTouch事件允许多个组件同时触发，因此，当触摸组件B和组件C的重叠区域时，会触发Stack A和组件C的onTouch回调，不会触发组件B的onTouch回调（组件B被组件C遮盖）。

### 手势与事件

除了触摸事件（onTouch事件）外的所有手势与事件，均是通过基础手势或者组合手势实现的。例如，拖拽事件是由长按手势和滑动手势组成的一个顺序手势。

在未显式声明的情况下，同一时间，一根手指对应的手势组中只会有一个手势获得成功从而触发所设置的回调。

因此，除非显式声明允许多个手势同时成功，同一时间只会有一个手势响应。

响应优先级遵循以下条件：

1.当父子组件均绑定同一类手势时，子组件优先于父组件触发。

2.当一个组件绑定多个手势时，先达到手势触发条件的手势优先触发。

1. ComponentA() {
2.     ComponentB().gesture(TapGesture({count: 1}))
3. }.gesture(TapGesture({count: 1}))

当父组件和子组件均绑定点击手势时，子组件的优先级高于父组件。

因此，当在B组件上进行点击时，组件B所绑定的TapGesture的回调会被触发，而组件A所绑定的TapGesture的回调不会被触发。

1. ComponentA()
2. .gesture(
3.     GestureGroup(
4.         GestureMode.Exclusive,
5.         TapGesture({count: 1}),
6.         PanGesture({distance: 5})
7.     )
8. )

当组件A上绑定了由点击和滑动手势组成的互斥手势组时，先达到触发条件的手势触发对应的回调。

若使用者做了一次点击操作，则响应点击对应的回调。若使用者进行了一次滑动操作并且滑动距离达到了阈值，则响应滑动对应的回调。

## 自定义控制的多层级手势事件

可以通过设置属性，控制默认的多层级手势事件竞争流程，更好地实现手势事件。

目前，responseRegion属性和hitTestBehavior属性可以控制Touch事件的分发，从而可以影响到onTouch事件和手势的响应。而绑定手势方法属性可以控制手势的竞争从而影响手势的响应，但不能影响到onTouch事件。

### responseRegion对手势和事件的控制

[responseRegion](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-touch-target#responseregion)属性可以实现组件的响应区域范围的变化。响应区域范围可以超出或者小于组件的布局范围。

1. ComponentA() {
2.     ComponentB()
3.     .onTouch(() => {})
4.     .gesture(TapGesture({count: 1}))
5.     .responseRegion({Rect1, Rect2, Rect3})
6. }
7. .onTouch(() => {})
8. .gesture(TapGesture({count: 1}))
9. .responseRegion({Rect4})

当组件A绑定了.responseRegion({Rect4})的属性后，所有落在Rect4区域范围的触摸事件和手势可被组件A对应的回调响应。

当组件B绑定了.responseRegion({Rect1, Rect2, Rect3})的属性后，所有落在Rect1,Rect2和Rect3区域范围的触摸事件和手势可被组件B对应的回调响应。

当绑定了responseRegion后，手势与事件的响应区域范围将以所绑定的区域范围为准，而不是以布局区域为准，可能出现布局相关区域不响应手势与事件的情况。

此外，responseRegion属性支持由多个Rect组成的数组作为入参，以支持更多开发需求。

### hitTestBehavior对手势和事件的控制

[hitTestBehavior](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior#hittestbehavior)属性可以实现在复杂的多层级场景下，一些组件能够响应手势和事件，而一些组件不能响应手势和事件。

1. ComponentA() {
2.     ComponentB()
3.     .onTouch(() => {})
4.     .gesture(TapGesture({count: 1}))

5.     ComponentC() {
6.         ComponentD()
7.         .onTouch(() => {})
8.         .gesture(TapGesture({count: 1}))
9.     }
10.     .onTouch(() => {})
11.     .gesture(TapGesture({count: 1}))
12.     .hitTestBehavior(HitTestMode.Block)
13. }
14. .onTouch(() => {})
15. .gesture(TapGesture({count: 1}))

HitTestMode.Block自身会响应触摸测试，阻塞子节点和兄弟节点的触摸测试，从而导致子节点和兄弟节点的onTouch事件和手势均无法触发。

当组件C未设置hitTestBehavior时，点击组件D区域，组件A、组件C和组件D的onTouch事件会触发，组件D的点击手势会触发。

当组件C设置了hitTestBehavior为HitTestMode.Block时，点击组件D区域，组件A和组件C的onTouch事件会触发，组件D的onTouch事件未触发。同时，由于组件D的点击手势因为被阻塞而无法触发，组件C的点击手势会触发。

1. Stack A() {
2.     ComponentB()
3.     .onTouch(() => {})
4.     .gesture(TapGesture({count: 1}))

5.     ComponentC()
6.     .onTouch(() => {})
7.     .gesture(TapGesture({count: 1}))
8.     .hitTestBehavior(HitTestMode.Transparent)
9. }
10. .onTouch(() => {})
11. .gesture(TapGesture({count: 1}))

HitTestMode.Transparent自身响应触摸测试，不会阻塞兄弟节点的触摸测试。

当组件C未设置hitTestBehavior时，点击组件B和组件C的重叠区域时，Stack A和组件C的onTouch事件会触发，组件C的点击事件会触发，组件B的onTouch事件和点击手势均不触发。

而当组件C设置hitTestBehavior为HitTestMode.Transparent时，点击组件B和组件C的重叠区域，组件A和组件C不受到影响与之前一致，组件A和组件C的onTouch事件会触发，组件C的点击手势会触发。而组件B因为组件C设置了HitTestMode.Transparent，组件B也收到了Touch事件，从而组件B的onTouch事件触发。

1. ComponentA() {
2.     ComponentB()
3.     .onTouch(() => {})
4.     .gesture(TapGesture({count: 1}))
5. }
6. .onTouch(() => {})
7. .gesture(TapGesture({count: 1}))
8. .hitTestBehavior(HitTestMode.None)

HitTestMode.None自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸控制。

当组件A未设置hitTestBehavior时，点击组件B区域时，组件A和组件B的onTouch事件均会触发，组件B的点击手势会触发。

当组件A设置hitTestBehavior为HitTestMode.None时，点击组件B区域时，组件B的onTouch事件触发，而组件A的onTouch事件无法触发，组件B的点击手势触发。

1. Stack A() {
2.     ComponentB()
3.     .onTouch(() => {})
4.     .gesture(TapGesture({count: 1}))
5.     ComponentC() {
6.         ComponentD()
7.         .onTouch(() => {})
8.         .gesture(TapGesture({count: 1}))
9.     }
10.     .onTouch(() => {})
11.     .gesture(TapGesture({count: 1}))
12.     .hitTestBehavior(HitTestMode.BLOCK_HIERARCHY)
13. }
14. .onTouch(() => {})
15. .gesture(TapGesture({count: 1}))

从API version 20开始，HitTestMode.BLOCK_HIERARCHY自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。

当组件C未设置hitTestBehavior时，点击组件B和组件D的重叠区域时，组件A，组件C和组件D的onTouch事件均会触发，组件D的点击手势会触发。

当组件C设置hitTestBehavior为BLOCK_HIERARCHY时，点击组件B和组件D的重叠区域时，组件C和组件D的onTouch事件触发，组件A和组件B的onTouch事件无法触发，组件D的点击手势会触发。

1. Stack A() {
2.     ComponentB()
3.     .onTouch(() => {})
4.     .gesture(TapGesture({count: 1}))
5.     ComponentC() {
6.         ComponentD()
7.         .onTouch(() => {})
8.         .gesture(TapGesture({count: 1}))
9.     }
10.     .onTouch(() => {})
11.     .gesture(TapGesture({count: 1}))
12.     .hitTestBehavior(HitTestMode.BLOCK_DESCENDANTS)
13. }
14. .onTouch(() => {})
15. .gesture(TapGesture({count: 1}))

从API version 20开始，[HitTestMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#hittestmode9).BLOCK_DESCENDANTS自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。

若组件C未设置[hitTestBehavior](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior#hittestbehavior)，点击组件B和组件D的重叠区域时，组件A、组件C和组件D都会触发[onTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#ontouch)事件，同时组件D的点击手势也会被触发。

当组件C设置[hitTestBehavior](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior#hittestbehavior)为BLOCK_DESCENDANTS时，点击组件B和组件D的重叠区域时，组件A和组件B的[onTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#ontouch)事件触发，组件C和组件D的[onTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#ontouch)事件无法触发，组件B的点击手势会触发。

针对简单的场景，建议在单个组件上绑定hitTestBehavior。

针对复杂场景，建议在多个组件上绑定不同的hitTestBehavior来控制Touch事件的分发。

### 绑定手势方法对手势的控制

设置绑定手势的方法可以实现在多层级场景下，当父组件与子组件绑定了相同的手势时，设置不同的绑定手势方法有不同的响应优先级。

当父组件使用.gesture绑定手势，父子组件所绑定手势类型相同时，子组件优先于父组件响应。

1. ComponentA() {
2.     ComponentB()
3.     .gesture(TapGesture({count: 1}))
4. }
5. .gesture(TapGesture({count: 1}))

当父子组件均正常绑定点击手势时，子组件优先于父组件响应。

此时，单击组件B区域范围，组件B的点击手势会触发，组件A的点击手势不会触发。

如果以带优先级的方式绑定手势，则可使得父组件所绑定手势的响应优先级高于子组件。

1. ComponentA() {
2.     ComponentB()
3.     .gesture(TapGesture({count: 1}))
4. }
5. .priorityGesture(TapGesture({count: 1}))

当父组件以.[priorityGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-settings#prioritygesture)的形式绑定手势时，父组件所绑定的手势优先级高于子组件。

此时，单击组件B区域范围，组件A的点击手势会触发，组件B的点击手势不会触发。

如果需要父子组件所绑定的手势不发生冲突，均可响应，则可以使用并行的方式在父组件绑定手势。

1. ComponentA() {
2.     ComponentB()
3.     .gesture(TapGesture({count: 1}))
4. }
5. .parallelGesture(TapGesture({count: 1}))

当父组件以.[parallelGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-settings#parallelgesture)的形式绑定手势时，父组件和子组件所绑定的手势均可触发。

此时，单击组件B区域范围，组件A和组件B的点击手势均会触发。

### OverlayManager的事件透传

[OverlayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager)事件机制，默认优先被[WrappedBuilder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-wrapbuilder#wrappedbuilder)内组件先接收，不会向下传递。

若希望OverlayManager下方的页面也能感应到事件，可采用hitTestBehavior(HitTestMode.Transparent)来传递事件，参考以下伪代码。

1. @Builder
2. function builderOverlay(params: Params) {
3.     Component().hitTestBehavior(HitTestMode.Transparent)
4. }

5. aboutToAppear(): void {
6.     let componentContent = new ComponentContent(
7.         this.context, wrapBuilder<[Params]>(builderOverlay),
8.         new Params(uiContext, {x:0, y: 100})
9.     );
10.     this.overlayManager.addComponentContent(componentContent, 0);
11. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures "组合手势")
# 手势冲突处理

更新时间: 2025-12-16 16:40

手势冲突是指多个手势识别器在同一组件或重叠区域同时识别时产生竞争，导致识别结果不符合预期。常见冲突场景包括：

- 同一组件上的多手势（如按钮同时添加点击与长按手势）。
- 父子组件的同类型手势识别器。
- 系统默认手势与自定义手势（如scroll滑动手势与子组件点击手势冲突）。

干预手势处理可有效解决冲突，除控制组件响应热区和命中测试模式外，主要通过以下三种方式：[自定义手势判定](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-gesture-judge#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%8B%E5%8A%BF%E5%88%A4%E5%AE%9A)、[手势并行动态控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-gesture-judge#%E6%89%8B%E5%8A%BF%E5%B9%B6%E8%A1%8C%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6)、[阻止手势参与识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-gesture-judge#%E9%98%BB%E6%AD%A2%E6%89%8B%E5%8A%BF%E5%8F%82%E4%B8%8E%E8%AF%86%E5%88%AB)。

## 自定义手势判定

自定义手势判定是指在系统判定阈值已满足的条件下，应用可自行判断是否应拦截该手势，使该手势识别失败，从而将识别成功的机会留给其他手势。

**图1** 自定义手势判定流程图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164053.23154199449030784997578830712154:50001231000000:2800:476C163B8331C0CB7617BCA03BDAB4D7FC509CA029BD38FCCEFD3BF29D800499.png)

自定义手势判定涉及以下接口。

|**接口**|**说明**|
|:--|:--|
|[onGestureJudgeBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#ongesturejudgebegin)|用于手势拦截，是通用事件。在手势满足系统触发阈值场景下，回调给应用判断是否拦截手势。|
|[onGestureRecognizerJudgeBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin)|用于手势拦截、获取手势识别器和设置手势识别器开闭状态。是onGestureJudgeBegin接口的能力扩展，可以代替onGestureJudgeBegin接口。<br><br>获取手势识别器时，会获取一次交互中手势响应链上的所有手势识别器，以及当前即将触发成功的手势识别器，此时可以设置手势的激活状态。|

以下示例中，Image和Stack两个组件位于同一区域。长按Stack组件的上半部分可触发挂载在Stack组件上的长按手势，长按Stack组件的下半部分则会响应Image组件的拖拽操作。

**图2** 示例图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164053.41047820710557418122022319565271:50001231000000:2800:20CCA29EBB5C26214110DED31874C4767372D055934C3BD572D55E1ABCAE8F0C.png)

1. Image组件设置拖拽。
    
    1. Image($r('sys.media.ohos_app_icon'))
    2.   .draggable(true)
    3.   .onDragStart(()=>{
    4.     promptAction.showToast({ message: "Drag 下半区蓝色区域，Image响应" });
    5.   })
    6.   .width('200vp').height('200vp')
    
2. Stack组件设置手势。
    
    1. Stack() {}
    2.   .width('200vp')
    3.   .height('200vp')
    4.   .hitTestBehavior(HitTestMode.Transparent)
    5.   .gesture(GestureGroup(GestureMode.Parallel,
    6.     LongPressGesture()
    7.       .onAction((event: GestureEvent) => {
    8.         promptAction.showToast({ message: "LongPressGesture 长按上半区 红色区域，红色区域响应" });
    9.       })
    10.       .tag("longpress")
    11.   ))
    
3. Stack组件设置拦截。
    
    1. .onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {
    2.   // 如果是长按类型手势，判断点击的位置是否在上半区
    3.   if (gestureInfo.type == GestureControl.GestureType.LONG_PRESS_GESTURE) {
    4.     if (event.fingerList.length > 0 && event.fingerList[0].localY < 100) {
    5.       return GestureJudgeResult.CONTINUE;
    6.     } else {
    7.       return GestureJudgeResult.REJECT;
    8.     }
    9.   }
    10.   return GestureJudgeResult.CONTINUE;
    11. })
    
4. 代码完整示例。
    
    1.  import { PromptAction } from '@kit.ArkUI';
    
    2.  @Entry
    3.  @Component
    4.  struct Index {
    5.    scroller: Scroller = new Scroller();
    6.    promptAction: PromptAction = this.getUIContext().getPromptAction();
    
    7.    build() {
    8.      Scroll(this.scroller) {
    9.        Column({ space: 8 }) {
    10.          //  $r('app.string.Drag_instructions') 需要替换为开发者所需的资源文件
    11.          Text($r('app.string.Drag_instructions')).width('100%').fontSize(20).fontColor('0xffdd00')
    12.          Stack({ alignContent: Alignment.Center }) {
    13.            Column() {
    14.              // 模拟上半区和下半区
    15.              Stack().width('200vp').height('100vp').backgroundColor(Color.Gray)
    16.              Stack().width('200vp').height('100vp').backgroundColor(Color.Blue)
    17.            }.width('200vp').height('200vp')
    
    18.            // Stack的下半区是绑定了滑动手势的图像区域。
    19.            //  $r('sys.media.ohos_app_icon') 需要替换为开发者所需的资源文件
    20.            Image($r('sys.media.ohos_app_icon'))
    21.              .draggable(true)
    22.              .onDragStart(() => {
    23.                //  $r('app.string.Allow_dragging_prompt') 需要替换为开发者所需的资源文件
    24.                this.promptAction.showToast({ message: $r('app.string.Allow_dragging_prompt') });
    25.              })
    26.              .width('200vp').height('200vp')
    27.            // Stack的上半区是绑定了长按手势的浮动区域。
    28.            Stack() {
    29.            }
    30.            .width('200vp')
    31.            .height('200vp')
    32.            .hitTestBehavior(HitTestMode.Transparent)
    33.            .gesture(GestureGroup(GestureMode.Parallel,
    34.              LongPressGesture()
    35.                .onAction((event: GestureEvent) => {
    36.                  //  $r('app.string.Stop_dragging_prompt') 需要替换为开发者所需的资源文件
    37.                  this.promptAction.showToast({ message: $r('app.string.Stop_dragging_prompt') });
    38.                })
    39.                .tag('longpress')
    40.            ))
    41.            .onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {
    42.              // 如果是长按类型手势，判断点击的位置是否在上半区
    43.              if (gestureInfo.type == GestureControl.GestureType.LONG_PRESS_GESTURE) {
    44.                if (event.fingerList.length > 0 && event.fingerList[0].localY < 100) {
    45.                  return GestureJudgeResult.CONTINUE;
    46.                } else {
    47.                  return GestureJudgeResult.REJECT;
    48.                }
    49.              };
    50.              return GestureJudgeResult.CONTINUE;
    51.            })
    52.          }.width('100%')
    53.        }.width('100%')
    54.      }
    55.    }
    56.  }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164053.40782800520272708741586127974929:50001231000000:2800:06754C889C40A74CDE51F2A8E470C6D99026E751A7D0EFE118B62966FEF12564.jpg)
    

## 手势并行动态控制

手势并行动态控制指的是手势已经成功识别，但是开发者仍然可以通过调用API接口控制手势回调是否能够响应。

**图3** 手势并行动态控制流程图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164053.75151506308962035742380957663420:50001231000000:2800:20D6017DED6C009B2CB03E00DCE0EB73A0E94DB75FF912F5A9FA438EB240F79E.png)

手势并行动态控制的前提是手势识别成功，如果手势不成功则不会产生手势回调响应。

1. 业务手势作业流：指真正触发UI变化的业务手势，比如使页面滚动的PanGesture，触发点击的TapGesture等。
    
2. 监听手势作业流：指在监听手势运行的过程中，应根据上下文的业务状态变化动态控制手势识别器的开闭，例如判断组件嵌套滚动过程中是否已滑至边缘。这一监听事件可借助一个使用[并行手势绑定方式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-binding#parallelgesture%E5%B9%B6%E8%A1%8C%E6%89%8B%E5%8A%BF%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95)的PanGesture实现，或者采用Touch事件来完成。
    
3. 设置手势并行：此步骤并非必需，典型场景是在嵌套滚动中，设置外部组件的滚动手势与内部的滚动手势并行。
    
4. 动态开闭手势：指通过手势识别器的setEnabled方法，控制手势是否响应用户回调。
    

手势并行动态控制涉及以下接口。

|**接口**|**说明**|
|:--|:--|
|[shouldBuiltInRecognizerParallelWith](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#shouldbuiltinrecognizerparallelwith)|用于设置系统组件内置手势与其他手势并行。|
|[onGestureRecognizerJudgeBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin)|用于手势拦截，获取手势识别器，初始化手势识别器开闭状态。|
|[parallelGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-binding#parallelgesture%E5%B9%B6%E8%A1%8C%E6%89%8B%E5%8A%BF%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95)|可使开发者定义的手势，与比他优先级高的手势并行。|

以下示例是两个Scroll组件的嵌套滚动场景，使用手势控制的api去控制外部组件和内部组件的嵌套滚动联动。

1. 使用shouldBuiltInRecognizerParallelWith接口设置外部Scroll组件的PanGesture手势与内部Scroll组件的PanGesture手势并行。
    
    1. .shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {
    2.   for (let i = 0; i < others.length; i++) {
    3.     let target = others[i].getEventTargetInfo();
    4.     if (target.getId() == "inner" && others[i].isBuiltIn() && others[i].getType() == GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器
    5.       this.currentRecognizer = current; // 保存当前组件的识别器
    6.       this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器
    7.       return others[i]; // 返回和当前手势将要组成并行手势的识别器
    8.     }
    9.   }
    10.   return undefined;
    11. })
    
2. 使用onGestureRecognizerJudgeBegin接口获取到Scroll组件的PanGesture手势识别器，同时根据内外Scroll组件的边界条件，设置内外手势的开闭状态。
    
    1. .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
    2.   let target = current.getEventTargetInfo();
    3.   if (target && target.getId() == "outer" && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
    4.     for (let i = 0; i < others.length; i++) {
    5.       let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;
    6.       if (target instanceof ScrollableTargetInfo && target.getId() == "inner") { // 找到响应链上对应并行的识别器
    7.         let panEvent = event as PanGestureEvent;
    8.         this.childRecognizer.setEnabled(true);
    9.         this.currentRecognizer.setEnabled(false);
    10.         if (target.isEnd()) { // 根据当前组件状态以及移动方向动态控制识别器使能状态
    11.           if (panEvent && panEvent.offsetY < 0) {
    12.             this.childRecognizer.setEnabled(false);
    13.             this.currentRecognizer.setEnabled(true);
    14.           }
    15.         } else if (target.isBegin()) {
    16.           if (panEvent.offsetY > 0) {
    17.             this.childRecognizer.setEnabled(false);
    18.             this.currentRecognizer.setEnabled(true);
    19.           }
    20.         }
    21.       }
    22.     }
    23.   }
    24.   return GestureJudgeResult.CONTINUE;
    25. })
    
3. 设置监听手势，监听Scroll组件状态，动态调整手势开闭状态，控制手势回调是否触发，从而控制Scroll是否滚动。
    
    1. .parallelGesture( // 绑定一个Pan手势作为动态控制器
    2.   PanGesture()
    3.     .onActionUpdate((event: GestureEvent)=>{
    4.       if (this.childRecognizer.getState() != GestureRecognizerState.SUCCESSFUL || this.currentRecognizer.getState() != GestureRecognizerState.SUCCESSFUL) { // 如果识别器状态不是SUCCESSFUL，则不做控制
    5.         return;
    6.       }
    7.       let target = this.childRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
    8.       let currentTarget = this.currentRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
    9.       if (target instanceof ScrollableTargetInfo && currentTarget instanceof ScrollableTargetInfo) {
    10.         this.childRecognizer.setEnabled(true);
    11.         this.currentRecognizer.setEnabled(false);
    12.         if (target.isEnd()) { // 在移动过程中实时根据当前组件状态，控制识别器的开闭状态
    13.           if ((event.offsetY - this.lastOffset) < 0) {
    14.             this.childRecognizer.setEnabled(false);
    15.             if (currentTarget.isEnd()) {
    16.               this.currentRecognizer.setEnabled(false);
    17.             } else {
    18.               this.currentRecognizer.setEnabled(true);
    19.             }
    20.           }
    21.         } else if (target.isBegin()) {
    22.           if ((event.offsetY - this.lastOffset) > 0) {
    23.             this.childRecognizer.setEnabled(false);
    24.             if (currentTarget.isBegin()) {
    25.               this.currentRecognizer.setEnabled(false);
    26.             } else {
    27.               this.currentRecognizer.setEnabled(true);
    28.             }
    29.           }
    30.         }
    31.       }
    32.       this.lastOffset = event.offsetY
    33.   })
    34. )
    
4. 代码完整示例。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct FatherControlChild {
    5.   scroller: Scroller = new Scroller();
    6.   scroller2: Scroller = new Scroller();
    7.   private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    8.   private childRecognizer: GestureRecognizer = new GestureRecognizer();
    9.   private currentRecognizer: GestureRecognizer = new GestureRecognizer();
    10.   private lastOffset: number = 0;
    
    11.   build() {
    12.     Stack({ alignContent: Alignment.TopStart }) {
    13.       Scroll(this.scroller) { // 外部滚动容器
    14.         Column() {
    15.           Text("Scroll Area")
    16.             .width('90%')
    17.             .height(150)
    18.             .backgroundColor(0xFFFFFF)
    19.             .borderRadius(15)
    20.             .fontSize(16)
    21.             .textAlign(TextAlign.Center)
    22.             .margin({ top: 10 })
    23.           Scroll(this.scroller2) { // 内部滚动容器
    24.             Column() {
    25.               Text("Scroll Area2")
    26.                 .width('90%')
    27.                 .height(150)
    28.                 .backgroundColor(0xFFFFFF)
    29.                 .borderRadius(15)
    30.                 .fontSize(16)
    31.                 .textAlign(TextAlign.Center)
    32.                 .margin({ top: 10 })
    33.               Column() {
    34.                 ForEach(this.arr, (item: number) => {
    35.                   Text(item.toString())
    36.                     .width('90%')
    37.                     .height(150)
    38.                     .backgroundColor(0xFFFFFF)
    39.                     .borderRadius(15)
    40.                     .fontSize(16)
    41.                     .textAlign(TextAlign.Center)
    42.                     .margin({ top: 10 })
    43.                 }, (item: string) => item)
    44.               }.width('100%')
    45.             }
    46.           }
    47.           .id("inner")
    48.           .width('100%')
    49.           .height(800)
    50.         }.width('100%')
    51.       }
    52.       .id("outer")
    53.       .height(600)
    54.       .scrollable(ScrollDirection.Vertical) // 滚动方向纵向
    55.       .scrollBar(BarState.On) // 滚动条常驻显示
    56.       .scrollBarColor(Color.Gray) // 滚动条颜色
    57.       .scrollBarWidth(10) // 滚动条宽度
    58.       .edgeEffect(EdgeEffect.None)
    59.       .shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {
    60.         for (let i = 0; i < others.length; i++) {
    61.           let target = others[i].getEventTargetInfo();
    62.           if (target.getId() == "inner" && others[i].isBuiltIn() &&
    63.             others[i].getType() == GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器
    64.             this.currentRecognizer = current; // 保存当前组件的识别器
    65.             this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器
    66.             return others[i]; // 返回和当前手势将要组成并行手势的识别器
    67.           }
    68.         }
    69.         return undefined;
    70.       })
    71.       .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer,
    72.         others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
    73.         let target = current.getEventTargetInfo();
    74.         if (target && target.getId() == "outer" && current.isBuiltIn() &&
    75.           current.getType() == GestureControl.GestureType.PAN_GESTURE) {
    76.           for (let i = 0; i < others.length; i++) {
    77.             let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;
    78.             if (target instanceof ScrollableTargetInfo && target.getId() == "inner") { // 找到响应链上对应并行的识别器
    79.               let panEvent = event as PanGestureEvent;
    80.               this.childRecognizer.setEnabled(true);
    81.               this.currentRecognizer.setEnabled(false);
    82.               if (target.isEnd()) { // 根据当前组件状态以及移动方向动态控制识别器使能状态
    83.                 if (panEvent && panEvent.offsetY < 0) {
    84.                   this.childRecognizer.setEnabled(false);
    85.                   this.currentRecognizer.setEnabled(true);
    86.                 }
    87.               } else if (target.isBegin()) {
    88.                 if (panEvent.offsetY > 0) {
    89.                   this.childRecognizer.setEnabled(false);
    90.                   this.currentRecognizer.setEnabled(true);
    91.                 }
    92.               }
    93.             }
    94.           }
    95.         }
    96.         return GestureJudgeResult.CONTINUE;
    97.       })
    98.       .parallelGesture( // 绑定一个Pan手势作为动态控制器
    99.         PanGesture()
    100.           .onActionUpdate((event: GestureEvent) => {
    101.             if (this.childRecognizer?.getState() != GestureRecognizerState.SUCCESSFUL ||
    102.               this.currentRecognizer?.getState() != GestureRecognizerState.SUCCESSFUL) { // 如果识别器状态不是SUCCESSFUL，则不做控制
    103.               return;
    104.             }
    105.             let target = this.childRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
    106.             let currentTarget = this.currentRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
    107.             if (target instanceof ScrollableTargetInfo && currentTarget instanceof ScrollableTargetInfo) {
    108.               this.childRecognizer.setEnabled(true);
    109.               this.currentRecognizer.setEnabled(false);
    110.               if (target.isEnd()) { // 在移动过程中实时根据当前组件状态，控制识别器的开闭状态
    111.                 if ((event.offsetY - this.lastOffset) < 0) {
    112.                   this.childRecognizer.setEnabled(false);
    113.                   if (currentTarget.isEnd()) {
    114.                     this.currentRecognizer.setEnabled(false);
    115.                   } else {
    116.                     this.currentRecognizer.setEnabled(true);
    117.                   }
    118.                 }
    119.               } else if (target.isBegin()) {
    120.                 if ((event.offsetY - this.lastOffset) > 0) {
    121.                   this.childRecognizer.setEnabled(false)
    122.                   if (currentTarget.isBegin()) {
    123.                     this.currentRecognizer.setEnabled(false);
    124.                   } else {
    125.                     this.currentRecognizer.setEnabled(true);
    126.                   }
    127.                 }
    128.               }
    129.             }
    130.             this.lastOffset = event.offsetY;
    131.           })
    132.       )
    133.     }.width('100%').height('100%').backgroundColor(0xDCDCDC)
    134.   }
    135. }
    

## 阻止手势参与识别

手势识别基于[触摸测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-basic-principles#%E8%A7%A6%E6%91%B8%E6%B5%8B%E8%AF%95)的响应链结果进行，因此在用户按下时，通过控制响应链中手势识别器的参与状态，实现高效的动态干预手势处理。

从API version 20开始，可以结合[onTouchTestDone](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ontouchtestdone20)接口来阻止手势参与识别。完成触摸测试后，系统通过该接口回调返回所有手势识别器对象。应用可根据类型、组件标识或关联组件信息筛选识别器，并通过调用[preventBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-common#preventbegin20)接口主动禁用特定识别器。

根据手势类型进行禁用：

1.   .onTouchTestDone((event, recognizers) => {
2.     for (let i = 0; i < recognizers.length; i++) {
3.       let recognizer = recognizers[i];
4.       // 根据类型禁用所有滑动手势
5.       if (recognizer.getType() == GestureControl.GestureType.PAN_GESTURE) {
6.         recognizer.preventBegin();
7.       }
8.     }
9.   })

根据手势所归属的组件禁用：

组件需要提前通过通用属性[id](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-component-id#id)配置组件标识。

1.   .onTouchTestDone((event, recognizers) => {
2.     for (let i = 0; i < recognizers.length; i++) {
3.       let recognizer = recognizers[i];
4.       // 禁用掉标识为myID的组件上的所有手势
5.       if (recognizer.getEventTargetInfo().getId() == "myID") {
6.         recognizer.preventBegin();
7.       }
8.     }
9.   })

根据是否系统内置手势禁用：

1.   .onTouchTestDone((event, recognizers) => {
2.     for (let i = 0; i < recognizers.length; i++) {
3.       let recognizer = recognizers[i];
4.       // 禁用掉所有系统内置的手势
5.       if (recognizer.isBuiltIn()) {
6.         recognizer.preventBegin();
7.       }
8.     }
9.   })

根据具体情况组合使用这些条件。

说明

系统由内向外执行节点上的onTouchTestDone回调。

在NDK中onTouchTestDone与preventBegin对应的接口分别为[OH_ArkUI_SetTouchTestDoneCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-gesture-h#oh_arkui_settouchtestdonecallback)和[OH_ArkUI_PreventGestureRecognizerBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-gesture-h#oh_arkui_preventgesturerecognizerbegin)，它们的使用方式及功能与ArkTS接口一致。

以下通过一个简化的视频播放界面交互为例来说明具体的用法：

父容器（video_layer）绑定了多种手势：

- 点击：控制暂停/播放。
- 双击：切换全屏。
- 长按：快进。
- 上下滑动：调节亮度。
- 左右滑动：调整进度。

其内部下方的Slider组件（progress_layer）未绑定长按手势，导致用户长按Slider时会触发父容器的快进手势，不符合预期。

解决方案：在Slider上注册onTouchTestDone回调，通过该回调禁用非Slider组件的手势识别器，即可解决冲突。

以下为完整示例代码：

1. @Entry
2. @ComponentV2
3. struct Index {
4.   @Local progress: number = 496000; // 初始进度，秒
5.   @Local total: number = 27490000; // 总时长，秒
6.   @Local currentWidth: string = '100%';
7.   @Local currentHeight: string = '100%';
8.   private currentPosX: number = 0;
9.   private currentPosY: number = 0;
10.   private currentFullScreenState: boolean = true;
11.   private normalPlayTimer: number = -1;
12.   private isPlaying: boolean = true;
13.   private fastForwardTimer: number = -1;
14.   private context = this.getUIContext().getHostContext()

15.   aboutToAppear(): void {
16.     // 启动一个周期性定时器每隔一秒刷新一次进度
17.     this.startNormalPlayTimer();
18.   };

19.   startNormalPlayTimer(): void {
20.     if (this.normalPlayTimer != -1) {
21.       this.stopNormalPlayTimer()
22.     };
23.     this.normalPlayTimer = setInterval(() => {
24.       this.progress = this.progress + 1000
25.     }, 1000);
26.   };

27.   stopNormalPlayTimer(): void {
28.     if (this.normalPlayTimer == -1) {
29.       return;
30.     };
31.     clearInterval(this.normalPlayTimer);
32.     this.normalPlayTimer = -1;
33.   };

34.   startFastForwardTimer(): void {
35.     if (this.fastForwardTimer != -1) {
36.       this.stopFastForwardTimer();
37.     };
38.     this.fastForwardTimer = setInterval(() => {
39.       this.progress = this.progress + 100000;
40.     }, 100);
41.   };

42.   stopFastForwardTimer(): void {
43.     if (this.fastForwardTimer == -1) {
44.       return;
45.     };
46.     clearInterval(this.fastForwardTimer);
47.     this.fastForwardTimer = -1;
48.   };

49.   showMessage(message: string): void {
50.     this.getUIContext().getPromptAction().showToast({ message: message, alignment: Alignment.Center });
51.   };

52.   resetPosInfo(): void {
53.     this.currentPosX = 0;
54.     this.currentPosY = 0;
55.   };

56.   toggleFullScreenState(): void {
57.     this.currentFullScreenState = !this.currentFullScreenState;
58.     if (this.currentFullScreenState) {
59.       this.currentWidth = '100%';
60.       this.currentHeight = '100%';
61.     } else {
62.       this.currentWidth = '100%';
63.       this.currentHeight = '50%';
64.     };
65.     //  $r('app.string.Play_full_screen') 需要替换为开发者所需的资源文件
66.     //  $r('app.string.Exit_play_full_screen') 需要替换为开发者所需的资源文件
67.     this.showMessage(this.currentFullScreenState
68.       ? this.context!.resourceManager.getStringSync($r('app.string.Play_full_screen').id)
69.       : this.context!.resourceManager.getStringSync($r('app.string.Exit_play_full_screen').id));
70.   };

71.   togglePlayAndPause(): void {
72.     this.isPlaying = !this.isPlaying;
73.     if (!this.isPlaying) {
74.       this.stopNormalPlayTimer();
75.     } else {
76.       // 重新启动
77.       this.startNormalPlayTimer();
78.     };
79.     //  $r('app.string.stop_playing') 需要替换为开发者所需的资源文件
80.     //  $r('app.string.Continue_playing') 需要替换为开发者所需的资源文件
81.     this.showMessage(this.isPlaying
82.       ? this.context!.resourceManager.getStringSync($r('app.string.stop_playing').id)
83.       : this.context!.resourceManager.getStringSync($r('app.string.Continue_playing').id));
84.   };

85.   doFastForward(start: boolean): void {
86.     if (!start) { // 停止快进，恢复正常播放
87.       this.stopFastForwardTimer();
88.       this.startNormalPlayTimer();
89.       //  $r('app.string.Cancel_FastForwarding') 需要替换为开发者所需的资源文件
90.       this.showMessage(
91.         this.context!.resourceManager.getStringSync($r('app.string.Cancel_FastForwarding').id));
92.       return;
93.     };

94.     this.stopNormalPlayTimer();
95.     this.startFastForwardTimer();
96.     //  $r('app.string.Start_FastForwarding') 需要替换为开发者所需的资源文件
97.     this.showMessage(
98.       this.context!.resourceManager.getStringSync($r('app.string.Start_FastForwarding').id));
99.   };

100.   updateBrightness(start: boolean, event: BaseGestureEvent): void {
101.     let newY = event.fingerList[0].localY;
102.     if (start) {
103.       this.currentPosY = newY;
104.       //  $r('app.string.Start_adjusting_brightness') 需要替换为开发者所需的资源文件
105.       this.showMessage(this.context!.resourceManager
106.         .getStringSync($r('app.string.Start_adjusting_brightness').id));
107.       return;
108.     };
109.     let offsetY = newY - this.currentPosY;
110.     if (Math.abs(offsetY) > 10) {
111.       //  $r('app.string.Reduce_brightness') 需要替换为开发者所需的资源文件
112.       //  $r('app.string.Increase_brightness') 需要替换为开发者所需的资源文件
113.       this.showMessage((offsetY > 0)
114.         ? this.context!.resourceManager.getStringSync($r('app.string.Reduce_brightness').id)
115.         : this.context!.resourceManager.getStringSync($r('app.string.Increase_brightness').id))
116.       this.currentPosY = newY;
117.     };
118.   };

119.   updateProgress(start: boolean, event: BaseGestureEvent): void {
120.     let newX = event.fingerList[0].localX;
121.     if (start) {
122.       this.currentPosX = newX;
123.       //  $r('app.string.Adjust_schedule') 需要替换为开发者所需的资源文件
124.       this.showMessage(this.context!.resourceManager
125.         .getStringSync($r('app.string.Adjust_schedule').id));
126.       return;
127.     };
128.     let offsetX = newX - this.currentPosX;
129.     this.progress = Math.floor(this.progress + offsetX * 10000);
130.     this.currentPosX = newX;
131.   };

132.   build() {
133.     Stack({ alignContent: Alignment.Center }) {
134.       Column() {
135.         Column() {
136.           //  $r('app.string.Playback_progress') 需要替换为开发者所需的资源文件
137.           Text(this.context!.resourceManager.getStringSync($r('app.string.Playback_progress').id) + this.progress)
138.         }
139.         .width('100%').height('90%')

140.         Flex({ alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {
141.           Slider({
142.             value: this.progress,
143.             min: 0,
144.             max: this.total,
145.             style: SliderStyle.OutSet
146.           })
147.             .onChange((value: number, mode: SliderChangeMode) => {
148.               this.progress = value;
149.             })
150.             .id('progress_layer')
151.             .onTouchTestDone((event, allRecognizers: Array<GestureRecognizer>) => {
152.               for (let i = 0; i < allRecognizers.length; i++) {
153.                 let recognizer = allRecognizers[i];
154.                 let inspectorInfo = recognizer.getEventTargetInfo().getId();
155.                 if (inspectorInfo !== 'progress_layer') {
156.                   // 用户操作到进度条区域时，禁用掉所有非progress_layer上的手势
157.                   recognizer.preventBegin();
158.                 };
159.               };
160.             })
161.             .margin({ left: 5 })
162.             .trackColor(Color.Blue)
163.             .blockColor(Color.Gray)
164.             .selectedColor(Color.White)
165.             .trackThickness(2)
166.             .flexShrink(1)
167.             .flexGrow(1)
168.         }
169.         .flexGrow(1)
170.         .flexShrink(1)
171.         .id('id_progress_view')
172.       }
173.     }
174.     .id('video_layer')
175.     .backgroundColor('#E0E0E0')
176.     .gesture(
177.       GestureGroup(GestureMode.Exclusive,
178.         PanGesture({ direction: PanDirection.Vertical, distance: 10 })
179.           .tag('pan_for_brightness_control')
180.           .onActionStart((event) => {
181.             this.updateBrightness(true, event);
182.           })
183.           .onActionUpdate((event) => {
184.             this.updateBrightness(false, event);
185.           }),
186.         PanGesture({ direction: PanDirection.Horizontal, distance: 10 })
187.           .tag('pan_for_play_progress_control')
188.           .onActionStart((event) => {
189.             this.updateProgress(true, event);
190.           })
191.           .onActionUpdate((event) => {
192.             this.updateProgress(false, event);
193.           }),

194.         LongPressGesture()
195.           .tag('long_press_for_fast_forward_control')
196.           .onAction(() => {
197.             this.doFastForward(true); // 开始快进
198.           })
199.           .onActionEnd(() => {
200.             this.doFastForward(false); // 停止快进
201.           })
202.           .onActionCancel(() => {
203.             this.doFastForward(false);
204.           }),

205.         TapGesture({ count: 2 })
206.           .tag('double_tap_on_video')
207.           .onAction(() => {
208.             this.toggleFullScreenState();
209.           }),

210.         TapGesture()
211.           .tag('single_tap_on_video')
212.           .onAction(() => {
213.             this.togglePlayAndPause();
214.           })
215.       )
216.     )
217.     .width(this.currentWidth)
218.     .height(this.currentHeight)
219.   }
220. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164053.77261197578881348678770409308348:50001231000000:2800:F43BD28B52B3E267588CBA75132D07CDB8BB7679C25673307825818217E2557A.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-multi-level-gesture "多层级手势事件")
# 支持焦点处理

更新时间: 2025-12-16 16:40

## 基础概念与规范

### 基础概念

**焦点、焦点链和走焦**

- 焦点：指向当前应用界面上唯一的一个可交互元素，当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入设备与应用程序进行间接交互时，基于焦点的导航和交互是重要的输入手段。
- 焦点链：在应用的组件树形结构中，当一个组件获得焦点时，从根节点到该组件节点的整条路径上的所有节点都会处于焦点状态，形成一条连续的焦点链。
- 走焦：指焦点在应用内的组件之间转移的行为。这一过程对用户是透明的，但开发者可以通过监听onFocus（焦点获取）和onBlur（焦点失去）事件来捕捉这些变化。关于走焦的具体方式和规则，详见[走焦规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)。

**焦点激活态**

焦点激活态是用来显示当前获焦组件焦点框的视觉样式。

- 显示规则
    
    - 默认状态：焦点激活态默认是隐藏的。
    - 激活条件：只有当应用程序进入"激活态"时，焦点激活态才会显示。
    - 重要关系：
        - 获得焦点的组件不一定显示激活态（取决于应用是否处于激活态）。
        - 显示激活态的组件必定是当前获得焦点的组件。
    - 样式定制：组件通常有内置的激活态样式，开发者可以通过样式接口自定义，自定义后会覆盖默认样式。
    - 显示优先级：当多个组件同时拥有焦点时，系统优先显示子组件的激活态，且同一时间只显示一个激活态。
- 如何进入激活态
    
    - 按下外接键盘的Tab键（注意：首次激活时的Tab键仅用于激活，不会触发焦点移动）。
    - 调用[FocusController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller)的activate(true)方法。
- 如何退出激活态
    
    - 调用FocusController的activate(false)方法。
    - 发生点击事件时（包括触屏点击或鼠标左键点击）。

1. @Entry
2. @Component
3. struct FocusActiveExample {
4.   build() {
5.     Column() {
6.       Button('Set Active').width(140).height(45).margin(5).onClick(() => {
7.         this.getUIContext().getFocusController().activate(true, true);
8.       })
9.       Button('Set Not Active').width(140).height(45).margin(5).onClick(() => {
10.         this.getUIContext().getFocusController().activate(false, true);
11.       })
12.     }.width('100%')
13.   }
14. }

按下Tab键，焦点激活态显示。点击鼠标退出焦点激活态。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.87842322685467604801662793724140:50001231000000:2800:F79231A05F00351B00E30E0E178E821E7B61603CF2446DF97F7B7044B73F16AF.gif)

调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口进入和退出焦点激活态。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.56410181471804487464553871116694:50001231000000:2800:B9AF31DF6E88F1EF74E19E6C5C4AC404F63960C550E3B870F0FF0479990817D0.gif)

示例操作步骤：

1. 点击Set Active按钮，调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口进入焦点激活态。
2. Tab走焦至Set Not Active按钮，Enter键触发按键事件，调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口退出焦点激活态。

**层级页面**

层级页面是焦点框架中特定容器组件的统称，涵盖Page、Dialog、SheetPage、ModalPage、Menu、Popup、NavBar、NavDestination等。这些组件通常具有以下关键特性：

- 视觉层级独立性：从视觉呈现上看，这些组件独立于其他页面内容，并通常位于其上方，形成视觉上的层级差异。
- 焦点跟随：此类组件在首次创建并展示之后，会立即将应用内焦点抢占。
- 走焦范围限制：当焦点位于这些组件内部时，用户无法通过键盘按键将焦点转移到组件外部的其他元素上，焦点移动仅限于组件内部。

在一个应用程序中，任何时候都至少存在一个层级页面组件，并且该组件会持有当前焦点。当该层级页面关闭或不再可见时，焦点会自动转移到下一个可用的层级页面组件上，确保用户交互的连贯性和一致性。

说明

Popup组件在focusable属性（组件属性，非通用属性）为false的时候，不会有第2条特性。

NavBar、NavDestination没有第3条特性，对于它们的走焦范围，是与它们的首个父层级页面相同的。

**根容器**

根容器是[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)内的概念，当某个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次创建并展示时，根据[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的特性，焦点会立即被该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)抢占。此时，该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)所在焦点链的末端节点将成为默认焦点，而这个默认焦点通常位于该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的根容器上。

在缺省状态下，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的默认焦点位于其根容器上，但开发者可以通过defaultFocus属性来自定义这一行为。

当焦点位于根容器时，首次按下Tab键不仅会使焦点进入激活状态，还会根据[焦点传递规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E7%84%A6%E7%82%B9%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99)进行传递。

### 焦点传递规则

焦点传递是指当用户首次激活应用焦点系统时，焦点如何从根节点逐级向下传递到具体组件的过程。

在焦点链上的组件，都会处于获焦状态。同时组件在获焦时，会继续向下递归传递获焦状态，每次传递给第一个子组件，直到叶子节点。

1. @Entry
2. struct Index {
3.   @State logText: string = '\n';

4.   addText(message: string) {
5.     this.logText += `${message}\n`;
6.   }

7.   build() {
8.     Column() {
9.       Row() {
10.         Column() {
11.           Button("Button 1")
12.             .margin(20)
13.             .onClick(() => {
14.               this.logText = '获焦信息：\n';
15.               this.getUIContext().getFocusController().requestFocus("Row 2")
16.             })
17.         }
18.       }

19.       Column() {
20.         Row() {
21.           Button("Button 2")
22.             .margin(20)
23.             .onFocus(() => {
24.               this.addText("Button 2 获得焦点");
25.             })
26.           Button("button 3")
27.             .margin(20)
28.             .onFocus(() => {
29.               this.addText("Button 3 获得焦点");
30.             })
31.         }
32.         .id("Row 2")
33.         .onFocus(() => {
34.           this.addText("Row 2 获得焦点");
35.         })
36.       }
37.       .onFocus(() => {
38.         this.addText("Column 2 获得焦点");
39.       })

40.       Scroll() {
41.         Text(this.logText)
42.           .fontSize(14)
43.           .textAlign(TextAlign.Start)
44.           .padding(10)
45.       }
46.       .height('40%')
47.       .width('100%')
48.       .border({ width: 1, color: '#ccc' })
49.       .margin(10)
50.     }
51.     .height('100%')
52.     .padding(20)
53.   }
54. }

运行后点击Button1，请求焦点给Row组件，Row组件的第一个可获焦子节点Button2获焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.33657945635981072347038409626891:50001231000000:2800:4AF361753D70D731C596C35F5ADA25F3A0DD33C8F2AF8B41A1F3F1AA8DAB5261.gif)

### 走焦规范

根据走焦的触发方式，可以分为主动走焦和被动走焦。

**主动走焦**

指开发者/用户主观行为导致的焦点移动，包括：使用外接键盘的按键走焦（Tab键/Shift+Tab键/方向键）、使用requestFocus申请焦点、clearFocus清除焦点、focusOnTouch点击申请焦点等接口导致的焦点转移。

- 按键走焦

1. 前提：当前应用需处于焦点激活态。
2. 范围限制：按键走焦仅在当前获得焦点的层级页面内进行，具体参见“层级页面”中的“走焦范围限制”部分。
3. 按键类型：
    
    Tab键：遵循Z字型遍历逻辑，完成当前范围内所有叶子节点的遍历，到达当前范围内的最后一个组件后，继续按下Tab键，焦点将循环至范围内的第一个可获焦组件，实现循环走焦。
    
    Shift+Tab键：与Tab键具有相反的焦点转移效果。
    
    方向键（上、下、左、右）：遵循十字型移动策略，在单层容器中，焦点的转移由该容器的特定走焦算法决定。若算法判定下一个焦点应落在某个容器组件上，系统将采用中心点距离优先的算法来进一步确定容器内的目标子节点。
    
4. 走焦算法：每个可获焦的容器组件都有其特定的走焦算法，用于定义焦点转移的规则。
5. 子组件优先：当子组件处理按键走焦事件，父组件将不再介入。

- requestFocus
    
    详见[主动获焦失焦](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E4%B8%BB%E5%8A%A8%E8%8E%B7%E7%84%A6%E5%A4%B1%E7%84%A6)，可以主动将焦点转移到指定组件上。
    
    不可跨窗口或跨ArkUI实例申请焦点，但可以跨层级页面申请焦点。
    
- clearFocus
    
    详见[clearFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#clearfocus12)，会清除当前层级页面中的焦点，最终焦点停留在根容器上。
    
- focusOnTouch
    
    详见[focusOnTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focusontouch9)，使绑定组件具备点击后获得焦点的能力。若组件本身不可获焦，则此功能无效。若绑定的是容器组件，点击后优先将焦点转移给上一次获焦的子组件，否则转移给第一个可获焦的子组件。
    

**被动走焦**

被动走焦是指组件焦点因系统或其他操作而自动转移，无需开发者直接干预，这是焦点系统的默认行为。

目前会被动走焦的机制有：

- 组件删除：当处于焦点状态的组件被删除时，焦点框架首先尝试将焦点转移到相邻的兄弟组件上，遵循先向后再向前的顺序。若所有兄弟组件均不可获焦，则焦点将释放，并通知其父组件进行焦点处理。
- 属性变更：若将处于焦点状态的组件的focusable或enabled属性设置为false，或者将visibility属性设置为不可见，系统将自动转移焦点至其他可获焦组件，转移方式与1中相同。
- [层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换：当发生[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换时，如从一个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)跳转到另一个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)，当前[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的焦点将自动释放，新[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)可能会根据预设逻辑自动获得焦点。
- Web组件初始化：对于Web组件，当其被创建时，若其设计需要立即获得焦点（如某些弹出框或输入框），则可能触发焦点转移至该Web组件，其行为属于组件自身的行为逻辑，不属于焦点框架的规格范围。

### 走焦算法

在焦点管理系统中，每个可获焦的容器都配备有特定的走焦算法，这些算法定义了当使用Tab键、Shift+Tab键或方向键时，焦点如何从当前获焦的子组件转移到下一个可获焦的子组件。

容器采用何种走焦算法取决于其UX（用户体验）规格，并由容器组件进行适配。目前，焦点框架支持三种走焦算法：线性走焦、投影走焦和自定义走焦。

**线性走焦算法**

线性走焦算法是默认的走焦策略，它基于容器中子节点在节点树中的挂载顺序进行走焦，常用于单方向布局的容器，如Row、Column和Flex容器。运行规则如下：

- 顺序依赖：走焦顺序完全基于子节点在节点树中的挂载顺序，与它们在界面上的实际布局位置无关。
- Tab键走焦：使用Tab键时，焦点将按照子节点的挂载顺序依次遍历。
- 方向键走焦：当使用与容器定义方向垂直的方向键时，容器不接受该方向的走焦请求。例如，在横向的Row容器中，无法使用方向键进行上下移动。
- 边界处理：当焦点位于容器的首尾子节点时，容器将拒绝与当前焦点方向相反的方向键走焦请求。例如，焦点在一个横向的Row容器的第一个子节点上时，该容器无法处理方向键左的走焦请求。

1. @Entry
2. @Component
3. struct FocusLinerExample {
4.   build() {
5.     Column() {
6.       Column() {
7.         Button("Column Button1")
8.           .width(150)
9.           .height(45)
10.           .fontColor(Color.White)
11.           .margin(10)
12.         Button("Column Button2")
13.           .width(150)
14.           .height(45)
15.           .fontColor(Color.White)
16.           .margin(10)
17.       }
18.       .margin(10)

19.       Row() {
20.         Button("Row Button1")
21.           .width(150)
22.           .height(45)
23.           .fontColor(Color.White)
24.           .margin(10)
25.         Button("Row Button2")
26.           .width(150)
27.           .height(45)
28.           .fontColor(Color.White)
29.           .margin(10)
30.       }
31.     }
32.   }
33. }

Tab键走焦：按照子节点的挂载顺序循环走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.67763606112505332746852831470376:50001231000000:2800:3474F13A44F978CEDACCDCDEFADB731AE35151ADF818AC223554A3A1C20AA57F.gif)

方向键上下走焦：纵向的Column容器中，可以使用上下键走焦，无法使用左右键走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.65394565649527609025701911760515:50001231000000:2800:B6FDAA2D053B02C6A05B0C18A76E9DA9F17CCC3B2937E582FCFBB48305BE228E.gif)

横向的Row容器中，可以使用左右键走焦，无法使用上下键走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.13418426341066464548754278051935:50001231000000:2800:4C09B3DCA4983F4AA999C84552394346370C3ED04C8699F1B6324034F575302C.gif)

**投影走焦算法**

投影走焦算法基于当前获焦组件在走焦方向上的投影，结合子组件与投影的重叠面积和中心点距离进行胜出判定。该算法适用于子组件大小不一的容器，目前仅支持配置了wrap属性的Flex组件。运行规则如下：

- 方向键走焦时，判断投影与子组件区域的重叠面积，在所有面积不为0的子组件中，计算它们与当前获焦组件的中心点直线距离，选择距离最短的子组件。若存在多个备选子组件，则选择节点树上更靠前的子组件。若无任何子组件与投影有重叠，说明该容器无法处理该方向键的走焦请求。
- Tab键走焦时，先使用规格1，按照方向键右进行判定，若找到则成功退出，若无法找到，则将当前获焦子组件的位置模拟往下移动该获焦子组件的高度，然后再按照方向键左进行投影判定，有投影重叠且中心点直线距离最近的子组件胜出，若无投影重叠的子组件，则表示该容器无法处理本次Tab键走焦请求。
- Shift+Tab键走焦时，先使用规格1，按照方向键左进行判定，找到则成功退出。若无法找到，则将当前获焦子组件的位置模拟向上移动该获焦子组件的高度，然后再按照方向键右进行投影判定，有投影重叠且中心点直线距离最近的子组件胜出，若无投影重叠的子组件，则表示该容器无法处理本次的Shift+Tab键走焦请求。

1. @Entry
2. @Component
3. struct ProjectAreaFocusExample {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Text('Wrap').fontSize(12).width('90%')
8.         // 子组件多行布局
9.         Flex({ wrap: FlexWrap.Wrap }) {
10.           Button('1').width(140).height(50).margin(5)
11.           Button('2').width(140).height(50).margin(5)
12.           Button('3').width(140).height(50).margin(5)
13.           Button('4').width(140).height(50).margin(5)
14.           Button('5').width(140).height(50).margin(5)
15.         }
16.         .width('90%')
17.         .padding(10)
18.       }.width('100%').margin({ top: 5 })
19.     }.width('100%')
20.   }
21. }

说明

- 这种投影聚焦算法计算的聚焦顺序与组件布局和大小密切相关，建议在组件排列非常规整的场景下使用。如果组件大小不一且存在横向或纵向的交叠关系，则可能会导致聚焦顺序与开发者预期不符。
- 如果开发者希望有明确的走焦顺序，建议使用Column/Row等顺序走焦的容器实现。

Flex多行组件布局，组件大小一致，走焦正常。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.97476089624538307657888383026394:50001231000000:2800:DED494A5A38A8F155D95C336140627D6B270BC2C59AFDC2B7C5F9699DBDE2818.gif)

1. @Entry
2. @Component
3. struct ProjectAreaFocusExample2 {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Text('Wrap').fontSize(12).width('90%')
8.         // 子组件多行布局
9.         Flex({ wrap: FlexWrap.Wrap }) {
10.           Button('1').width(145).height(50).margin(5)
11.           Button('2').width(145).height(50).margin(5)
12.           Button('3').width(150).height(50).margin(5)
13.           Button('4').width(160).height(50).margin(5)
14.           Button('5').width(170).height(50).margin(5)
15.         }
16.         .width('90%')
17.         .padding(10)
18.       }.width('100%').margin({ top: 5 })
19.     }.width('100%')
20.   }
21. }

Flex多行组件布局，组件大小不一且有纵向的交叠关系，无法Tab走焦至下方4、5按钮组件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.76783338379593373741134037318032:50001231000000:2800:ACD5D9ED55A0F0DBEFE0ED4BD2428B297A9DD958EFC0ADCBEEA7F7B4E3D12BDD.gif)

**自定义走焦算法**

由组件自定义的走焦算法，规格由组件定义。

## 获焦/失焦事件

1. onFocus(event: () => void)

获焦事件回调，绑定该接口的组件获焦时，回调响应。

1. onBlur(event:() => void)

失焦事件回调，绑定该接口的组件失焦时，回调响应。

onFocus和onBlur两个接口通常成对使用，来监听组件的焦点变化。

1. // xxx.ets
2. @Entry
3. @Component
4. struct FocusEventExample {
5.   @State oneButtonColor: Color = Color.Gray;
6.   @State twoButtonColor: Color = Color.Gray;
7.   @State threeButtonColor: Color = Color.Gray;

8.   build() {
9.     Column({ space: 20 }) {
10.       // 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
11.       Button('First Button')
12.         .width(260)
13.         .height(70)
14.         .backgroundColor(this.oneButtonColor)
15.         .fontColor(Color.Black)
16.           // 监听第一个组件的获焦事件，获焦后改变颜色
17.         .onFocus(() => {
18.           this.oneButtonColor = Color.Green;
19.         })
20.           // 监听第一个组件的失焦事件，失焦后改变颜色
21.         .onBlur(() => {
22.           this.oneButtonColor = Color.Gray;
23.         })

24.       Button('Second Button')
25.         .width(260)
26.         .height(70)
27.         .backgroundColor(this.twoButtonColor)
28.         .fontColor(Color.Black)
29.           // 监听第二个组件的获焦事件，获焦后改变颜色
30.         .onFocus(() => {
31.           this.twoButtonColor = Color.Green;
32.         })
33.           // 监听第二个组件的失焦事件，失焦后改变颜色
34.         .onBlur(() => {
35.           this.twoButtonColor = Color.Gray;
36.         })

37.       Button('Third Button')
38.         .width(260)
39.         .height(70)
40.         .backgroundColor(this.threeButtonColor)
41.         .fontColor(Color.Black)
42.           // 监听第三个组件的获焦事件，获焦后改变颜色
43.         .onFocus(() => {
44.           this.threeButtonColor = Color.Green;
45.         })
46.           // 监听第三个组件的失焦事件，失焦后改变颜色
47.         .onBlur(() => {
48.           this.threeButtonColor = Color.Gray ;
49.         })
50.     }.width('100%').margin({ top: 20 })
51.   }
52. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.15553965774827401495272683119777:50001231000000:2800:4C730B6DB303EFC9B1445ABBAFCD5615CD7582F11618B01E439F3CC62815B53B.gif)

上述示例包含以下3步：

- 应用打开，按下Tab键激活走焦，“First Button”显示焦点激活态样式：组件外围有一个蓝色的闭合框，onFocus回调响应，背景色变成绿色。
- 按下Tab键，触发走焦，“Second Button”获焦，onFocus回调响应，背景色变成绿色；“First Button”失焦，onBlur回调响应，背景色变回灰色。
- 按下Tab键，触发走焦，“Third Button”获焦，onFocus回调响应，背景色变成绿色；“Second Button”失焦，onBlur回调响应，背景色变回灰色。

父子节点同时存在获焦和失焦事件时，获焦/失焦事件响应顺序为：

父节点Row1失焦 —> 子节点Button1失焦 —> 子节点Button2获焦 —> 父节点Row2获焦。

1. @Entry
2. @Component
3. struct FocusAndBlurExample {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Row() { // 父节点Row1
8.           Button('Button1') // 子节点Button1
9.             .width(140)
10.             .height(45)
11.             .margin(5)
12.             .onFocus(() => {
13.               console.info("Button1 onFocus");
14.             })
15.             .onBlur(() => {
16.               console.info("Button1 onBlur");
17.             })
18.         }
19.         .onFocus(() => {
20.           console.info("Row1 onFocus");
21.         })
22.         .onBlur(() => {
23.           console.info("Row1 onBlur");
24.         })

25.         Row() { // 父节点Row2
26.           Button('Button2') // 子节点Button2
27.             .width(140)
28.             .height(45)
29.             .margin(5)
30.             .onFocus(() => {
31.               console.info("Button2 onFocus");
32.             })
33.             .onBlur(() => {
34.               console.info("Button2 onBlur");
35.             })
36.         }
37.         .onFocus(() => {
38.           console.info("Row2 onFocus");
39.         })
40.         .onBlur(() => {
41.           console.info("Row2 onBlur");
42.         })
43.       }.width('100%').margin({ top: 5 })
44.     }.width('100%')
45.   }
46. }

Button1走焦到Button2，日志打印顺序：

1. Row1 onBlur
2. Button1 onBlur
3. Button2 onFocus
4. Row2 onFocus

## 设置组件是否可获焦

1. focusable(value: boolean)

设置组件是否可获焦。

按照组件的获焦能力可大致分为三类：

- 默认可获焦的组件，通常是有交互行为的组件，例如Button、Checkbox、TextInput组件，此类组件无需设置任何属性，默认即可获焦。
    
- 有获焦能力，但默认不可获焦的组件，典型的是Text、Image组件，此类组件缺省情况下无法获焦，若需要使其获焦，可使用通用属性focusable(true)使能。对于没有配置focusable属性，有获焦能力但默认不可获焦的组件，例如没有可获焦子组件的容器组件，为其配置onClick或是单指单击的Tap手势，该组件会隐式地成为可获焦组件。如果其focusable属性被设置为false，即使配置了上述事件，该组件依然不可获焦。
    
- 无获焦能力的组件，通常是无任何交互行为的展示类组件，例如Blank、Circle组件，此类组件即使使用focusable属性也无法使其可获焦。
    

设置容器组件可获焦：

获焦的主要目的是为了响应用户交互，如果组件不具备交互能力，则其也不会具有可获焦能力。容器组件通常不具备交互能力，因此如果一个容器组件（如Stack、Column）作为叶子节点，即使通过.focusable(true)也无法使其具备可获焦能力。需要注意的是通过动态方式创建的[FrameNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-framenode)节点也受限于这个规则。

如果想让作为叶子节点的容器组件可获焦，可通过以下任一方式实现：

- 在其内添加一个具备获焦能力的叶子节点组件(如button)。
    
- 为其配置onClick、Tap手势等使其能响应点击交互。
    

1. enabled(value: boolean)

设置组件可交互性属性[enabled](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-enable#enabled)为false，则组件不可交互，无法获焦。

1. visibility(value: Visibility)

设置组件可见性属性[visibility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-visibility#visibility)为Visibility.None或Visibility.Hidden，则组件不可见，无法获焦。

1. focusOnTouch(value: boolean)

设置当前组件是否支持点击获焦能力。

说明

当某组件处于获焦状态时，将其的focusable属性或enabled属性设置为false，会自动使该组件失焦，然后焦点按照[走焦规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)将焦点转移给其他组件。

1. // xxx.ets
2. @Entry
3. @Component
4. struct FocusableExample {
5.   @State textFocusable: boolean = true;
6.   @State textEnabled: boolean = true;
7.   @State color1: Color = Color.Yellow;
8.   @State color2: Color = Color.Yellow;
9.   @State color3: Color = Color.Yellow;

10.   build() {
11.     Column({ space: 5 }) {
12.       Text('Default Text')    // 第一个Text组件未设置focusable属性，默认不可获焦
13.         .borderColor(this.color1)
14.         .borderWidth(2)
15.         .width(300)
16.         .height(70)
17.         .onFocus(() => {
18.           this.color1 = Color.Blue;
19.         })
20.         .onBlur(() => {
21.           this.color1 = Color.Yellow;
22.         })
23.       Divider()

24.       Text('focusable: ' + this.textFocusable)    // 第二个Text设置了focusable初始为true，focusableOnTouch为true
25.         .borderColor(this.color2)
26.         .borderWidth(2)
27.         .width(300)
28.         .height(70)
29.         .focusable(this.textFocusable)
30.         .focusOnTouch(true)
31.         .onFocus(() => {
32.           this.color2 = Color.Blue;
33.         })
34.         .onBlur(() => {
35.           this.color2 = Color.Yellow;
36.         })

37.       Text('enabled: ' + this.textEnabled)    // 第三个Text设置了focusable为true，enabled初始为true
38.         .borderColor(this.color3)
39.         .borderWidth(2)
40.         .width(300)
41.         .height(70)
42.         .focusable(true)
43.         .enabled(this.textEnabled)
44.         .focusOnTouch(true)
45.         .onFocus(() => {
46.           this.color3 = Color.Blue;
47.         })
48.         .onBlur(() => {
49.           this.color3 = Color.Yellow;
50.         })

51.       Divider()

52.       Row() {
53.         Button('Button1')
54.           .width(140).height(70)
55.         Button('Button2')
56.           .width(160).height(70)
57.       }

58.       Divider()
59.       Button('Button3')
60.         .width(300).height(70)

61.       Divider()
62.     }.width('100%').justifyContent(FlexAlign.Center)
63.     .onKeyEvent((e) => {
64.       // 绑定onKeyEvent，在该Column组件获焦时，按下'F'键，可将第二个Text的focusable置反
65.       if (e.keyCode === 2022 && e.type === KeyType.Down) {
66.         this.textFocusable = !this.textFocusable;
67.       }
68.       // 绑定onKeyEvent，在该Column组件获焦时，按下'G'键，可将第三个Text的enabled置反
69.       if (e.keyCode === 2023 && e.type === KeyType.Down) {
70.         this.textEnabled = !this.textEnabled;
71.       }
72.     })
73.   }
74. }

运行效果：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.77692462681152263010218841066401:50001231000000:2800:821560F89CE47B89CAC67FE96EA4378D2B6299D4A98A031FF90A35595DE234A7.gif)

上述示例包含以下3步：

- 第一个Text组件没有设置focusable(true)属性，该Text组件无法获焦。
- 点击第二个Text组件，由于设置了focusOnTouch(true)，第二个组件获焦。按下Tab键，触发走焦，仍然是第二个Text组件获焦。按键盘F键，触发onKeyEvent，focusable置为false，第二个Text组件变成不可获焦，焦点自动转移，会自动从Text组件寻找下一个可获焦组件，焦点转移到第三个Text组件上。
- 按键盘G键，触发onKeyEvent，enabled置为false，第三个Text组件变成不可获焦，焦点自动转移，使焦点转移到Row容器上，容器中使用的是默认配置，会转移到Button1上。

## 设置容器绘制焦点框

虽然容器组件本身可以获焦，但是无法绘制焦点框。可以为其配置onClick或是单指单击的Tap手势，在容器上绘制焦点框。

说明

容器绘制焦点框前提：

- 容器内部没有可获焦子节点。
- 容器配置有onClick或是单指单击的Tap手势。
- 容器本身未设置focusable属性，或设置在onClick或是单指单击的Tap手势之后。

1. @Entry
2. @Component
3. struct ScopeFocusExample {
4.   @State scopeFocusState: boolean = true;

5.   build() {
6.     Column() {
7.       Column({ space: 5 }) {
8.         Text("容器获焦").textAlign(TextAlign.Center)
9.       }
10.       .justifyContent(FlexAlign.Center)
11.       .width('80%')
12.       .height(50)
13.       .margin({ top: 5, bottom: 5 })
14.       .onClick(() => {
15.       })
16.       .focusable(this.scopeFocusState)

17.       Button('Button1')
18.         .width(140)
19.         .height(45)
20.         .margin(5)
21.         .onClick(() => {
22.           this.scopeFocusState = !this.scopeFocusState;
23.           console.info("Button1 onFocus");
24.         })
25.       Button('Button2')
26.         .width(140)
27.         .height(45)
28.         .margin(5)
29.     }.width('100%')
30.   }
31. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.61390750096022653274925250777580:50001231000000:2800:17D3AFFFCB1C7407042CFB9E83F2D269ADCF8995E5BC657952414F132BA6A133.gif)

上述示例包含以下2步：

- Column配置onClick事件并设置focusable为true后，Tab键走焦，Column容器可以绘制焦点框。
- 点击Button1，将Column的focusable属性设置为false，Column容器无法获焦和绘制焦点框。

## 设置焦点停留在容器上

1. tabStop(isTabStop: boolean)

设置当前容器组件的[tabStop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#tabstop14)属性，可决定在走焦时焦点是否会停留在当前容器。

1. @Entry
2. @Component
3. struct TabStopExample {
4.   build() {
5.     Column({ space: 20 }) {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5)
10.       Column() {
11.         Button('Button2')
12.           .width(140)
13.           .height(45)
14.           .margin(5)
15.         Button('Button3')
16.           .width(140)
17.           .height(45)
18.           .margin(5)
19.       }.tabStop(true)
20.     }.width('100%')
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.35783033853164192623377862907896:50001231000000:2800:B8ECB4F5993FD2B7F9F16BA17CE1F02135E1AC402720D20A65766F9877607A64.gif)

上述示例包含以下2步：

- Column配置tabStop后，Tab键走焦，焦点在Button1和Column容器之间切换，Column容器可以绘制焦点框。
- 走焦至Column容器后，按Enter键，焦点转移到容器中的第一个可获焦节点上。Tab键走焦，走焦至容器中其他可获焦节点。

## 默认焦点

### 层级页面的默认焦点

1. defaultFocus(value: boolean)

设置当前组件是否为当前[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)上的默认焦点。

1. // xxx.ets
2. @Entry
3. @Component
4. struct DefaultFocus {
5.   @State oneButtonColor: Color = Color.Gray;
6.   @State twoButtonColor: Color = Color.Gray;
7.   @State threeButtonColor: Color = Color.Gray;

8.   build() {
9.     Column({ space: 20 }) {
10.       // 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
11.       Button('First Button')
12.         .width(260)
13.         .height(70)
14.         .backgroundColor(this.oneButtonColor)
15.         .fontColor(Color.Black)
16.           // 监听第一个组件的获焦事件，获焦后改变颜色
17.         .onFocus(() => {
18.           this.oneButtonColor = Color.Green;
19.         })
20.           // 监听第一个组件的失焦事件，失焦后改变颜色
21.         .onBlur(() => {
22.           this.oneButtonColor = Color.Gray;
23.         })

24.       Button('Second Button')
25.         .width(260)
26.         .height(70)
27.         .backgroundColor(this.twoButtonColor)
28.         .fontColor(Color.Black)
29.           // 监听第二个组件的获焦事件，获焦后改变颜色
30.         .onFocus(() => {
31.           this.twoButtonColor = Color.Green;
32.         })
33.           // 监听第二个组件的失焦事件，失焦后改变颜色
34.         .onBlur(() => {
35.           this.twoButtonColor = Color.Gray;
36.         })

37.       Button('Third Button')
38.         .width(260)
39.         .height(70)
40.         .backgroundColor(this.threeButtonColor)
41.         .fontColor(Color.Black)
42.           // 设置默认焦点
43.         .defaultFocus(true)
44.           // 监听第三个组件的获焦事件，获焦后改变颜色
45.         .onFocus(() => {
46.           this.threeButtonColor = Color.Green;
47.         })
48.           // 监听第三个组件的失焦事件，失焦后改变颜色
49.         .onBlur(() => {
50.           this.threeButtonColor = Color.Gray ;
51.         })
52.     }.width('100%').margin({ top: 20 })
53.   }
54. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.11434695702020431751981205129526:50001231000000:2800:322DB4B30F0ED83E3AAA77A335ECA052870AC82530F1B6AC42C7A07A4B6956A8.gif)

上述示例包含以下2步：

- 在第三个Button组件上设置了defaultFocus(true)，进入[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)后第三个Button默认获焦，显示为绿色。
- 按下Tab键，触发走焦，第三个Button正处于获焦状态，会出现焦点框。

### 容器的默认焦点

容器的默认焦点受到[获焦优先级](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E7%84%A6%E7%82%B9%E7%BB%84%E4%B8%8E%E8%8E%B7%E7%84%A6%E4%BC%98%E5%85%88%E7%BA%A7)的影响。

**defaultFocus与FocusPriority的区别**

[defaultFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#defaultfocus9)是用于指定[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次展示时的默认获焦节点，[FocusPriority](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focuspriority12)是用于指定某个容器首次获焦时其子节点的获焦优先级。上述两个属性在某些场景同时配置时行为未定义，例如下面的场景，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次展示无法同时满足defaultFocus获焦和高优先级组件获焦。

示例

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Row() {
6.       Button('Button1')
7.         .defaultFocus(true)
8.       Button('Button2')
9.         .focusScopePriority('RowScope', FocusPriority.PREVIOUS)
10.     }.focusScopeId('RowScope')
11.   }
12. }

### 层级页面/容器整体获焦时的焦点链

**整体获焦与非整体获焦**

- 整体获焦是[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)/容器自身作为焦点链的叶节点获焦，获焦后再把焦点链叶节点转移到子孙组件。例如，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换、Navigation组件中的路由切换、焦点组走焦、容器组件主动调用requestFocusById等。
    
- 非整体获焦是某个组件作为焦点链叶节点获焦，导致其祖先节点跟着获焦。例如TextInput组件主动获取焦点、Tab键在非焦点组场景下走焦等。
    

**整体获焦的焦点链形成**

1.[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次获焦：

- 焦点链叶节点为配置了defaultFocus的节点。
    
- 未配置defaultFocus时，焦点停留在[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的根容器上。
    

2.[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)非首次获焦：由上次获焦的节点获焦。

3.获焦链上存在配置了获焦优先级的组件和容器：

- 容器内存在优先级大于PREVIOUS的组件，由优先级最高的组件获焦。
    
- 容器内不存在优先级大于PREVIOUS的组件，由上次获焦的节点获焦。例如，窗口失焦后重新获焦。
    

## 焦点样式

说明

最终绘制焦点激活态的组件的[zIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-z-order#zindex)默认会被抬升至INT_MAX，如果该组件已经配置了zIndex，则不做zIndex调整。该组件不再绘制焦点激活态时，例如组件失焦或是退出走焦态，zIndex恢复为默认层级。

1. focusBox(style: FocusBoxStyle)

设置当前组件系统焦点框样式。

1. import { ColorMetrics, LengthMetrics } from '@kit.ArkUI'

2. @Entry
3. @Component
4. struct RequestFocusExample {
5.   build() {
6.     Column({ space: 30 }) {
7.       Button("small black focus box")
8.         .focusBox({
9.           margin: new LengthMetrics(0),
10.           strokeColor: ColorMetrics.rgba(0, 0, 0),
11.         })
12.       Button("large red focus box")
13.         .focusBox({
14.           margin: LengthMetrics.px(20),
15.           strokeColor: ColorMetrics.rgba(255, 0, 0),
16.           strokeWidth: LengthMetrics.px(10)
17.         })
18.     }
19.     .alignItems(HorizontalAlign.Center)
20.     .width('100%')
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.41659777254987774270453555000048:50001231000000:2800:0862308711451414B1C8A4C333F2EC8AFECE1178101C4168E6CD1CB86DECC739.gif)

上述示例包含以下2步：

- 进入[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)，按下Tab键触发走焦，第一个Button获焦，焦点框样式为紧贴边缘的黑色细框。
- 按下Tab键，走焦到第二个Button，焦点框样式为远离边缘的红色粗框。

## 主动获焦/失焦

- 使用FocusController中的方法
    
    更推荐使用FocusController中的requestFocus主动获取焦点。优势如下：
    
    - 当前帧生效，避免被下一帧组件树变化影响。
    - 有异常值返回，便于排查主动获取焦点失败的原因。
    - 避免多实例场景中取到错误实例。
    
    需先使用UIContext中的[getFocusController()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getfocuscontroller12)方法获取实例，再通过此实例调用对应方法。
    
    1. requestFocus(key: string): void
    
    通过组件的id将焦点转移到组件树对应的实体节点，生效时间为当帧生效。
    
    2. clearFocus(): void
    
    清除焦点，将焦点强制转移到层级页面根容器节点，焦点链路上其他节点失焦。
    
- 使用focusControl中的方法
    
    1. requestFocus(value: string): boolean
    
    调用此接口可以主动让焦点转移至参数指定的组件上，焦点转移生效时间为下一个帧信号。
    

1. // focusTest.ets
2. @Entry
3. @Component
4. struct RequestExample {
5.   @State btColor: string = '#ff2787d9'
6.   @State btColor2: string = '#ff2787d9'

7.   build() {
8.     Column({ space: 20 }) {
9.       Column({ space: 5 }) {
10.         Button('Button')
11.           .width(200)
12.           .height(70)
13.           .fontColor(Color.White)
14.           .focusOnTouch(true)
15.           .backgroundColor(this.btColor)
16.           .onFocus(() => {
17.             this.btColor = '#ffd5d5d5'
18.           })
19.           .onBlur(() => {
20.             this.btColor = '#ff2787d9'
21.           })
22.           .id("testButton")

23.         Button('Button')
24.           .width(200)
25.           .height(70)
26.           .fontColor(Color.White)
27.           .focusOnTouch(true)
28.           .backgroundColor(this.btColor2)
29.           .onFocus(() => {
30.             this.btColor2 = '#ffd5d5d5'
31.           })
32.           .onBlur(() => {
33.             this.btColor2 = '#ff2787d9'
34.           })
35.           .id("testButton2")

36.         Divider()
37.           .vertical(false)
38.           .width("80%")
39.           .backgroundColor('#ff707070')
40.           .height(10)

41.         Button('FocusController.requestFocus')
42.           .width(200).height(70).fontColor(Color.White)
43.           .onClick(() => {
44.             this.getUIContext().getFocusController().requestFocus("testButton")
45.           })
46.           .backgroundColor('#ff2787d9')

47.         Button("focusControl.requestFocus")
48.           .width(200).height(70).fontColor(Color.White)
49.           .onClick(() => {
50.             focusControl.requestFocus("testButton2")
51.           })
52.           .backgroundColor('#ff2787d9')

53.         Button("clearFocus")
54.           .width(200).height(70).fontColor(Color.White)
55.           .onClick(() => {
56.             this.getUIContext().getFocusController().clearFocus()
57.           })
58.           .backgroundColor('#ff2787d9')
59.       }
60.     }
61.     .width('100%')
62.     .height('100%')
63.   }
64. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.97740767440526976787540854945747:50001231000000:2800:C4111BC36B6599D652AAD9B820B0FEE1A7BD6AFECE500CF4A784BEE49847629C.gif)

上述示例包含以下3步：

- 点击FocusController.requestFocus按钮，第一个Button获焦。
- 点击focusControl.requestFocus按钮，第二个Button获焦。
- 点击clearFocus按钮，第二个Button失焦。

## 自定义组件走焦顺序

### nextFocus自定义走焦

1. nextFocus(nextStep: Optional<FocusMovement>): T

若存在配置了nextFocus的组件，则走焦只会按照设置的nextFocus走焦顺序走焦，没有设置自定义走焦或者设置自定义走焦的组件或容器不存在时，仍进行默认走焦规则。

说明

- 该能力从API version 18开始支持。

1. @Entry
2. @Component
3. struct NextFocusExample {
4.   build() {
5.     Column({space: 30}) {
6.       Row().height('30%')
7.       Row({space: 10}) {
8.         Button('A')
9.           .id('A')
10.           .nextFocus({forward: 'F', backward: 'C', down: 'B'})
11.         Button('B')
12.           .id('B')
13.           .nextFocus({ down: 'C'})
14.         Button('C')
15.           .id('C')
16.       }
17.       Column({space: 10}) {
18.         Button('D')
19.           .id('D')
20.         Button('E')
21.           .id('E')
22.           .nextFocus({forward: 'A', backward: 'M', up: 'E', right: 'F'})
23.       }
24.       Row({space: 10}) {
25.         Button('F')
26.           .id('F')
27.           .nextFocus({forward: 'B', down: 'A'});
28.       }
29.     }.width('100%')
30.   }
31. }

Tab键走焦：未配置nextFocus时，Tab键走焦顺序为A->B->C->D->E->F。配置nextFocus之后，Tab键走焦顺序为A->F->B->C->D->E->A。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.20924133050221638703423866142948:50001231000000:2800:A7FF473C58FAE4F1FCC3563D60F8184EB25A28FCAD6CE46F024BADC91C50F26D.gif)

方向键走焦（以方向下键为例）：未配置nextFocus时，按下Tab键激活焦点态之后，按方向下键走焦顺序为A->D->E->F。配置nextFocus之后，按下Tab键激活焦点态之后，按方向下键走焦顺序为A->B->C->D->E->F->A。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.69993108034770259696033359880898:50001231000000:2800:187B5FED65D1B965936745D8590407F8E5EBFD7FE0D0DE4C8F896840C9C889D5.gif)

### tabIndex自定义走焦

1. tabIndex(index: number)

tabIndex自定义组件Tab键走焦顺序。

若存在配置了tabIndex大于0的组件，则Tab键走焦只会在tabIndex大于0的组件内，按照tabIndex的值从小到大并循环依次走焦。若没有配置tabIndex大于0的组件，则tabIndex等于0的组件按照组件预设的走焦规则走焦。

说明

不能同时设置tabIndex与focusScopeId属性。

不建议在[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)中通过单独设置组件的tabIndex属性为负数来控制获焦能力，可以使用focusable属性代替。

tabIndex只能够自定义Tab键走焦，若想同时自定义方向键等走焦能力，建议使用[nextfocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#nextfocus%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%B0%E7%84%A6)。

1. @Entry
2. @Component
3. struct TabIndexExample {
4.   build() {
5.     Column() {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5)
10.       Button('Focus Button1')
11.         .width(140)
12.         .height(45)
13.         .margin(5).tabIndex(1)
14.       Button('Button2')
15.         .width(140)
16.         .height(45)
17.         .margin(5)
18.       Button('Focus Button2')
19.         .width(140)
20.         .height(45)
21.         .margin(5).tabIndex(2)
22.     }.width('100%')
23.   }
24. }

Tab键走焦：只在配置TabIndex的节点间循环走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.51486502427571866865317321931093:50001231000000:2800:7727C38FC3CB8C864A63CD85F9834DD5A5271CC7D3BAA52A8D7B7CB6282B2D72.gif)

tabIndex配置在容器上时，如果容器中的所有组件都没有获焦过，则走到第一个可获焦组件上，否则会走到上次获焦的节点。

1. @Entry
2. @Component
3. struct TabIndexExample2 {
4.   build() {
5.     Column() {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5).tabIndex(1)
10.       Column() {
11.         Button('Button2')
12.           .width(140)
13.           .height(45)
14.           .margin(5)
15.         Button('Button3')
16.           .width(140)
17.           .height(45)
18.           .margin(5)
19.       }.tabIndex(2)
20.     }.width('100%')
21.   }
22. }

Tab键走焦：tabIndex配置在容器上。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.69766945152546567976053498676098:50001231000000:2800:1227629C5419CD56ED0276905759A77E7CE436AB4F347F73D331CA0E31640728.gif)

上述示例包含以下3步：

- 使用Tab走焦，焦点在Button1和Button2之间循环走焦（tabIndex配置在Button2和Button3的父组件上）。
- 在走焦至Button2时，使用方向下键，将焦点转移至Button3上。
- 使用Tab走焦，焦点在Button1和Button3之间循环走焦。

## 焦点组与获焦优先级

1. focusScopePriority(scopeId: string, priority?: FocusPriority)

设置当前组件在指定容器内获焦的优先级。需要配合focusScopeId一起使用。

1. focusScopeId(id: string, isGroup?: boolean)

设置当前容器组件的id标识，设置当前容器组件是否为焦点组。焦点组与tabIndex不能混用。

1. // focusTest.ets
2. @Entry
3. @Component
4. struct FocusableExample {
5.   @State inputValue: string = ''

6.   build() {
7.     Scroll() {
8.       Row({ space: 20 }) {
9.         Column({ space: 20 }) {  // 标记为Column1
10.           Column({ space: 5 }) {
11.             Button('Group1')
12.               .width(165)
13.               .height(40)
14.               .fontColor(Color.White)
15.             Row({ space: 5 }) {
16.               Button()
17.                 .width(80)
18.                 .height(40)
19.                 .fontColor(Color.White)
20.               Button()
21.                 .width(80)
22.                 .height(40)
23.                 .fontColor(Color.White)
24.             }
25.             Row({ space: 5 }) {
26.               Button()
27.                 .width(80)
28.                 .height(40)
29.                 .fontColor(Color.White)
30.               Button()
31.                 .width(80)
32.                 .height(40)
33.                 .fontColor(Color.White)
34.             }
35.           }.borderWidth(2).borderColor(Color.Red).borderStyle(BorderStyle.Dashed)
36.           Column({ space: 5 }) {
37.             Button('Group2')
38.               .width(165)
39.               .height(40)
40.               .fontColor(Color.White)
41.             Row({ space: 5 }) {
42.               Button()
43.                 .width(80)
44.                 .height(40)
45.                 .fontColor(Color.White)
46.               Button()
47.                 .width(80)
48.                 .height(40)
49.                 .fontColor(Color.White)
50.                 .focusScopePriority('ColumnScope1', FocusPriority.PRIOR)  // Column1首次获焦时获焦
51.             }
52.             Row({ space: 5 }) {
53.               Button()
54.                 .width(80)
55.                 .height(40)
56.                 .fontColor(Color.White)
57.               Button()
58.                 .width(80)
59.                 .height(40)
60.                 .fontColor(Color.White)
61.             }
62.           }.borderWidth(2).borderColor(Color.Green).borderStyle(BorderStyle.Dashed)
63.         }
64.         .focusScopeId('ColumnScope1')
65.         Column({ space: 5 }) {  // 标记为Column2
66.           TextInput({placeholder: 'input', text: this.inputValue})
67.             .onChange((value: string) => {
68.               this.inputValue = value
69.             })
70.             .width(156)
71.           Button('Group3')
72.             .width(165)
73.             .height(40)
74.             .fontColor(Color.White)
75.           Row({ space: 5 }) {
76.             Button()
77.               .width(80)
78.               .height(40)
79.               .fontColor(Color.White)
80.             Button()
81.               .width(80)
82.               .height(40)
83.               .fontColor(Color.White)
84.           }
85.           Button()
86.             .width(165)
87.             .height(40)
88.             .fontColor(Color.White)
89.             .focusScopePriority('ColumnScope2', FocusPriority.PREVIOUS)  // Column2获焦时获焦
90.           Row({ space: 5 }) {
91.             Button()
92.               .width(80)
93.               .height(40)
94.               .fontColor(Color.White)
95.             Button()
96.               .width(80)
97.               .height(40)
98.               .fontColor(Color.White)
99.           }
100.           Button()
101.             .width(165)
102.             .height(40)
103.             .fontColor(Color.White)
104.           Row({ space: 5 }) {
105.             Button()
106.               .width(80)
107.               .height(40)
108.               .fontColor(Color.White)
109.             Button()
110.               .width(80)
111.               .height(40)
112.               .fontColor(Color.White)
113.           }
114.         }.borderWidth(2).borderColor(Color.Orange).borderStyle(BorderStyle.Dashed)
115.         .focusScopeId('ColumnScope2', true)  // Column2为焦点组
116.       }.alignItems(VerticalAlign.Top)
117.     }
118.   }
119. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.64806538796341658333103812050250:50001231000000:2800:EC2AFA4424A6D3CF197AEA756844A99A0D5998879164DD7B3A3F962297C16886.gif)

上述示例包含以下2步：

- input方框内设置了焦点组，因此按下Tab键后焦点会快速从input中走出去，而按下方向键后可以在input内走焦。
- 左侧的两个Column没有设置焦点组，因此只能通过Tab键一个一个地走焦。

在API version 14，焦点组新增参数arrowStepOut，用于设置能否使用方向键走焦出当前焦点组。

1. focusScopeId(id: string, isGroup?: boolean, arrowStepOut?: boolean)

2. @Entry
3. @Component
4. struct FocusScopeIdExample {
5.   build() {
6.     Column({ space: 20 }) {
7.       Column() {
8.         Button('Group1')
9.           .width(165)
10.           .height(40)
11.           .margin(5)
12.           .fontColor(Color.White)
13.         Row({ space: 5 }) {
14.           Button("Button1")
15.             .width(80)
16.             .height(40)
17.             .margin(5)
18.             .fontColor(Color.White)
19.           Button("Button2")
20.             .width(80)
21.             .height(40)
22.             .margin(5)
23.             .fontColor(Color.White)
24.         }
25.       }.focusScopeId("1", true, true)
26.       .borderWidth(2).borderColor(Color.Red).borderStyle(BorderStyle.Dashed)

27.       TextInput()
28.       Column() {
29.         Button('Group2')
30.           .width(165)
31.           .height(40)
32.           .margin(5)
33.           .fontColor(Color.White)
34.         Row({ space: 5 }) {
35.           Button("Button3")
36.             .width(80)
37.             .height(40)
38.             .margin(5)
39.             .fontColor(Color.White)
40.           Button("Button4")
41.             .width(80)
42.             .height(40)
43.             .margin(5)
44.             .fontColor(Color.White)
45.         }
46.       }.focusScopeId("2", true, false)
47.       .borderWidth(2).borderColor(Color.Green).borderStyle(BorderStyle.Dashed)

48.       TextInput()
49.     }.width('100%')
50.   }
51. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.13720911488363316597969965400768:50001231000000:2800:B1645C8A8DD2A142F05ACC95A832E3A35135371FECA4232599E65C4EE6347BE0.gif)

上述示例包含以下3步：

- Group1和Group2设置焦点组，因此按下Tab键后焦点会快速从Group1和Group2的方框内走出。
- Group1设置焦点组时，允许使用方向键走焦出当前焦点组。在Group1方框内走焦时，使用方向键可以走焦至input输入框。
- Group2设置焦点组时，不允许使用方向键走焦出当前焦点组。在Group2方框内走焦时，使用方向键无法走焦至input输入框。

说明

TextInput组件本身对方向键存在独有处理，因此无法使用方向键直接走出TextInput组件。

## 焦点与按键事件

当组件获焦且存在点击事件（onClick）或单指单击事件（TapGesture）时，回车和空格会触发对应的事件回调。

说明

1. 点击事件（onClick）或单指单击事件（TapGesture）在回车、空格触发对应事件回调时，默认不冒泡传递，即父组件对应[按键事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key)不会被同步触发。
2. 按键事件（onKeyEvent）默认冒泡传递，即同时会触发父组件的按键事件回调。
3. 组件同时存在点击事件（onClick）和按键事件（onKeyEvent），在回车、空格触发时，两者都会响应。
4. 获焦组件响应点击事件（onClick），与焦点激活态无关。

5. @Entry
6. @Component
7. struct FocusOnclickExample {
8.   @State count: number = 0
9.   @State name: string = 'Button'

10.   build() {
11.     Column() {
12.       Button(this.name)
13.         .fontSize(30)
14.         .onClick(() => {
15.           this.count++
16.           if (this.count % 2 === 0) {
17.             this.name = "count is even number"
18.           } else {
19.             this.name = "count is odd number"
20.           }
21.         }).height(60)
22.     }.height('100%').width('100%').justifyContent(FlexAlign.Center)
23.   }
24. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.65037606847477599416505461065922:50001231000000:2800:D5B7A9701BBA829A663F0AA9D0472DC2D193783B3A62BCD229339C7E92B9B212.gif)

## 组件获焦能力说明

**表1** 基础组件获焦能力

|基础组件|是否有获焦能力|focusable默认值|
|:--|:--|:--|
|[AlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-alphabet-indexer)|是|true|
|[Blank](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-blank)|否|false|
|[Button](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button)|是|true|
|[CalendarPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-calendarpicker)|是|true|
|[Checkbox](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-checkbox)|是|true|
|[CheckboxGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-checkboxgroup)|是|true|
|[ContainerSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-containerspan)|否|false|
|[DataPanel](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datapanel)|是|false|
|[DatePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datepicker)|是|true|
|[Divider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-divider)|是|false|
|[Gauge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-gauge)|是|false|
|[Image](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image)|是|false|
|[ImageAnimator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imageanimator)|否|false|
|[ImageSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imagespan)|否|false|
|[LoadingProgress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-loadingprogress)|是|true|
|[Marquee](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-marquee)|否|false|
|[Menu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menu)|是|true|
|[MenuItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menuitem)|是|true|
|[MenuItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menuitemgroup)|否|false|
|[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)|是|true|
|[NavRouter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navrouter)|否|false|
|[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)|是|true|
|[PatternLock](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-patternlock)|是|true|
|[Progress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-progress)|是|true|
|[QRCode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-qrcode)|是|true|
|[Radio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-radio)|是|true|
|[Rating](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-rating)|是|true|
|[RichEditor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor)|是|true|
|[RichText](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richtext)|否|false|
|[ScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar)|否|false|
|[Search](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search)|是|true|
|[Select](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-select)|是|true|
|[Slider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-slider)|是|true|
|[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)|否|false|
|[Stepper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-stepper)|是|true|
|[StepperItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-stepperitem)|是|true|
|[SymbolSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan)|否|false|
|[SymbolGlyph](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph)|否|false|
|[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)|是|false|
|[TextArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea)|是|true|
|[TextClock](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textclock)|否|false|
|[TextInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput)|是|true|
|[TextPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textpicker)|是|true|
|[TextTimer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-texttimer)|否|false|
|[TimePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker)|否|false|
|[Toggle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-toggle)|是|true|
|[XComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent)|是|false|

**表2** 容器组件获焦能力

|容器组件|是否可获焦|focusable默认值|
|:--|:--|:--|
|[Badge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-badge)|否|false|
|[Column](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-column)|是|true|
|[ColumnSplit](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-columnsplit)|是|true|
|[Counter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-counter)|是|false|
|[EmbeddedComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-embedded-component)|否|false|
|[Flex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flex)|是|true|
|[FlowItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flowitem)|是|true|
|[FolderStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-folderstack)|是|true|
|[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)|否|false|
|[GridCol](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridcol)|是|true|
|[GridRow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridrow)|是|true|
|[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)|是|true|
|[GridItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-griditem)|是|true|
|[Hyperlink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-hyperlink)|是|true|
|[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)|是|true|
|[ListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitem)|是|true|
|[ListItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitemgroup)|是|true|
|[Navigator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-navigator)|是|true|
|[Refresh](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-refresh)|是|true|
|[RelativeContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-relativecontainer)|否|false|
|[Row](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-row)|是|true|
|[RowSplit](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-rowsplit)|是|true|
|[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)|是|true|
|[SideBarContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer)|是|true|
|[Stack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-stack)|是|true|
|[Swiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper)|是|true|
|[Tabs](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs)|是|true|
|[TabContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabcontent)|是|true|
|[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)|否|false|
|[WithTheme](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-with-theme)|是|true|

**表3** 媒体组件获焦能力

|媒体组件|是否可获焦|focusable默认值|
|:--|:--|:--|
|[Video](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-media-components-video)|是|true|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-drag-event "支持统一拖拽")
# 支持焦点处理

更新时间: 2025-12-16 16:40

## 基础概念与规范

### 基础概念

**焦点、焦点链和走焦**

- 焦点：指向当前应用界面上唯一的一个可交互元素，当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入设备与应用程序进行间接交互时，基于焦点的导航和交互是重要的输入手段。
- 焦点链：在应用的组件树形结构中，当一个组件获得焦点时，从根节点到该组件节点的整条路径上的所有节点都会处于焦点状态，形成一条连续的焦点链。
- 走焦：指焦点在应用内的组件之间转移的行为。这一过程对用户是透明的，但开发者可以通过监听onFocus（焦点获取）和onBlur（焦点失去）事件来捕捉这些变化。关于走焦的具体方式和规则，详见[走焦规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)。

**焦点激活态**

焦点激活态是用来显示当前获焦组件焦点框的视觉样式。

- 显示规则
    
    - 默认状态：焦点激活态默认是隐藏的。
    - 激活条件：只有当应用程序进入"激活态"时，焦点激活态才会显示。
    - 重要关系：
        - 获得焦点的组件不一定显示激活态（取决于应用是否处于激活态）。
        - 显示激活态的组件必定是当前获得焦点的组件。
    - 样式定制：组件通常有内置的激活态样式，开发者可以通过样式接口自定义，自定义后会覆盖默认样式。
    - 显示优先级：当多个组件同时拥有焦点时，系统优先显示子组件的激活态，且同一时间只显示一个激活态。
- 如何进入激活态
    
    - 按下外接键盘的Tab键（注意：首次激活时的Tab键仅用于激活，不会触发焦点移动）。
    - 调用[FocusController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller)的activate(true)方法。
- 如何退出激活态
    
    - 调用FocusController的activate(false)方法。
    - 发生点击事件时（包括触屏点击或鼠标左键点击）。

1. @Entry
2. @Component
3. struct FocusActiveExample {
4.   build() {
5.     Column() {
6.       Button('Set Active').width(140).height(45).margin(5).onClick(() => {
7.         this.getUIContext().getFocusController().activate(true, true);
8.       })
9.       Button('Set Not Active').width(140).height(45).margin(5).onClick(() => {
10.         this.getUIContext().getFocusController().activate(false, true);
11.       })
12.     }.width('100%')
13.   }
14. }

按下Tab键，焦点激活态显示。点击鼠标退出焦点激活态。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.87842322685467604801662793724140:50001231000000:2800:F79231A05F00351B00E30E0E178E821E7B61603CF2446DF97F7B7044B73F16AF.gif)

调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口进入和退出焦点激活态。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.56410181471804487464553871116694:50001231000000:2800:B9AF31DF6E88F1EF74E19E6C5C4AC404F63960C550E3B870F0FF0479990817D0.gif)

示例操作步骤：

1. 点击Set Active按钮，调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口进入焦点激活态。
2. Tab走焦至Set Not Active按钮，Enter键触发按键事件，调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口退出焦点激活态。

**层级页面**

层级页面是焦点框架中特定容器组件的统称，涵盖Page、Dialog、SheetPage、ModalPage、Menu、Popup、NavBar、NavDestination等。这些组件通常具有以下关键特性：

- 视觉层级独立性：从视觉呈现上看，这些组件独立于其他页面内容，并通常位于其上方，形成视觉上的层级差异。
- 焦点跟随：此类组件在首次创建并展示之后，会立即将应用内焦点抢占。
- 走焦范围限制：当焦点位于这些组件内部时，用户无法通过键盘按键将焦点转移到组件外部的其他元素上，焦点移动仅限于组件内部。

在一个应用程序中，任何时候都至少存在一个层级页面组件，并且该组件会持有当前焦点。当该层级页面关闭或不再可见时，焦点会自动转移到下一个可用的层级页面组件上，确保用户交互的连贯性和一致性。

说明

Popup组件在focusable属性（组件属性，非通用属性）为false的时候，不会有第2条特性。

NavBar、NavDestination没有第3条特性，对于它们的走焦范围，是与它们的首个父层级页面相同的。

**根容器**

根容器是[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)内的概念，当某个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次创建并展示时，根据[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的特性，焦点会立即被该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)抢占。此时，该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)所在焦点链的末端节点将成为默认焦点，而这个默认焦点通常位于该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的根容器上。

在缺省状态下，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的默认焦点位于其根容器上，但开发者可以通过defaultFocus属性来自定义这一行为。

当焦点位于根容器时，首次按下Tab键不仅会使焦点进入激活状态，还会根据[焦点传递规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E7%84%A6%E7%82%B9%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99)进行传递。

### 焦点传递规则

焦点传递是指当用户首次激活应用焦点系统时，焦点如何从根节点逐级向下传递到具体组件的过程。

在焦点链上的组件，都会处于获焦状态。同时组件在获焦时，会继续向下递归传递获焦状态，每次传递给第一个子组件，直到叶子节点。

1. @Entry
2. struct Index {
3.   @State logText: string = '\n';

4.   addText(message: string) {
5.     this.logText += `${message}\n`;
6.   }

7.   build() {
8.     Column() {
9.       Row() {
10.         Column() {
11.           Button("Button 1")
12.             .margin(20)
13.             .onClick(() => {
14.               this.logText = '获焦信息：\n';
15.               this.getUIContext().getFocusController().requestFocus("Row 2")
16.             })
17.         }
18.       }

19.       Column() {
20.         Row() {
21.           Button("Button 2")
22.             .margin(20)
23.             .onFocus(() => {
24.               this.addText("Button 2 获得焦点");
25.             })
26.           Button("button 3")
27.             .margin(20)
28.             .onFocus(() => {
29.               this.addText("Button 3 获得焦点");
30.             })
31.         }
32.         .id("Row 2")
33.         .onFocus(() => {
34.           this.addText("Row 2 获得焦点");
35.         })
36.       }
37.       .onFocus(() => {
38.         this.addText("Column 2 获得焦点");
39.       })

40.       Scroll() {
41.         Text(this.logText)
42.           .fontSize(14)
43.           .textAlign(TextAlign.Start)
44.           .padding(10)
45.       }
46.       .height('40%')
47.       .width('100%')
48.       .border({ width: 1, color: '#ccc' })
49.       .margin(10)
50.     }
51.     .height('100%')
52.     .padding(20)
53.   }
54. }

运行后点击Button1，请求焦点给Row组件，Row组件的第一个可获焦子节点Button2获焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.33657945635981072347038409626891:50001231000000:2800:4AF361753D70D731C596C35F5ADA25F3A0DD33C8F2AF8B41A1F3F1AA8DAB5261.gif)

### 走焦规范

根据走焦的触发方式，可以分为主动走焦和被动走焦。

**主动走焦**

指开发者/用户主观行为导致的焦点移动，包括：使用外接键盘的按键走焦（Tab键/Shift+Tab键/方向键）、使用requestFocus申请焦点、clearFocus清除焦点、focusOnTouch点击申请焦点等接口导致的焦点转移。

- 按键走焦

1. 前提：当前应用需处于焦点激活态。
2. 范围限制：按键走焦仅在当前获得焦点的层级页面内进行，具体参见“层级页面”中的“走焦范围限制”部分。
3. 按键类型：
    
    Tab键：遵循Z字型遍历逻辑，完成当前范围内所有叶子节点的遍历，到达当前范围内的最后一个组件后，继续按下Tab键，焦点将循环至范围内的第一个可获焦组件，实现循环走焦。
    
    Shift+Tab键：与Tab键具有相反的焦点转移效果。
    
    方向键（上、下、左、右）：遵循十字型移动策略，在单层容器中，焦点的转移由该容器的特定走焦算法决定。若算法判定下一个焦点应落在某个容器组件上，系统将采用中心点距离优先的算法来进一步确定容器内的目标子节点。
    
4. 走焦算法：每个可获焦的容器组件都有其特定的走焦算法，用于定义焦点转移的规则。
5. 子组件优先：当子组件处理按键走焦事件，父组件将不再介入。

- requestFocus
    
    详见[主动获焦失焦](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E4%B8%BB%E5%8A%A8%E8%8E%B7%E7%84%A6%E5%A4%B1%E7%84%A6)，可以主动将焦点转移到指定组件上。
    
    不可跨窗口或跨ArkUI实例申请焦点，但可以跨层级页面申请焦点。
    
- clearFocus
    
    详见[clearFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#clearfocus12)，会清除当前层级页面中的焦点，最终焦点停留在根容器上。
    
- focusOnTouch
    
    详见[focusOnTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focusontouch9)，使绑定组件具备点击后获得焦点的能力。若组件本身不可获焦，则此功能无效。若绑定的是容器组件，点击后优先将焦点转移给上一次获焦的子组件，否则转移给第一个可获焦的子组件。
    

**被动走焦**

被动走焦是指组件焦点因系统或其他操作而自动转移，无需开发者直接干预，这是焦点系统的默认行为。

目前会被动走焦的机制有：

- 组件删除：当处于焦点状态的组件被删除时，焦点框架首先尝试将焦点转移到相邻的兄弟组件上，遵循先向后再向前的顺序。若所有兄弟组件均不可获焦，则焦点将释放，并通知其父组件进行焦点处理。
- 属性变更：若将处于焦点状态的组件的focusable或enabled属性设置为false，或者将visibility属性设置为不可见，系统将自动转移焦点至其他可获焦组件，转移方式与1中相同。
- [层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换：当发生[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换时，如从一个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)跳转到另一个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)，当前[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的焦点将自动释放，新[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)可能会根据预设逻辑自动获得焦点。
- Web组件初始化：对于Web组件，当其被创建时，若其设计需要立即获得焦点（如某些弹出框或输入框），则可能触发焦点转移至该Web组件，其行为属于组件自身的行为逻辑，不属于焦点框架的规格范围。

### 走焦算法

在焦点管理系统中，每个可获焦的容器都配备有特定的走焦算法，这些算法定义了当使用Tab键、Shift+Tab键或方向键时，焦点如何从当前获焦的子组件转移到下一个可获焦的子组件。

容器采用何种走焦算法取决于其UX（用户体验）规格，并由容器组件进行适配。目前，焦点框架支持三种走焦算法：线性走焦、投影走焦和自定义走焦。

**线性走焦算法**

线性走焦算法是默认的走焦策略，它基于容器中子节点在节点树中的挂载顺序进行走焦，常用于单方向布局的容器，如Row、Column和Flex容器。运行规则如下：

- 顺序依赖：走焦顺序完全基于子节点在节点树中的挂载顺序，与它们在界面上的实际布局位置无关。
- Tab键走焦：使用Tab键时，焦点将按照子节点的挂载顺序依次遍历。
- 方向键走焦：当使用与容器定义方向垂直的方向键时，容器不接受该方向的走焦请求。例如，在横向的Row容器中，无法使用方向键进行上下移动。
- 边界处理：当焦点位于容器的首尾子节点时，容器将拒绝与当前焦点方向相反的方向键走焦请求。例如，焦点在一个横向的Row容器的第一个子节点上时，该容器无法处理方向键左的走焦请求。

1. @Entry
2. @Component
3. struct FocusLinerExample {
4.   build() {
5.     Column() {
6.       Column() {
7.         Button("Column Button1")
8.           .width(150)
9.           .height(45)
10.           .fontColor(Color.White)
11.           .margin(10)
12.         Button("Column Button2")
13.           .width(150)
14.           .height(45)
15.           .fontColor(Color.White)
16.           .margin(10)
17.       }
18.       .margin(10)

19.       Row() {
20.         Button("Row Button1")
21.           .width(150)
22.           .height(45)
23.           .fontColor(Color.White)
24.           .margin(10)
25.         Button("Row Button2")
26.           .width(150)
27.           .height(45)
28.           .fontColor(Color.White)
29.           .margin(10)
30.       }
31.     }
32.   }
33. }

Tab键走焦：按照子节点的挂载顺序循环走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.67763606112505332746852831470376:50001231000000:2800:3474F13A44F978CEDACCDCDEFADB731AE35151ADF818AC223554A3A1C20AA57F.gif)

方向键上下走焦：纵向的Column容器中，可以使用上下键走焦，无法使用左右键走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.65394565649527609025701911760515:50001231000000:2800:B6FDAA2D053B02C6A05B0C18A76E9DA9F17CCC3B2937E582FCFBB48305BE228E.gif)

横向的Row容器中，可以使用左右键走焦，无法使用上下键走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.13418426341066464548754278051935:50001231000000:2800:4C09B3DCA4983F4AA999C84552394346370C3ED04C8699F1B6324034F575302C.gif)

**投影走焦算法**

投影走焦算法基于当前获焦组件在走焦方向上的投影，结合子组件与投影的重叠面积和中心点距离进行胜出判定。该算法适用于子组件大小不一的容器，目前仅支持配置了wrap属性的Flex组件。运行规则如下：

- 方向键走焦时，判断投影与子组件区域的重叠面积，在所有面积不为0的子组件中，计算它们与当前获焦组件的中心点直线距离，选择距离最短的子组件。若存在多个备选子组件，则选择节点树上更靠前的子组件。若无任何子组件与投影有重叠，说明该容器无法处理该方向键的走焦请求。
- Tab键走焦时，先使用规格1，按照方向键右进行判定，若找到则成功退出，若无法找到，则将当前获焦子组件的位置模拟往下移动该获焦子组件的高度，然后再按照方向键左进行投影判定，有投影重叠且中心点直线距离最近的子组件胜出，若无投影重叠的子组件，则表示该容器无法处理本次Tab键走焦请求。
- Shift+Tab键走焦时，先使用规格1，按照方向键左进行判定，找到则成功退出。若无法找到，则将当前获焦子组件的位置模拟向上移动该获焦子组件的高度，然后再按照方向键右进行投影判定，有投影重叠且中心点直线距离最近的子组件胜出，若无投影重叠的子组件，则表示该容器无法处理本次的Shift+Tab键走焦请求。

1. @Entry
2. @Component
3. struct ProjectAreaFocusExample {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Text('Wrap').fontSize(12).width('90%')
8.         // 子组件多行布局
9.         Flex({ wrap: FlexWrap.Wrap }) {
10.           Button('1').width(140).height(50).margin(5)
11.           Button('2').width(140).height(50).margin(5)
12.           Button('3').width(140).height(50).margin(5)
13.           Button('4').width(140).height(50).margin(5)
14.           Button('5').width(140).height(50).margin(5)
15.         }
16.         .width('90%')
17.         .padding(10)
18.       }.width('100%').margin({ top: 5 })
19.     }.width('100%')
20.   }
21. }

说明

- 这种投影聚焦算法计算的聚焦顺序与组件布局和大小密切相关，建议在组件排列非常规整的场景下使用。如果组件大小不一且存在横向或纵向的交叠关系，则可能会导致聚焦顺序与开发者预期不符。
- 如果开发者希望有明确的走焦顺序，建议使用Column/Row等顺序走焦的容器实现。

Flex多行组件布局，组件大小一致，走焦正常。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.97476089624538307657888383026394:50001231000000:2800:DED494A5A38A8F155D95C336140627D6B270BC2C59AFDC2B7C5F9699DBDE2818.gif)

1. @Entry
2. @Component
3. struct ProjectAreaFocusExample2 {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Text('Wrap').fontSize(12).width('90%')
8.         // 子组件多行布局
9.         Flex({ wrap: FlexWrap.Wrap }) {
10.           Button('1').width(145).height(50).margin(5)
11.           Button('2').width(145).height(50).margin(5)
12.           Button('3').width(150).height(50).margin(5)
13.           Button('4').width(160).height(50).margin(5)
14.           Button('5').width(170).height(50).margin(5)
15.         }
16.         .width('90%')
17.         .padding(10)
18.       }.width('100%').margin({ top: 5 })
19.     }.width('100%')
20.   }
21. }

Flex多行组件布局，组件大小不一且有纵向的交叠关系，无法Tab走焦至下方4、5按钮组件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.76783338379593373741134037318032:50001231000000:2800:ACD5D9ED55A0F0DBEFE0ED4BD2428B297A9DD958EFC0ADCBEEA7F7B4E3D12BDD.gif)

**自定义走焦算法**

由组件自定义的走焦算法，规格由组件定义。

## 获焦/失焦事件

1. onFocus(event: () => void)

获焦事件回调，绑定该接口的组件获焦时，回调响应。

1. onBlur(event:() => void)

失焦事件回调，绑定该接口的组件失焦时，回调响应。

onFocus和onBlur两个接口通常成对使用，来监听组件的焦点变化。

1. // xxx.ets
2. @Entry
3. @Component
4. struct FocusEventExample {
5.   @State oneButtonColor: Color = Color.Gray;
6.   @State twoButtonColor: Color = Color.Gray;
7.   @State threeButtonColor: Color = Color.Gray;

8.   build() {
9.     Column({ space: 20 }) {
10.       // 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
11.       Button('First Button')
12.         .width(260)
13.         .height(70)
14.         .backgroundColor(this.oneButtonColor)
15.         .fontColor(Color.Black)
16.           // 监听第一个组件的获焦事件，获焦后改变颜色
17.         .onFocus(() => {
18.           this.oneButtonColor = Color.Green;
19.         })
20.           // 监听第一个组件的失焦事件，失焦后改变颜色
21.         .onBlur(() => {
22.           this.oneButtonColor = Color.Gray;
23.         })

24.       Button('Second Button')
25.         .width(260)
26.         .height(70)
27.         .backgroundColor(this.twoButtonColor)
28.         .fontColor(Color.Black)
29.           // 监听第二个组件的获焦事件，获焦后改变颜色
30.         .onFocus(() => {
31.           this.twoButtonColor = Color.Green;
32.         })
33.           // 监听第二个组件的失焦事件，失焦后改变颜色
34.         .onBlur(() => {
35.           this.twoButtonColor = Color.Gray;
36.         })

37.       Button('Third Button')
38.         .width(260)
39.         .height(70)
40.         .backgroundColor(this.threeButtonColor)
41.         .fontColor(Color.Black)
42.           // 监听第三个组件的获焦事件，获焦后改变颜色
43.         .onFocus(() => {
44.           this.threeButtonColor = Color.Green;
45.         })
46.           // 监听第三个组件的失焦事件，失焦后改变颜色
47.         .onBlur(() => {
48.           this.threeButtonColor = Color.Gray ;
49.         })
50.     }.width('100%').margin({ top: 20 })
51.   }
52. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.15553965774827401495272683119777:50001231000000:2800:4C730B6DB303EFC9B1445ABBAFCD5615CD7582F11618B01E439F3CC62815B53B.gif)

上述示例包含以下3步：

- 应用打开，按下Tab键激活走焦，“First Button”显示焦点激活态样式：组件外围有一个蓝色的闭合框，onFocus回调响应，背景色变成绿色。
- 按下Tab键，触发走焦，“Second Button”获焦，onFocus回调响应，背景色变成绿色；“First Button”失焦，onBlur回调响应，背景色变回灰色。
- 按下Tab键，触发走焦，“Third Button”获焦，onFocus回调响应，背景色变成绿色；“Second Button”失焦，onBlur回调响应，背景色变回灰色。

父子节点同时存在获焦和失焦事件时，获焦/失焦事件响应顺序为：

父节点Row1失焦 —> 子节点Button1失焦 —> 子节点Button2获焦 —> 父节点Row2获焦。

1. @Entry
2. @Component
3. struct FocusAndBlurExample {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Row() { // 父节点Row1
8.           Button('Button1') // 子节点Button1
9.             .width(140)
10.             .height(45)
11.             .margin(5)
12.             .onFocus(() => {
13.               console.info("Button1 onFocus");
14.             })
15.             .onBlur(() => {
16.               console.info("Button1 onBlur");
17.             })
18.         }
19.         .onFocus(() => {
20.           console.info("Row1 onFocus");
21.         })
22.         .onBlur(() => {
23.           console.info("Row1 onBlur");
24.         })

25.         Row() { // 父节点Row2
26.           Button('Button2') // 子节点Button2
27.             .width(140)
28.             .height(45)
29.             .margin(5)
30.             .onFocus(() => {
31.               console.info("Button2 onFocus");
32.             })
33.             .onBlur(() => {
34.               console.info("Button2 onBlur");
35.             })
36.         }
37.         .onFocus(() => {
38.           console.info("Row2 onFocus");
39.         })
40.         .onBlur(() => {
41.           console.info("Row2 onBlur");
42.         })
43.       }.width('100%').margin({ top: 5 })
44.     }.width('100%')
45.   }
46. }

Button1走焦到Button2，日志打印顺序：

1. Row1 onBlur
2. Button1 onBlur
3. Button2 onFocus
4. Row2 onFocus

## 设置组件是否可获焦

1. focusable(value: boolean)

设置组件是否可获焦。

按照组件的获焦能力可大致分为三类：

- 默认可获焦的组件，通常是有交互行为的组件，例如Button、Checkbox、TextInput组件，此类组件无需设置任何属性，默认即可获焦。
    
- 有获焦能力，但默认不可获焦的组件，典型的是Text、Image组件，此类组件缺省情况下无法获焦，若需要使其获焦，可使用通用属性focusable(true)使能。对于没有配置focusable属性，有获焦能力但默认不可获焦的组件，例如没有可获焦子组件的容器组件，为其配置onClick或是单指单击的Tap手势，该组件会隐式地成为可获焦组件。如果其focusable属性被设置为false，即使配置了上述事件，该组件依然不可获焦。
    
- 无获焦能力的组件，通常是无任何交互行为的展示类组件，例如Blank、Circle组件，此类组件即使使用focusable属性也无法使其可获焦。
    

设置容器组件可获焦：

获焦的主要目的是为了响应用户交互，如果组件不具备交互能力，则其也不会具有可获焦能力。容器组件通常不具备交互能力，因此如果一个容器组件（如Stack、Column）作为叶子节点，即使通过.focusable(true)也无法使其具备可获焦能力。需要注意的是通过动态方式创建的[FrameNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-framenode)节点也受限于这个规则。

如果想让作为叶子节点的容器组件可获焦，可通过以下任一方式实现：

- 在其内添加一个具备获焦能力的叶子节点组件(如button)。
    
- 为其配置onClick、Tap手势等使其能响应点击交互。
    

1. enabled(value: boolean)

设置组件可交互性属性[enabled](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-enable#enabled)为false，则组件不可交互，无法获焦。

1. visibility(value: Visibility)

设置组件可见性属性[visibility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-visibility#visibility)为Visibility.None或Visibility.Hidden，则组件不可见，无法获焦。

1. focusOnTouch(value: boolean)

设置当前组件是否支持点击获焦能力。

说明

当某组件处于获焦状态时，将其的focusable属性或enabled属性设置为false，会自动使该组件失焦，然后焦点按照[走焦规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)将焦点转移给其他组件。

1. // xxx.ets
2. @Entry
3. @Component
4. struct FocusableExample {
5.   @State textFocusable: boolean = true;
6.   @State textEnabled: boolean = true;
7.   @State color1: Color = Color.Yellow;
8.   @State color2: Color = Color.Yellow;
9.   @State color3: Color = Color.Yellow;

10.   build() {
11.     Column({ space: 5 }) {
12.       Text('Default Text')    // 第一个Text组件未设置focusable属性，默认不可获焦
13.         .borderColor(this.color1)
14.         .borderWidth(2)
15.         .width(300)
16.         .height(70)
17.         .onFocus(() => {
18.           this.color1 = Color.Blue;
19.         })
20.         .onBlur(() => {
21.           this.color1 = Color.Yellow;
22.         })
23.       Divider()

24.       Text('focusable: ' + this.textFocusable)    // 第二个Text设置了focusable初始为true，focusableOnTouch为true
25.         .borderColor(this.color2)
26.         .borderWidth(2)
27.         .width(300)
28.         .height(70)
29.         .focusable(this.textFocusable)
30.         .focusOnTouch(true)
31.         .onFocus(() => {
32.           this.color2 = Color.Blue;
33.         })
34.         .onBlur(() => {
35.           this.color2 = Color.Yellow;
36.         })

37.       Text('enabled: ' + this.textEnabled)    // 第三个Text设置了focusable为true，enabled初始为true
38.         .borderColor(this.color3)
39.         .borderWidth(2)
40.         .width(300)
41.         .height(70)
42.         .focusable(true)
43.         .enabled(this.textEnabled)
44.         .focusOnTouch(true)
45.         .onFocus(() => {
46.           this.color3 = Color.Blue;
47.         })
48.         .onBlur(() => {
49.           this.color3 = Color.Yellow;
50.         })

51.       Divider()

52.       Row() {
53.         Button('Button1')
54.           .width(140).height(70)
55.         Button('Button2')
56.           .width(160).height(70)
57.       }

58.       Divider()
59.       Button('Button3')
60.         .width(300).height(70)

61.       Divider()
62.     }.width('100%').justifyContent(FlexAlign.Center)
63.     .onKeyEvent((e) => {
64.       // 绑定onKeyEvent，在该Column组件获焦时，按下'F'键，可将第二个Text的focusable置反
65.       if (e.keyCode === 2022 && e.type === KeyType.Down) {
66.         this.textFocusable = !this.textFocusable;
67.       }
68.       // 绑定onKeyEvent，在该Column组件获焦时，按下'G'键，可将第三个Text的enabled置反
69.       if (e.keyCode === 2023 && e.type === KeyType.Down) {
70.         this.textEnabled = !this.textEnabled;
71.       }
72.     })
73.   }
74. }

运行效果：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.77692462681152263010218841066401:50001231000000:2800:821560F89CE47B89CAC67FE96EA4378D2B6299D4A98A031FF90A35595DE234A7.gif)

上述示例包含以下3步：

- 第一个Text组件没有设置focusable(true)属性，该Text组件无法获焦。
- 点击第二个Text组件，由于设置了focusOnTouch(true)，第二个组件获焦。按下Tab键，触发走焦，仍然是第二个Text组件获焦。按键盘F键，触发onKeyEvent，focusable置为false，第二个Text组件变成不可获焦，焦点自动转移，会自动从Text组件寻找下一个可获焦组件，焦点转移到第三个Text组件上。
- 按键盘G键，触发onKeyEvent，enabled置为false，第三个Text组件变成不可获焦，焦点自动转移，使焦点转移到Row容器上，容器中使用的是默认配置，会转移到Button1上。

## 设置容器绘制焦点框

虽然容器组件本身可以获焦，但是无法绘制焦点框。可以为其配置onClick或是单指单击的Tap手势，在容器上绘制焦点框。

说明

容器绘制焦点框前提：

- 容器内部没有可获焦子节点。
- 容器配置有onClick或是单指单击的Tap手势。
- 容器本身未设置focusable属性，或设置在onClick或是单指单击的Tap手势之后。

1. @Entry
2. @Component
3. struct ScopeFocusExample {
4.   @State scopeFocusState: boolean = true;

5.   build() {
6.     Column() {
7.       Column({ space: 5 }) {
8.         Text("容器获焦").textAlign(TextAlign.Center)
9.       }
10.       .justifyContent(FlexAlign.Center)
11.       .width('80%')
12.       .height(50)
13.       .margin({ top: 5, bottom: 5 })
14.       .onClick(() => {
15.       })
16.       .focusable(this.scopeFocusState)

17.       Button('Button1')
18.         .width(140)
19.         .height(45)
20.         .margin(5)
21.         .onClick(() => {
22.           this.scopeFocusState = !this.scopeFocusState;
23.           console.info("Button1 onFocus");
24.         })
25.       Button('Button2')
26.         .width(140)
27.         .height(45)
28.         .margin(5)
29.     }.width('100%')
30.   }
31. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.61390750096022653274925250777580:50001231000000:2800:17D3AFFFCB1C7407042CFB9E83F2D269ADCF8995E5BC657952414F132BA6A133.gif)

上述示例包含以下2步：

- Column配置onClick事件并设置focusable为true后，Tab键走焦，Column容器可以绘制焦点框。
- 点击Button1，将Column的focusable属性设置为false，Column容器无法获焦和绘制焦点框。

## 设置焦点停留在容器上

1. tabStop(isTabStop: boolean)

设置当前容器组件的[tabStop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#tabstop14)属性，可决定在走焦时焦点是否会停留在当前容器。

1. @Entry
2. @Component
3. struct TabStopExample {
4.   build() {
5.     Column({ space: 20 }) {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5)
10.       Column() {
11.         Button('Button2')
12.           .width(140)
13.           .height(45)
14.           .margin(5)
15.         Button('Button3')
16.           .width(140)
17.           .height(45)
18.           .margin(5)
19.       }.tabStop(true)
20.     }.width('100%')
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.35783033853164192623377862907896:50001231000000:2800:B8ECB4F5993FD2B7F9F16BA17CE1F02135E1AC402720D20A65766F9877607A64.gif)

上述示例包含以下2步：

- Column配置tabStop后，Tab键走焦，焦点在Button1和Column容器之间切换，Column容器可以绘制焦点框。
- 走焦至Column容器后，按Enter键，焦点转移到容器中的第一个可获焦节点上。Tab键走焦，走焦至容器中其他可获焦节点。

## 默认焦点

### 层级页面的默认焦点

1. defaultFocus(value: boolean)

设置当前组件是否为当前[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)上的默认焦点。

1. // xxx.ets
2. @Entry
3. @Component
4. struct DefaultFocus {
5.   @State oneButtonColor: Color = Color.Gray;
6.   @State twoButtonColor: Color = Color.Gray;
7.   @State threeButtonColor: Color = Color.Gray;

8.   build() {
9.     Column({ space: 20 }) {
10.       // 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
11.       Button('First Button')
12.         .width(260)
13.         .height(70)
14.         .backgroundColor(this.oneButtonColor)
15.         .fontColor(Color.Black)
16.           // 监听第一个组件的获焦事件，获焦后改变颜色
17.         .onFocus(() => {
18.           this.oneButtonColor = Color.Green;
19.         })
20.           // 监听第一个组件的失焦事件，失焦后改变颜色
21.         .onBlur(() => {
22.           this.oneButtonColor = Color.Gray;
23.         })

24.       Button('Second Button')
25.         .width(260)
26.         .height(70)
27.         .backgroundColor(this.twoButtonColor)
28.         .fontColor(Color.Black)
29.           // 监听第二个组件的获焦事件，获焦后改变颜色
30.         .onFocus(() => {
31.           this.twoButtonColor = Color.Green;
32.         })
33.           // 监听第二个组件的失焦事件，失焦后改变颜色
34.         .onBlur(() => {
35.           this.twoButtonColor = Color.Gray;
36.         })

37.       Button('Third Button')
38.         .width(260)
39.         .height(70)
40.         .backgroundColor(this.threeButtonColor)
41.         .fontColor(Color.Black)
42.           // 设置默认焦点
43.         .defaultFocus(true)
44.           // 监听第三个组件的获焦事件，获焦后改变颜色
45.         .onFocus(() => {
46.           this.threeButtonColor = Color.Green;
47.         })
48.           // 监听第三个组件的失焦事件，失焦后改变颜色
49.         .onBlur(() => {
50.           this.threeButtonColor = Color.Gray ;
51.         })
52.     }.width('100%').margin({ top: 20 })
53.   }
54. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.11434695702020431751981205129526:50001231000000:2800:322DB4B30F0ED83E3AAA77A335ECA052870AC82530F1B6AC42C7A07A4B6956A8.gif)

上述示例包含以下2步：

- 在第三个Button组件上设置了defaultFocus(true)，进入[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)后第三个Button默认获焦，显示为绿色。
- 按下Tab键，触发走焦，第三个Button正处于获焦状态，会出现焦点框。

### 容器的默认焦点

容器的默认焦点受到[获焦优先级](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E7%84%A6%E7%82%B9%E7%BB%84%E4%B8%8E%E8%8E%B7%E7%84%A6%E4%BC%98%E5%85%88%E7%BA%A7)的影响。

**defaultFocus与FocusPriority的区别**

[defaultFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#defaultfocus9)是用于指定[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次展示时的默认获焦节点，[FocusPriority](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focuspriority12)是用于指定某个容器首次获焦时其子节点的获焦优先级。上述两个属性在某些场景同时配置时行为未定义，例如下面的场景，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次展示无法同时满足defaultFocus获焦和高优先级组件获焦。

示例

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Row() {
6.       Button('Button1')
7.         .defaultFocus(true)
8.       Button('Button2')
9.         .focusScopePriority('RowScope', FocusPriority.PREVIOUS)
10.     }.focusScopeId('RowScope')
11.   }
12. }

### 层级页面/容器整体获焦时的焦点链

**整体获焦与非整体获焦**

- 整体获焦是[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)/容器自身作为焦点链的叶节点获焦，获焦后再把焦点链叶节点转移到子孙组件。例如，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换、Navigation组件中的路由切换、焦点组走焦、容器组件主动调用requestFocusById等。
    
- 非整体获焦是某个组件作为焦点链叶节点获焦，导致其祖先节点跟着获焦。例如TextInput组件主动获取焦点、Tab键在非焦点组场景下走焦等。
    

**整体获焦的焦点链形成**

1.[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次获焦：

- 焦点链叶节点为配置了defaultFocus的节点。
    
- 未配置defaultFocus时，焦点停留在[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的根容器上。
    

2.[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)非首次获焦：由上次获焦的节点获焦。

3.获焦链上存在配置了获焦优先级的组件和容器：

- 容器内存在优先级大于PREVIOUS的组件，由优先级最高的组件获焦。
    
- 容器内不存在优先级大于PREVIOUS的组件，由上次获焦的节点获焦。例如，窗口失焦后重新获焦。
    

## 焦点样式

说明

最终绘制焦点激活态的组件的[zIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-z-order#zindex)默认会被抬升至INT_MAX，如果该组件已经配置了zIndex，则不做zIndex调整。该组件不再绘制焦点激活态时，例如组件失焦或是退出走焦态，zIndex恢复为默认层级。

1. focusBox(style: FocusBoxStyle)

设置当前组件系统焦点框样式。

1. import { ColorMetrics, LengthMetrics } from '@kit.ArkUI'

2. @Entry
3. @Component
4. struct RequestFocusExample {
5.   build() {
6.     Column({ space: 30 }) {
7.       Button("small black focus box")
8.         .focusBox({
9.           margin: new LengthMetrics(0),
10.           strokeColor: ColorMetrics.rgba(0, 0, 0),
11.         })
12.       Button("large red focus box")
13.         .focusBox({
14.           margin: LengthMetrics.px(20),
15.           strokeColor: ColorMetrics.rgba(255, 0, 0),
16.           strokeWidth: LengthMetrics.px(10)
17.         })
18.     }
19.     .alignItems(HorizontalAlign.Center)
20.     .width('100%')
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.41659777254987774270453555000048:50001231000000:2800:0862308711451414B1C8A4C333F2EC8AFECE1178101C4168E6CD1CB86DECC739.gif)

上述示例包含以下2步：

- 进入[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)，按下Tab键触发走焦，第一个Button获焦，焦点框样式为紧贴边缘的黑色细框。
- 按下Tab键，走焦到第二个Button，焦点框样式为远离边缘的红色粗框。

## 主动获焦/失焦

- 使用FocusController中的方法
    
    更推荐使用FocusController中的requestFocus主动获取焦点。优势如下：
    
    - 当前帧生效，避免被下一帧组件树变化影响。
    - 有异常值返回，便于排查主动获取焦点失败的原因。
    - 避免多实例场景中取到错误实例。
    
    需先使用UIContext中的[getFocusController()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getfocuscontroller12)方法获取实例，再通过此实例调用对应方法。
    
    1. requestFocus(key: string): void
    
    通过组件的id将焦点转移到组件树对应的实体节点，生效时间为当帧生效。
    
    2. clearFocus(): void
    
    清除焦点，将焦点强制转移到层级页面根容器节点，焦点链路上其他节点失焦。
    
- 使用focusControl中的方法
    
    1. requestFocus(value: string): boolean
    
    调用此接口可以主动让焦点转移至参数指定的组件上，焦点转移生效时间为下一个帧信号。
    

1. // focusTest.ets
2. @Entry
3. @Component
4. struct RequestExample {
5.   @State btColor: string = '#ff2787d9'
6.   @State btColor2: string = '#ff2787d9'

7.   build() {
8.     Column({ space: 20 }) {
9.       Column({ space: 5 }) {
10.         Button('Button')
11.           .width(200)
12.           .height(70)
13.           .fontColor(Color.White)
14.           .focusOnTouch(true)
15.           .backgroundColor(this.btColor)
16.           .onFocus(() => {
17.             this.btColor = '#ffd5d5d5'
18.           })
19.           .onBlur(() => {
20.             this.btColor = '#ff2787d9'
21.           })
22.           .id("testButton")

23.         Button('Button')
24.           .width(200)
25.           .height(70)
26.           .fontColor(Color.White)
27.           .focusOnTouch(true)
28.           .backgroundColor(this.btColor2)
29.           .onFocus(() => {
30.             this.btColor2 = '#ffd5d5d5'
31.           })
32.           .onBlur(() => {
33.             this.btColor2 = '#ff2787d9'
34.           })
35.           .id("testButton2")

36.         Divider()
37.           .vertical(false)
38.           .width("80%")
39.           .backgroundColor('#ff707070')
40.           .height(10)

41.         Button('FocusController.requestFocus')
42.           .width(200).height(70).fontColor(Color.White)
43.           .onClick(() => {
44.             this.getUIContext().getFocusController().requestFocus("testButton")
45.           })
46.           .backgroundColor('#ff2787d9')

47.         Button("focusControl.requestFocus")
48.           .width(200).height(70).fontColor(Color.White)
49.           .onClick(() => {
50.             focusControl.requestFocus("testButton2")
51.           })
52.           .backgroundColor('#ff2787d9')

53.         Button("clearFocus")
54.           .width(200).height(70).fontColor(Color.White)
55.           .onClick(() => {
56.             this.getUIContext().getFocusController().clearFocus()
57.           })
58.           .backgroundColor('#ff2787d9')
59.       }
60.     }
61.     .width('100%')
62.     .height('100%')
63.   }
64. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.97740767440526976787540854945747:50001231000000:2800:C4111BC36B6599D652AAD9B820B0FEE1A7BD6AFECE500CF4A784BEE49847629C.gif)

上述示例包含以下3步：

- 点击FocusController.requestFocus按钮，第一个Button获焦。
- 点击focusControl.requestFocus按钮，第二个Button获焦。
- 点击clearFocus按钮，第二个Button失焦。

## 自定义组件走焦顺序

### nextFocus自定义走焦

1. nextFocus(nextStep: Optional<FocusMovement>): T

若存在配置了nextFocus的组件，则走焦只会按照设置的nextFocus走焦顺序走焦，没有设置自定义走焦或者设置自定义走焦的组件或容器不存在时，仍进行默认走焦规则。

说明

- 该能力从API version 18开始支持。

1. @Entry
2. @Component
3. struct NextFocusExample {
4.   build() {
5.     Column({space: 30}) {
6.       Row().height('30%')
7.       Row({space: 10}) {
8.         Button('A')
9.           .id('A')
10.           .nextFocus({forward: 'F', backward: 'C', down: 'B'})
11.         Button('B')
12.           .id('B')
13.           .nextFocus({ down: 'C'})
14.         Button('C')
15.           .id('C')
16.       }
17.       Column({space: 10}) {
18.         Button('D')
19.           .id('D')
20.         Button('E')
21.           .id('E')
22.           .nextFocus({forward: 'A', backward: 'M', up: 'E', right: 'F'})
23.       }
24.       Row({space: 10}) {
25.         Button('F')
26.           .id('F')
27.           .nextFocus({forward: 'B', down: 'A'});
28.       }
29.     }.width('100%')
30.   }
31. }

Tab键走焦：未配置nextFocus时，Tab键走焦顺序为A->B->C->D->E->F。配置nextFocus之后，Tab键走焦顺序为A->F->B->C->D->E->A。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.20924133050221638703423866142948:50001231000000:2800:A7FF473C58FAE4F1FCC3563D60F8184EB25A28FCAD6CE46F024BADC91C50F26D.gif)

方向键走焦（以方向下键为例）：未配置nextFocus时，按下Tab键激活焦点态之后，按方向下键走焦顺序为A->D->E->F。配置nextFocus之后，按下Tab键激活焦点态之后，按方向下键走焦顺序为A->B->C->D->E->F->A。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.69993108034770259696033359880898:50001231000000:2800:187B5FED65D1B965936745D8590407F8E5EBFD7FE0D0DE4C8F896840C9C889D5.gif)

### tabIndex自定义走焦

1. tabIndex(index: number)

tabIndex自定义组件Tab键走焦顺序。

若存在配置了tabIndex大于0的组件，则Tab键走焦只会在tabIndex大于0的组件内，按照tabIndex的值从小到大并循环依次走焦。若没有配置tabIndex大于0的组件，则tabIndex等于0的组件按照组件预设的走焦规则走焦。

说明

不能同时设置tabIndex与focusScopeId属性。

不建议在[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)中通过单独设置组件的tabIndex属性为负数来控制获焦能力，可以使用focusable属性代替。

tabIndex只能够自定义Tab键走焦，若想同时自定义方向键等走焦能力，建议使用[nextfocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#nextfocus%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%B0%E7%84%A6)。

1. @Entry
2. @Component
3. struct TabIndexExample {
4.   build() {
5.     Column() {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5)
10.       Button('Focus Button1')
11.         .width(140)
12.         .height(45)
13.         .margin(5).tabIndex(1)
14.       Button('Button2')
15.         .width(140)
16.         .height(45)
17.         .margin(5)
18.       Button('Focus Button2')
19.         .width(140)
20.         .height(45)
21.         .margin(5).tabIndex(2)
22.     }.width('100%')
23.   }
24. }

Tab键走焦：只在配置TabIndex的节点间循环走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.51486502427571866865317321931093:50001231000000:2800:7727C38FC3CB8C864A63CD85F9834DD5A5271CC7D3BAA52A8D7B7CB6282B2D72.gif)

tabIndex配置在容器上时，如果容器中的所有组件都没有获焦过，则走到第一个可获焦组件上，否则会走到上次获焦的节点。

1. @Entry
2. @Component
3. struct TabIndexExample2 {
4.   build() {
5.     Column() {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5).tabIndex(1)
10.       Column() {
11.         Button('Button2')
12.           .width(140)
13.           .height(45)
14.           .margin(5)
15.         Button('Button3')
16.           .width(140)
17.           .height(45)
18.           .margin(5)
19.       }.tabIndex(2)
20.     }.width('100%')
21.   }
22. }

Tab键走焦：tabIndex配置在容器上。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.69766945152546567976053498676098:50001231000000:2800:1227629C5419CD56ED0276905759A77E7CE436AB4F347F73D331CA0E31640728.gif)

上述示例包含以下3步：

- 使用Tab走焦，焦点在Button1和Button2之间循环走焦（tabIndex配置在Button2和Button3的父组件上）。
- 在走焦至Button2时，使用方向下键，将焦点转移至Button3上。
- 使用Tab走焦，焦点在Button1和Button3之间循环走焦。

## 焦点组与获焦优先级

1. focusScopePriority(scopeId: string, priority?: FocusPriority)

设置当前组件在指定容器内获焦的优先级。需要配合focusScopeId一起使用。

1. focusScopeId(id: string, isGroup?: boolean)

设置当前容器组件的id标识，设置当前容器组件是否为焦点组。焦点组与tabIndex不能混用。

1. // focusTest.ets
2. @Entry
3. @Component
4. struct FocusableExample {
5.   @State inputValue: string = ''

6.   build() {
7.     Scroll() {
8.       Row({ space: 20 }) {
9.         Column({ space: 20 }) {  // 标记为Column1
10.           Column({ space: 5 }) {
11.             Button('Group1')
12.               .width(165)
13.               .height(40)
14.               .fontColor(Color.White)
15.             Row({ space: 5 }) {
16.               Button()
17.                 .width(80)
18.                 .height(40)
19.                 .fontColor(Color.White)
20.               Button()
21.                 .width(80)
22.                 .height(40)
23.                 .fontColor(Color.White)
24.             }
25.             Row({ space: 5 }) {
26.               Button()
27.                 .width(80)
28.                 .height(40)
29.                 .fontColor(Color.White)
30.               Button()
31.                 .width(80)
32.                 .height(40)
33.                 .fontColor(Color.White)
34.             }
35.           }.borderWidth(2).borderColor(Color.Red).borderStyle(BorderStyle.Dashed)
36.           Column({ space: 5 }) {
37.             Button('Group2')
38.               .width(165)
39.               .height(40)
40.               .fontColor(Color.White)
41.             Row({ space: 5 }) {
42.               Button()
43.                 .width(80)
44.                 .height(40)
45.                 .fontColor(Color.White)
46.               Button()
47.                 .width(80)
48.                 .height(40)
49.                 .fontColor(Color.White)
50.                 .focusScopePriority('ColumnScope1', FocusPriority.PRIOR)  // Column1首次获焦时获焦
51.             }
52.             Row({ space: 5 }) {
53.               Button()
54.                 .width(80)
55.                 .height(40)
56.                 .fontColor(Color.White)
57.               Button()
58.                 .width(80)
59.                 .height(40)
60.                 .fontColor(Color.White)
61.             }
62.           }.borderWidth(2).borderColor(Color.Green).borderStyle(BorderStyle.Dashed)
63.         }
64.         .focusScopeId('ColumnScope1')
65.         Column({ space: 5 }) {  // 标记为Column2
66.           TextInput({placeholder: 'input', text: this.inputValue})
67.             .onChange((value: string) => {
68.               this.inputValue = value
69.             })
70.             .width(156)
71.           Button('Group3')
72.             .width(165)
73.             .height(40)
74.             .fontColor(Color.White)
75.           Row({ space: 5 }) {
76.             Button()
77.               .width(80)
78.               .height(40)
79.               .fontColor(Color.White)
80.             Button()
81.               .width(80)
82.               .height(40)
83.               .fontColor(Color.White)
84.           }
85.           Button()
86.             .width(165)
87.             .height(40)
88.             .fontColor(Color.White)
89.             .focusScopePriority('ColumnScope2', FocusPriority.PREVIOUS)  // Column2获焦时获焦
90.           Row({ space: 5 }) {
91.             Button()
92.               .width(80)
93.               .height(40)
94.               .fontColor(Color.White)
95.             Button()
96.               .width(80)
97.               .height(40)
98.               .fontColor(Color.White)
99.           }
100.           Button()
101.             .width(165)
102.             .height(40)
103.             .fontColor(Color.White)
104.           Row({ space: 5 }) {
105.             Button()
106.               .width(80)
107.               .height(40)
108.               .fontColor(Color.White)
109.             Button()
110.               .width(80)
111.               .height(40)
112.               .fontColor(Color.White)
113.           }
114.         }.borderWidth(2).borderColor(Color.Orange).borderStyle(BorderStyle.Dashed)
115.         .focusScopeId('ColumnScope2', true)  // Column2为焦点组
116.       }.alignItems(VerticalAlign.Top)
117.     }
118.   }
119. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.64806538796341658333103812050250:50001231000000:2800:EC2AFA4424A6D3CF197AEA756844A99A0D5998879164DD7B3A3F962297C16886.gif)

上述示例包含以下2步：

- input方框内设置了焦点组，因此按下Tab键后焦点会快速从input中走出去，而按下方向键后可以在input内走焦。
- 左侧的两个Column没有设置焦点组，因此只能通过Tab键一个一个地走焦。

在API version 14，焦点组新增参数arrowStepOut，用于设置能否使用方向键走焦出当前焦点组。

1. focusScopeId(id: string, isGroup?: boolean, arrowStepOut?: boolean)

2. @Entry
3. @Component
4. struct FocusScopeIdExample {
5.   build() {
6.     Column({ space: 20 }) {
7.       Column() {
8.         Button('Group1')
9.           .width(165)
10.           .height(40)
11.           .margin(5)
12.           .fontColor(Color.White)
13.         Row({ space: 5 }) {
14.           Button("Button1")
15.             .width(80)
16.             .height(40)
17.             .margin(5)
18.             .fontColor(Color.White)
19.           Button("Button2")
20.             .width(80)
21.             .height(40)
22.             .margin(5)
23.             .fontColor(Color.White)
24.         }
25.       }.focusScopeId("1", true, true)
26.       .borderWidth(2).borderColor(Color.Red).borderStyle(BorderStyle.Dashed)

27.       TextInput()
28.       Column() {
29.         Button('Group2')
30.           .width(165)
31.           .height(40)
32.           .margin(5)
33.           .fontColor(Color.White)
34.         Row({ space: 5 }) {
35.           Button("Button3")
36.             .width(80)
37.             .height(40)
38.             .margin(5)
39.             .fontColor(Color.White)
40.           Button("Button4")
41.             .width(80)
42.             .height(40)
43.             .margin(5)
44.             .fontColor(Color.White)
45.         }
46.       }.focusScopeId("2", true, false)
47.       .borderWidth(2).borderColor(Color.Green).borderStyle(BorderStyle.Dashed)

48.       TextInput()
49.     }.width('100%')
50.   }
51. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.13720911488363316597969965400768:50001231000000:2800:B1645C8A8DD2A142F05ACC95A832E3A35135371FECA4232599E65C4EE6347BE0.gif)

上述示例包含以下3步：

- Group1和Group2设置焦点组，因此按下Tab键后焦点会快速从Group1和Group2的方框内走出。
- Group1设置焦点组时，允许使用方向键走焦出当前焦点组。在Group1方框内走焦时，使用方向键可以走焦至input输入框。
- Group2设置焦点组时，不允许使用方向键走焦出当前焦点组。在Group2方框内走焦时，使用方向键无法走焦至input输入框。

说明

TextInput组件本身对方向键存在独有处理，因此无法使用方向键直接走出TextInput组件。

## 焦点与按键事件

当组件获焦且存在点击事件（onClick）或单指单击事件（TapGesture）时，回车和空格会触发对应的事件回调。

说明

1. 点击事件（onClick）或单指单击事件（TapGesture）在回车、空格触发对应事件回调时，默认不冒泡传递，即父组件对应[按键事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key)不会被同步触发。
2. 按键事件（onKeyEvent）默认冒泡传递，即同时会触发父组件的按键事件回调。
3. 组件同时存在点击事件（onClick）和按键事件（onKeyEvent），在回车、空格触发时，两者都会响应。
4. 获焦组件响应点击事件（onClick），与焦点激活态无关。

5. @Entry
6. @Component
7. struct FocusOnclickExample {
8.   @State count: number = 0
9.   @State name: string = 'Button'

10.   build() {
11.     Column() {
12.       Button(this.name)
13.         .fontSize(30)
14.         .onClick(() => {
15.           this.count++
16.           if (this.count % 2 === 0) {
17.             this.name = "count is even number"
18.           } else {
19.             this.name = "count is odd number"
20.           }
21.         }).height(60)
22.     }.height('100%').width('100%').justifyContent(FlexAlign.Center)
23.   }
24. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.65037606847477599416505461065922:50001231000000:2800:D5B7A9701BBA829A663F0AA9D0472DC2D193783B3A62BCD229339C7E92B9B212.gif)

## 组件获焦能力说明

**表1** 基础组件获焦能力

|基础组件|是否有获焦能力|focusable默认值|
|:--|:--|:--|
|[AlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-alphabet-indexer)|是|true|
|[Blank](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-blank)|否|false|
|[Button](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button)|是|true|
|[CalendarPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-calendarpicker)|是|true|
|[Checkbox](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-checkbox)|是|true|
|[CheckboxGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-checkboxgroup)|是|true|
|[ContainerSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-containerspan)|否|false|
|[DataPanel](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datapanel)|是|false|
|[DatePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datepicker)|是|true|
|[Divider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-divider)|是|false|
|[Gauge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-gauge)|是|false|
|[Image](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image)|是|false|
|[ImageAnimator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imageanimator)|否|false|
|[ImageSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imagespan)|否|false|
|[LoadingProgress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-loadingprogress)|是|true|
|[Marquee](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-marquee)|否|false|
|[Menu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menu)|是|true|
|[MenuItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menuitem)|是|true|
|[MenuItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menuitemgroup)|否|false|
|[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)|是|true|
|[NavRouter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navrouter)|否|false|
|[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)|是|true|
|[PatternLock](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-patternlock)|是|true|
|[Progress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-progress)|是|true|
|[QRCode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-qrcode)|是|true|
|[Radio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-radio)|是|true|
|[Rating](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-rating)|是|true|
|[RichEditor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor)|是|true|
|[RichText](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richtext)|否|false|
|[ScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar)|否|false|
|[Search](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search)|是|true|
|[Select](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-select)|是|true|
|[Slider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-slider)|是|true|
|[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)|否|false|
|[Stepper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-stepper)|是|true|
|[StepperItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-stepperitem)|是|true|
|[SymbolSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan)|否|false|
|[SymbolGlyph](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph)|否|false|
|[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)|是|false|
|[TextArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea)|是|true|
|[TextClock](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textclock)|否|false|
|[TextInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput)|是|true|
|[TextPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textpicker)|是|true|
|[TextTimer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-texttimer)|否|false|
|[TimePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker)|否|false|
|[Toggle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-toggle)|是|true|
|[XComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent)|是|false|

**表2** 容器组件获焦能力

|容器组件|是否可获焦|focusable默认值|
|:--|:--|:--|
|[Badge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-badge)|否|false|
|[Column](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-column)|是|true|
|[ColumnSplit](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-columnsplit)|是|true|
|[Counter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-counter)|是|false|
|[EmbeddedComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-embedded-component)|否|false|
|[Flex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flex)|是|true|
|[FlowItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flowitem)|是|true|
|[FolderStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-folderstack)|是|true|
|[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)|否|false|
|[GridCol](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridcol)|是|true|
|[GridRow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridrow)|是|true|
|[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)|是|true|
|[GridItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-griditem)|是|true|
|[Hyperlink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-hyperlink)|是|true|
|[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)|是|true|
|[ListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitem)|是|true|
|[ListItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitemgroup)|是|true|
|[Navigator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-navigator)|是|true|
|[Refresh](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-refresh)|是|true|
|[RelativeContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-relativecontainer)|否|false|
|[Row](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-row)|是|true|
|[RowSplit](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-rowsplit)|是|true|
|[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)|是|true|
|[SideBarContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer)|是|true|
|[Stack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-stack)|是|true|
|[Swiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper)|是|true|
|[Tabs](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs)|是|true|
|[TabContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabcontent)|是|true|
|[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)|否|false|
|[WithTheme](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-with-theme)|是|true|

**表3** 媒体组件获焦能力

|媒体组件|是否可获焦|focusable默认值|
|:--|:--|:--|
|[Video](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-media-components-video)|是|true|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-drag-event "支持统一拖拽")
