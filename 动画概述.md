# 支持焦点处理

更新时间: 2025-12-16 16:40

## 基础概念与规范

### 基础概念

**焦点、焦点链和走焦**

- 焦点：指向当前应用界面上唯一的一个可交互元素，当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入设备与应用程序进行间接交互时，基于焦点的导航和交互是重要的输入手段。
- 焦点链：在应用的组件树形结构中，当一个组件获得焦点时，从根节点到该组件节点的整条路径上的所有节点都会处于焦点状态，形成一条连续的焦点链。
- 走焦：指焦点在应用内的组件之间转移的行为。这一过程对用户是透明的，但开发者可以通过监听onFocus（焦点获取）和onBlur（焦点失去）事件来捕捉这些变化。关于走焦的具体方式和规则，详见[走焦规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)。

**焦点激活态**

焦点激活态是用来显示当前获焦组件焦点框的视觉样式。

- 显示规则
    
    - 默认状态：焦点激活态默认是隐藏的。
    - 激活条件：只有当应用程序进入"激活态"时，焦点激活态才会显示。
    - 重要关系：
        - 获得焦点的组件不一定显示激活态（取决于应用是否处于激活态）。
        - 显示激活态的组件必定是当前获得焦点的组件。
    - 样式定制：组件通常有内置的激活态样式，开发者可以通过样式接口自定义，自定义后会覆盖默认样式。
    - 显示优先级：当多个组件同时拥有焦点时，系统优先显示子组件的激活态，且同一时间只显示一个激活态。
- 如何进入激活态
    
    - 按下外接键盘的Tab键（注意：首次激活时的Tab键仅用于激活，不会触发焦点移动）。
    - 调用[FocusController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller)的activate(true)方法。
- 如何退出激活态
    
    - 调用FocusController的activate(false)方法。
    - 发生点击事件时（包括触屏点击或鼠标左键点击）。

1. @Entry
2. @Component
3. struct FocusActiveExample {
4.   build() {
5.     Column() {
6.       Button('Set Active').width(140).height(45).margin(5).onClick(() => {
7.         this.getUIContext().getFocusController().activate(true, true);
8.       })
9.       Button('Set Not Active').width(140).height(45).margin(5).onClick(() => {
10.         this.getUIContext().getFocusController().activate(false, true);
11.       })
12.     }.width('100%')
13.   }
14. }

按下Tab键，焦点激活态显示。点击鼠标退出焦点激活态。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.87842322685467604801662793724140:50001231000000:2800:F79231A05F00351B00E30E0E178E821E7B61603CF2446DF97F7B7044B73F16AF.gif)

调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口进入和退出焦点激活态。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.56410181471804487464553871116694:50001231000000:2800:B9AF31DF6E88F1EF74E19E6C5C4AC404F63960C550E3B870F0FF0479990817D0.gif)

示例操作步骤：

1. 点击Set Active按钮，调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口进入焦点激活态。
2. Tab走焦至Set Not Active按钮，Enter键触发按键事件，调用[activate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#activate14)接口退出焦点激活态。

**层级页面**

层级页面是焦点框架中特定容器组件的统称，涵盖Page、Dialog、SheetPage、ModalPage、Menu、Popup、NavBar、NavDestination等。这些组件通常具有以下关键特性：

- 视觉层级独立性：从视觉呈现上看，这些组件独立于其他页面内容，并通常位于其上方，形成视觉上的层级差异。
- 焦点跟随：此类组件在首次创建并展示之后，会立即将应用内焦点抢占。
- 走焦范围限制：当焦点位于这些组件内部时，用户无法通过键盘按键将焦点转移到组件外部的其他元素上，焦点移动仅限于组件内部。

在一个应用程序中，任何时候都至少存在一个层级页面组件，并且该组件会持有当前焦点。当该层级页面关闭或不再可见时，焦点会自动转移到下一个可用的层级页面组件上，确保用户交互的连贯性和一致性。

说明

Popup组件在focusable属性（组件属性，非通用属性）为false的时候，不会有第2条特性。

NavBar、NavDestination没有第3条特性，对于它们的走焦范围，是与它们的首个父层级页面相同的。

**根容器**

根容器是[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)内的概念，当某个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次创建并展示时，根据[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的特性，焦点会立即被该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)抢占。此时，该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)所在焦点链的末端节点将成为默认焦点，而这个默认焦点通常位于该[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的根容器上。

在缺省状态下，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的默认焦点位于其根容器上，但开发者可以通过defaultFocus属性来自定义这一行为。

当焦点位于根容器时，首次按下Tab键不仅会使焦点进入激活状态，还会根据[焦点传递规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E7%84%A6%E7%82%B9%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99)进行传递。

### 焦点传递规则

焦点传递是指当用户首次激活应用焦点系统时，焦点如何从根节点逐级向下传递到具体组件的过程。

在焦点链上的组件，都会处于获焦状态。同时组件在获焦时，会继续向下递归传递获焦状态，每次传递给第一个子组件，直到叶子节点。

1. @Entry
2. struct Index {
3.   @State logText: string = '\n';

4.   addText(message: string) {
5.     this.logText += `${message}\n`;
6.   }

7.   build() {
8.     Column() {
9.       Row() {
10.         Column() {
11.           Button("Button 1")
12.             .margin(20)
13.             .onClick(() => {
14.               this.logText = '获焦信息：\n';
15.               this.getUIContext().getFocusController().requestFocus("Row 2")
16.             })
17.         }
18.       }

19.       Column() {
20.         Row() {
21.           Button("Button 2")
22.             .margin(20)
23.             .onFocus(() => {
24.               this.addText("Button 2 获得焦点");
25.             })
26.           Button("button 3")
27.             .margin(20)
28.             .onFocus(() => {
29.               this.addText("Button 3 获得焦点");
30.             })
31.         }
32.         .id("Row 2")
33.         .onFocus(() => {
34.           this.addText("Row 2 获得焦点");
35.         })
36.       }
37.       .onFocus(() => {
38.         this.addText("Column 2 获得焦点");
39.       })

40.       Scroll() {
41.         Text(this.logText)
42.           .fontSize(14)
43.           .textAlign(TextAlign.Start)
44.           .padding(10)
45.       }
46.       .height('40%')
47.       .width('100%')
48.       .border({ width: 1, color: '#ccc' })
49.       .margin(10)
50.     }
51.     .height('100%')
52.     .padding(20)
53.   }
54. }

运行后点击Button1，请求焦点给Row组件，Row组件的第一个可获焦子节点Button2获焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.33657945635981072347038409626891:50001231000000:2800:4AF361753D70D731C596C35F5ADA25F3A0DD33C8F2AF8B41A1F3F1AA8DAB5261.gif)

### 走焦规范

根据走焦的触发方式，可以分为主动走焦和被动走焦。

**主动走焦**

指开发者/用户主观行为导致的焦点移动，包括：使用外接键盘的按键走焦（Tab键/Shift+Tab键/方向键）、使用requestFocus申请焦点、clearFocus清除焦点、focusOnTouch点击申请焦点等接口导致的焦点转移。

- 按键走焦

1. 前提：当前应用需处于焦点激活态。
2. 范围限制：按键走焦仅在当前获得焦点的层级页面内进行，具体参见“层级页面”中的“走焦范围限制”部分。
3. 按键类型：
    
    Tab键：遵循Z字型遍历逻辑，完成当前范围内所有叶子节点的遍历，到达当前范围内的最后一个组件后，继续按下Tab键，焦点将循环至范围内的第一个可获焦组件，实现循环走焦。
    
    Shift+Tab键：与Tab键具有相反的焦点转移效果。
    
    方向键（上、下、左、右）：遵循十字型移动策略，在单层容器中，焦点的转移由该容器的特定走焦算法决定。若算法判定下一个焦点应落在某个容器组件上，系统将采用中心点距离优先的算法来进一步确定容器内的目标子节点。
    
4. 走焦算法：每个可获焦的容器组件都有其特定的走焦算法，用于定义焦点转移的规则。
5. 子组件优先：当子组件处理按键走焦事件，父组件将不再介入。

- requestFocus
    
    详见[主动获焦失焦](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E4%B8%BB%E5%8A%A8%E8%8E%B7%E7%84%A6%E5%A4%B1%E7%84%A6)，可以主动将焦点转移到指定组件上。
    
    不可跨窗口或跨ArkUI实例申请焦点，但可以跨层级页面申请焦点。
    
- clearFocus
    
    详见[clearFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-focuscontroller#clearfocus12)，会清除当前层级页面中的焦点，最终焦点停留在根容器上。
    
- focusOnTouch
    
    详见[focusOnTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focusontouch9)，使绑定组件具备点击后获得焦点的能力。若组件本身不可获焦，则此功能无效。若绑定的是容器组件，点击后优先将焦点转移给上一次获焦的子组件，否则转移给第一个可获焦的子组件。
    

**被动走焦**

被动走焦是指组件焦点因系统或其他操作而自动转移，无需开发者直接干预，这是焦点系统的默认行为。

目前会被动走焦的机制有：

- 组件删除：当处于焦点状态的组件被删除时，焦点框架首先尝试将焦点转移到相邻的兄弟组件上，遵循先向后再向前的顺序。若所有兄弟组件均不可获焦，则焦点将释放，并通知其父组件进行焦点处理。
- 属性变更：若将处于焦点状态的组件的focusable或enabled属性设置为false，或者将visibility属性设置为不可见，系统将自动转移焦点至其他可获焦组件，转移方式与1中相同。
- [层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换：当发生[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换时，如从一个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)跳转到另一个[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)，当前[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的焦点将自动释放，新[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)可能会根据预设逻辑自动获得焦点。
- Web组件初始化：对于Web组件，当其被创建时，若其设计需要立即获得焦点（如某些弹出框或输入框），则可能触发焦点转移至该Web组件，其行为属于组件自身的行为逻辑，不属于焦点框架的规格范围。

### 走焦算法

在焦点管理系统中，每个可获焦的容器都配备有特定的走焦算法，这些算法定义了当使用Tab键、Shift+Tab键或方向键时，焦点如何从当前获焦的子组件转移到下一个可获焦的子组件。

容器采用何种走焦算法取决于其UX（用户体验）规格，并由容器组件进行适配。目前，焦点框架支持三种走焦算法：线性走焦、投影走焦和自定义走焦。

**线性走焦算法**

线性走焦算法是默认的走焦策略，它基于容器中子节点在节点树中的挂载顺序进行走焦，常用于单方向布局的容器，如Row、Column和Flex容器。运行规则如下：

- 顺序依赖：走焦顺序完全基于子节点在节点树中的挂载顺序，与它们在界面上的实际布局位置无关。
- Tab键走焦：使用Tab键时，焦点将按照子节点的挂载顺序依次遍历。
- 方向键走焦：当使用与容器定义方向垂直的方向键时，容器不接受该方向的走焦请求。例如，在横向的Row容器中，无法使用方向键进行上下移动。
- 边界处理：当焦点位于容器的首尾子节点时，容器将拒绝与当前焦点方向相反的方向键走焦请求。例如，焦点在一个横向的Row容器的第一个子节点上时，该容器无法处理方向键左的走焦请求。

1. @Entry
2. @Component
3. struct FocusLinerExample {
4.   build() {
5.     Column() {
6.       Column() {
7.         Button("Column Button1")
8.           .width(150)
9.           .height(45)
10.           .fontColor(Color.White)
11.           .margin(10)
12.         Button("Column Button2")
13.           .width(150)
14.           .height(45)
15.           .fontColor(Color.White)
16.           .margin(10)
17.       }
18.       .margin(10)

19.       Row() {
20.         Button("Row Button1")
21.           .width(150)
22.           .height(45)
23.           .fontColor(Color.White)
24.           .margin(10)
25.         Button("Row Button2")
26.           .width(150)
27.           .height(45)
28.           .fontColor(Color.White)
29.           .margin(10)
30.       }
31.     }
32.   }
33. }

Tab键走焦：按照子节点的挂载顺序循环走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.67763606112505332746852831470376:50001231000000:2800:3474F13A44F978CEDACCDCDEFADB731AE35151ADF818AC223554A3A1C20AA57F.gif)

方向键上下走焦：纵向的Column容器中，可以使用上下键走焦，无法使用左右键走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.65394565649527609025701911760515:50001231000000:2800:B6FDAA2D053B02C6A05B0C18A76E9DA9F17CCC3B2937E582FCFBB48305BE228E.gif)

横向的Row容器中，可以使用左右键走焦，无法使用上下键走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.13418426341066464548754278051935:50001231000000:2800:4C09B3DCA4983F4AA999C84552394346370C3ED04C8699F1B6324034F575302C.gif)

**投影走焦算法**

投影走焦算法基于当前获焦组件在走焦方向上的投影，结合子组件与投影的重叠面积和中心点距离进行胜出判定。该算法适用于子组件大小不一的容器，目前仅支持配置了wrap属性的Flex组件。运行规则如下：

- 方向键走焦时，判断投影与子组件区域的重叠面积，在所有面积不为0的子组件中，计算它们与当前获焦组件的中心点直线距离，选择距离最短的子组件。若存在多个备选子组件，则选择节点树上更靠前的子组件。若无任何子组件与投影有重叠，说明该容器无法处理该方向键的走焦请求。
- Tab键走焦时，先使用规格1，按照方向键右进行判定，若找到则成功退出，若无法找到，则将当前获焦子组件的位置模拟往下移动该获焦子组件的高度，然后再按照方向键左进行投影判定，有投影重叠且中心点直线距离最近的子组件胜出，若无投影重叠的子组件，则表示该容器无法处理本次Tab键走焦请求。
- Shift+Tab键走焦时，先使用规格1，按照方向键左进行判定，找到则成功退出。若无法找到，则将当前获焦子组件的位置模拟向上移动该获焦子组件的高度，然后再按照方向键右进行投影判定，有投影重叠且中心点直线距离最近的子组件胜出，若无投影重叠的子组件，则表示该容器无法处理本次的Shift+Tab键走焦请求。

1. @Entry
2. @Component
3. struct ProjectAreaFocusExample {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Text('Wrap').fontSize(12).width('90%')
8.         // 子组件多行布局
9.         Flex({ wrap: FlexWrap.Wrap }) {
10.           Button('1').width(140).height(50).margin(5)
11.           Button('2').width(140).height(50).margin(5)
12.           Button('3').width(140).height(50).margin(5)
13.           Button('4').width(140).height(50).margin(5)
14.           Button('5').width(140).height(50).margin(5)
15.         }
16.         .width('90%')
17.         .padding(10)
18.       }.width('100%').margin({ top: 5 })
19.     }.width('100%')
20.   }
21. }

说明

- 这种投影聚焦算法计算的聚焦顺序与组件布局和大小密切相关，建议在组件排列非常规整的场景下使用。如果组件大小不一且存在横向或纵向的交叠关系，则可能会导致聚焦顺序与开发者预期不符。
- 如果开发者希望有明确的走焦顺序，建议使用Column/Row等顺序走焦的容器实现。

Flex多行组件布局，组件大小一致，走焦正常。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.97476089624538307657888383026394:50001231000000:2800:DED494A5A38A8F155D95C336140627D6B270BC2C59AFDC2B7C5F9699DBDE2818.gif)

1. @Entry
2. @Component
3. struct ProjectAreaFocusExample2 {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Text('Wrap').fontSize(12).width('90%')
8.         // 子组件多行布局
9.         Flex({ wrap: FlexWrap.Wrap }) {
10.           Button('1').width(145).height(50).margin(5)
11.           Button('2').width(145).height(50).margin(5)
12.           Button('3').width(150).height(50).margin(5)
13.           Button('4').width(160).height(50).margin(5)
14.           Button('5').width(170).height(50).margin(5)
15.         }
16.         .width('90%')
17.         .padding(10)
18.       }.width('100%').margin({ top: 5 })
19.     }.width('100%')
20.   }
21. }

Flex多行组件布局，组件大小不一且有纵向的交叠关系，无法Tab走焦至下方4、5按钮组件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.76783338379593373741134037318032:50001231000000:2800:ACD5D9ED55A0F0DBEFE0ED4BD2428B297A9DD958EFC0ADCBEEA7F7B4E3D12BDD.gif)

**自定义走焦算法**

由组件自定义的走焦算法，规格由组件定义。

## 获焦/失焦事件

1. onFocus(event: () => void)

获焦事件回调，绑定该接口的组件获焦时，回调响应。

1. onBlur(event:() => void)

失焦事件回调，绑定该接口的组件失焦时，回调响应。

onFocus和onBlur两个接口通常成对使用，来监听组件的焦点变化。

1. // xxx.ets
2. @Entry
3. @Component
4. struct FocusEventExample {
5.   @State oneButtonColor: Color = Color.Gray;
6.   @State twoButtonColor: Color = Color.Gray;
7.   @State threeButtonColor: Color = Color.Gray;

8.   build() {
9.     Column({ space: 20 }) {
10.       // 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
11.       Button('First Button')
12.         .width(260)
13.         .height(70)
14.         .backgroundColor(this.oneButtonColor)
15.         .fontColor(Color.Black)
16.           // 监听第一个组件的获焦事件，获焦后改变颜色
17.         .onFocus(() => {
18.           this.oneButtonColor = Color.Green;
19.         })
20.           // 监听第一个组件的失焦事件，失焦后改变颜色
21.         .onBlur(() => {
22.           this.oneButtonColor = Color.Gray;
23.         })

24.       Button('Second Button')
25.         .width(260)
26.         .height(70)
27.         .backgroundColor(this.twoButtonColor)
28.         .fontColor(Color.Black)
29.           // 监听第二个组件的获焦事件，获焦后改变颜色
30.         .onFocus(() => {
31.           this.twoButtonColor = Color.Green;
32.         })
33.           // 监听第二个组件的失焦事件，失焦后改变颜色
34.         .onBlur(() => {
35.           this.twoButtonColor = Color.Gray;
36.         })

37.       Button('Third Button')
38.         .width(260)
39.         .height(70)
40.         .backgroundColor(this.threeButtonColor)
41.         .fontColor(Color.Black)
42.           // 监听第三个组件的获焦事件，获焦后改变颜色
43.         .onFocus(() => {
44.           this.threeButtonColor = Color.Green;
45.         })
46.           // 监听第三个组件的失焦事件，失焦后改变颜色
47.         .onBlur(() => {
48.           this.threeButtonColor = Color.Gray ;
49.         })
50.     }.width('100%').margin({ top: 20 })
51.   }
52. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.15553965774827401495272683119777:50001231000000:2800:4C730B6DB303EFC9B1445ABBAFCD5615CD7582F11618B01E439F3CC62815B53B.gif)

上述示例包含以下3步：

- 应用打开，按下Tab键激活走焦，“First Button”显示焦点激活态样式：组件外围有一个蓝色的闭合框，onFocus回调响应，背景色变成绿色。
- 按下Tab键，触发走焦，“Second Button”获焦，onFocus回调响应，背景色变成绿色；“First Button”失焦，onBlur回调响应，背景色变回灰色。
- 按下Tab键，触发走焦，“Third Button”获焦，onFocus回调响应，背景色变成绿色；“Second Button”失焦，onBlur回调响应，背景色变回灰色。

父子节点同时存在获焦和失焦事件时，获焦/失焦事件响应顺序为：

父节点Row1失焦 —> 子节点Button1失焦 —> 子节点Button2获焦 —> 父节点Row2获焦。

1. @Entry
2. @Component
3. struct FocusAndBlurExample {
4.   build() {
5.     Column() {
6.       Column({ space: 5 }) {
7.         Row() { // 父节点Row1
8.           Button('Button1') // 子节点Button1
9.             .width(140)
10.             .height(45)
11.             .margin(5)
12.             .onFocus(() => {
13.               console.info("Button1 onFocus");
14.             })
15.             .onBlur(() => {
16.               console.info("Button1 onBlur");
17.             })
18.         }
19.         .onFocus(() => {
20.           console.info("Row1 onFocus");
21.         })
22.         .onBlur(() => {
23.           console.info("Row1 onBlur");
24.         })

25.         Row() { // 父节点Row2
26.           Button('Button2') // 子节点Button2
27.             .width(140)
28.             .height(45)
29.             .margin(5)
30.             .onFocus(() => {
31.               console.info("Button2 onFocus");
32.             })
33.             .onBlur(() => {
34.               console.info("Button2 onBlur");
35.             })
36.         }
37.         .onFocus(() => {
38.           console.info("Row2 onFocus");
39.         })
40.         .onBlur(() => {
41.           console.info("Row2 onBlur");
42.         })
43.       }.width('100%').margin({ top: 5 })
44.     }.width('100%')
45.   }
46. }

Button1走焦到Button2，日志打印顺序：

1. Row1 onBlur
2. Button1 onBlur
3. Button2 onFocus
4. Row2 onFocus

## 设置组件是否可获焦

1. focusable(value: boolean)

设置组件是否可获焦。

按照组件的获焦能力可大致分为三类：

- 默认可获焦的组件，通常是有交互行为的组件，例如Button、Checkbox、TextInput组件，此类组件无需设置任何属性，默认即可获焦。
    
- 有获焦能力，但默认不可获焦的组件，典型的是Text、Image组件，此类组件缺省情况下无法获焦，若需要使其获焦，可使用通用属性focusable(true)使能。对于没有配置focusable属性，有获焦能力但默认不可获焦的组件，例如没有可获焦子组件的容器组件，为其配置onClick或是单指单击的Tap手势，该组件会隐式地成为可获焦组件。如果其focusable属性被设置为false，即使配置了上述事件，该组件依然不可获焦。
    
- 无获焦能力的组件，通常是无任何交互行为的展示类组件，例如Blank、Circle组件，此类组件即使使用focusable属性也无法使其可获焦。
    

设置容器组件可获焦：

获焦的主要目的是为了响应用户交互，如果组件不具备交互能力，则其也不会具有可获焦能力。容器组件通常不具备交互能力，因此如果一个容器组件（如Stack、Column）作为叶子节点，即使通过.focusable(true)也无法使其具备可获焦能力。需要注意的是通过动态方式创建的[FrameNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-framenode)节点也受限于这个规则。

如果想让作为叶子节点的容器组件可获焦，可通过以下任一方式实现：

- 在其内添加一个具备获焦能力的叶子节点组件(如button)。
    
- 为其配置onClick、Tap手势等使其能响应点击交互。
    

1. enabled(value: boolean)

设置组件可交互性属性[enabled](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-enable#enabled)为false，则组件不可交互，无法获焦。

1. visibility(value: Visibility)

设置组件可见性属性[visibility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-visibility#visibility)为Visibility.None或Visibility.Hidden，则组件不可见，无法获焦。

1. focusOnTouch(value: boolean)

设置当前组件是否支持点击获焦能力。

说明

当某组件处于获焦状态时，将其的focusable属性或enabled属性设置为false，会自动使该组件失焦，然后焦点按照[走焦规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)将焦点转移给其他组件。

1. // xxx.ets
2. @Entry
3. @Component
4. struct FocusableExample {
5.   @State textFocusable: boolean = true;
6.   @State textEnabled: boolean = true;
7.   @State color1: Color = Color.Yellow;
8.   @State color2: Color = Color.Yellow;
9.   @State color3: Color = Color.Yellow;

10.   build() {
11.     Column({ space: 5 }) {
12.       Text('Default Text')    // 第一个Text组件未设置focusable属性，默认不可获焦
13.         .borderColor(this.color1)
14.         .borderWidth(2)
15.         .width(300)
16.         .height(70)
17.         .onFocus(() => {
18.           this.color1 = Color.Blue;
19.         })
20.         .onBlur(() => {
21.           this.color1 = Color.Yellow;
22.         })
23.       Divider()

24.       Text('focusable: ' + this.textFocusable)    // 第二个Text设置了focusable初始为true，focusableOnTouch为true
25.         .borderColor(this.color2)
26.         .borderWidth(2)
27.         .width(300)
28.         .height(70)
29.         .focusable(this.textFocusable)
30.         .focusOnTouch(true)
31.         .onFocus(() => {
32.           this.color2 = Color.Blue;
33.         })
34.         .onBlur(() => {
35.           this.color2 = Color.Yellow;
36.         })

37.       Text('enabled: ' + this.textEnabled)    // 第三个Text设置了focusable为true，enabled初始为true
38.         .borderColor(this.color3)
39.         .borderWidth(2)
40.         .width(300)
41.         .height(70)
42.         .focusable(true)
43.         .enabled(this.textEnabled)
44.         .focusOnTouch(true)
45.         .onFocus(() => {
46.           this.color3 = Color.Blue;
47.         })
48.         .onBlur(() => {
49.           this.color3 = Color.Yellow;
50.         })

51.       Divider()

52.       Row() {
53.         Button('Button1')
54.           .width(140).height(70)
55.         Button('Button2')
56.           .width(160).height(70)
57.       }

58.       Divider()
59.       Button('Button3')
60.         .width(300).height(70)

61.       Divider()
62.     }.width('100%').justifyContent(FlexAlign.Center)
63.     .onKeyEvent((e) => {
64.       // 绑定onKeyEvent，在该Column组件获焦时，按下'F'键，可将第二个Text的focusable置反
65.       if (e.keyCode === 2022 && e.type === KeyType.Down) {
66.         this.textFocusable = !this.textFocusable;
67.       }
68.       // 绑定onKeyEvent，在该Column组件获焦时，按下'G'键，可将第三个Text的enabled置反
69.       if (e.keyCode === 2023 && e.type === KeyType.Down) {
70.         this.textEnabled = !this.textEnabled;
71.       }
72.     })
73.   }
74. }

运行效果：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.77692462681152263010218841066401:50001231000000:2800:821560F89CE47B89CAC67FE96EA4378D2B6299D4A98A031FF90A35595DE234A7.gif)

上述示例包含以下3步：

- 第一个Text组件没有设置focusable(true)属性，该Text组件无法获焦。
- 点击第二个Text组件，由于设置了focusOnTouch(true)，第二个组件获焦。按下Tab键，触发走焦，仍然是第二个Text组件获焦。按键盘F键，触发onKeyEvent，focusable置为false，第二个Text组件变成不可获焦，焦点自动转移，会自动从Text组件寻找下一个可获焦组件，焦点转移到第三个Text组件上。
- 按键盘G键，触发onKeyEvent，enabled置为false，第三个Text组件变成不可获焦，焦点自动转移，使焦点转移到Row容器上，容器中使用的是默认配置，会转移到Button1上。

## 设置容器绘制焦点框

虽然容器组件本身可以获焦，但是无法绘制焦点框。可以为其配置onClick或是单指单击的Tap手势，在容器上绘制焦点框。

说明

容器绘制焦点框前提：

- 容器内部没有可获焦子节点。
- 容器配置有onClick或是单指单击的Tap手势。
- 容器本身未设置focusable属性，或设置在onClick或是单指单击的Tap手势之后。

1. @Entry
2. @Component
3. struct ScopeFocusExample {
4.   @State scopeFocusState: boolean = true;

5.   build() {
6.     Column() {
7.       Column({ space: 5 }) {
8.         Text("容器获焦").textAlign(TextAlign.Center)
9.       }
10.       .justifyContent(FlexAlign.Center)
11.       .width('80%')
12.       .height(50)
13.       .margin({ top: 5, bottom: 5 })
14.       .onClick(() => {
15.       })
16.       .focusable(this.scopeFocusState)

17.       Button('Button1')
18.         .width(140)
19.         .height(45)
20.         .margin(5)
21.         .onClick(() => {
22.           this.scopeFocusState = !this.scopeFocusState;
23.           console.info("Button1 onFocus");
24.         })
25.       Button('Button2')
26.         .width(140)
27.         .height(45)
28.         .margin(5)
29.     }.width('100%')
30.   }
31. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164001.61390750096022653274925250777580:50001231000000:2800:17D3AFFFCB1C7407042CFB9E83F2D269ADCF8995E5BC657952414F132BA6A133.gif)

上述示例包含以下2步：

- Column配置onClick事件并设置focusable为true后，Tab键走焦，Column容器可以绘制焦点框。
- 点击Button1，将Column的focusable属性设置为false，Column容器无法获焦和绘制焦点框。

## 设置焦点停留在容器上

1. tabStop(isTabStop: boolean)

设置当前容器组件的[tabStop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#tabstop14)属性，可决定在走焦时焦点是否会停留在当前容器。

1. @Entry
2. @Component
3. struct TabStopExample {
4.   build() {
5.     Column({ space: 20 }) {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5)
10.       Column() {
11.         Button('Button2')
12.           .width(140)
13.           .height(45)
14.           .margin(5)
15.         Button('Button3')
16.           .width(140)
17.           .height(45)
18.           .margin(5)
19.       }.tabStop(true)
20.     }.width('100%')
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.35783033853164192623377862907896:50001231000000:2800:B8ECB4F5993FD2B7F9F16BA17CE1F02135E1AC402720D20A65766F9877607A64.gif)

上述示例包含以下2步：

- Column配置tabStop后，Tab键走焦，焦点在Button1和Column容器之间切换，Column容器可以绘制焦点框。
- 走焦至Column容器后，按Enter键，焦点转移到容器中的第一个可获焦节点上。Tab键走焦，走焦至容器中其他可获焦节点。

## 默认焦点

### 层级页面的默认焦点

1. defaultFocus(value: boolean)

设置当前组件是否为当前[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)上的默认焦点。

1. // xxx.ets
2. @Entry
3. @Component
4. struct DefaultFocus {
5.   @State oneButtonColor: Color = Color.Gray;
6.   @State twoButtonColor: Color = Color.Gray;
7.   @State threeButtonColor: Color = Color.Gray;

8.   build() {
9.     Column({ space: 20 }) {
10.       // 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
11.       Button('First Button')
12.         .width(260)
13.         .height(70)
14.         .backgroundColor(this.oneButtonColor)
15.         .fontColor(Color.Black)
16.           // 监听第一个组件的获焦事件，获焦后改变颜色
17.         .onFocus(() => {
18.           this.oneButtonColor = Color.Green;
19.         })
20.           // 监听第一个组件的失焦事件，失焦后改变颜色
21.         .onBlur(() => {
22.           this.oneButtonColor = Color.Gray;
23.         })

24.       Button('Second Button')
25.         .width(260)
26.         .height(70)
27.         .backgroundColor(this.twoButtonColor)
28.         .fontColor(Color.Black)
29.           // 监听第二个组件的获焦事件，获焦后改变颜色
30.         .onFocus(() => {
31.           this.twoButtonColor = Color.Green;
32.         })
33.           // 监听第二个组件的失焦事件，失焦后改变颜色
34.         .onBlur(() => {
35.           this.twoButtonColor = Color.Gray;
36.         })

37.       Button('Third Button')
38.         .width(260)
39.         .height(70)
40.         .backgroundColor(this.threeButtonColor)
41.         .fontColor(Color.Black)
42.           // 设置默认焦点
43.         .defaultFocus(true)
44.           // 监听第三个组件的获焦事件，获焦后改变颜色
45.         .onFocus(() => {
46.           this.threeButtonColor = Color.Green;
47.         })
48.           // 监听第三个组件的失焦事件，失焦后改变颜色
49.         .onBlur(() => {
50.           this.threeButtonColor = Color.Gray ;
51.         })
52.     }.width('100%').margin({ top: 20 })
53.   }
54. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.11434695702020431751981205129526:50001231000000:2800:322DB4B30F0ED83E3AAA77A335ECA052870AC82530F1B6AC42C7A07A4B6956A8.gif)

上述示例包含以下2步：

- 在第三个Button组件上设置了defaultFocus(true)，进入[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)后第三个Button默认获焦，显示为绿色。
- 按下Tab键，触发走焦，第三个Button正处于获焦状态，会出现焦点框。

### 容器的默认焦点

容器的默认焦点受到[获焦优先级](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E7%84%A6%E7%82%B9%E7%BB%84%E4%B8%8E%E8%8E%B7%E7%84%A6%E4%BC%98%E5%85%88%E7%BA%A7)的影响。

**defaultFocus与FocusPriority的区别**

[defaultFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#defaultfocus9)是用于指定[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次展示时的默认获焦节点，[FocusPriority](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focuspriority12)是用于指定某个容器首次获焦时其子节点的获焦优先级。上述两个属性在某些场景同时配置时行为未定义，例如下面的场景，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次展示无法同时满足defaultFocus获焦和高优先级组件获焦。

示例

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Row() {
6.       Button('Button1')
7.         .defaultFocus(true)
8.       Button('Button2')
9.         .focusScopePriority('RowScope', FocusPriority.PREVIOUS)
10.     }.focusScopeId('RowScope')
11.   }
12. }

### 层级页面/容器整体获焦时的焦点链

**整体获焦与非整体获焦**

- 整体获焦是[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)/容器自身作为焦点链的叶节点获焦，获焦后再把焦点链叶节点转移到子孙组件。例如，[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)切换、Navigation组件中的路由切换、焦点组走焦、容器组件主动调用requestFocusById等。
    
- 非整体获焦是某个组件作为焦点链叶节点获焦，导致其祖先节点跟着获焦。例如TextInput组件主动获取焦点、Tab键在非焦点组场景下走焦等。
    

**整体获焦的焦点链形成**

1.[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)首次获焦：

- 焦点链叶节点为配置了defaultFocus的节点。
    
- 未配置defaultFocus时，焦点停留在[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)的根容器上。
    

2.[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)非首次获焦：由上次获焦的节点获焦。

3.获焦链上存在配置了获焦优先级的组件和容器：

- 容器内存在优先级大于PREVIOUS的组件，由优先级最高的组件获焦。
    
- 容器内不存在优先级大于PREVIOUS的组件，由上次获焦的节点获焦。例如，窗口失焦后重新获焦。
    

## 焦点样式

说明

最终绘制焦点激活态的组件的[zIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-z-order#zindex)默认会被抬升至INT_MAX，如果该组件已经配置了zIndex，则不做zIndex调整。该组件不再绘制焦点激活态时，例如组件失焦或是退出走焦态，zIndex恢复为默认层级。

1. focusBox(style: FocusBoxStyle)

设置当前组件系统焦点框样式。

1. import { ColorMetrics, LengthMetrics } from '@kit.ArkUI'

2. @Entry
3. @Component
4. struct RequestFocusExample {
5.   build() {
6.     Column({ space: 30 }) {
7.       Button("small black focus box")
8.         .focusBox({
9.           margin: new LengthMetrics(0),
10.           strokeColor: ColorMetrics.rgba(0, 0, 0),
11.         })
12.       Button("large red focus box")
13.         .focusBox({
14.           margin: LengthMetrics.px(20),
15.           strokeColor: ColorMetrics.rgba(255, 0, 0),
16.           strokeWidth: LengthMetrics.px(10)
17.         })
18.     }
19.     .alignItems(HorizontalAlign.Center)
20.     .width('100%')
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.41659777254987774270453555000048:50001231000000:2800:0862308711451414B1C8A4C333F2EC8AFECE1178101C4168E6CD1CB86DECC739.gif)

上述示例包含以下2步：

- 进入[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)，按下Tab键触发走焦，第一个Button获焦，焦点框样式为紧贴边缘的黑色细框。
- 按下Tab键，走焦到第二个Button，焦点框样式为远离边缘的红色粗框。

## 主动获焦/失焦

- 使用FocusController中的方法
    
    更推荐使用FocusController中的requestFocus主动获取焦点。优势如下：
    
    - 当前帧生效，避免被下一帧组件树变化影响。
    - 有异常值返回，便于排查主动获取焦点失败的原因。
    - 避免多实例场景中取到错误实例。
    
    需先使用UIContext中的[getFocusController()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getfocuscontroller12)方法获取实例，再通过此实例调用对应方法。
    
    1. requestFocus(key: string): void
    
    通过组件的id将焦点转移到组件树对应的实体节点，生效时间为当帧生效。
    
    2. clearFocus(): void
    
    清除焦点，将焦点强制转移到层级页面根容器节点，焦点链路上其他节点失焦。
    
- 使用focusControl中的方法
    
    1. requestFocus(value: string): boolean
    
    调用此接口可以主动让焦点转移至参数指定的组件上，焦点转移生效时间为下一个帧信号。
    

1. // focusTest.ets
2. @Entry
3. @Component
4. struct RequestExample {
5.   @State btColor: string = '#ff2787d9'
6.   @State btColor2: string = '#ff2787d9'

7.   build() {
8.     Column({ space: 20 }) {
9.       Column({ space: 5 }) {
10.         Button('Button')
11.           .width(200)
12.           .height(70)
13.           .fontColor(Color.White)
14.           .focusOnTouch(true)
15.           .backgroundColor(this.btColor)
16.           .onFocus(() => {
17.             this.btColor = '#ffd5d5d5'
18.           })
19.           .onBlur(() => {
20.             this.btColor = '#ff2787d9'
21.           })
22.           .id("testButton")

23.         Button('Button')
24.           .width(200)
25.           .height(70)
26.           .fontColor(Color.White)
27.           .focusOnTouch(true)
28.           .backgroundColor(this.btColor2)
29.           .onFocus(() => {
30.             this.btColor2 = '#ffd5d5d5'
31.           })
32.           .onBlur(() => {
33.             this.btColor2 = '#ff2787d9'
34.           })
35.           .id("testButton2")

36.         Divider()
37.           .vertical(false)
38.           .width("80%")
39.           .backgroundColor('#ff707070')
40.           .height(10)

41.         Button('FocusController.requestFocus')
42.           .width(200).height(70).fontColor(Color.White)
43.           .onClick(() => {
44.             this.getUIContext().getFocusController().requestFocus("testButton")
45.           })
46.           .backgroundColor('#ff2787d9')

47.         Button("focusControl.requestFocus")
48.           .width(200).height(70).fontColor(Color.White)
49.           .onClick(() => {
50.             focusControl.requestFocus("testButton2")
51.           })
52.           .backgroundColor('#ff2787d9')

53.         Button("clearFocus")
54.           .width(200).height(70).fontColor(Color.White)
55.           .onClick(() => {
56.             this.getUIContext().getFocusController().clearFocus()
57.           })
58.           .backgroundColor('#ff2787d9')
59.       }
60.     }
61.     .width('100%')
62.     .height('100%')
63.   }
64. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.97740767440526976787540854945747:50001231000000:2800:C4111BC36B6599D652AAD9B820B0FEE1A7BD6AFECE500CF4A784BEE49847629C.gif)

上述示例包含以下3步：

- 点击FocusController.requestFocus按钮，第一个Button获焦。
- 点击focusControl.requestFocus按钮，第二个Button获焦。
- 点击clearFocus按钮，第二个Button失焦。

## 自定义组件走焦顺序

### nextFocus自定义走焦

1. nextFocus(nextStep: Optional<FocusMovement>): T

若存在配置了nextFocus的组件，则走焦只会按照设置的nextFocus走焦顺序走焦，没有设置自定义走焦或者设置自定义走焦的组件或容器不存在时，仍进行默认走焦规则。

说明

- 该能力从API version 18开始支持。

1. @Entry
2. @Component
3. struct NextFocusExample {
4.   build() {
5.     Column({space: 30}) {
6.       Row().height('30%')
7.       Row({space: 10}) {
8.         Button('A')
9.           .id('A')
10.           .nextFocus({forward: 'F', backward: 'C', down: 'B'})
11.         Button('B')
12.           .id('B')
13.           .nextFocus({ down: 'C'})
14.         Button('C')
15.           .id('C')
16.       }
17.       Column({space: 10}) {
18.         Button('D')
19.           .id('D')
20.         Button('E')
21.           .id('E')
22.           .nextFocus({forward: 'A', backward: 'M', up: 'E', right: 'F'})
23.       }
24.       Row({space: 10}) {
25.         Button('F')
26.           .id('F')
27.           .nextFocus({forward: 'B', down: 'A'});
28.       }
29.     }.width('100%')
30.   }
31. }

Tab键走焦：未配置nextFocus时，Tab键走焦顺序为A->B->C->D->E->F。配置nextFocus之后，Tab键走焦顺序为A->F->B->C->D->E->A。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.20924133050221638703423866142948:50001231000000:2800:A7FF473C58FAE4F1FCC3563D60F8184EB25A28FCAD6CE46F024BADC91C50F26D.gif)

方向键走焦（以方向下键为例）：未配置nextFocus时，按下Tab键激活焦点态之后，按方向下键走焦顺序为A->D->E->F。配置nextFocus之后，按下Tab键激活焦点态之后，按方向下键走焦顺序为A->B->C->D->E->F->A。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.69993108034770259696033359880898:50001231000000:2800:187B5FED65D1B965936745D8590407F8E5EBFD7FE0D0DE4C8F896840C9C889D5.gif)

### tabIndex自定义走焦

1. tabIndex(index: number)

tabIndex自定义组件Tab键走焦顺序。

若存在配置了tabIndex大于0的组件，则Tab键走焦只会在tabIndex大于0的组件内，按照tabIndex的值从小到大并循环依次走焦。若没有配置tabIndex大于0的组件，则tabIndex等于0的组件按照组件预设的走焦规则走焦。

说明

不能同时设置tabIndex与focusScopeId属性。

不建议在[层级页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)中通过单独设置组件的tabIndex属性为负数来控制获焦能力，可以使用focusable属性代替。

tabIndex只能够自定义Tab键走焦，若想同时自定义方向键等走焦能力，建议使用[nextfocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#nextfocus%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%B0%E7%84%A6)。

1. @Entry
2. @Component
3. struct TabIndexExample {
4.   build() {
5.     Column() {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5)
10.       Button('Focus Button1')
11.         .width(140)
12.         .height(45)
13.         .margin(5).tabIndex(1)
14.       Button('Button2')
15.         .width(140)
16.         .height(45)
17.         .margin(5)
18.       Button('Focus Button2')
19.         .width(140)
20.         .height(45)
21.         .margin(5).tabIndex(2)
22.     }.width('100%')
23.   }
24. }

Tab键走焦：只在配置TabIndex的节点间循环走焦。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.51486502427571866865317321931093:50001231000000:2800:7727C38FC3CB8C864A63CD85F9834DD5A5271CC7D3BAA52A8D7B7CB6282B2D72.gif)

tabIndex配置在容器上时，如果容器中的所有组件都没有获焦过，则走到第一个可获焦组件上，否则会走到上次获焦的节点。

1. @Entry
2. @Component
3. struct TabIndexExample2 {
4.   build() {
5.     Column() {
6.       Button('Button1')
7.         .width(140)
8.         .height(45)
9.         .margin(5).tabIndex(1)
10.       Column() {
11.         Button('Button2')
12.           .width(140)
13.           .height(45)
14.           .margin(5)
15.         Button('Button3')
16.           .width(140)
17.           .height(45)
18.           .margin(5)
19.       }.tabIndex(2)
20.     }.width('100%')
21.   }
22. }

Tab键走焦：tabIndex配置在容器上。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.69766945152546567976053498676098:50001231000000:2800:1227629C5419CD56ED0276905759A77E7CE436AB4F347F73D331CA0E31640728.gif)

上述示例包含以下3步：

- 使用Tab走焦，焦点在Button1和Button2之间循环走焦（tabIndex配置在Button2和Button3的父组件上）。
- 在走焦至Button2时，使用方向下键，将焦点转移至Button3上。
- 使用Tab走焦，焦点在Button1和Button3之间循环走焦。

## 焦点组与获焦优先级

1. focusScopePriority(scopeId: string, priority?: FocusPriority)

设置当前组件在指定容器内获焦的优先级。需要配合focusScopeId一起使用。

1. focusScopeId(id: string, isGroup?: boolean)

设置当前容器组件的id标识，设置当前容器组件是否为焦点组。焦点组与tabIndex不能混用。

1. // focusTest.ets
2. @Entry
3. @Component
4. struct FocusableExample {
5.   @State inputValue: string = ''

6.   build() {
7.     Scroll() {
8.       Row({ space: 20 }) {
9.         Column({ space: 20 }) {  // 标记为Column1
10.           Column({ space: 5 }) {
11.             Button('Group1')
12.               .width(165)
13.               .height(40)
14.               .fontColor(Color.White)
15.             Row({ space: 5 }) {
16.               Button()
17.                 .width(80)
18.                 .height(40)
19.                 .fontColor(Color.White)
20.               Button()
21.                 .width(80)
22.                 .height(40)
23.                 .fontColor(Color.White)
24.             }
25.             Row({ space: 5 }) {
26.               Button()
27.                 .width(80)
28.                 .height(40)
29.                 .fontColor(Color.White)
30.               Button()
31.                 .width(80)
32.                 .height(40)
33.                 .fontColor(Color.White)
34.             }
35.           }.borderWidth(2).borderColor(Color.Red).borderStyle(BorderStyle.Dashed)
36.           Column({ space: 5 }) {
37.             Button('Group2')
38.               .width(165)
39.               .height(40)
40.               .fontColor(Color.White)
41.             Row({ space: 5 }) {
42.               Button()
43.                 .width(80)
44.                 .height(40)
45.                 .fontColor(Color.White)
46.               Button()
47.                 .width(80)
48.                 .height(40)
49.                 .fontColor(Color.White)
50.                 .focusScopePriority('ColumnScope1', FocusPriority.PRIOR)  // Column1首次获焦时获焦
51.             }
52.             Row({ space: 5 }) {
53.               Button()
54.                 .width(80)
55.                 .height(40)
56.                 .fontColor(Color.White)
57.               Button()
58.                 .width(80)
59.                 .height(40)
60.                 .fontColor(Color.White)
61.             }
62.           }.borderWidth(2).borderColor(Color.Green).borderStyle(BorderStyle.Dashed)
63.         }
64.         .focusScopeId('ColumnScope1')
65.         Column({ space: 5 }) {  // 标记为Column2
66.           TextInput({placeholder: 'input', text: this.inputValue})
67.             .onChange((value: string) => {
68.               this.inputValue = value
69.             })
70.             .width(156)
71.           Button('Group3')
72.             .width(165)
73.             .height(40)
74.             .fontColor(Color.White)
75.           Row({ space: 5 }) {
76.             Button()
77.               .width(80)
78.               .height(40)
79.               .fontColor(Color.White)
80.             Button()
81.               .width(80)
82.               .height(40)
83.               .fontColor(Color.White)
84.           }
85.           Button()
86.             .width(165)
87.             .height(40)
88.             .fontColor(Color.White)
89.             .focusScopePriority('ColumnScope2', FocusPriority.PREVIOUS)  // Column2获焦时获焦
90.           Row({ space: 5 }) {
91.             Button()
92.               .width(80)
93.               .height(40)
94.               .fontColor(Color.White)
95.             Button()
96.               .width(80)
97.               .height(40)
98.               .fontColor(Color.White)
99.           }
100.           Button()
101.             .width(165)
102.             .height(40)
103.             .fontColor(Color.White)
104.           Row({ space: 5 }) {
105.             Button()
106.               .width(80)
107.               .height(40)
108.               .fontColor(Color.White)
109.             Button()
110.               .width(80)
111.               .height(40)
112.               .fontColor(Color.White)
113.           }
114.         }.borderWidth(2).borderColor(Color.Orange).borderStyle(BorderStyle.Dashed)
115.         .focusScopeId('ColumnScope2', true)  // Column2为焦点组
116.       }.alignItems(VerticalAlign.Top)
117.     }
118.   }
119. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.64806538796341658333103812050250:50001231000000:2800:EC2AFA4424A6D3CF197AEA756844A99A0D5998879164DD7B3A3F962297C16886.gif)

上述示例包含以下2步：

- input方框内设置了焦点组，因此按下Tab键后焦点会快速从input中走出去，而按下方向键后可以在input内走焦。
- 左侧的两个Column没有设置焦点组，因此只能通过Tab键一个一个地走焦。

在API version 14，焦点组新增参数arrowStepOut，用于设置能否使用方向键走焦出当前焦点组。

1. focusScopeId(id: string, isGroup?: boolean, arrowStepOut?: boolean)

2. @Entry
3. @Component
4. struct FocusScopeIdExample {
5.   build() {
6.     Column({ space: 20 }) {
7.       Column() {
8.         Button('Group1')
9.           .width(165)
10.           .height(40)
11.           .margin(5)
12.           .fontColor(Color.White)
13.         Row({ space: 5 }) {
14.           Button("Button1")
15.             .width(80)
16.             .height(40)
17.             .margin(5)
18.             .fontColor(Color.White)
19.           Button("Button2")
20.             .width(80)
21.             .height(40)
22.             .margin(5)
23.             .fontColor(Color.White)
24.         }
25.       }.focusScopeId("1", true, true)
26.       .borderWidth(2).borderColor(Color.Red).borderStyle(BorderStyle.Dashed)

27.       TextInput()
28.       Column() {
29.         Button('Group2')
30.           .width(165)
31.           .height(40)
32.           .margin(5)
33.           .fontColor(Color.White)
34.         Row({ space: 5 }) {
35.           Button("Button3")
36.             .width(80)
37.             .height(40)
38.             .margin(5)
39.             .fontColor(Color.White)
40.           Button("Button4")
41.             .width(80)
42.             .height(40)
43.             .margin(5)
44.             .fontColor(Color.White)
45.         }
46.       }.focusScopeId("2", true, false)
47.       .borderWidth(2).borderColor(Color.Green).borderStyle(BorderStyle.Dashed)

48.       TextInput()
49.     }.width('100%')
50.   }
51. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.13720911488363316597969965400768:50001231000000:2800:B1645C8A8DD2A142F05ACC95A832E3A35135371FECA4232599E65C4EE6347BE0.gif)

上述示例包含以下3步：

- Group1和Group2设置焦点组，因此按下Tab键后焦点会快速从Group1和Group2的方框内走出。
- Group1设置焦点组时，允许使用方向键走焦出当前焦点组。在Group1方框内走焦时，使用方向键可以走焦至input输入框。
- Group2设置焦点组时，不允许使用方向键走焦出当前焦点组。在Group2方框内走焦时，使用方向键无法走焦至input输入框。

说明

TextInput组件本身对方向键存在独有处理，因此无法使用方向键直接走出TextInput组件。

## 焦点与按键事件

当组件获焦且存在点击事件（onClick）或单指单击事件（TapGesture）时，回车和空格会触发对应的事件回调。

说明

1. 点击事件（onClick）或单指单击事件（TapGesture）在回车、空格触发对应事件回调时，默认不冒泡传递，即父组件对应[按键事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-key)不会被同步触发。
2. 按键事件（onKeyEvent）默认冒泡传递，即同时会触发父组件的按键事件回调。
3. 组件同时存在点击事件（onClick）和按键事件（onKeyEvent），在回车、空格触发时，两者都会响应。
4. 获焦组件响应点击事件（onClick），与焦点激活态无关。

5. @Entry
6. @Component
7. struct FocusOnclickExample {
8.   @State count: number = 0
9.   @State name: string = 'Button'

10.   build() {
11.     Column() {
12.       Button(this.name)
13.         .fontSize(30)
14.         .onClick(() => {
15.           this.count++
16.           if (this.count % 2 === 0) {
17.             this.name = "count is even number"
18.           } else {
19.             this.name = "count is odd number"
20.           }
21.         }).height(60)
22.     }.height('100%').width('100%').justifyContent(FlexAlign.Center)
23.   }
24. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164002.65037606847477599416505461065922:50001231000000:2800:D5B7A9701BBA829A663F0AA9D0472DC2D193783B3A62BCD229339C7E92B9B212.gif)

## 组件获焦能力说明

**表1** 基础组件获焦能力

|基础组件|是否有获焦能力|focusable默认值|
|:--|:--|:--|
|[AlphabetIndexer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-alphabet-indexer)|是|true|
|[Blank](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-blank)|否|false|
|[Button](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button)|是|true|
|[CalendarPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-calendarpicker)|是|true|
|[Checkbox](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-checkbox)|是|true|
|[CheckboxGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-checkboxgroup)|是|true|
|[ContainerSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-containerspan)|否|false|
|[DataPanel](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datapanel)|是|false|
|[DatePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datepicker)|是|true|
|[Divider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-divider)|是|false|
|[Gauge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-gauge)|是|false|
|[Image](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image)|是|false|
|[ImageAnimator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imageanimator)|否|false|
|[ImageSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imagespan)|否|false|
|[LoadingProgress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-loadingprogress)|是|true|
|[Marquee](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-marquee)|否|false|
|[Menu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menu)|是|true|
|[MenuItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menuitem)|是|true|
|[MenuItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menuitemgroup)|否|false|
|[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)|是|true|
|[NavRouter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navrouter)|否|false|
|[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)|是|true|
|[PatternLock](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-patternlock)|是|true|
|[Progress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-progress)|是|true|
|[QRCode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-qrcode)|是|true|
|[Radio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-radio)|是|true|
|[Rating](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-rating)|是|true|
|[RichEditor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor)|是|true|
|[RichText](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richtext)|否|false|
|[ScrollBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-scrollbar)|否|false|
|[Search](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search)|是|true|
|[Select](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-select)|是|true|
|[Slider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-slider)|是|true|
|[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)|否|false|
|[Stepper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-stepper)|是|true|
|[StepperItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-stepperitem)|是|true|
|[SymbolSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolspan)|否|false|
|[SymbolGlyph](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-symbolglyph)|否|false|
|[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)|是|false|
|[TextArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textarea)|是|true|
|[TextClock](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textclock)|否|false|
|[TextInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput)|是|true|
|[TextPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textpicker)|是|true|
|[TextTimer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-texttimer)|否|false|
|[TimePicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker)|否|false|
|[Toggle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-toggle)|是|true|
|[XComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent)|是|false|

**表2** 容器组件获焦能力

|容器组件|是否可获焦|focusable默认值|
|:--|:--|:--|
|[Badge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-badge)|否|false|
|[Column](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-column)|是|true|
|[ColumnSplit](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-columnsplit)|是|true|
|[Counter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-counter)|是|false|
|[EmbeddedComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-embedded-component)|否|false|
|[Flex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flex)|是|true|
|[FlowItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flowitem)|是|true|
|[FolderStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-folderstack)|是|true|
|[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)|否|false|
|[GridCol](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridcol)|是|true|
|[GridRow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridrow)|是|true|
|[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)|是|true|
|[GridItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-griditem)|是|true|
|[Hyperlink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-hyperlink)|是|true|
|[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)|是|true|
|[ListItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitem)|是|true|
|[ListItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitemgroup)|是|true|
|[Navigator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-navigator)|是|true|
|[Refresh](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-refresh)|是|true|
|[RelativeContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-relativecontainer)|否|false|
|[Row](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-row)|是|true|
|[RowSplit](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-rowsplit)|是|true|
|[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)|是|true|
|[SideBarContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer)|是|true|
|[Stack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-stack)|是|true|
|[Swiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper)|是|true|
|[Tabs](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs)|是|true|
|[TabContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabcontent)|是|true|
|[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)|否|false|
|[WithTheme](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-with-theme)|是|true|

**表3** 媒体组件获焦能力

|媒体组件|是否可获焦|focusable默认值|
|:--|:--|:--|
|[Video](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-media-components-video)|是|true|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-drag-event "支持统一拖拽")
# 动画概述

更新时间: 2025-12-16 16:39

UI（用户界面）中包含开发者与设备进行交互时所看到的各种组件（如时间、壁纸等）。属性作为接口，用于控制组件的行为。例如，开发者可通过位置属性调整组件在屏幕上的位置。

属性值的变化，通常会引起UI的变化。动画可在UI发生改变时，添加流畅的过渡效果。如果不加入动画，属性将在一瞬间完成变化。造成突兀感的同时，容易导致用户失去视觉焦点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163900.92833411274389462638594915539537:50001231000000:2800:3E99E8C9ECD87D14D2748B4A4BF6927E64EB1241C9345168051F10E676B05377.gif)

动画的目的包括：

- 使界面的过渡自然流畅。
- 增强用户从界面获得的反馈感和互动感。
- 在内容加载等场景中，增加用户的耐心，缓解等待带来的不适感。
- 引导用户了解和操作设备。

在需要为UI变化添加过渡的场景，都可以使用动画，如开机、应用启动退出、下拉进入控制中心等。这些动画可向用户提供关于其操作的反馈，并有助于让用户始终关注界面。

ArkUI中提供多种动画接口（属性动画、转场动画等），用于驱动属性值按照设定的动画参数，从起始值逐渐变化到终点值。尽管变化过程中参数值并非绝对的连续，而是具有一定的离散性。但由于人眼会产生视觉暂留，所以最终看到的就是一个“连续“的动画。UI的一次改变称为一个动画帧，对应一次屏幕刷新。决定动画流畅度的一个重要指标就是帧率FPS（Frame Per Second），即每秒的动画帧数，帧率越高则动画就会越流畅。ArkUI中，动画参数包含了如动画时长、动画曲线等参数。动画曲线作为主要因素，决定了属性值变化的规律。以线性动画曲线为例，在动画时长内，属性值将从起点值匀速变化到终点值。属性过快或过慢的变化，都可能带来不好的视觉感受，影响用户体验。因此动画参数特别是动画曲线，需要结合场景和曲线特点进行设计和调整。

动画接口驱动属性值按照动画参数决定的规律，从原来的状态连续过渡到新的状态，进而在UI上产生连续的视觉效果。本文将按照如下结构，提供各种动画的使用方法和注意事项，使开发者快速学习动画。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163900.73226686018425638742548623914457:50001231000000:2800:315E6B0D7FAE115731A030B5E4912B7891BC22302A32FEDDC74783DC1A51D9EA.png)

- 属性动画：最基础的动画类型，按照动画参数逐帧驱动属性的变化，产生一帧帧的动画效果。除其中的自定义属性动画外，动画过程的驱动由系统完成，应用侧不感知动画过程。
    
- 转场动画：为组件在出现和消失时添加过渡动画。为了保证动画一致性，部分接口动画曲线已内置，不支持开发者自定义。
    
    - 不推荐在应用内使用UIAbility组合所有的界面：UIAbility是一个任务，会在多任务界面独立显示一个卡片，UIAbility之间的跳转是任务之间的跳转。以应用内查看大图的典型场景为例，不建议应用内调用图库的UIAbility去打开图片查看大图，会导致任务的跳转，图库的UIAbility也会加入多任务界面中。正确的方式是应用内构建大图组件，通过模态转场去调起大图组件，一个任务内的所有的界面都在一个UIAbility内闭环。
    - 导航转场中，应使用Navigation组件实现转场动画。过去的page+router方式在实现导航转场过程中，因为page和page之间相互独立，其联动动画效果受限。不仅容易导致页面之间的割裂，并且不支持一次开发多端部署。
- 组件动画：组件提供默认动效（如List的滑动动效）便于开发者使用，同时部分组件还支持定制化动效。
    
- 动画曲线：介绍传统曲线和弹簧曲线的特点和使用方式。动画曲线影响属性值的运动规律，进而决定界面的动画效果。
    
- 动画衔接：介绍如何实现动画与动画之间、手势与动画之间的自然过渡。
    
- 高阶效果属性：介绍模糊、大阴影和颜色渐变等高阶效果接口的使用方法。
    
- 帧动画：系统侧提供在动画过程中的插值结果，由开发者每帧修改属性值产生动画，相比于属性动画，有可实现暂停的优点，但性能不如属性动画。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-animation "使用动画")
# 实现属性动画

更新时间: 2025-12-16 16:40

通过可动画属性改变引起UI上产生的连续视觉效果，即为属性动画。属性动画是最基础易懂的动画，ArkUI提供三种动画接口[animateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#animateto)、[animation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)和[keyframeAnimateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-keyframeanimateto)驱动组件属性按照动画曲线等动画参数进行连续的变化，产生属性动画。

说明

本章节讨论的属性动画不是狭义的[属性动画接口](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)，而是通过给定新的可动画属性终值，对属性产生动画的方式。

|动画接口|作用域|原理|使用场景|
|:--|:--|:--|:--|
|animateTo|闭包内改变属性引起的界面变化。<br><br>作用于出现消失转场。|通用函数，对闭包前界面和闭包中的状态变量引起的界面之间的差异做动画。<br><br>支持多次调用，支持嵌套。|适用对多个可动画属性配置相同动画参数的动画。<br><br>需要嵌套使用动画的场景。<br><br>如果需要实现多段动画循环的效果，建议通过设置[AnimateParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation#animateparam%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)的playMode和iterations属性实现，或使用keyframeAnimateTo实现。|
|animation|组件通过属性接口绑定的属性变化引起的界面变化。|识别组件的可动画属性变化，自动添加动画。<br><br>组件的接口调用是从下往上执行，animation只会作用于在其之上的属性调用。<br><br>组件可以根据调用顺序对多个属性设置不同的animation。|适用于对多个可动画属性配置不同参数动画的场景。|
|keyframeAnimateTo|多个闭包内改变属性引起的分段属性动画。|通用函数，每一段闭包中的状态变量与前一次的差异做动画。<br><br>支持多次调用，不推荐嵌套。|适用于同一属性需要做连续多个动画的场景。|

## 使用animateTo产生属性动画

1. animateTo(value: AnimateParam, event: () => void): void

[animateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#animateto)接口参数中，value指定[AnimateParam对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation#animateparam%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)（包括时长、[Curve](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-curve#curve)等）event为动画的闭包函数，闭包内变量改变产生的属性动画将遵循相同的动画参数。

说明

直接使用animateTo可能导致[UI上下文不明确](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-global-interface)的问题，建议使用[getUIContext()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-api#getuicontext)获取[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)实例，并使用[animateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#animateto)调用绑定实例的animateTo。

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct AnimateToDemo {
5.   @State animate: boolean = false;
6.   // 第一步: 声明相关状态变量
7.   @State rotateValue: number = 0; // 组件一旋转角度
8.   @State translateX: number = 0; // 组件二偏移量
9.   @State opacityValue: number = 1; // 组件二透明度

10.   // 第二步：将状态变量设置到相关可动画属性接口
11.   build() {
12.     Row() {
13.       // 组件一
14.       Column() {
15.       }
16.       .rotate({ angle: this.rotateValue })
17.       .backgroundColor('#317AF7')
18.       .justifyContent(FlexAlign.Center)
19.       .width(100)
20.       .height(100)
21.       .borderRadius(30)
22.       .onClick(() => {
23.         this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
24.           this.animate = !this.animate;
25.           // 第三步：闭包内通过状态变量改变UI界面
26.           // 这里可以写任何能改变UI的逻辑比如数组添加，显隐控制，系统会检测改变后的UI界面与之前的UI界面的差异，对有差异的部分添加动画
27.           // 组件一的rotate属性发生变化，所以会给组件一添加rotate旋转动画
28.           this.rotateValue = this.animate ? 90 : 0;
29.           // 组件二的透明度发生变化，所以会给组件二添加透明度的动画
30.           this.opacityValue = this.animate ? 0.6 : 1;
31.           // 组件二的translate属性发生变化，所以会给组件二添加translate偏移动画
32.           this.translateX = this.animate ? 50 : 0;
33.         })
34.       })

35.       // 组件二
36.       Column() {

37.       }
38.       .justifyContent(FlexAlign.Center)
39.       .width(100)
40.       .height(100)
41.       .backgroundColor('#D94838')
42.       .borderRadius(30)
43.       .opacity(this.opacityValue)
44.       .translate({ x: this.translateX })
45.     }
46.     .width('100%')
47.     .height('100%')
48.     .justifyContent(FlexAlign.Center)
49.   }
50. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164027.26158556582840026601027068464081:50001231000000:2800:054F7B81AC12B49A7361E14B1BE5316CE0B185CDB2E6B719AC6ADF1E3F318519.gif)

## 使用animation产生属性动画

相比于animateTo接口需要把要执行动画的属性的修改放在闭包中，[animation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)接口无需使用闭包，把animation接口加在要做属性动画的可动画属性后即可。animation只要检测到其绑定的可动画属性发生变化，就会自动添加属性动画，animateTo则必须在动画闭包内改变可动画属性的值从而生成动画。

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct AnimationDemo {
5.   @State animate: boolean = false;
6.   // 第一步: 声明相关状态变量
7.   @State rotateValue: number = 0; // 组件一旋转角度
8.   @State translateX: number = 0; // 组件二偏移量
9.   @State opacityValue: number = 1; // 组件二透明度

10.   // 第二步：将状态变量设置到相关可动画属性接口
11.   build() {
12.     Row() {
13.       // 组件一
14.       Column() {
15.       }
16.       .opacity(this.opacityValue)
17.       .rotate({ angle: this.rotateValue })
18.       // 第三步：通过属性动画接口开启属性动画
19.       .animation({ curve: curves.springMotion() })
20.       .backgroundColor('#317AF7')
21.       .justifyContent(FlexAlign.Center)
22.       .width(100)
23.       .height(100)
24.       .borderRadius(30)
25.       .onClick(() => {
26.         this.animate = !this.animate;
27.         // 第四步：闭包内通过状态变量改变UI界面
28.         // 这里可以写任何能改变UI的逻辑比如数组添加，显隐控制，系统会检测改变后的UI界面与之前的UI界面的差异，对有差异的部分添加动画
29.         // 组件一的rotate属性发生变化，所以会给组件一添加rotate旋转动画
30.         this.rotateValue = this.animate ? 90 : 0;
31.         // 组件二的translate属性发生变化，所以会给组件二添加translate偏移动画
32.         this.translateX = this.animate ? 50 : 0;
33.         // 父组件column的opacity属性有变化，会导致其子节点的透明度也变化，所以这里会给column和其子节点的透明度属性都添加动画
34.         this.opacityValue = this.animate ? 0.6 : 1;
35.       })

36.       // 组件二
37.       Column() {
38.       }
39.       .justifyContent(FlexAlign.Center)
40.       .width(100)
41.       .height(100)
42.       .backgroundColor('#D94838')
43.       .borderRadius(30)
44.       .opacity(this.opacityValue)
45.       .translate({ x: this.translateX })
46.       .animation({ curve: curves.springMotion() })
47.     }
48.     .width('100%')
49.     .height('100%')
50.     .justifyContent(FlexAlign.Center)
51.   }
52. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164027.49079505494258926562693366771116:50001231000000:2800:A6B3DA5909327364D7B40AAA04160F59C5527BAAF88C4EBE1136E765151959C0.gif)

## 使用keyframeAnimateTo产生属性动画

1. keyframeAnimateTo(param: KeyframeAnimateParam, keyframes: Array<KeyframeState>): void

[keyframeAnimateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-keyframeanimateto)接口参数中，第一个参数[KeyframeAnimateParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-keyframeanimateto#keyframeanimateparam%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)为关键帧动画的整体参数（包括延时、播放次数、结束回调、期望帧率），第二个参数是一个数组，每一项表示一个关键帧内的动画行为；每一段动画可单独控制动画参数（包括时长、[Curve](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-curve#curve)等）。

在同一属性存在多段动画过程的场景，可通过在结束回调中再创建新动画实现，但写法更复杂，且每次创建新动画需要耗时，会有衔接卡顿现象。此场景更适宜用关键帧动画实现。

以下示例主要演示如何通过keyframeAnimateTo来设置关键帧动画。

1. @Entry
2. @Component
3. struct KeyframeAnimateToDemo {
4.   // 第一步: 声明相关状态变量
5.   @State rotateValue: number = 0; // 组件一旋转角度
6.   @State translateX: number = 0; // 组件二偏移量
7.   @State opacityValue: number = 1; // 组件二透明度
8.   // 第二步：将状态变量设置到相关可动画属性接口
9.   build() {
10.     Row() {
11.       // 组件一
12.       Column() {
13.       }
14.       .rotate({ angle: this.rotateValue })
15.       .backgroundColor('#317AF7')
16.       .justifyContent(FlexAlign.Center)
17.       .width(100)
18.       .height(100)
19.       .borderRadius(30)
20.       .onClick(() => {
21.         // 第三步：调用keyframeAnimateTo接口
22.         this.getUIContext()?.keyframeAnimateTo({
23.           iterations: 1
24.         }, [
25.           {
26.             // 第一段关键帧动画时长为800ms，组件一顺时针旋转90度，组件二的透明度变从1变为0.6，组件二的translate从0位移到50
27.             duration: 800,
28.             event: () => {
29.               this.rotateValue = 90;
30.               this.opacityValue = 0.6;
31.               this.translateX = 50;
32.             }
33.           },
34.           {
35.             // 第二段关键帧动画时长为500ms，组件一逆时针旋转90度恢复至0度，组件二的透明度变从0.6变为1，组件二的translate从50位移到0
36.             duration: 500,
37.             event: () => {
38.               this.rotateValue = 0;
39.               this.opacityValue = 1;
40.               this.translateX = 0;
41.             }
42.           }
43.         ]);
44.       })
45.       // 组件二
46.       Column() {
47.       }
48.       .justifyContent(FlexAlign.Center)
49.       .width(100)
50.       .height(100)
51.       .backgroundColor('#D94838')
52.       .borderRadius(30)
53.       .opacity(this.opacityValue)
54.       .translate({ x: this.translateX })
55.     }
56.     .width('100%')
57.     .height('100%')
58.     .justifyContent(FlexAlign.Center)
59.   }
60. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164027.40558039353615372868703769053485:50001231000000:2800:3CC22D451DA43C9B2E10475291089E098FC660343461477EDC53AAD191358788.gif)

说明

- 在对组件的位置大小的变化做动画的时候，由于布局属性的改变会触发测量布局，性能开销大。[scale](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-transformation#scale)属性的改变不会触发测量布局，性能开销小。因此，在组件位置大小持续发生变化的场景，如跟手触发组件大小变化的场景，推荐使用scale。
    
- 属性动画应该作用于始终存在的组件，对于将要出现或者将要消失的组件的动画应该使用[转场动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-transition-overview)。
    
- 尽量不要使用动画结束回调。属性动画是对已经发生的状态进行的动画，不需要开发者去处理结束的逻辑。如果要使用结束回调，一定要正确处理连续操作的数据管理。
    
- 在设置的开发者选项中关闭过渡动画，或UIAbility从前台切换至后台，会立即执行动画结束回调。建议对此类场景进行一定的验证并避免在动画结束回调中加入时序相关的功能逻辑。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-overview "属性动画概述")
# 自定义属性动画

更新时间: 2025-12-16 16:40

属性动画是可动画属性的参数值发生变化时，引起UI上产生的连续视觉效果。当参数值发生连续变化，且设置到可以引起UI发生变化的属性接口上时，就可以实现属性动画。

ArkUI提供[@AnimatableExtend装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animatable-extend)，用于自定义可动画属性接口。由于参数的数据类型必须具备一定程度的连续性，自定义可动画属性接口的参数类型仅支持number类型和实现[AnimatableArithmetic<T>接口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animatable-extend#animatablearithmetict%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E)的自定义类型。通过自定义可动画属性接口和可动画数据类型，在使用animateTo或animation执行动画时，通过逐帧回调函数修改不可动画属性接口的值，能够让不可动画属性接口实现动画效果。也可通过逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。

## 使用number数据类型和@AnimatableExtend装饰器改变Text组件宽度实现逐帧布局的效果

1. // 第一步：使用@AnimatableExtend装饰器，自定义可动画属性接口
2. @AnimatableExtend(Text)
3. function animatableWidth(width: number) {
4.   .width(width) // 调用系统属性接口，逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。
5. }

6. @Entry
7. @Component
8. struct AnimatablePropertyExample {
9.   @State textWidth: number = 80;

10.   build() {
11.     Column() {
12.       Text("AnimatableProperty")
13.         .animatableWidth(this.textWidth)// 第二步：将自定义可动画属性接口设置到组件上
14.         .animation({ duration: 2000, curve: Curve.Ease }) // 第三步:为自定义可动画属性接口绑定动画
15.       Button("Play")
16.         .onClick(() => {
17.           this.textWidth = this.textWidth == 80 ? 160 : 80; // 第四步：改变自定义可动画属性的参数，产生动画
18.         })
19.     }.width("100%")
20.     .padding(10)
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.34047642526096542406493052938243:50001231000000:2800:FC99CF5981595BB68A6AC85B631D7B8276C151909A8311395498F8B5AF2E857D.gif)

## 使用自定义数据类型和@AnimatableExtend装饰器改变图形形状

1. declare type Point = number[];

2. // 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数
3. class PointClass extends Array<number> {
4.   constructor(value: Point) {
5.     super(value[0], value[1])
6.   }

7.   add(rhs: PointClass): PointClass {
8.     let result: Point = new Array<number>() as Point;
9.     for (let i = 0; i < 2; i++) {
10.       result.push(rhs[i] + this[i])
11.     }
12.     return new PointClass(result);
13.   }

14.   subtract(rhs: PointClass): PointClass {
15.     let result: Point = new Array<number>() as Point;
16.     for (let i = 0; i < 2; i++) {
17.       result.push(this[i] - rhs[i]);
18.     }
19.     return new PointClass(result);
20.   }

21.   multiply(scale: number): PointClass {
22.     let result: Point = new Array<number>() as Point;
23.     for (let i = 0; i < 2; i++) {
24.       result.push(this[i] * scale)
25.     }
26.     return new PointClass(result);
27.   }
28. }

29. // 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数
30. // 模板T支持嵌套实现AnimatableArithmetic<T>的类型
31. class PointVector extends Array<PointClass> implements AnimatableArithmetic<Array<Point>> {
32.   constructor(initialValue: Array<Point>) {
33.     super();
34.     if (initialValue.length) {
35.       initialValue.forEach((p: Point) => this.push(new PointClass(p)))
36.     }
37.   }

38.   // implement the IAnimatableArithmetic interface
39.   plus(rhs: PointVector): PointVector {
40.     let result = new PointVector([]);
41.     const len = Math.min(this.length, rhs.length)
42.     for (let i = 0; i < len; i++) {
43.       result.push(this[i].add(rhs[i]))
44.     }
45.     return result;
46.   }

47.   subtract(rhs: PointVector): PointVector {
48.     let result = new PointVector([]);
49.     const len = Math.min(this.length, rhs.length)
50.     for (let i = 0; i < len; i++) {
51.       result.push(this[i].subtract(rhs[i]))
52.     }
53.     return result;
54.   }

55.   multiply(scale: number): PointVector {
56.     let result = new PointVector([]);
57.     for (let i = 0; i < this.length; i++) {
58.       result.push(this[i].multiply(scale))
59.     }
60.     return result;
61.   }

62.   equals(rhs: PointVector): boolean {
63.     if (this.length !== rhs.length) {
64.       return false;
65.     }
66.     for (let index = 0, size = this.length; index < size; ++index) {
67.       if (this[index][0] !== rhs[index][0] || this[index][1] !== rhs[index][1]) {
68.         return false;
69.       }
70.     }
71.     return true;
72.   }
73. }

74. // 自定义可动画属性接口
75. @AnimatableExtend(Polyline)
76. function animatablePoints(points: PointVector) {
77.   .points(points)
78. }

79. @Entry
80. @Component
81. struct AnimatedShape {
82.   squareStartPointX: number = 75;
83.   squareStartPointY: number = 25;
84.   squareWidth: number = 150;
85.   squareEndTranslateX: number = 50;
86.   squareEndTranslateY: number = 50;
87.   @State pointVec1: PointVector = new PointVector([
88.     [this.squareStartPointX, this.squareStartPointY],
89.     [this.squareStartPointX + this.squareWidth, this.squareStartPointY],
90.     [this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],
91.     [this.squareStartPointX, this.squareStartPointY + this.squareWidth]
92.   ]);
93.   @State pointVec2: PointVector = new PointVector([
94.     [this.squareStartPointX + this.squareEndTranslateX, this.squareStartPointY + this.squareStartPointY],
95.     [this.squareStartPointX + this.squareWidth + this.squareEndTranslateX,
96.       this.squareStartPointY + this.squareStartPointY],
97.     [this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],
98.     [this.squareStartPointX, this.squareStartPointY + this.squareWidth]
99.   ]);
100.   @State color: Color = Color.Green;
101.   @State fontSize: number = 20.0;
102.   @State polyline1Vec: PointVector = this.pointVec1;
103.   @State polyline2Vec: PointVector = this.pointVec2;

104.   build() {
105.     Row() {
106.       Polyline()
107.         .width(300)
108.         .height(200)
109.         .backgroundColor("#0C000000")
110.         .fill('#317AF7')
111.         .animatablePoints(this.polyline1Vec)
112.         .animation({ duration: 2000, delay: 0, curve: Curve.Ease })
113.         .onClick(() => {

114.           if (this.polyline1Vec.equals(this.pointVec1)) {
115.             this.polyline1Vec = this.pointVec2;
116.           } else {
117.             this.polyline1Vec = this.pointVec1;
118.           }
119.         })
120.     }
121.     .width('100%').height('100%').justifyContent(FlexAlign.Center)
122.   }
123. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.63251197450497720100351248672884:50001231000000:2800:C80C95EF0DB84FB9C0167E452E5AB24DC5B29E95AF0E19851946F4CF8C0608A2.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis "实现属性动画")
# 自定义属性动画

更新时间: 2025-12-16 16:40

属性动画是可动画属性的参数值发生变化时，引起UI上产生的连续视觉效果。当参数值发生连续变化，且设置到可以引起UI发生变化的属性接口上时，就可以实现属性动画。

ArkUI提供[@AnimatableExtend装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animatable-extend)，用于自定义可动画属性接口。由于参数的数据类型必须具备一定程度的连续性，自定义可动画属性接口的参数类型仅支持number类型和实现[AnimatableArithmetic<T>接口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animatable-extend#animatablearithmetict%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E)的自定义类型。通过自定义可动画属性接口和可动画数据类型，在使用animateTo或animation执行动画时，通过逐帧回调函数修改不可动画属性接口的值，能够让不可动画属性接口实现动画效果。也可通过逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。

## 使用number数据类型和@AnimatableExtend装饰器改变Text组件宽度实现逐帧布局的效果

1. // 第一步：使用@AnimatableExtend装饰器，自定义可动画属性接口
2. @AnimatableExtend(Text)
3. function animatableWidth(width: number) {
4.   .width(width) // 调用系统属性接口，逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。
5. }

6. @Entry
7. @Component
8. struct AnimatablePropertyExample {
9.   @State textWidth: number = 80;

10.   build() {
11.     Column() {
12.       Text("AnimatableProperty")
13.         .animatableWidth(this.textWidth)// 第二步：将自定义可动画属性接口设置到组件上
14.         .animation({ duration: 2000, curve: Curve.Ease }) // 第三步:为自定义可动画属性接口绑定动画
15.       Button("Play")
16.         .onClick(() => {
17.           this.textWidth = this.textWidth == 80 ? 160 : 80; // 第四步：改变自定义可动画属性的参数，产生动画
18.         })
19.     }.width("100%")
20.     .padding(10)
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.34047642526096542406493052938243:50001231000000:2800:FC99CF5981595BB68A6AC85B631D7B8276C151909A8311395498F8B5AF2E857D.gif)

## 使用自定义数据类型和@AnimatableExtend装饰器改变图形形状

1. declare type Point = number[];

2. // 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数
3. class PointClass extends Array<number> {
4.   constructor(value: Point) {
5.     super(value[0], value[1])
6.   }

7.   add(rhs: PointClass): PointClass {
8.     let result: Point = new Array<number>() as Point;
9.     for (let i = 0; i < 2; i++) {
10.       result.push(rhs[i] + this[i])
11.     }
12.     return new PointClass(result);
13.   }

14.   subtract(rhs: PointClass): PointClass {
15.     let result: Point = new Array<number>() as Point;
16.     for (let i = 0; i < 2; i++) {
17.       result.push(this[i] - rhs[i]);
18.     }
19.     return new PointClass(result);
20.   }

21.   multiply(scale: number): PointClass {
22.     let result: Point = new Array<number>() as Point;
23.     for (let i = 0; i < 2; i++) {
24.       result.push(this[i] * scale)
25.     }
26.     return new PointClass(result);
27.   }
28. }

29. // 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数
30. // 模板T支持嵌套实现AnimatableArithmetic<T>的类型
31. class PointVector extends Array<PointClass> implements AnimatableArithmetic<Array<Point>> {
32.   constructor(initialValue: Array<Point>) {
33.     super();
34.     if (initialValue.length) {
35.       initialValue.forEach((p: Point) => this.push(new PointClass(p)))
36.     }
37.   }

38.   // implement the IAnimatableArithmetic interface
39.   plus(rhs: PointVector): PointVector {
40.     let result = new PointVector([]);
41.     const len = Math.min(this.length, rhs.length)
42.     for (let i = 0; i < len; i++) {
43.       result.push(this[i].add(rhs[i]))
44.     }
45.     return result;
46.   }

47.   subtract(rhs: PointVector): PointVector {
48.     let result = new PointVector([]);
49.     const len = Math.min(this.length, rhs.length)
50.     for (let i = 0; i < len; i++) {
51.       result.push(this[i].subtract(rhs[i]))
52.     }
53.     return result;
54.   }

55.   multiply(scale: number): PointVector {
56.     let result = new PointVector([]);
57.     for (let i = 0; i < this.length; i++) {
58.       result.push(this[i].multiply(scale))
59.     }
60.     return result;
61.   }

62.   equals(rhs: PointVector): boolean {
63.     if (this.length !== rhs.length) {
64.       return false;
65.     }
66.     for (let index = 0, size = this.length; index < size; ++index) {
67.       if (this[index][0] !== rhs[index][0] || this[index][1] !== rhs[index][1]) {
68.         return false;
69.       }
70.     }
71.     return true;
72.   }
73. }

74. // 自定义可动画属性接口
75. @AnimatableExtend(Polyline)
76. function animatablePoints(points: PointVector) {
77.   .points(points)
78. }

79. @Entry
80. @Component
81. struct AnimatedShape {
82.   squareStartPointX: number = 75;
83.   squareStartPointY: number = 25;
84.   squareWidth: number = 150;
85.   squareEndTranslateX: number = 50;
86.   squareEndTranslateY: number = 50;
87.   @State pointVec1: PointVector = new PointVector([
88.     [this.squareStartPointX, this.squareStartPointY],
89.     [this.squareStartPointX + this.squareWidth, this.squareStartPointY],
90.     [this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],
91.     [this.squareStartPointX, this.squareStartPointY + this.squareWidth]
92.   ]);
93.   @State pointVec2: PointVector = new PointVector([
94.     [this.squareStartPointX + this.squareEndTranslateX, this.squareStartPointY + this.squareStartPointY],
95.     [this.squareStartPointX + this.squareWidth + this.squareEndTranslateX,
96.       this.squareStartPointY + this.squareStartPointY],
97.     [this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],
98.     [this.squareStartPointX, this.squareStartPointY + this.squareWidth]
99.   ]);
100.   @State color: Color = Color.Green;
101.   @State fontSize: number = 20.0;
102.   @State polyline1Vec: PointVector = this.pointVec1;
103.   @State polyline2Vec: PointVector = this.pointVec2;

104.   build() {
105.     Row() {
106.       Polyline()
107.         .width(300)
108.         .height(200)
109.         .backgroundColor("#0C000000")
110.         .fill('#317AF7')
111.         .animatablePoints(this.polyline1Vec)
112.         .animation({ duration: 2000, delay: 0, curve: Curve.Ease })
113.         .onClick(() => {

114.           if (this.polyline1Vec.equals(this.pointVec1)) {
115.             this.polyline1Vec = this.pointVec2;
116.           } else {
117.             this.polyline1Vec = this.pointVec1;
118.           }
119.         })
120.     }
121.     .width('100%').height('100%').justifyContent(FlexAlign.Center)
122.   }
123. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164038.63251197450497720100351248672884:50001231000000:2800:C80C95EF0DB84FB9C0167E452E5AB24DC5B29E95AF0E19851946F4CF8C0608A2.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis "实现属性动画")
# 出现/消失转场

更新时间: 2025-12-16 16:40

[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)是基础的组件转场接口，用于实现一个组件出现或者消失时的动画效果。可以通过[TransitionEffect对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component#transitioneffect10%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)的组合使用，定义出各式效果。

**表1** 转场效果接口

|转场效果|说明|动画|
|:--|:--|:--|
|IDENTITY|禁用转场效果。|无。|
|OPACITY|默认的转场效果，透明度转场。|出现时透明度从0到1，消失时透明度从1到0。|
|SLIDE|滑动转场效果。|出现时从窗口左侧滑入，消失时从窗口右侧滑出。|
|translate|通过设置组件平移创建转场效果。|出现时为translate接口设置的值到默认值0，消失时为默认值0到translate接口设置的值。|
|rotate|通过设置组件旋转创建转场效果。|出现时为rotate接口设置的值到默认值0，消失时为默认值0到rotate接口设置的值。|
|opacity|通过设置透明度参数创建转场效果。|出现时为opacity设置的值到默认透明度1，消失时为默认透明度1到opacity设置的值。|
|move|通过[TransitionEdge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component#transitionedge10)创建从窗口哪条边缘出来的效果。|出现时从TransitionEdge方向滑入，消失时滑出到TransitionEdge方向。|
|asymmetric|通过此方法组合非对称的出现消失转场效果。<br><br>- appear:出现转场的效果。<br><br>- disappear：消失转场的效果。|出现时采用appear设置的TransitionEffect出现效果，消失时采用disappear设置的TransitionEffect消失效果。|
|combine|组合其他TransitionEffect。|组合其他TransitionEffect，一起生效。|
|animation|定义转场效果的动画参数：<br><br>- 如果不定义会跟随animateTo的动画参数。<br><br>- 不支持通过控件的animation接口配置动画参数。<br><br>- TransitionEffect中animation的onFinish不生效。|调用顺序是从上往下，上面TransitionEffect的animation也会作用到下面TransitionEffect。|

1. 创建TransitionEffect。
    
    1. // 出现时会是所有转场效果的出现效果叠加，消失时会是所有消失转场效果的叠加
    2. // 说明各个effect跟随的动画参数
    3. private effect: object =
    4.   TransitionEffect.OPACITY // 创建了透明度转场效果，这里没有调用animation接口，会跟随animateTo的动画参数
    5.     // 通过combine方法，添加缩放转场效果，并指定了springMotion(0.6, 1.2)曲线
    6.     .combine(TransitionEffect.scale({ x: 0, y: 0 }).animation({ curve: curves.springMotion(0.6, 1.2) }))
    7.     // 添加旋转转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 1.2)
    8.     .combine(TransitionEffect.rotate({ angle: 90 }))
    9.     // 添加平移转场效果，动画参数会跟随其之上带animation的TransitionEffect，也就是springMotion(0.6, 1.2)
    10.     .combine(TransitionEffect.translate({ x: 150, y: 150 }))
    11.     // 添加move转场效果，并指定了springMotion曲线
    12.     .combine(TransitionEffect.move(TransitionEdge.END)).animation({curve: curves.springMotion()})
    13.     // 添加非对称的转场效果，由于这里没有设置animation，会跟随上面的TransitionEffect的animation效果，也就是springMotion
    14.     .combine(TransitionEffect.asymmetric(TransitionEffect.scale({ x: 0, y: 0 }), TransitionEffect.rotate({ angle: 90 })));
    
2. 将转场效果通过[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)接口设置到组件。
    
    1. Text('test')
    2.   .transition(this.effect)
    
3. 新增或者删除组件触发转场。
    
    1. @State isPresent: boolean = true;
    2. // ...
    3. if (this.isPresent) {
    4.   Text('test')
    5.     .transition(this.effect)
    6. }
    7. // ...
    8. // 控制新增或者删除组件
    9. // 方式一：将控制变量放到animateTo闭包内，未通过animation接口定义动画参数的TransitionEffect将跟随animateTo的动画参数
    10. this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
    11.   this.isPresent = false;
    12. })
    
    13. // 方式二：直接控制删除或者新增组件，动画参数由TransitionEffect的animation接口配置
    14. this.isPresent = false;
    

完整的示例代码和效果如下，示例中采用直接删除或新增组件的方式触发转场，也可以替换为在animateTo闭包内改变控制变量触发转场。

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct TransitionEffectDemo {
5.   @State isPresent: boolean = false;
6.   // 第一步，创建TransitionEffect
7.   private effect: TransitionEffect =
8.     // 创建默认透明度转场效果，并指定了springMotion(0.6, 0.8)曲线
9.     TransitionEffect.OPACITY.animation({
10.       curve: curves.springMotion(0.6, 0.8)
11.     })// 通过combine方法，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 0.8)
12.       .combine(TransitionEffect.scale({
13.         x: 0,
14.         y: 0
15.       }))// 添加旋转转场效果，这里的动画参数会跟随上面带animation的TransitionEffect，也就是springMotion(0.6, 0.8)
16.       .combine(TransitionEffect.rotate({ angle: 90 }))// 添加平移转场效果，这里的动画参数使用指定的springMotion()
17.       .combine(TransitionEffect.translate({ y: 150 })
18.         .animation({ curve: curves.springMotion() }))// 添加move转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion()
19.       .combine(TransitionEffect.move(TransitionEdge.END));

20.   build() {
21.     Stack() {
22.       if (this.isPresent) {
23.         Column() {
24.           Text('ArkUI')
25.             .fontWeight(FontWeight.Bold)
26.             .fontSize(20)
27.             .fontColor(Color.White)
28.         }
29.         .justifyContent(FlexAlign.Center)
30.         .width(150)
31.         .height(150)
32.         .borderRadius(10)
33.         .backgroundColor(0xf56c6c)
34.         // 第二步：将转场效果通过transition接口设置到组件
35.         .transition(this.effect)
36.       }

37.       // 边框
38.       Column()
39.         .width(155)
40.         .height(155)
41.         .border({
42.           width: 5,
43.           radius: 10,
44.           color: Color.Black
45.         })

46.       // 第三步：新增或者删除组件触发转场，控制新增或者删除组件
47.       Button('Click')
48.         .margin({ top: 320 })
49.         .onClick(() => {
50.           this.isPresent = !this.isPresent;
51.         })
52.     }
53.     .width('100%')
54.     .height('60%')
55.   }
56. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164027.18232688060223799851033437223079:50001231000000:2800:ADDF4D5397D86833C28ACA5E620EEA0884E3A796677B0317E2188555F035A849.gif)

对多个组件添加转场效果时，可以在animation动画参数中配置不同的delay值，实现组件渐次出现消失的效果：

1. const ITEM_COUNTS = 9;
2. const ITEM_COLOR = '#ED6F21';
3. const INTERVAL = 30;
4. const DURATION = 300;

5. @Entry
6. @Component
7. struct Index1 {
8.   @State isGridShow: boolean = false;
9.   private dataArray: number[] = new Array(ITEM_COUNTS);

10.   aboutToAppear(): void {
11.     for (let i = 0; i < ITEM_COUNTS; i++) {
12.       this.dataArray[i] = i;
13.     }
14.   }

15.   build() {
16.     Stack() {
17.       if (this.isGridShow) {
18.         Grid() {
19.           ForEach(this.dataArray, (item: number, index: number) => {
20.             GridItem() {
21.               Stack() {
22.                 Text((item + 1).toString())
23.               }
24.               .size({ width: 50, height: 50 })
25.               .backgroundColor(ITEM_COLOR)
26.               .transition(TransitionEffect.OPACITY
27.                 .combine(TransitionEffect.scale({ x: 0.5, y: 0.5 }))// 对每个方格的转场添加delay，实现组件的渐次出现消失效果
28.                 .animation({ duration: DURATION, curve: Curve.Friction, delay: INTERVAL * index }))
29.               .borderRadius(10)
30.             }
31.             // 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效
32.             // 此处让方格的父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响
33.             .transition(TransitionEffect.opacity(0.99))
34.           }, (item: number) => item.toString())
35.         }
36.         .columnsTemplate('1fr 1fr 1fr')
37.         .rowsGap(15)
38.         .columnsGap(15)
39.         .size({ width: 180, height: 180 })
40.         // 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效
41.         // 此处让父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响
42.         .transition(TransitionEffect.opacity(0.99))
43.       }
44.     }
45.     .size({ width: '100%', height: '100%' })
46.     .onClick(() => {
47.       this.getUIContext()?.animateTo({
48.         duration: DURATION + INTERVAL * (ITEM_COUNTS - 1),
49.         curve: Curve.Friction
50.       }, () => {
51.         this.isGridShow = !this.isGridShow;
52.       })
53.     })
54.   }
55. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164027.65647628603972492557459087010114:50001231000000:2800:472AFD7511DFC4560BFC9B14F8A9BDF961B28B2ED9FE4DCCCF6E1CE67B321FD1.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-transition-overview "转场动画概述")
# 出现/消失转场

更新时间: 2025-12-16 16:40

[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)是基础的组件转场接口，用于实现一个组件出现或者消失时的动画效果。可以通过[TransitionEffect对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component#transitioneffect10%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)的组合使用，定义出各式效果。

**表1** 转场效果接口

|转场效果|说明|动画|
|:--|:--|:--|
|IDENTITY|禁用转场效果。|无。|
|OPACITY|默认的转场效果，透明度转场。|出现时透明度从0到1，消失时透明度从1到0。|
|SLIDE|滑动转场效果。|出现时从窗口左侧滑入，消失时从窗口右侧滑出。|
|translate|通过设置组件平移创建转场效果。|出现时为translate接口设置的值到默认值0，消失时为默认值0到translate接口设置的值。|
|rotate|通过设置组件旋转创建转场效果。|出现时为rotate接口设置的值到默认值0，消失时为默认值0到rotate接口设置的值。|
|opacity|通过设置透明度参数创建转场效果。|出现时为opacity设置的值到默认透明度1，消失时为默认透明度1到opacity设置的值。|
|move|通过[TransitionEdge](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component#transitionedge10)创建从窗口哪条边缘出来的效果。|出现时从TransitionEdge方向滑入，消失时滑出到TransitionEdge方向。|
|asymmetric|通过此方法组合非对称的出现消失转场效果。<br><br>- appear:出现转场的效果。<br><br>- disappear：消失转场的效果。|出现时采用appear设置的TransitionEffect出现效果，消失时采用disappear设置的TransitionEffect消失效果。|
|combine|组合其他TransitionEffect。|组合其他TransitionEffect，一起生效。|
|animation|定义转场效果的动画参数：<br><br>- 如果不定义会跟随animateTo的动画参数。<br><br>- 不支持通过控件的animation接口配置动画参数。<br><br>- TransitionEffect中animation的onFinish不生效。|调用顺序是从上往下，上面TransitionEffect的animation也会作用到下面TransitionEffect。|

1. 创建TransitionEffect。
    
    1. // 出现时会是所有转场效果的出现效果叠加，消失时会是所有消失转场效果的叠加
    2. // 说明各个effect跟随的动画参数
    3. private effect: object =
    4.   TransitionEffect.OPACITY // 创建了透明度转场效果，这里没有调用animation接口，会跟随animateTo的动画参数
    5.     // 通过combine方法，添加缩放转场效果，并指定了springMotion(0.6, 1.2)曲线
    6.     .combine(TransitionEffect.scale({ x: 0, y: 0 }).animation({ curve: curves.springMotion(0.6, 1.2) }))
    7.     // 添加旋转转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 1.2)
    8.     .combine(TransitionEffect.rotate({ angle: 90 }))
    9.     // 添加平移转场效果，动画参数会跟随其之上带animation的TransitionEffect，也就是springMotion(0.6, 1.2)
    10.     .combine(TransitionEffect.translate({ x: 150, y: 150 }))
    11.     // 添加move转场效果，并指定了springMotion曲线
    12.     .combine(TransitionEffect.move(TransitionEdge.END)).animation({curve: curves.springMotion()})
    13.     // 添加非对称的转场效果，由于这里没有设置animation，会跟随上面的TransitionEffect的animation效果，也就是springMotion
    14.     .combine(TransitionEffect.asymmetric(TransitionEffect.scale({ x: 0, y: 0 }), TransitionEffect.rotate({ angle: 90 })));
    
2. 将转场效果通过[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)接口设置到组件。
    
    1. Text('test')
    2.   .transition(this.effect)
    
3. 新增或者删除组件触发转场。
    
    1. @State isPresent: boolean = true;
    2. // ...
    3. if (this.isPresent) {
    4.   Text('test')
    5.     .transition(this.effect)
    6. }
    7. // ...
    8. // 控制新增或者删除组件
    9. // 方式一：将控制变量放到animateTo闭包内，未通过animation接口定义动画参数的TransitionEffect将跟随animateTo的动画参数
    10. this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
    11.   this.isPresent = false;
    12. })
    
    13. // 方式二：直接控制删除或者新增组件，动画参数由TransitionEffect的animation接口配置
    14. this.isPresent = false;
    

完整的示例代码和效果如下，示例中采用直接删除或新增组件的方式触发转场，也可以替换为在animateTo闭包内改变控制变量触发转场。

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct TransitionEffectDemo {
5.   @State isPresent: boolean = false;
6.   // 第一步，创建TransitionEffect
7.   private effect: TransitionEffect =
8.     // 创建默认透明度转场效果，并指定了springMotion(0.6, 0.8)曲线
9.     TransitionEffect.OPACITY.animation({
10.       curve: curves.springMotion(0.6, 0.8)
11.     })// 通过combine方法，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 0.8)
12.       .combine(TransitionEffect.scale({
13.         x: 0,
14.         y: 0
15.       }))// 添加旋转转场效果，这里的动画参数会跟随上面带animation的TransitionEffect，也就是springMotion(0.6, 0.8)
16.       .combine(TransitionEffect.rotate({ angle: 90 }))// 添加平移转场效果，这里的动画参数使用指定的springMotion()
17.       .combine(TransitionEffect.translate({ y: 150 })
18.         .animation({ curve: curves.springMotion() }))// 添加move转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion()
19.       .combine(TransitionEffect.move(TransitionEdge.END));

20.   build() {
21.     Stack() {
22.       if (this.isPresent) {
23.         Column() {
24.           Text('ArkUI')
25.             .fontWeight(FontWeight.Bold)
26.             .fontSize(20)
27.             .fontColor(Color.White)
28.         }
29.         .justifyContent(FlexAlign.Center)
30.         .width(150)
31.         .height(150)
32.         .borderRadius(10)
33.         .backgroundColor(0xf56c6c)
34.         // 第二步：将转场效果通过transition接口设置到组件
35.         .transition(this.effect)
36.       }

37.       // 边框
38.       Column()
39.         .width(155)
40.         .height(155)
41.         .border({
42.           width: 5,
43.           radius: 10,
44.           color: Color.Black
45.         })

46.       // 第三步：新增或者删除组件触发转场，控制新增或者删除组件
47.       Button('Click')
48.         .margin({ top: 320 })
49.         .onClick(() => {
50.           this.isPresent = !this.isPresent;
51.         })
52.     }
53.     .width('100%')
54.     .height('60%')
55.   }
56. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164027.18232688060223799851033437223079:50001231000000:2800:ADDF4D5397D86833C28ACA5E620EEA0884E3A796677B0317E2188555F035A849.gif)

对多个组件添加转场效果时，可以在animation动画参数中配置不同的delay值，实现组件渐次出现消失的效果：

1. const ITEM_COUNTS = 9;
2. const ITEM_COLOR = '#ED6F21';
3. const INTERVAL = 30;
4. const DURATION = 300;

5. @Entry
6. @Component
7. struct Index1 {
8.   @State isGridShow: boolean = false;
9.   private dataArray: number[] = new Array(ITEM_COUNTS);

10.   aboutToAppear(): void {
11.     for (let i = 0; i < ITEM_COUNTS; i++) {
12.       this.dataArray[i] = i;
13.     }
14.   }

15.   build() {
16.     Stack() {
17.       if (this.isGridShow) {
18.         Grid() {
19.           ForEach(this.dataArray, (item: number, index: number) => {
20.             GridItem() {
21.               Stack() {
22.                 Text((item + 1).toString())
23.               }
24.               .size({ width: 50, height: 50 })
25.               .backgroundColor(ITEM_COLOR)
26.               .transition(TransitionEffect.OPACITY
27.                 .combine(TransitionEffect.scale({ x: 0.5, y: 0.5 }))// 对每个方格的转场添加delay，实现组件的渐次出现消失效果
28.                 .animation({ duration: DURATION, curve: Curve.Friction, delay: INTERVAL * index }))
29.               .borderRadius(10)
30.             }
31.             // 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效
32.             // 此处让方格的父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响
33.             .transition(TransitionEffect.opacity(0.99))
34.           }, (item: number) => item.toString())
35.         }
36.         .columnsTemplate('1fr 1fr 1fr')
37.         .rowsGap(15)
38.         .columnsGap(15)
39.         .size({ width: 180, height: 180 })
40.         // 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效
41.         // 此处让父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响
42.         .transition(TransitionEffect.opacity(0.99))
43.       }
44.     }
45.     .size({ width: '100%', height: '100%' })
46.     .onClick(() => {
47.       this.getUIContext()?.animateTo({
48.         duration: DURATION + INTERVAL * (ITEM_COUNTS - 1),
49.         curve: Curve.Friction
50.       }, () => {
51.         this.isGridShow = !this.isGridShow;
52.       })
53.     })
54.   }
55. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164027.65647628603972492557459087010114:50001231000000:2800:472AFD7511DFC4560BFC9B14F8A9BDF961B28B2ED9FE4DCCCF6E1CE67B321FD1.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-transition-overview "转场动画概述")
# 共享元素转场 (一镜到底)

更新时间: 2025-12-16 16:40

共享元素转场是一种界面切换时对相同或者相似的两个元素做的一种位置和大小匹配的过渡动画效果，也称一镜到底动效。

如下例所示，在点击图片后，该图片消失，同时在另一个位置出现新的图片，二者之间内容相同，可以对它们添加一镜到底动效。左图为不添加一镜到底动效的效果，右图为添加一镜到底动效的效果，一镜到底的效果能够让二者的出现消失产生联动，使得内容切换过程显得灵动自然而不生硬。

|   |   |
|---|---|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.84094530939537589914493896349658:50001231000000:2800:37C5C7D9D6216F417E0A207CD22D2E4BF08403AE4B85D14972E1DCBF1A62FB3E.gif)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.80553205120654277749869978432078:50001231000000:2800:8DF360AC7C09D418081F02CFA9CF50983AC6EC9432CB42A053DA9C03ECBE3378.gif)|

一镜到底的动效有多种实现方式，在实际开发过程中，应根据具体场景选择合适的方法进行实现。

以下是不同实现方式的对比：

|一镜到底实现方式|特点|适用场景|
|:--|:--|:--|
|不新建容器直接变化原容器|不发生路由跳转，需要在一个组件中实现展开及关闭两种状态的布局，展开后组件层级不变。|适用于转场开销小的简单场景，如点开页面无需加载大量数据及组件。|
|新建容器并跨容器迁移组件|通过使用NodeController，将组件从一个容器迁移到另一个容器，在开始迁移时，需要根据前后两个布局的位置大小等信息对组件添加位移及缩放，确保迁移开始时组件能够对齐初始布局，避免出现视觉上的跳变现象。之后再添加动画将位移及缩放等属性复位，实现组件从初始布局到目标布局的一镜到底过渡效果。|适用于新建对象开销大的场景，如视频直播组件点击转为全屏等。|
|使用geometryTransition共享元素转场|利用系统能力，转场前后两个组件调用geometryTransition接口绑定同一id，同时将转场逻辑置于animateTo动画闭包内，这样系统侧会自动为二者添加一镜到底的过渡效果。|系统将调整绑定的两个组件的宽高及位置至相同值，并切换二者的透明度，以实现一镜到底过渡效果。因此，为了实现流畅的动画效果，需要确保对绑定geometryTransition的节点添加宽高动画不会有跳变。此方式适用于创建新节点开销小的场景。|

## 不新建容器并直接变化原容器

该方法不新建容器，通过在已有容器上增删组件触发[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)，搭配组件[属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis)实现一镜到底效果。

对于同一个容器展开，容器内兄弟组件消失或者出现的场景，可通过对同一个容器展开前后进行宽高位置变化并配置属性动画，对兄弟组件配置出现消失转场动画实现一镜到底效果。基本步骤为：

1. 构建需要展开的页面，并通过状态变量构建好普通状态和展开状态的界面。
    
2. 将需要展开的页面展开，通过状态变量控制兄弟组件消失或出现，并通过绑定出现消失转场实现兄弟组件转场效果。
    

以点击卡片后显示卡片内容详情场景为例：

1. class PostData {
2.   // 图片使用Resource资源，需用户自定义
3.   avatar: Resource = $r('app.media.flower');
4.   name: string = '';
5.   message: string = '';
6.   images: Resource[] = [];
7. }

8. @Entry
9. @Component
10. struct Index {
11.   @State isExpand: boolean = false;
12.   @State @Watch('onItemClicked') selectedIndex: number = -1;

13.   // 数组中图片均使用Resource资源，需用户自定义
14.   private allPostData: PostData[] = [
15.     { avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
16.       images: [$r('app.media.spring'), $r('app.media.tree')] },
17.     { avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
18.       images: [$r('app.media.island')] },
19.     { avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
20.       images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];

21.   private onItemClicked(): void {
22.     if (this.selectedIndex < 0) {
23.       return;
24.     }
25.     this.getUIContext()?.animateTo({
26.       duration: 350,
27.       curve: Curve.Friction
28.     }, () => {
29.       this.isExpand = !this.isExpand;
30.     });
31.   }

32.   build() {
33.     Column({ space: 20 }) {
34.       ForEach(this.allPostData, (postData: PostData, index: number) => {
35.         // 当点击了某个post后，会使其余的post消失下树
36.         if (!this.isExpand || this.selectedIndex === index) {
37.           Column() {
38.             Post({ data: postData, selectedIndex: this.selectedIndex, index: index })
39.           }
40.           .width('100%')
41.           // 对出现消失的post添加透明度转场和位移转场效果
42.           .transition(TransitionEffect.OPACITY
43.             .combine(TransitionEffect.translate({ y: index < this.selectedIndex ? -250 : 250 }))
44.             .animation({ duration: 350, curve: Curve.Friction}))
45.         }
46.       }, (postData: PostData, index: number) => index.toString())
47.     }
48.     .size({ width: '100%', height: '100%' })
49.     .backgroundColor('#40808080')
50.   }
51. }

52. @Component
53. export default struct  Post {
54.   @Link selectedIndex: number;

55.   @Prop data: PostData;
56.   @Prop index: number;

57.   @State itemHeight: number = 250;
58.   @State isExpand: boolean = false;
59.   @State expandImageSize: number = 100;
60.   @State avatarSize: number = 50;

61.   build() {
62.     Column({ space: 20 }) {
63.       Row({ space: 10 }) {
64.         Image(this.data.avatar)
65.           .size({ width: this.avatarSize, height: this.avatarSize })
66.           .borderRadius(this.avatarSize / 2)
67.           .clip(true)

68.         Text(this.data.name)
69.       }
70.       .justifyContent(FlexAlign.Start)

71.       Text(this.data.message)

72.       Row({ space: 15 }) {
73.         ForEach(this.data.images, (imageResource: Resource, index: number) => {
74.           Image(imageResource)
75.             .size({ width: this.expandImageSize, height: this.expandImageSize })
76.         }, (imageResource: Resource, index: number) => index.toString())
77.       }

78.       // 展开态下组件增加的内容
79.       if (this.isExpand) {
80.         Column() {
81.           Text('评论区')
82.             // 对评论区文本添加出现消失转场效果
83.             .transition( TransitionEffect.OPACITY
84.               .animation({ duration: 350, curve: Curve.Friction }))
85.             .padding({ top: 10 })
86.         }
87.         .transition(TransitionEffect.asymmetric(
88.           TransitionEffect.opacity(0.99)
89.             .animation({ duration: 350, curve: Curve.Friction }),
90.           TransitionEffect.OPACITY.animation({ duration: 0 })
91.         ))
92.         .size({ width: '100%'})
93.       }
94.     }
95.     .backgroundColor(Color.White)
96.     .size({ width: '100%', height: this.itemHeight })
97.     .alignItems(HorizontalAlign.Start)
98.     .padding({ left: 10, top: 10 })
99.     .onClick(() => {
100.       this.selectedIndex = -1;
101.       this.selectedIndex = this.index;
102.       this.getUIContext()?.animateTo({
103.         duration: 350,
104.         curve: Curve.Friction
105.       }, () => {
106.         // 对展开的post做宽高动画，并对头像尺寸和图片尺寸加动画
107.         this.isExpand = !this.isExpand;
108.         this.itemHeight = this.isExpand ? 780 : 250;
109.         this.avatarSize = this.isExpand ? 75: 50;
110.         this.expandImageSize = (this.isExpand && this.data.images.length > 0)
111.           ? (360 - (this.data.images.length + 1) * 15) / this.data.images.length : 100;
112.       })
113.     })
114.   }
115. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.11573830513638335466236997937071:50001231000000:2800:71C86D5867B7E0F69C74F660D5E5B70D3B2064A2C5A5EAEA4901D8C75E8E2298.gif)

## 新建容器并跨容器迁移组件

通过[NodeContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-nodecontainer)[自定义占位节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-place-holder)，利用[NodeController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontroller)实现组件的跨节点迁移，配合属性动画给组件的迁移过程赋予一镜到底效果。这种一镜到底的实现方式可以结合多种转场方式使用，如导航转场（[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)）、半模态转场（[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#bindsheet)）等。

### 结合Stack使用

可以利用Stack内后定义组件在最上方的特性控制组件在跨节点迁移后位z序最高，以展开收起卡片的场景为例，实现步骤为：

- 展开卡片时，获取节点A的位置信息，将其中的组件迁移到与节点A位置一致的节点B处，节点B的层级高于节点A。
    
- 对节点B添加属性动画，使之展开并运动到展开后的位置，完成一镜到底的动画效果。
    
- 收起卡片时，对节点B添加属性动画，使之收起并运动到收起时的位置，即节点A的位置，实现一镜到底的动画效果。
    
- 在动画结束时利用回调将节点B中的组件迁移回节点A处。
    

1. // Index.ets
2. import { createPostNode, getPostNode, PostNode } from "./PostNode";
3. import { componentUtils, curves, UIContext } from '@kit.ArkUI';

4. @Entry
5. @Component
6. struct Index {
7.   // 新建一镜到底动画类
8.   private uiContext: UIContext = this.getUIContext();
9.   @State animationProperties: AnimationProperties = new AnimationProperties(this.uiContext);
10.   private listArray: Array<number> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

11.   build() {
12.     // 卡片折叠态，展开态的共同父组件
13.     Stack() {
14.       List({ space: 20 }) {
15.         ForEach(this.listArray, (item: number) => {
16.           ListItem() {
17.             // 卡片折叠态
18.             PostItem({ index: item, animationProperties: this.animationProperties })
19.           }
20.         })
21.       }
22.       .clip(false)
23.       .alignListItem(ListItemAlign.Center)

24.       if (this.animationProperties.isExpandPageShow) {
25.         // 卡片展开态
26.         ExpandPage({ animationProperties: this.animationProperties })
27.       }
28.     }
29.     .key('rootStack')
30.     .enabled(this.animationProperties.isEnabled)
31.   }
32. }

33. @Component
34. struct PostItem {
35.   @Prop index: number
36.   @Link animationProperties: AnimationProperties;
37.   @State nodeController: PostNode | undefined = undefined;
38.   // 折叠时详细内容隐藏
39.   private showDetailContent: boolean = false;

40.   aboutToAppear(): void {
41.     this.nodeController = createPostNode(this.getUIContext(), this.index.toString(), this.showDetailContent);
42.     if (this.nodeController != undefined) {
43.       // 设置回调，当卡片从展开态回到折叠态时触发
44.       this.nodeController.setCallback(this.resetNode.bind(this));
45.     }
46.   }

47.   resetNode() {
48.     this.nodeController = getPostNode(this.index.toString());
49.   }

50.   build() {
51.     Stack() {
52.       NodeContainer(this.nodeController)
53.     }
54.     .width('100%')
55.     .height(100)
56.     .key(this.index.toString())
57.     .onClick(() => {
58.       if (this.nodeController != undefined) {
59.         // 卡片从折叠态节点下树
60.         this.nodeController.onRemove();
61.       }
62.       // 触发卡片从折叠到展开态的动画
63.       this.animationProperties.expandAnimation(this.index);
64.     })
65.   }
66. }

67. @Component
68. struct ExpandPage {
69.   @Link animationProperties: AnimationProperties;
70.   @State nodeController: PostNode | undefined = undefined;
71.   // 展开时详细内容出现
72.   private showDetailContent: boolean = true;

73.   aboutToAppear(): void {
74.     // 获取对应序号的卡片组件
75.     this.nodeController = getPostNode(this.animationProperties.curIndex.toString())
76.     // 更新为详细内容出现
77.     this.nodeController?.update(this.animationProperties.curIndex.toString(), this.showDetailContent)
78.   }

79.   build() {
80.     Stack() {
81.       NodeContainer(this.nodeController)
82.     }
83.     .width('100%')
84.     .height(this.animationProperties.changedHeight ? '100%' : 100)
85.     .translate({ x: this.animationProperties.translateX, y: this.animationProperties.translateY })
86.     .position({ x: this.animationProperties.positionX, y: this.animationProperties.positionY })
87.     .onClick(() => {
88.       this.getUIContext()?.animateTo({ curve: curves.springMotion(0.6, 0.9),
89.         onFinish: () => {
90.           if (this.nodeController != undefined) {
91.             // 执行回调，折叠态节点获取卡片组件
92.             this.nodeController.callCallback();
93.             // 当前展开态节点的卡片组件下树
94.             this.nodeController.onRemove();
95.           }
96.           // 卡片展开态节点下树
97.           this.animationProperties.isExpandPageShow = false;
98.           this.animationProperties.isEnabled = true;
99.         }
100.       }, () => {
101.         // 卡片从展开态回到折叠态
102.         this.animationProperties.isEnabled = false;
103.         this.animationProperties.translateX = 0;
104.         this.animationProperties.translateY = 0;
105.         this.animationProperties.changedHeight = false;
106.         // 更新为详细内容消失
107.         this.nodeController?.update(this.animationProperties.curIndex.toString(), false);
108.       })
109.     })
110.   }
111. }

112. class RectInfo {
113.   left: number = 0;
114.   top: number = 0;
115.   right: number = 0;
116.   bottom: number = 0;
117.   width: number = 0;
118.   height: number = 0;
119. }

120. // 封装的一镜到底动画类
121. @Observed
122. class AnimationProperties {
123.   public isExpandPageShow: boolean = false;
124.   // 控制组件是否响应点击事件
125.   public isEnabled: boolean = true;
126.   // 展开卡片的序号
127.   public curIndex: number = -1;
128.   public translateX: number = 0;
129.   public translateY: number = 0;
130.   public positionX: number = 0;
131.   public positionY: number = 0;
132.   public changedHeight: boolean = false;
133.   private calculatedTranslateX: number = 0;
134.   private calculatedTranslateY: number = 0;
135.   // 设置卡片展开后相对父组件的位置
136.   private expandTranslateX: number = 0;
137.   private expandTranslateY: number = 0;
138.   private uiContext: UIContext;

139.   constructor(uiContext: UIContext) {
140.     this.uiContext = uiContext
141.   }

142.   public expandAnimation(index: number): void {
143.     // 记录展开态卡片的序号
144.     if (index != undefined) {
145.       this.curIndex = index;
146.     }
147.     // 计算折叠态卡片相对父组件的位置
148.     this.calculateData(index.toString());
149.     // 展开态卡片上树
150.     this.isExpandPageShow = true;
151.     // 卡片展开的属性动画
152.     this.uiContext?.animateTo({ curve: curves.springMotion(0.6, 0.9)
153.     }, () => {
154.       this.translateX = this.calculatedTranslateX;
155.       this.translateY = this.calculatedTranslateY;
156.       this.changedHeight = true;
157.     })
158.   }

159.   // 获取需要跨节点迁移的组件的位置，及迁移前后节点的公共父节点的位置，用以计算做动画组件的动画参数
160.   public calculateData(key: string): void {
161.     let clickedImageInfo = this.getRectInfoById(this.uiContext, key);
162.     let rootStackInfo = this.getRectInfoById(this.uiContext, 'rootStack');
163.     this.positionX = this.uiContext.px2vp(clickedImageInfo.left - rootStackInfo.left);
164.     this.positionY = this.uiContext.px2vp(clickedImageInfo.top - rootStackInfo.top);
165.     this.calculatedTranslateX = this.uiContext.px2vp(rootStackInfo.left - clickedImageInfo.left) + this.expandTranslateX;
166.     this.calculatedTranslateY = this.uiContext.px2vp(rootStackInfo.top - clickedImageInfo.top) + this.expandTranslateY;
167.   }

168.   // 根据组件的id获取组件的位置信息
169.   private getRectInfoById(context: UIContext, id: string): RectInfo {
170.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

171.     if (!componentInfo) {
172.       throw Error('object is empty');
173.     }

174.     let rstRect: RectInfo = new RectInfo();
175.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
176.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
177.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
178.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
179.     rstRect.right =
180.     componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
181.     rstRect.bottom =
182.     componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
183.     rstRect.width = rstRect.right - rstRect.left;
184.     rstRect.height = rstRect.bottom - rstRect.top;

185.     return {
186.       left: rstRect.left,
187.       right: rstRect.right,
188.       top: rstRect.top,
189.       bottom: rstRect.bottom,
190.       width: rstRect.width,
191.       height: rstRect.height
192.     }
193.   }
194. }

195. // PostNode.ets
196. // 跨容器迁移能力
197. import { UIContext, curves, NodeController, BuilderNode, FrameNode } from '@kit.ArkUI';

198. class Data {
199.   item: string | null = null
200.   isExpand: boolean = false
201. }

202. @Builder
203. function PostBuilder(data: Data) {
204.   // 跨容器迁移组件置于@Builder内
205.   Column() {
206.       Row() {
207.         Row()
208.           .backgroundColor(Color.Pink)
209.           .borderRadius(20)
210.           .width(80)
211.           .height(80)

212.         Column() {
213.           Text('点击展开 Item ' + data.item)
214.             .fontSize(20)
215.           Text('共享元素转场')
216.             .fontSize(12)
217.             .fontColor(0x909399)
218.         }
219.         .alignItems(HorizontalAlign.Start)
220.         .justifyContent(FlexAlign.SpaceAround)
221.         .margin({ left: 10 })
222.         .height(80)
223.       }
224.       .width('90%')
225.       .height(100)
226.       // 展开后显示细节内容
227.       if (data.isExpand) {
228.         Row() {
229.           Text('展开态')
230.             .fontSize(28)
231.             .fontColor(0x909399)
232.             .textAlign(TextAlign.Center)
233.             .transition(TransitionEffect.OPACITY.animation({ curve: curves.springMotion(0.6, 0.9) }))
234.         }
235.         .width('90%')
236.         .justifyContent(FlexAlign.Center)
237.       }
238.     }
239.     .width('90%')
240.     .height('100%')
241.     .alignItems(HorizontalAlign.Center)
242.     .borderRadius(10)
243.     .margin({ top: 15 })
244.     .backgroundColor(Color.White)
245.     .shadow({
246.       radius: 20,
247.       color: 0x909399,
248.       offsetX: 20,
249.       offsetY: 10
250.     })
251. }

252. class __InternalValue__ {
253.   flag:boolean =false;
254. };

255. export class PostNode extends NodeController {
256.   private node: BuilderNode<Data[]> | null = null;
257.   private isRemove: __InternalValue__ = new __InternalValue__();
258.   private callback: Function | undefined = undefined
259.   private data: Data | null = null

260.   makeNode(uiContext: UIContext): FrameNode | null {
261.     if(this.isRemove.flag == true){
262.       return null;
263.     }
264.     if (this.node != null) {
265.       return this.node.getFrameNode();
266.     }

267.     return null;
268.   }

269.   init(uiContext: UIContext, id: string, isExpand: boolean) {
270.     if (this.node != null) {
271.       return;
272.     }
273.     // 创建节点，需要uiContext
274.     this.node = new BuilderNode(uiContext)
275.     // 创建离线组件
276.     this.data = { item: id, isExpand: isExpand }
277.     this.node.build(wrapBuilder<Data[]>(PostBuilder), this.data)
278.   }

279.   update(id: string, isExpand: boolean) {
280.     if (this.node !== null) {
281.       // 调用update进行更新。
282.       this.data = { item: id, isExpand: isExpand }
283.       this.node.update(this.data);
284.     }
285.   }

286.   setCallback(callback: Function | undefined) {
287.     this.callback = callback
288.   }

289.   callCallback() {
290.     if (this.callback != undefined) {
291.       this.callback();
292.     }
293.   }

294.   onRemove(){
295.     this.isRemove.flag = true;
296.     // 组件迁移出节点时触发重建
297.     this.rebuild();
298.     this.isRemove.flag = false;
299.   }
300. }

301. let gNodeMap: Map<string, PostNode | undefined> = new Map();

302. export const createPostNode =
303.   (uiContext: UIContext, id: string, isExpand: boolean): PostNode | undefined => {
304.     let node = new PostNode();
305.     node.init(uiContext, id, isExpand);
306.     gNodeMap.set(id, node);
307.     return node;
308.   }

309. export const getPostNode = (id: string): PostNode | undefined => {
310.   if (!gNodeMap.has(id)) {
311.     return undefined
312.   }
313.   return gNodeMap.get(id);
314. }

315. export const deleteNode = (id: string) => {
316.   gNodeMap.delete(id)
317. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.37240076024957776115084098912993:50001231000000:2800:B9E792E963226DA984B2911D76846EF0920C29BA99A6C95FAE354FC23729B429.gif)

### 结合Navigation使用

可以利用[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)的自定义导航转场动画能力（[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)，可参考Navigation[示例3](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B3%E8%AE%BE%E7%BD%AE%E5%8F%AF%E4%BA%A4%E4%BA%92%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB)）实现一镜到底动效。共享元素转场期间，组件由消失页面迁移至出现页面。

以展开收起缩略图的场景为例，实现步骤为：

- 通过customNavContentTransition配置PageOne与PageTwo的自定义导航转场动画。
    
- 自定义的共享元素转场效果由属性动画实现，具体实现方式为抓取页面内组件相对窗口的位置信息从而正确匹配组件在PageOne与PageTwo的位置、缩放等，即动画开始和结束的属性信息。
    
- 点击缩略图后共享元素组件从PageOne被迁移至PageTwo，随后触发由PageOne至PageTwo的自定义转场动画，即PageTwo的共享元素组件从原来的缩略图状态做动画到全屏状态。
    
- 由全屏状态返回到缩略图时，触发由PageTwo至PageOne的自定义转场动画，即PageTwo的共享元素组件从全屏状态做动画到原PageOne的缩略图状态，转场结束后共享元素组件从PageTwo被迁移回PageOne。
    

1. ├──entry/src/main/ets                 // 代码区
2. │  ├──CustomTransition
3. │  │  ├──AnimationProperties.ets      // 一镜到底转场动画封装
4. │  │  └──CustomNavigationUtils.ets    // Navigation自定义转场动画配置
5. │  ├──entryability
6. │  │  └──EntryAbility.ets             // 程序入口类
7. │  ├──NodeContainer
8. │  │  └──CustomComponent.ets          // 自定义占位节点
9. │  ├──pages
10. │  │  ├──Index.ets                    // 导航页面
11. │  │  ├──PageOne.ets                  // 缩略图页面
12. │  │  └──PageTwo.ets                  // 全屏展开页面
13. │  └──utils
14. │     ├──ComponentAttrUtils.ets       // 组件位置获取
15. │     └──WindowUtils.ets              // 窗口信息
16. └──entry/src/main/resources           // 资源文件

17. // Index.ets
18. import { AnimateCallback, CustomTransition } from '../CustomTransition/CustomNavigationUtils';

19. const TAG: string = 'Index';

20. @Entry
21. @Component
22. struct Index {
23.   private pageInfos: NavPathStack = new NavPathStack();
24.   // 允许进行自定义转场的页面名称
25.   private allowedCustomTransitionFromPageName: string[] = ['PageOne'];
26.   private allowedCustomTransitionToPageName: string[] = ['PageTwo'];

27.   aboutToAppear(): void {
28.     this.pageInfos.pushPath({ name: 'PageOne' });
29.   }

30.   private isCustomTransitionEnabled(fromName: string, toName: string): boolean {
31.     // 点击和返回均需要进行自定义转场，因此需要分别判断
32.     if ((this.allowedCustomTransitionFromPageName.includes(fromName)
33.       && this.allowedCustomTransitionToPageName.includes(toName))
34.       || (this.allowedCustomTransitionFromPageName.includes(toName)
35.         && this.allowedCustomTransitionToPageName.includes(fromName))) {
36.       return true;
37.     }
38.     return false;
39.   }

40.   build() {
41.     Navigation(this.pageInfos)
42.       .hideNavBar(true)
43.       .customNavContentTransition((from: NavContentInfo, to: NavContentInfo, operation: NavigationOperation) => {
44.         if ((!from || !to) || (!from.name || !to.name)) {
45.           return undefined;
46.         }

47.         // 通过from和to的name对自定义转场路由进行管控
48.         if (!this.isCustomTransitionEnabled(from.name, to.name)) {
49.           return undefined;
50.         }

51.         // 需要对转场页面是否注册了animation进行判断，来决定是否进行自定义转场
52.         let fromParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(from.index);
53.         let toParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(to.index);
54.         if (!fromParam.animation || !toParam.animation) {
55.           return undefined;
56.         }

57.         // 一切判断完成后，构造customAnimation给系统侧调用，执行自定义转场动画
58.         let customAnimation: NavigationAnimatedTransition = {
59.           onTransitionEnd: (isSuccess: boolean) => {
60.             console.info(TAG, `current transition result is ${isSuccess}`);
61.           },
62.           timeout: 2000,
63.           transition: (transitionProxy: NavigationTransitionProxy) => {
64.             console.info(TAG, 'trigger transition callback');
65.             if (fromParam.animation) {
66.               fromParam.animation(operation == NavigationOperation.PUSH, true, transitionProxy);
67.             }
68.             if (toParam.animation) {
69.               toParam.animation(operation == NavigationOperation.PUSH, false, transitionProxy);
70.             }
71.           }
72.         };
73.         return customAnimation;
74.       })
75.   }
76. }

77. // PageOne.ets
78. import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
79. import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
80. import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
81. import { WindowUtils } from '../utils/WindowUtils';

82. @Builder
83. export function PageOneBuilder() {
84.   PageOne();
85. }

86. @Component
87. export struct PageOne {
88.   private pageInfos: NavPathStack = new NavPathStack();
89.   private pageId: number = -1;
90.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

91.   aboutToAppear(): void {
92.     let node = getMyNode();
93.     if (node == undefined) {
94.       // 新建自定义节点
95.       createMyNode(this.getUIContext());
96.     }
97.     this.myNodeController = getMyNode();
98.   }

99.   private doFinishTransition(): void {
100.     // PageTwo结束转场时将节点从PageTwo迁移回PageOne
101.     this.myNodeController = getMyNode();
102.   }

103.   private registerCustomTransition(): void {
104.     // 注册自定义动画协议
105.     CustomTransition.getInstance().registerNavParam(this.pageId,
106.       (isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {}, 500);
107.   }

108.   private onCardClicked(): void {
109.     let cardItemInfo: RectInfoInPx =
110.       ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), 'card');
111.     let param: Record<string, Object> = {};
112.     param['cardItemInfo'] = cardItemInfo;
113.     param['doDefaultTransition'] = (myController: MyNodeController) => {
114.       this.doFinishTransition()
115.     };
116.     this.pageInfos.pushPath({ name: 'PageTwo', param: param });
117.     // 自定义节点从PageOne下树
118.     if (this.myNodeController != undefined) {
119.       (this.myNodeController as MyNodeController).onRemove();
120.     }
121.   }

122.   build() {
123.     NavDestination() {
124.       Stack() {
125.         Column({ space: 20 }) {
126.           Row({ space: 10 }) {
127.             // 图片使用Resource资源，需用户自定义
128.             Image($r("app.media.avatar"))
129.               .size({ width: 50, height: 50 })
130.               .borderRadius(25)
131.               .clip(true)

132.             Text('Alice')
133.           }
134.           .justifyContent(FlexAlign.Start)

135.           Text('你好世界')

136.           NodeContainer(this.myNodeController)
137.             .size({ width: 320, height: 250 })
138.             .onClick(() => {
139.               this.onCardClicked()
140.             })
141.         }
142.         .alignItems(HorizontalAlign.Start)
143.         .margin(30)
144.       }
145.     }
146.     .onReady((context: NavDestinationContext) => {
147.       this.pageInfos = context.pathStack;
148.       this.pageId = this.pageInfos.getAllPathName().length - 1;
149.       this.registerCustomTransition();
150.     })
151.     .onDisAppear(() => {
152.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
153.       // 自定义节点从PageOne下树
154.       if (this.myNodeController != undefined) {
155.         (this.myNodeController as MyNodeController).onRemove();
156.       }
157.     })
158.   }
159. }

160. // PageTwo.ets
161. import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
162. import { AnimationProperties } from '../CustomTransition/AnimationProperties';
163. import { RectInfoInPx } from '../utils/ComponentAttrUtils';
164. import { getMyNode, MyNodeController } from '../NodeContainer/CustomComponent';

165. @Builder
166. export function PageTwoBuilder() {
167.   PageTwo();
168. }

169. @Component
170. export struct PageTwo {
171.   @State pageInfos: NavPathStack = new NavPathStack();
172.   @State animationProperties: AnimationProperties = new AnimationProperties(this.getUIContext());
173.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

174.   private pageId: number = -1;

175.   private shouldDoDefaultTransition: boolean = false;
176.   private prePageDoFinishTransition: () => void = () => {};
177.   private cardItemInfo: RectInfoInPx = new RectInfoInPx();

178.   @StorageProp('windowSizeChanged') @Watch('unRegisterNavParam') windowSizeChangedTime: number = 0;
179.   @StorageProp('onConfigurationUpdate') @Watch('unRegisterNavParam') onConfigurationUpdateTime: number = 0;

180.   aboutToAppear(): void {
181.     // 迁移自定义节点至当前页面
182.     this.myNodeController = getMyNode();
183.   }

184.   private unRegisterNavParam(): void {
185.     this.shouldDoDefaultTransition = true;
186.   }

187.   private onBackPressed(): boolean {
188.     if (this.shouldDoDefaultTransition) {
189.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
190.       this.pageInfos.pop();
191.       this.prePageDoFinishTransition();
192.       this.shouldDoDefaultTransition = false;
193.       return true;
194.     }
195.     this.pageInfos.pop();
196.     return true;
197.   }

198.   build() {
199.     NavDestination() {
200.       // Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
201.       Stack({ alignContent: Alignment.TopStart }) {
202.         Stack({ alignContent: Alignment.TopStart }) {
203.           Column({space: 20}) {
204.             NodeContainer(this.myNodeController)
205.             if (this.animationProperties.showDetailContent)
206.               Text('展开态内容')
207.                 .fontSize(20)
208.                 .transition(TransitionEffect.OPACITY)
209.                 .margin(30)
210.           }
211.           .alignItems(HorizontalAlign.Start)
212.         }
213.         .position({ y: this.animationProperties.positionValue })
214.       }
215.       .scale({ x: this.animationProperties.scaleValue, y: this.animationProperties.scaleValue })
216.       .translate({ x: this.animationProperties.translateX, y: this.animationProperties.translateY })
217.       .width(this.animationProperties.clipWidth)
218.       .height(this.animationProperties.clipHeight)
219.       .borderRadius(this.animationProperties.radius)
220.       // expandSafeArea使得Stack做沉浸式效果，向上扩到状态栏，向下扩到导航条
221.       .expandSafeArea([SafeAreaType.SYSTEM])
222.       // 对高度进行裁切
223.       .clip(true)
224.     }
225.     .backgroundColor(this.animationProperties.navDestinationBgColor)
226.     .hideTitleBar(true)
227.     .onReady((context: NavDestinationContext) => {
228.       this.pageInfos = context.pathStack;
229.       this.pageId = this.pageInfos.getAllPathName().length - 1;
230.       let param = context.pathInfo?.param as Record<string, Object>;
231.       this.prePageDoFinishTransition = param['doDefaultTransition'] as () => void;
232.       this.cardItemInfo = param['cardItemInfo'] as RectInfoInPx;
233.       CustomTransition.getInstance().registerNavParam(this.pageId,
234.         (isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {
235.           this.animationProperties.doAnimation(
236.             this.cardItemInfo, isPush, isExit, transitionProxy, 0,
237.             this.prePageDoFinishTransition, this.myNodeController);
238.         }, 500);
239.     })
240.     .onBackPressed(() => {
241.       return this.onBackPressed();
242.     })
243.     .onDisAppear(() => {
244.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
245.     })
246.   }
247. }

248. // CustomNavigationUtils.ets
249. // 配置Navigation自定义转场动画
250. export interface AnimateCallback {
251.   animation: ((isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void | undefined)
252.     | undefined;
253.   timeout: (number | undefined) | undefined;
254. }

255. const customTransitionMap: Map<number, AnimateCallback> = new Map();

256. export class CustomTransition {
257.   private constructor() {};

258.   static delegate = new CustomTransition();

259.   static getInstance() {
260.     return CustomTransition.delegate;
261.   }

262.   // 注册页面的动画回调，name是注册页面的动画的回调
263.   // animationCallback是需要执行的动画内容，timeout是转场结束的超时时间
264.   registerNavParam(
265.     name: number,
266.     animationCallback: (operation: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void,
267.     timeout: number): void {
268.     if (customTransitionMap.has(name)) {
269.       let param = customTransitionMap.get(name);
270.       if (param != undefined) {
271.         param.animation = animationCallback;
272.         param.timeout = timeout;
273.         return;
274.       }
275.     }
276.     let params: AnimateCallback = { timeout: timeout, animation: animationCallback };
277.     customTransitionMap.set(name, params);
278.   }

279.   unRegisterNavParam(name: number): void {
280.     customTransitionMap.delete(name);
281.   }

282.   getAnimateParam(name: number): AnimateCallback {
283.     let result: AnimateCallback = {
284.       animation: customTransitionMap.get(name)?.animation,
285.       timeout: customTransitionMap.get(name)?.timeout,
286.     };
287.     return result;
288.   }
289. }

290. // 工程配置文件module.json5中配置 {"routerMap": "$profile:route_map"}
291. // route_map.json
292. {
293.   "routerMap": [
294.     {
295.       "name": "PageOne",
296.       "pageSourceFile": "src/main/ets/pages/PageOne.ets",
297.       "buildFunction": "PageOneBuilder"
298.     },
299.     {
300.       "name": "PageTwo",
301.       "pageSourceFile": "src/main/ets/pages/PageTwo.ets",
302.       "buildFunction": "PageTwoBuilder"
303.     }
304.   ]
305. }

306. // AnimationProperties.ets
307. // 一镜到底转场动画封装
308. import { curves, UIContext } from '@kit.ArkUI';
309. import { RectInfoInPx } from '../utils/ComponentAttrUtils';
310. import { WindowUtils } from '../utils/WindowUtils';
311. import { MyNodeController } from '../NodeContainer/CustomComponent';

312. const TAG: string = 'AnimationProperties';

313. const DEVICE_BORDER_RADIUS: number = 34;

314. // 将自定义一镜到底转场动画进行封装，其他界面也需要做自定义一镜到底转场的话，可以直接复用，减少工作量
315. @Observed
316. export class AnimationProperties {
317.   public navDestinationBgColor: ResourceColor = Color.Transparent;
318.   public translateX: number = 0;
319.   public translateY: number = 0;
320.   public scaleValue: number = 1;
321.   public clipWidth: Dimension = 0;
322.   public clipHeight: Dimension = 0;
323.   public radius: number = 0;
324.   public positionValue: number = 0;
325.   public showDetailContent: boolean = false;
326.   private uiContext: UIContext;

327.   constructor(uiContext: UIContext) {
328.     this.uiContext = uiContext
329.   }

330.   public doAnimation(cardItemInfo_px: RectInfoInPx, isPush: boolean, isExit: boolean,
331.                      transitionProxy: NavigationTransitionProxy, extraTranslateValue: number, prePageOnFinish: (index: MyNodeController) => void, myNodeController: MyNodeController | undefined): void {
332.     // 首先计算卡片的宽高与窗口宽高的比例
333.     let widthScaleRatio = cardItemInfo_px.width / WindowUtils.windowWidth_px;
334.     let heightScaleRatio = cardItemInfo_px.height / WindowUtils.windowHeight_px;
335.     let isUseWidthScale = widthScaleRatio > heightScaleRatio;
336.     let initScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;

337.     let initTranslateX: number = 0;
338.     let initTranslateY: number = 0;
339.     let initClipWidth: Dimension = 0;
340.     let initClipHeight: Dimension = 0;
341.     // 使得PageTwo卡片向上扩到状态栏
342.     let initPositionValue: number = -this.uiContext.px2vp(WindowUtils.topAvoidAreaHeight_px + extraTranslateValue);

343.     if (isUseWidthScale) {
344.       initTranslateX = this.uiContext.px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px - cardItemInfo_px.width) / 2);
345.       initClipWidth = '100%';
346.       initClipHeight = this.uiContext.px2vp((cardItemInfo_px.height) / initScale);
347.       initTranslateY = this.uiContext.px2vp(cardItemInfo_px.top - ((this.uiContext.vp2px(initClipHeight) - this.uiContext.vp2px(initClipHeight) * initScale) / 2));
348.     } else {
349.       initTranslateY = this.uiContext.px2vp(cardItemInfo_px.top - (WindowUtils.windowHeight_px - cardItemInfo_px.height) / 2);
350.       initClipHeight = '100%';
351.       initClipWidth = this.uiContext.px2vp((cardItemInfo_px.width) / initScale);
352.       initTranslateX = this.uiContext.px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px / 2 - cardItemInfo_px.width / 2));
353.     }

354.     // 转场动画开始前通过计算scale、translate、position和clip height & width，确定节点迁移前后位置一致
355.     console.info(TAG, 'initScale: ' + initScale + ' initTranslateX ' + initTranslateX +
356.     ' initTranslateY ' + initTranslateY + ' initClipWidth ' + initClipWidth +
357.     ' initClipHeight ' + initClipHeight + ' initPositionValue ' + initPositionValue);
358.     // 转场至新页面
359.     if (isPush && !isExit) {
360.       this.scaleValue = initScale;
361.       this.translateX = initTranslateX;
362.       this.clipWidth = initClipWidth;
363.       this.clipHeight = initClipHeight;
364.       this.translateY = initTranslateY;
365.       this.positionValue = initPositionValue;

366.       this.uiContext?.animateTo({
367.         curve: curves.interpolatingSpring(0, 1, 328, 36),
368.         onFinish: () => {
369.           if (transitionProxy) {
370.             transitionProxy.finishTransition();
371.           }
372.         }
373.       }, () => {
374.         this.scaleValue = 1.0;
375.         this.translateX = 0;
376.         this.translateY = 0;
377.         this.clipWidth = '100%';
378.         this.clipHeight = '100%';
379.         // 页面圆角与系统圆角一致
380.         this.radius = DEVICE_BORDER_RADIUS;
381.         this.showDetailContent = true;
382.       })

383.       this.uiContext?.animateTo({
384.         duration: 100,
385.         curve: Curve.Sharp,
386.       }, () => {
387.         // 页面由透明逐渐变为设置背景色
388.         this.navDestinationBgColor = '#00ffffff';
389.       })

390.       // 返回旧页面
391.     } else if (!isPush && isExit) {

392.       this.uiContext?.animateTo({
393.         duration: 350,
394.         curve: Curve.EaseInOut,
395.         onFinish: () => {
396.           if (transitionProxy) {
397.             transitionProxy.finishTransition();
398.           }
399.           prePageOnFinish(myNodeController);
400.           // 自定义节点从PageTwo下树
401.           if (myNodeController != undefined) {
402.             (myNodeController as MyNodeController).onRemove();
403.           }
404.         }
405.       }, () => {
406.         this.scaleValue = initScale;
407.         this.translateX = initTranslateX;
408.         this.translateY = initTranslateY;
409.         this.radius = 0;
410.         this.clipWidth = initClipWidth;
411.         this.clipHeight = initClipHeight;
412.         this.showDetailContent = false;
413.       })

414.       this.uiContext?.animateTo({
415.         duration: 200,
416.         delay: 150,
417.         curve: Curve.Friction,
418.       }, () => {
419.         this.navDestinationBgColor = Color.Transparent;
420.       })
421.     }
422.   }
423. }

424. // ComponentAttrUtils.ets
425. // 获取组件相对窗口的位置
426. import { componentUtils, UIContext } from '@kit.ArkUI';
427. import { JSON } from '@kit.ArkTS';

428. export class ComponentAttrUtils {
429.   // 根据组件的id获取组件的位置信息
430.   public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
431.     if (!context || !id) {
432.       throw Error('object is empty');
433.     }
434.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

435.     if (!componentInfo) {
436.       throw Error('object is empty');
437.     }

438.     let rstRect: RectInfoInPx = new RectInfoInPx();
439.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
440.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
441.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
442.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
443.     rstRect.right =
444.       componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
445.     rstRect.bottom =
446.       componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
447.     rstRect.width = rstRect.right - rstRect.left;
448.     rstRect.height = rstRect.bottom - rstRect.top;
449.     return {
450.       left: rstRect.left,
451.       right: rstRect.right,
452.       top: rstRect.top,
453.       bottom: rstRect.bottom,
454.       width: rstRect.width,
455.       height: rstRect.height
456.     }
457.   }
458. }

459. export class RectInfoInPx {
460.   left: number = 0;
461.   top: number = 0;
462.   right: number = 0;
463.   bottom: number = 0;
464.   width: number = 0;
465.   height: number = 0;
466. }

467. export class RectJson {
468.   $rect: Array<number> = [];
469. }

470. // WindowUtils.ets
471. // 窗口信息
472. import { window } from '@kit.ArkUI';

473. export class WindowUtils {
474.   public static window: window.Window;
475.   public static windowWidth_px: number;
476.   public static windowHeight_px: number;
477.   public static topAvoidAreaHeight_px: number;
478.   public static navigationIndicatorHeight_px: number;
479. }

480. // EntryAbility.ets
481. // 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取

482. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
483. import { hilog } from '@kit.PerformanceAnalysisKit';
484. import { display, window } from '@kit.ArkUI';
485. import { WindowUtils } from '../utils/WindowUtils';

486. const TAG: string = 'EntryAbility';

487. export default class EntryAbility extends UIAbility {
488.   private currentBreakPoint: string = '';

489.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
490.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
491.   }

492.   onDestroy(): void {
493.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
494.   }

495.   onWindowStageCreate(windowStage: window.WindowStage): void {
496.     // Main window is created, set main page for this ability
497.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

498.     // 获取窗口宽高
499.     WindowUtils.window = windowStage.getMainWindowSync();
500.     WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
501.     WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;

502.     this.updateBreakpoint(WindowUtils.windowWidth_px);

503.     // 获取上方避让区(状态栏等)高度
504.     let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
505.     WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;

506.     // 获取导航条高度
507.     let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
508.     WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;

509.     hilog.info(0x0000, TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
510.     WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);

511.     // 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
512.     try {
513.       WindowUtils.window.on('windowSizeChange', (data) => {
514.         hilog.info(0x0000, TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
515.         WindowUtils.windowWidth_px = data.width;
516.         WindowUtils.windowHeight_px = data.height;
517.         this.updateBreakpoint(data.width);
518.         AppStorage.setOrCreate('windowSizeChanged', Date.now())
519.       })

520.       WindowUtils.window.on('avoidAreaChange', (data) => {
521.         if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
522.           let topRectHeight = data.area.topRect.height;
523.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
524.           WindowUtils.topAvoidAreaHeight_px = topRectHeight;
525.         } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
526.           let bottomRectHeight = data.area.bottomRect.height;
527.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
528.           WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
529.         }
530.       })
531.     } catch (exception) {
532.       hilog.error(0x0000, TAG, `register failed. code: ${exception.code}, message: ${exception.message}`);
533.     }

534.     windowStage.loadContent('pages/Index', (err) => {
535.       if (err.code) {
536.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
537.         return;
538.       }
539.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
540.     });
541.   }

542.   updateBreakpoint(width: number) {
543.     let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
544.     let newBreakPoint: string = '';
545.     if (windowWidthVp < 400) {
546.       newBreakPoint = 'xs';
547.     } else if (windowWidthVp < 600) {
548.       newBreakPoint = 'sm';
549.     } else if (windowWidthVp < 800) {
550.       newBreakPoint = 'md';
551.     } else {
552.       newBreakPoint = 'lg';
553.     }
554.     if (this.currentBreakPoint !== newBreakPoint) {
555.       this.currentBreakPoint = newBreakPoint;
556.       // 使用状态变量记录当前断点值
557.       AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
558.     }
559.   }

560.   onWindowStageDestroy(): void {
561.     // Main window is destroyed, release UI related resources
562.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
563.   }

564.   onForeground(): void {
565.     // Ability has brought to foreground
566.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
567.   }

568.   onBackground(): void {
569.     // Ability has back to background
570.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
571.   }
572. }

573. // CustomComponent.ets
574. // 自定义占位节点，跨容器迁移能力
575. import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';

576. @Builder
577. function CardBuilder() {
578.   // 图片使用Resource资源，需用户自定义
579.   Image($r("app.media.card"))
580.     .width('100%')
581.     .id('card')
582. }

583. export class MyNodeController extends NodeController {
584.   private CardNode: BuilderNode<[]> | null = null;
585.   private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
586.   private needCreate: boolean = false;
587.   private isRemove: boolean = false;

588.   constructor(create: boolean) {
589.     super();
590.     this.needCreate = create;
591.   }

592.   makeNode(uiContext: UIContext): FrameNode | null {
593.     if(this.isRemove == true){
594.       return null;
595.     }
596.     if (this.needCreate && this.CardNode == null) {
597.       this.CardNode = new BuilderNode(uiContext);
598.       this.CardNode.build(this.wrapBuilder)
599.     }
600.     if (this.CardNode == null) {
601.       return null;
602.     }
603.     return this.CardNode!.getFrameNode()!;
604.   }

605.   getNode(): BuilderNode<[]> | null {
606.     return this.CardNode;
607.   }

608.   setNode(node: BuilderNode<[]> | null) {
609.     this.CardNode = node;
610.     this.rebuild();
611.   }

612.   onRemove() {
613.     this.isRemove = true;
614.     this.rebuild();
615.     this.isRemove = false;
616.   }

617.   init(uiContext: UIContext) {
618.     this.CardNode = new BuilderNode(uiContext);
619.     this.CardNode.build(this.wrapBuilder)
620.   }
621. }

622. let myNode: MyNodeController | undefined;

623. export const createMyNode =
624.   (uiContext: UIContext) => {
625.     myNode = new MyNodeController(false);
626.     myNode.init(uiContext);
627.   }

628. export const getMyNode = (): MyNodeController | undefined => {
629.   return myNode;
630. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.91962943741384209044607278822523:50001231000000:2800:8DFAE46CA0C1C9EEEA6A76B7605F719C3543BF27EC4EE3857F1BF851396FE47F.gif)

### 结合BindSheet使用

想实现半模态转场（[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#bindsheet)）的同时，组件从初始界面做一镜到底动画到半模态页面的效果，可以使用这样的设计思路。将[SheetOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#sheetoptions)中的mode设置为SheetMode.EMBEDDED，该模式下新起的页面可以覆盖在半模态弹窗上，页面返回后该半模态依旧存在，半模态面板内容不丢失。在半模态转场的同时设置一全模态转场（[bindContentCover](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-modal-transition#bindcontentcover)）页面无转场出现，该页面仅有需要做共享元素转场的组件，通过属性动画，展示组件从初始界面至半模态页面的一镜到底动效，并在动画结束时关闭页面，并将该组件迁移至半模态页面。

以点击图片展开半模态页的场景为例，实现步骤为：

- 在初始界面挂载半模态转场和全模态转场两个页面，半模态页按需布局，全模态页面仅放置一镜到底动效需要的组件，抓取布局信息，使其初始位置为初始界面图片的位置。点击初始界面图片时，同时触发半模态和全模态页面出现，因设置为SheetMode.EMBEDDED模式，此时全模态页面层级最高。
    
- 设置不可见的占位图片置于半模态页上，作为一镜到底动效结束时图片的终止位置。利用[布局回调](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-inspector)监听该占位图片布局完成的时候，此时执行回调抓取占位图片的位置信息，随后全模态页面上的图片利用属性动画开始进行共享元素转场。
    
- 全模态页面的动画结束时触发结束回调，关闭全模态页面，将共享元素图片的节点迁移至半模态页面，替换占位图片。
    
- 需注意，半模态页面的弹起高度不同，其页面起始位置也有所不同，而全模态则是全屏显示，两者存在一高度差，做一镜到底动画时，需要计算差值并进行修正，具体可见demo。
    
- 还可以配合一镜到底动画，给初始界面图片也增加一个从透明到出现的动画，使得动效更为流畅。
    

1. ├──entry/src/main/ets                 // 代码区
2. │  ├──entryability
3. │  │  └──EntryAbility.ets             // 程序入口类
4. │  ├──NodeContainer
5. │  │  └──CustomComponent.ets          // 自定义占位节点
6. │  ├──pages
7. │  │  └──Index.ets                    // 进行共享元素转场的主页面
8. │  └──utils
9. │     ├──ComponentAttrUtils.ets       // 组件位置获取
10. │     └──WindowUtils.ets              // 窗口信息
11. └──entry/src/main/resources           // 资源文件

12. // index.ets
13. import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
14. import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
15. import { WindowUtils } from '../utils/WindowUtils';
16. import { inspector } from '@kit.ArkUI'

17. class AnimationInfo {
18.   scale: number = 0;
19.   translateX: number = 0;
20.   translateY: number = 0;
21.   clipWidth: Dimension = 0;
22.   clipHeight: Dimension = 0;
23. }

24. @Entry
25. @Component
26. struct Index {
27.   @State isShowSheet: boolean = false;
28.   @State isShowImage: boolean = false;
29.   @State isShowOverlay: boolean = false;
30.   @State isAnimating: boolean = false;
31.   @State isEnabled: boolean = true;

32.   @State scaleValue: number = 0;
33.   @State translateX: number = 0;
34.   @State translateY: number = 0;
35.   @State clipWidth: Dimension = 0;
36.   @State clipHeight: Dimension = 0;
37.   @State radius: number = 0;
38.   // 原图的透明度
39.   @State opacityDegree: number = 1;

40.   // 抓取照片原位置信息
41.   private originInfo: AnimationInfo = new AnimationInfo;
42.   // 抓取照片在半模态页上位置信息
43.   private targetInfo: AnimationInfo = new AnimationInfo;
44.   // 半模态高度
45.   private bindSheetHeight: number = 450;
46.   // 半模态上图片圆角
47.   private sheetRadius: number = 20;

48.   // 设置半模态上图片的布局监听
49.   listener:inspector.ComponentObserver = this.getUIContext().getUIInspector().createComponentObserver('target');
50.   aboutToAppear(): void {
51.     // 设置半模态上图片的布局完成回调
52.     let onLayoutComplete:()=>void=():void=>{
53.       // 目标图片布局完成时抓取布局信息
54.       this.targetInfo = this.calculateData('target');
55.       // 仅半模态正确布局且此时无动画时触发一镜到底动画
56.       if (this.targetInfo.scale != 0 && this.targetInfo.clipWidth != 0 && this.targetInfo.clipHeight != 0 && !this.isAnimating) {
57.         this.isAnimating = true;
58.         // 用于一镜到底的模态页的属性动画
59.         this.getUIContext()?.animateTo({
60.           duration: 1000,
61.           curve: Curve.Friction,
62.           onFinish: () => {
63.             // 模态转场页（overlay）上的自定义节点下树
64.             this.isShowOverlay = false;
65.             // 半模态上的自定义节点上树，由此完成节点迁移
66.             this.isShowImage = true;
67.           }
68.         }, () => {
69.           this.scaleValue = this.targetInfo.scale;
70.           this.translateX = this.targetInfo.translateX;
71.           this.clipWidth = this.targetInfo.clipWidth;
72.           this.clipHeight = this.targetInfo.clipHeight;
73.           // 修正因半模态高度和缩放导致的高度差
74.           this.translateY = this.targetInfo.translateY +
75.             (this.getUIContext().px2vp(WindowUtils.windowHeight_px) - this.bindSheetHeight
76.               - this.getUIContext().px2vp(WindowUtils.navigationIndicatorHeight_px) - this.getUIContext().px2vp(WindowUtils.topAvoidAreaHeight_px));
77.           // 修正因缩放导致的圆角差异
78.           this.radius = this.sheetRadius / this.scaleValue
79.         })
80.         // 原图从透明到出现的动画
81.         this.getUIContext()?.animateTo({
82.           duration: 2000,
83.           curve: Curve.Friction,
84.         }, () => {
85.           this.opacityDegree = 1;
86.         })
87.       }
88.     }
89.     // 打开布局监听
90.     this.listener.on('layout', onLayoutComplete)
91.   }

92.   // 获取对应id的组件相对窗口左上角的属性
93.   calculateData(id: string): AnimationInfo {
94.     let itemInfo: RectInfoInPx =
95.       ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), id);
96.     // 首先计算图片的宽高与窗口宽高的比例
97.     let widthScaleRatio = itemInfo.width / WindowUtils.windowWidth_px;
98.     let heightScaleRatio = itemInfo.height / WindowUtils.windowHeight_px;
99.     let isUseWidthScale = widthScaleRatio > heightScaleRatio;
100.     let itemScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;
101.     let itemTranslateX: number = 0;
102.     let itemClipWidth: Dimension = 0;
103.     let itemClipHeight: Dimension = 0;
104.     let itemTranslateY: number = 0;

105.     if (isUseWidthScale) {
106.       itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px - itemInfo.width) / 2);
107.       itemClipWidth = '100%';
108.       itemClipHeight = this.getUIContext().px2vp((itemInfo.height) / itemScale);
109.       itemTranslateY = this.getUIContext().px2vp(itemInfo.top - ((this.getUIContext().vp2px(itemClipHeight) - this.getUIContext().vp2px(itemClipHeight) * itemScale) / 2));
110.     } else {
111.       itemTranslateY = this.getUIContext().px2vp(itemInfo.top - (WindowUtils.windowHeight_px - itemInfo.height) / 2);
112.       itemClipHeight = '100%';
113.       itemClipWidth = this.getUIContext().px2vp((itemInfo.width) / itemScale);
114.       itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px / 2 - itemInfo.width / 2));
115.     }

116.     return {
117.       scale: itemScale,
118.       translateX: itemTranslateX ,
119.       translateY: itemTranslateY,
120.       clipWidth: itemClipWidth,
121.       clipHeight: itemClipHeight,
122.     }
123.   }

124.   // 照片页
125.   build() {
126.     Column() {
127.       Text('照片')
128.         .textAlign(TextAlign.Start)
129.         .width('100%')
130.         .fontSize(30)
131.         .padding(20)
132.       // 图片使用Resource资源，需用户自定义
133.       Image($r("app.media.flower"))
134.         .opacity(this.opacityDegree)
135.         .width('90%')
136.         .id('origin')// 挂载半模态页
137.         .enabled(this.isEnabled)
138.         .onClick(() => {
139.           // 获取原始图像的位置信息，将模态页上图片移动缩放至该位置
140.           this.originInfo = this.calculateData('origin');
141.           this.scaleValue = this.originInfo.scale;
142.           this.translateX = this.originInfo.translateX;
143.           this.translateY = this.originInfo.translateY;
144.           this.clipWidth = this.originInfo.clipWidth;
145.           this.clipHeight = this.originInfo.clipHeight;
146.           this.radius = 0;
147.           this.opacityDegree = 0;
148.           // 启动半模态页和模态页
149.           this.isShowSheet = true;
150.           this.isShowOverlay = true;
151.           // 设置原图为不可交互抗打断
152.           this.isEnabled = false;
153.         })
154.     }
155.     .width('100%')
156.     .height('100%')
157.     .padding({ top: 20 })
158.     .alignItems(HorizontalAlign.Center)
159.     .bindSheet(this.isShowSheet, this.mySheet(), {
160.       // Embedded模式使得其他页面可以高于半模态页
161.       mode: SheetMode.EMBEDDED,
162.       height: this.bindSheetHeight,
163.       onDisappear: () => {
164.         // 保证半模态消失时状态正确
165.         this.isShowImage = false;
166.         this.isShowSheet = false;
167.         // 设置一镜到底动画又进入可触发状态
168.         this.isAnimating = false;
169.         // 原图重新变为可交互状态
170.         this.isEnabled = true;
171.       }
172.     }) // 挂载模态页作为一镜到底动画的实现页
173.     .bindContentCover(this.isShowOverlay, this.overlayNode(), {
174.       // 模态页面设置为无转场
175.       transition: TransitionEffect.IDENTITY,
176.     })
177.   }

178.   // 半模态页面
179.   @Builder
180.   mySheet() {
181.     Column({space: 20}) {
182.       Text('半模态页面')
183.         .fontSize(30)
184.       Row({space: 40}) {
185.         Column({space: 20}) {
186.           ForEach([1, 2, 3, 4], () => {
187.             Stack()
188.               .backgroundColor(Color.Pink)
189.               .borderRadius(20)
190.               .width(60)
191.               .height(60)
192.           })
193.         }
194.         Column() {
195.           if (this.isShowImage) {
196.             // 半模态页面的自定义图片节点
197.             ImageNode()
198.           }
199.           else {
200.             // 抓取布局和占位用，实际不显示
201.             // 图片使用Resource资源，需用户自定义
202.             Image($r("app.media.flower"))
203.               .visibility(Visibility.Hidden)
204.           }
205.         }
206.         .height(300)
207.         .width(200)
208.         .borderRadius(20)
209.         .clip(true)
210.         .id('target')
211.       }
212.       .alignItems(VerticalAlign.Top)
213.     }
214.     .alignItems(HorizontalAlign.Start)
215.     .height('100%')
216.     .width('100%')
217.     .margin(40)
218.   }

219.   @Builder
220.   overlayNode() {
221.     // Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
222.     Stack({ alignContent: Alignment.TopStart }) {
223.       ImageNode()
224.     }
225.     .scale({ x: this.scaleValue, y: this.scaleValue, centerX: undefined, centerY: undefined})
226.     .translate({ x: this.translateX, y: this.translateY })
227.     .width(this.clipWidth)
228.     .height(this.clipHeight)
229.     .borderRadius(this.radius)
230.     .clip(true)
231.   }
232. }

233. @Component
234. struct ImageNode {
235.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

236.   aboutToAppear(): void {
237.     // 获取自定义节点
238.     let node = getMyNode();
239.     if (node == undefined) {
240.       // 新建自定义节点
241.       createMyNode(this.getUIContext());
242.     }
243.     this.myNodeController = getMyNode();
244.   }

245.   aboutToDisappear(): void {
246.     if (this.myNodeController != undefined) {
247.       // 节点下树
248.       this.myNodeController.onRemove();
249.     }
250.   }
251.   build() {
252.     NodeContainer(this.myNodeController)
253.   }
254. }

255. // CustomComponent.ets
256. // 自定义占位节点，跨容器迁移能力
257. import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';

258. @Builder
259. function CardBuilder() {
260.   // 图片使用Resource资源，需用户自定义
261.   Image($r("app.media.flower"))
262.     // 避免第一次加载图片时图片闪烁
263.     .syncLoad(true)
264. }

265. export class MyNodeController extends NodeController {
266.   private CardNode: BuilderNode<[]> | null = null;
267.   private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
268.   private needCreate: boolean = false;
269.   private isRemove: boolean = false;

270.   constructor(create: boolean) {
271.     super();
272.     this.needCreate = create;
273.   }

274.   makeNode(uiContext: UIContext): FrameNode | null {
275.     if(this.isRemove == true){
276.       return null;
277.     }
278.     if (this.needCreate && this.CardNode == null) {
279.       this.CardNode = new BuilderNode(uiContext);
280.       this.CardNode.build(this.wrapBuilder)
281.     }
282.     if (this.CardNode == null) {
283.       return null;
284.     }
285.     return this.CardNode!.getFrameNode()!;
286.   }

287.   getNode(): BuilderNode<[]> | null {
288.     return this.CardNode;
289.   }

290.   setNode(node: BuilderNode<[]> | null) {
291.     this.CardNode = node;
292.     this.rebuild();
293.   }

294.   onRemove() {
295.     this.isRemove = true;
296.     this.rebuild();
297.     this.isRemove = false;
298.   }

299.   init(uiContext: UIContext) {
300.     this.CardNode = new BuilderNode(uiContext);
301.     this.CardNode.build(this.wrapBuilder)
302.   }
303. }

304. let myNode: MyNodeController | undefined;

305. export const createMyNode =
306.   (uiContext: UIContext) => {
307.     myNode = new MyNodeController(false);
308.     myNode.init(uiContext);
309.   }

310. export const getMyNode = (): MyNodeController | undefined => {
311.   return myNode;
312. }

313. // ComponentAttrUtils.ets
314. // 获取组件相对窗口的位置
315. import { componentUtils, UIContext } from '@kit.ArkUI';
316. import { JSON } from '@kit.ArkTS';

317. export class ComponentAttrUtils {
318.   // 根据组件的id获取组件的位置信息
319.   public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
320.     if (!context || !id) {
321.       throw Error('object is empty');
322.     }
323.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

324.     if (!componentInfo) {
325.       throw Error('object is empty');
326.     }

327.     let rstRect: RectInfoInPx = new RectInfoInPx();
328.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
329.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
330.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
331.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
332.     rstRect.right =
333.       componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
334.     rstRect.bottom =
335.       componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
336.     rstRect.width = rstRect.right - rstRect.left;
337.     rstRect.height = rstRect.bottom - rstRect.top;
338.     return {
339.       left: rstRect.left,
340.       right: rstRect.right,
341.       top: rstRect.top,
342.       bottom: rstRect.bottom,
343.       width: rstRect.width,
344.       height: rstRect.height
345.     }
346.   }
347. }

348. export class RectInfoInPx {
349.   left: number = 0;
350.   top: number = 0;
351.   right: number = 0;
352.   bottom: number = 0;
353.   width: number = 0;
354.   height: number = 0;
355. }

356. export class RectJson {
357.   $rect: Array<number> = [];
358. }

359. // WindowUtils.ets
360. // 窗口信息
361. import { window } from '@kit.ArkUI';

362. export class WindowUtils {
363.   public static window: window.Window;
364.   public static windowWidth_px: number;
365.   public static windowHeight_px: number;
366.   public static topAvoidAreaHeight_px: number;
367.   public static navigationIndicatorHeight_px: number;
368. }

369. // EntryAbility.ets
370. // 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取

371. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
372. import { hilog } from '@kit.PerformanceAnalysisKit';
373. import { display, window } from '@kit.ArkUI';
374. import { WindowUtils } from '../utils/WindowUtils';

375. const TAG: string = 'EntryAbility';

376. export default class EntryAbility extends UIAbility {
377.   private currentBreakPoint: string = '';

378.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
379.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
380.   }

381.   onDestroy(): void {
382.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
383.   }

384.   onWindowStageCreate(windowStage: window.WindowStage): void {
385.     // Main window is created, set main page for this ability
386.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

387.     // 获取窗口宽高
388.     WindowUtils.window = windowStage.getMainWindowSync();
389.     WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
390.     WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;

391.     this.updateBreakpoint(WindowUtils.windowWidth_px);

392.     // 获取上方避让区(状态栏等)高度
393.     let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
394.     WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;

395.     // 获取导航条高度
396.     let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
397.     WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;

398.     hilog.info(0x0000, TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
399.     WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);

400.     // 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
401.     try {
402.       WindowUtils.window.on('windowSizeChange', (data) => {
403.         hilog.info(0x0000, TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
404.         WindowUtils.windowWidth_px = data.width;
405.         WindowUtils.windowHeight_px = data.height;
406.         this.updateBreakpoint(data.width);
407.         AppStorage.setOrCreate('windowSizeChanged', Date.now())
408.       })

409.       WindowUtils.window.on('avoidAreaChange', (data) => {
410.         if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
411.           let topRectHeight = data.area.topRect.height;
412.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
413.           WindowUtils.topAvoidAreaHeight_px = topRectHeight;
414.         } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
415.           let bottomRectHeight = data.area.bottomRect.height;
416.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
417.           WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
418.         }
419.       })
420.     } catch (exception) {
421.       hilog.error(0x0000, TAG, `register failed. code: ${exception.code}, message: ${exception.message}`);
422.     }

423.     windowStage.loadContent('pages/Index', (err) => {
424.       if (err.code) {
425.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
426.         return;
427.       }
428.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
429.     });
430.   }

431.   updateBreakpoint(width: number) {
432.     let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
433.     let newBreakPoint: string = '';
434.     if (windowWidthVp < 400) {
435.       newBreakPoint = 'xs';
436.     } else if (windowWidthVp < 600) {
437.       newBreakPoint = 'sm';
438.     } else if (windowWidthVp < 800) {
439.       newBreakPoint = 'md';
440.     } else {
441.       newBreakPoint = 'lg';
442.     }
443.     if (this.currentBreakPoint !== newBreakPoint) {
444.       this.currentBreakPoint = newBreakPoint;
445.       // 使用状态变量记录当前断点值
446.       AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
447.     }
448.   }

449.   onWindowStageDestroy(): void {
450.     // Main window is destroyed, release UI related resources
451.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
452.   }

453.   onForeground(): void {
454.     // Ability has brought to foreground
455.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
456.   }

457.   onBackground(): void {
458.     // Ability has back to background
459.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
460.   }
461. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.94596976349835209240042454924339:50001231000000:2800:4A1587C908876454A8D1E02A27656B0A047FB4D15668A8CE38F4B2DBB5B3C7B5.gif)

## 使用geometryTransition共享元素转场

[geometryTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-geometrytransition)用于组件内隐式共享元素转场，在视图状态切换过程中提供丝滑的上下文继承过渡体验。

geometryTransition的使用方式为对需要添加一镜到底动效的两个组件使用geometryTransition接口绑定同一id，这样在其中一个组件消失同时另一个组件创建出现的时候，系统会对二者添加一镜到底动效。

geometryTransition绑定两个对象的实现方式使得geometryTransition区别于其他方法，最适合用于两个不同对象之间完成一镜到底。

### geometryTransition的简单使用

对于同一个页面中的两个元素的一镜到底效果，geometryTransition接口的简单使用示例如下：

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct IfElseGeometryTransition {
5.   @State isShow: boolean = false;

6.   build() {
7.     Stack({ alignContent: Alignment.Center }) {
8.       if (this.isShow) {
9.         // 图片使用Resource资源，需用户自定义
10.         Image($r('app.media.spring'))
11.           .autoResize(false)
12.           .clip(true)
13.           .width(200)
14.           .height(200)
15.           .borderRadius(100)
16.           .geometryTransition("picture")
17.           .transition(TransitionEffect.OPACITY)
18.           // 在打断场景下，即动画过程中点击页面触发下一次转场，如果不加id，则会出现重影
19.           // 加了id之后，新建的spring图片会复用之前的spring图片节点，不会重新创建节点，也就不会有重影问题
20.           // 加id的规则为加在if和else下的第一个节点上，有多个并列节点则也需要进行添加
21.           .id('item1')
22.       } else {
23.         // geometryTransition此处绑定的是容器，那么容器内的子组件需设为相对布局跟随父容器变化，
24.         // 套多层容器为了说明相对布局约束传递
25.         Column() {
26.           Column() {
27.             // 图片使用Resource资源，需用户自定义
28.             Image($r('app.media.sky'))
29.               .size({ width: '100%', height: '100%' })
30.           }
31.           .size({ width: '100%', height: '100%' })
32.         }
33.         .width(100)
34.         .height(100)
35.         // geometryTransition会同步圆角，但仅限于geometryTransition绑定处，此处绑定的是容器
36.         // 则对容器本身有圆角同步而不会操作容器内部子组件的borderRadius
37.         .borderRadius(50)
38.         .clip(true)
39.         .geometryTransition("picture")
40.         // transition保证节点离场不被立即析构，设置通用转场效果
41.         .transition(TransitionEffect.OPACITY)
42.         .position({ x: 40, y: 40 })
43.         .id('item2')
44.       }
45.     }
46.     .onClick(() => {
47.       this.getUIContext()?.animateTo({
48.         curve: curves.springMotion()
49.       }, () => {
50.         this.isShow = !this.isShow;
51.       })
52.     })
53.     .size({ width: '100%', height: '100%' })
54.   }
55. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.34247257179854547412558413214758:50001231000000:2800:7C08D34AEAB1EE500B2DA23B310AD59E21FB7C992DC92A3666BC87240F20409A.gif)

### geometryTransition结合模态转场使用

更多的场景中，需要对一个页面的元素与另一个页面的元素添加一镜到底动效。可以通过geometryTransition搭配模态转场接口实现。以点击头像弹出个人信息页的demo为例：

1. class PostData {
2.   // 图片使用Resource资源，需用户自定义
3.   avatar: Resource = $r('app.media.flower');
4.   name: string = '';
5.   message: string = '';
6.   images: Resource[] = [];
7. }

8. @Entry
9. @Component
10. struct Index {
11.   @State isPersonalPageShow: boolean = false;
12.   @State selectedIndex: number = 0;
13.   @State alphaValue: number = 1;

14.   // 数组中图片均使用Resource资源，需用户自定义
15.   private allPostData: PostData[] = [
16.     { avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
17.       images: [$r('app.media.spring'), $r('app.media.tree')] },
18.     { avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
19.       images: [$r('app.media.island')] },
20.     { avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
21.       images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];

22.   private onAvatarClicked(index: number): void {
23.     this.selectedIndex = index;
24.     this.getUIContext()?.animateTo({
25.       duration: 350,
26.       curve: Curve.Friction
27.     }, () => {
28.       this.isPersonalPageShow = !this.isPersonalPageShow;
29.       this.alphaValue = 0;
30.     });
31.   }

32.   private onPersonalPageBack(index: number): void {
33.     this.getUIContext()?.animateTo({
34.       duration: 350,
35.       curve: Curve.Friction
36.     }, () => {
37.       this.isPersonalPageShow = !this.isPersonalPageShow;
38.       this.alphaValue = 1;
39.     });
40.   }

41.   @Builder
42.   PersonalPageBuilder(index: number) {
43.     Column({ space: 20 }) {
44.       Image(this.allPostData[index].avatar)
45.         .size({ width: 200, height: 200 })
46.         .borderRadius(100)
47.         // 头像配置共享元素效果，与点击的头像的id匹配
48.         .geometryTransition(index.toString())
49.         .clip(true)
50.         .transition(TransitionEffect.opacity(0.99))

51.       Text(this.allPostData[index].name)
52.         .font({ size: 30, weight: 600 })
53.         // 对文本添加出现转场效果
54.         .transition(TransitionEffect.asymmetric(
55.           TransitionEffect.OPACITY
56.             .combine(TransitionEffect.translate({ y: 100 })),
57.           TransitionEffect.OPACITY.animation({ duration: 0 })
58.         ))

59.       Text('你好，我是' + this.allPostData[index].name)
60.         // 对文本添加出现转场效果
61.         .transition(TransitionEffect.asymmetric(
62.           TransitionEffect.OPACITY
63.             .combine(TransitionEffect.translate({ y: 100 })),
64.           TransitionEffect.OPACITY.animation({ duration: 0 })
65.         ))
66.     }
67.     .padding({ top: 20 })
68.     .size({ width: 360, height: 780 })
69.     .backgroundColor(Color.White)
70.     .onClick(() => {
71.       this.onPersonalPageBack(index);
72.     })
73.     .transition(TransitionEffect.asymmetric(
74.       TransitionEffect.opacity(0.99),
75.       TransitionEffect.OPACITY
76.     ))
77.   }

78.   build() {
79.     Column({ space: 20 }) {
80.       ForEach(this.allPostData, (postData: PostData, index: number) => {
81.         Column() {
82.           Post({ data: postData, index: index, onAvatarClicked: (index: number) => { this.onAvatarClicked(index) } })
83.         }
84.         .width('100%')
85.       }, (postData: PostData, index: number) => index.toString())
86.     }
87.     .size({ width: '100%', height: '100%' })
88.     .backgroundColor('#40808080')
89.     .bindContentCover(this.isPersonalPageShow,
90.       this.PersonalPageBuilder(this.selectedIndex), { modalTransition: ModalTransition.NONE })
91.     .opacity(this.alphaValue)
92.   }
93. }

94. @Component
95. export default struct  Post {
96.   @Prop data: PostData;
97.   @Prop index: number;

98.   @State expandImageSize: number = 100;
99.   @State avatarSize: number = 50;

100.   private onAvatarClicked: (index: number) => void = (index: number) => { };

101.   build() {
102.     Column({ space: 20 }) {
103.       Row({ space: 10 }) {
104.         Image(this.data.avatar)
105.           .size({ width: this.avatarSize, height: this.avatarSize })
106.           .borderRadius(this.avatarSize / 2)
107.           .clip(true)
108.           .onClick(() => {
109.             this.onAvatarClicked(this.index);
110.           })
111.           // 对头像绑定共享元素转场的id
112.           .geometryTransition(this.index.toString(), {follow:true})
113.           .transition(TransitionEffect.OPACITY.animation({ duration: 350, curve: Curve.Friction }))

114.         Text(this.data.name)
115.       }
116.       .justifyContent(FlexAlign.Start)

117.       Text(this.data.message)

118.       Row({ space: 15 }) {
119.         ForEach(this.data.images, (imageResource: Resource, index: number) => {
120.           Image(imageResource)
121.             .size({ width: 100, height: 100 })
122.         }, (imageResource: Resource, index: number) => index.toString())
123.       }
124.     }
125.     .backgroundColor(Color.White)
126.     .size({ width: '100%', height: 250 })
127.     .alignItems(HorizontalAlign.Start)
128.     .padding({ left: 10, top: 10 })
129.   }
130. }

效果为点击主页的头像后，弹出模态页面显示个人信息，并且两个页面之间的头像做一镜到底动效：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.40028410023183083819362411137140:50001231000000:2800:C4A113ACE78D678023273FD86D3A9BE07ECFCE51EE0C62D4BEB9DCB8658A89F8.gif)

## 示例代码

- [转场动效合集](https://gitcode.com/harmonyos_samples/transitions-collection)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-modal-transition "模态转场")
# 共享元素转场 (一镜到底)

更新时间: 2025-12-16 16:40

共享元素转场是一种界面切换时对相同或者相似的两个元素做的一种位置和大小匹配的过渡动画效果，也称一镜到底动效。

如下例所示，在点击图片后，该图片消失，同时在另一个位置出现新的图片，二者之间内容相同，可以对它们添加一镜到底动效。左图为不添加一镜到底动效的效果，右图为添加一镜到底动效的效果，一镜到底的效果能够让二者的出现消失产生联动，使得内容切换过程显得灵动自然而不生硬。

|   |   |
|---|---|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.84094530939537589914493896349658:50001231000000:2800:37C5C7D9D6216F417E0A207CD22D2E4BF08403AE4B85D14972E1DCBF1A62FB3E.gif)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.80553205120654277749869978432078:50001231000000:2800:8DF360AC7C09D418081F02CFA9CF50983AC6EC9432CB42A053DA9C03ECBE3378.gif)|

一镜到底的动效有多种实现方式，在实际开发过程中，应根据具体场景选择合适的方法进行实现。

以下是不同实现方式的对比：

|一镜到底实现方式|特点|适用场景|
|:--|:--|:--|
|不新建容器直接变化原容器|不发生路由跳转，需要在一个组件中实现展开及关闭两种状态的布局，展开后组件层级不变。|适用于转场开销小的简单场景，如点开页面无需加载大量数据及组件。|
|新建容器并跨容器迁移组件|通过使用NodeController，将组件从一个容器迁移到另一个容器，在开始迁移时，需要根据前后两个布局的位置大小等信息对组件添加位移及缩放，确保迁移开始时组件能够对齐初始布局，避免出现视觉上的跳变现象。之后再添加动画将位移及缩放等属性复位，实现组件从初始布局到目标布局的一镜到底过渡效果。|适用于新建对象开销大的场景，如视频直播组件点击转为全屏等。|
|使用geometryTransition共享元素转场|利用系统能力，转场前后两个组件调用geometryTransition接口绑定同一id，同时将转场逻辑置于animateTo动画闭包内，这样系统侧会自动为二者添加一镜到底的过渡效果。|系统将调整绑定的两个组件的宽高及位置至相同值，并切换二者的透明度，以实现一镜到底过渡效果。因此，为了实现流畅的动画效果，需要确保对绑定geometryTransition的节点添加宽高动画不会有跳变。此方式适用于创建新节点开销小的场景。|

## 不新建容器并直接变化原容器

该方法不新建容器，通过在已有容器上增删组件触发[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)，搭配组件[属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis)实现一镜到底效果。

对于同一个容器展开，容器内兄弟组件消失或者出现的场景，可通过对同一个容器展开前后进行宽高位置变化并配置属性动画，对兄弟组件配置出现消失转场动画实现一镜到底效果。基本步骤为：

1. 构建需要展开的页面，并通过状态变量构建好普通状态和展开状态的界面。
    
2. 将需要展开的页面展开，通过状态变量控制兄弟组件消失或出现，并通过绑定出现消失转场实现兄弟组件转场效果。
    

以点击卡片后显示卡片内容详情场景为例：

1. class PostData {
2.   // 图片使用Resource资源，需用户自定义
3.   avatar: Resource = $r('app.media.flower');
4.   name: string = '';
5.   message: string = '';
6.   images: Resource[] = [];
7. }

8. @Entry
9. @Component
10. struct Index {
11.   @State isExpand: boolean = false;
12.   @State @Watch('onItemClicked') selectedIndex: number = -1;

13.   // 数组中图片均使用Resource资源，需用户自定义
14.   private allPostData: PostData[] = [
15.     { avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
16.       images: [$r('app.media.spring'), $r('app.media.tree')] },
17.     { avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
18.       images: [$r('app.media.island')] },
19.     { avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
20.       images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];

21.   private onItemClicked(): void {
22.     if (this.selectedIndex < 0) {
23.       return;
24.     }
25.     this.getUIContext()?.animateTo({
26.       duration: 350,
27.       curve: Curve.Friction
28.     }, () => {
29.       this.isExpand = !this.isExpand;
30.     });
31.   }

32.   build() {
33.     Column({ space: 20 }) {
34.       ForEach(this.allPostData, (postData: PostData, index: number) => {
35.         // 当点击了某个post后，会使其余的post消失下树
36.         if (!this.isExpand || this.selectedIndex === index) {
37.           Column() {
38.             Post({ data: postData, selectedIndex: this.selectedIndex, index: index })
39.           }
40.           .width('100%')
41.           // 对出现消失的post添加透明度转场和位移转场效果
42.           .transition(TransitionEffect.OPACITY
43.             .combine(TransitionEffect.translate({ y: index < this.selectedIndex ? -250 : 250 }))
44.             .animation({ duration: 350, curve: Curve.Friction}))
45.         }
46.       }, (postData: PostData, index: number) => index.toString())
47.     }
48.     .size({ width: '100%', height: '100%' })
49.     .backgroundColor('#40808080')
50.   }
51. }

52. @Component
53. export default struct  Post {
54.   @Link selectedIndex: number;

55.   @Prop data: PostData;
56.   @Prop index: number;

57.   @State itemHeight: number = 250;
58.   @State isExpand: boolean = false;
59.   @State expandImageSize: number = 100;
60.   @State avatarSize: number = 50;

61.   build() {
62.     Column({ space: 20 }) {
63.       Row({ space: 10 }) {
64.         Image(this.data.avatar)
65.           .size({ width: this.avatarSize, height: this.avatarSize })
66.           .borderRadius(this.avatarSize / 2)
67.           .clip(true)

68.         Text(this.data.name)
69.       }
70.       .justifyContent(FlexAlign.Start)

71.       Text(this.data.message)

72.       Row({ space: 15 }) {
73.         ForEach(this.data.images, (imageResource: Resource, index: number) => {
74.           Image(imageResource)
75.             .size({ width: this.expandImageSize, height: this.expandImageSize })
76.         }, (imageResource: Resource, index: number) => index.toString())
77.       }

78.       // 展开态下组件增加的内容
79.       if (this.isExpand) {
80.         Column() {
81.           Text('评论区')
82.             // 对评论区文本添加出现消失转场效果
83.             .transition( TransitionEffect.OPACITY
84.               .animation({ duration: 350, curve: Curve.Friction }))
85.             .padding({ top: 10 })
86.         }
87.         .transition(TransitionEffect.asymmetric(
88.           TransitionEffect.opacity(0.99)
89.             .animation({ duration: 350, curve: Curve.Friction }),
90.           TransitionEffect.OPACITY.animation({ duration: 0 })
91.         ))
92.         .size({ width: '100%'})
93.       }
94.     }
95.     .backgroundColor(Color.White)
96.     .size({ width: '100%', height: this.itemHeight })
97.     .alignItems(HorizontalAlign.Start)
98.     .padding({ left: 10, top: 10 })
99.     .onClick(() => {
100.       this.selectedIndex = -1;
101.       this.selectedIndex = this.index;
102.       this.getUIContext()?.animateTo({
103.         duration: 350,
104.         curve: Curve.Friction
105.       }, () => {
106.         // 对展开的post做宽高动画，并对头像尺寸和图片尺寸加动画
107.         this.isExpand = !this.isExpand;
108.         this.itemHeight = this.isExpand ? 780 : 250;
109.         this.avatarSize = this.isExpand ? 75: 50;
110.         this.expandImageSize = (this.isExpand && this.data.images.length > 0)
111.           ? (360 - (this.data.images.length + 1) * 15) / this.data.images.length : 100;
112.       })
113.     })
114.   }
115. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.11573830513638335466236997937071:50001231000000:2800:71C86D5867B7E0F69C74F660D5E5B70D3B2064A2C5A5EAEA4901D8C75E8E2298.gif)

## 新建容器并跨容器迁移组件

通过[NodeContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-nodecontainer)[自定义占位节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-place-holder)，利用[NodeController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontroller)实现组件的跨节点迁移，配合属性动画给组件的迁移过程赋予一镜到底效果。这种一镜到底的实现方式可以结合多种转场方式使用，如导航转场（[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)）、半模态转场（[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#bindsheet)）等。

### 结合Stack使用

可以利用Stack内后定义组件在最上方的特性控制组件在跨节点迁移后位z序最高，以展开收起卡片的场景为例，实现步骤为：

- 展开卡片时，获取节点A的位置信息，将其中的组件迁移到与节点A位置一致的节点B处，节点B的层级高于节点A。
    
- 对节点B添加属性动画，使之展开并运动到展开后的位置，完成一镜到底的动画效果。
    
- 收起卡片时，对节点B添加属性动画，使之收起并运动到收起时的位置，即节点A的位置，实现一镜到底的动画效果。
    
- 在动画结束时利用回调将节点B中的组件迁移回节点A处。
    

1. // Index.ets
2. import { createPostNode, getPostNode, PostNode } from "./PostNode";
3. import { componentUtils, curves, UIContext } from '@kit.ArkUI';

4. @Entry
5. @Component
6. struct Index {
7.   // 新建一镜到底动画类
8.   private uiContext: UIContext = this.getUIContext();
9.   @State animationProperties: AnimationProperties = new AnimationProperties(this.uiContext);
10.   private listArray: Array<number> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

11.   build() {
12.     // 卡片折叠态，展开态的共同父组件
13.     Stack() {
14.       List({ space: 20 }) {
15.         ForEach(this.listArray, (item: number) => {
16.           ListItem() {
17.             // 卡片折叠态
18.             PostItem({ index: item, animationProperties: this.animationProperties })
19.           }
20.         })
21.       }
22.       .clip(false)
23.       .alignListItem(ListItemAlign.Center)

24.       if (this.animationProperties.isExpandPageShow) {
25.         // 卡片展开态
26.         ExpandPage({ animationProperties: this.animationProperties })
27.       }
28.     }
29.     .key('rootStack')
30.     .enabled(this.animationProperties.isEnabled)
31.   }
32. }

33. @Component
34. struct PostItem {
35.   @Prop index: number
36.   @Link animationProperties: AnimationProperties;
37.   @State nodeController: PostNode | undefined = undefined;
38.   // 折叠时详细内容隐藏
39.   private showDetailContent: boolean = false;

40.   aboutToAppear(): void {
41.     this.nodeController = createPostNode(this.getUIContext(), this.index.toString(), this.showDetailContent);
42.     if (this.nodeController != undefined) {
43.       // 设置回调，当卡片从展开态回到折叠态时触发
44.       this.nodeController.setCallback(this.resetNode.bind(this));
45.     }
46.   }

47.   resetNode() {
48.     this.nodeController = getPostNode(this.index.toString());
49.   }

50.   build() {
51.     Stack() {
52.       NodeContainer(this.nodeController)
53.     }
54.     .width('100%')
55.     .height(100)
56.     .key(this.index.toString())
57.     .onClick(() => {
58.       if (this.nodeController != undefined) {
59.         // 卡片从折叠态节点下树
60.         this.nodeController.onRemove();
61.       }
62.       // 触发卡片从折叠到展开态的动画
63.       this.animationProperties.expandAnimation(this.index);
64.     })
65.   }
66. }

67. @Component
68. struct ExpandPage {
69.   @Link animationProperties: AnimationProperties;
70.   @State nodeController: PostNode | undefined = undefined;
71.   // 展开时详细内容出现
72.   private showDetailContent: boolean = true;

73.   aboutToAppear(): void {
74.     // 获取对应序号的卡片组件
75.     this.nodeController = getPostNode(this.animationProperties.curIndex.toString())
76.     // 更新为详细内容出现
77.     this.nodeController?.update(this.animationProperties.curIndex.toString(), this.showDetailContent)
78.   }

79.   build() {
80.     Stack() {
81.       NodeContainer(this.nodeController)
82.     }
83.     .width('100%')
84.     .height(this.animationProperties.changedHeight ? '100%' : 100)
85.     .translate({ x: this.animationProperties.translateX, y: this.animationProperties.translateY })
86.     .position({ x: this.animationProperties.positionX, y: this.animationProperties.positionY })
87.     .onClick(() => {
88.       this.getUIContext()?.animateTo({ curve: curves.springMotion(0.6, 0.9),
89.         onFinish: () => {
90.           if (this.nodeController != undefined) {
91.             // 执行回调，折叠态节点获取卡片组件
92.             this.nodeController.callCallback();
93.             // 当前展开态节点的卡片组件下树
94.             this.nodeController.onRemove();
95.           }
96.           // 卡片展开态节点下树
97.           this.animationProperties.isExpandPageShow = false;
98.           this.animationProperties.isEnabled = true;
99.         }
100.       }, () => {
101.         // 卡片从展开态回到折叠态
102.         this.animationProperties.isEnabled = false;
103.         this.animationProperties.translateX = 0;
104.         this.animationProperties.translateY = 0;
105.         this.animationProperties.changedHeight = false;
106.         // 更新为详细内容消失
107.         this.nodeController?.update(this.animationProperties.curIndex.toString(), false);
108.       })
109.     })
110.   }
111. }

112. class RectInfo {
113.   left: number = 0;
114.   top: number = 0;
115.   right: number = 0;
116.   bottom: number = 0;
117.   width: number = 0;
118.   height: number = 0;
119. }

120. // 封装的一镜到底动画类
121. @Observed
122. class AnimationProperties {
123.   public isExpandPageShow: boolean = false;
124.   // 控制组件是否响应点击事件
125.   public isEnabled: boolean = true;
126.   // 展开卡片的序号
127.   public curIndex: number = -1;
128.   public translateX: number = 0;
129.   public translateY: number = 0;
130.   public positionX: number = 0;
131.   public positionY: number = 0;
132.   public changedHeight: boolean = false;
133.   private calculatedTranslateX: number = 0;
134.   private calculatedTranslateY: number = 0;
135.   // 设置卡片展开后相对父组件的位置
136.   private expandTranslateX: number = 0;
137.   private expandTranslateY: number = 0;
138.   private uiContext: UIContext;

139.   constructor(uiContext: UIContext) {
140.     this.uiContext = uiContext
141.   }

142.   public expandAnimation(index: number): void {
143.     // 记录展开态卡片的序号
144.     if (index != undefined) {
145.       this.curIndex = index;
146.     }
147.     // 计算折叠态卡片相对父组件的位置
148.     this.calculateData(index.toString());
149.     // 展开态卡片上树
150.     this.isExpandPageShow = true;
151.     // 卡片展开的属性动画
152.     this.uiContext?.animateTo({ curve: curves.springMotion(0.6, 0.9)
153.     }, () => {
154.       this.translateX = this.calculatedTranslateX;
155.       this.translateY = this.calculatedTranslateY;
156.       this.changedHeight = true;
157.     })
158.   }

159.   // 获取需要跨节点迁移的组件的位置，及迁移前后节点的公共父节点的位置，用以计算做动画组件的动画参数
160.   public calculateData(key: string): void {
161.     let clickedImageInfo = this.getRectInfoById(this.uiContext, key);
162.     let rootStackInfo = this.getRectInfoById(this.uiContext, 'rootStack');
163.     this.positionX = this.uiContext.px2vp(clickedImageInfo.left - rootStackInfo.left);
164.     this.positionY = this.uiContext.px2vp(clickedImageInfo.top - rootStackInfo.top);
165.     this.calculatedTranslateX = this.uiContext.px2vp(rootStackInfo.left - clickedImageInfo.left) + this.expandTranslateX;
166.     this.calculatedTranslateY = this.uiContext.px2vp(rootStackInfo.top - clickedImageInfo.top) + this.expandTranslateY;
167.   }

168.   // 根据组件的id获取组件的位置信息
169.   private getRectInfoById(context: UIContext, id: string): RectInfo {
170.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

171.     if (!componentInfo) {
172.       throw Error('object is empty');
173.     }

174.     let rstRect: RectInfo = new RectInfo();
175.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
176.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
177.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
178.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
179.     rstRect.right =
180.     componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
181.     rstRect.bottom =
182.     componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
183.     rstRect.width = rstRect.right - rstRect.left;
184.     rstRect.height = rstRect.bottom - rstRect.top;

185.     return {
186.       left: rstRect.left,
187.       right: rstRect.right,
188.       top: rstRect.top,
189.       bottom: rstRect.bottom,
190.       width: rstRect.width,
191.       height: rstRect.height
192.     }
193.   }
194. }

195. // PostNode.ets
196. // 跨容器迁移能力
197. import { UIContext, curves, NodeController, BuilderNode, FrameNode } from '@kit.ArkUI';

198. class Data {
199.   item: string | null = null
200.   isExpand: boolean = false
201. }

202. @Builder
203. function PostBuilder(data: Data) {
204.   // 跨容器迁移组件置于@Builder内
205.   Column() {
206.       Row() {
207.         Row()
208.           .backgroundColor(Color.Pink)
209.           .borderRadius(20)
210.           .width(80)
211.           .height(80)

212.         Column() {
213.           Text('点击展开 Item ' + data.item)
214.             .fontSize(20)
215.           Text('共享元素转场')
216.             .fontSize(12)
217.             .fontColor(0x909399)
218.         }
219.         .alignItems(HorizontalAlign.Start)
220.         .justifyContent(FlexAlign.SpaceAround)
221.         .margin({ left: 10 })
222.         .height(80)
223.       }
224.       .width('90%')
225.       .height(100)
226.       // 展开后显示细节内容
227.       if (data.isExpand) {
228.         Row() {
229.           Text('展开态')
230.             .fontSize(28)
231.             .fontColor(0x909399)
232.             .textAlign(TextAlign.Center)
233.             .transition(TransitionEffect.OPACITY.animation({ curve: curves.springMotion(0.6, 0.9) }))
234.         }
235.         .width('90%')
236.         .justifyContent(FlexAlign.Center)
237.       }
238.     }
239.     .width('90%')
240.     .height('100%')
241.     .alignItems(HorizontalAlign.Center)
242.     .borderRadius(10)
243.     .margin({ top: 15 })
244.     .backgroundColor(Color.White)
245.     .shadow({
246.       radius: 20,
247.       color: 0x909399,
248.       offsetX: 20,
249.       offsetY: 10
250.     })
251. }

252. class __InternalValue__ {
253.   flag:boolean =false;
254. };

255. export class PostNode extends NodeController {
256.   private node: BuilderNode<Data[]> | null = null;
257.   private isRemove: __InternalValue__ = new __InternalValue__();
258.   private callback: Function | undefined = undefined
259.   private data: Data | null = null

260.   makeNode(uiContext: UIContext): FrameNode | null {
261.     if(this.isRemove.flag == true){
262.       return null;
263.     }
264.     if (this.node != null) {
265.       return this.node.getFrameNode();
266.     }

267.     return null;
268.   }

269.   init(uiContext: UIContext, id: string, isExpand: boolean) {
270.     if (this.node != null) {
271.       return;
272.     }
273.     // 创建节点，需要uiContext
274.     this.node = new BuilderNode(uiContext)
275.     // 创建离线组件
276.     this.data = { item: id, isExpand: isExpand }
277.     this.node.build(wrapBuilder<Data[]>(PostBuilder), this.data)
278.   }

279.   update(id: string, isExpand: boolean) {
280.     if (this.node !== null) {
281.       // 调用update进行更新。
282.       this.data = { item: id, isExpand: isExpand }
283.       this.node.update(this.data);
284.     }
285.   }

286.   setCallback(callback: Function | undefined) {
287.     this.callback = callback
288.   }

289.   callCallback() {
290.     if (this.callback != undefined) {
291.       this.callback();
292.     }
293.   }

294.   onRemove(){
295.     this.isRemove.flag = true;
296.     // 组件迁移出节点时触发重建
297.     this.rebuild();
298.     this.isRemove.flag = false;
299.   }
300. }

301. let gNodeMap: Map<string, PostNode | undefined> = new Map();

302. export const createPostNode =
303.   (uiContext: UIContext, id: string, isExpand: boolean): PostNode | undefined => {
304.     let node = new PostNode();
305.     node.init(uiContext, id, isExpand);
306.     gNodeMap.set(id, node);
307.     return node;
308.   }

309. export const getPostNode = (id: string): PostNode | undefined => {
310.   if (!gNodeMap.has(id)) {
311.     return undefined
312.   }
313.   return gNodeMap.get(id);
314. }

315. export const deleteNode = (id: string) => {
316.   gNodeMap.delete(id)
317. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.37240076024957776115084098912993:50001231000000:2800:B9E792E963226DA984B2911D76846EF0920C29BA99A6C95FAE354FC23729B429.gif)

### 结合Navigation使用

可以利用[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)的自定义导航转场动画能力（[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)，可参考Navigation[示例3](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B3%E8%AE%BE%E7%BD%AE%E5%8F%AF%E4%BA%A4%E4%BA%92%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB)）实现一镜到底动效。共享元素转场期间，组件由消失页面迁移至出现页面。

以展开收起缩略图的场景为例，实现步骤为：

- 通过customNavContentTransition配置PageOne与PageTwo的自定义导航转场动画。
    
- 自定义的共享元素转场效果由属性动画实现，具体实现方式为抓取页面内组件相对窗口的位置信息从而正确匹配组件在PageOne与PageTwo的位置、缩放等，即动画开始和结束的属性信息。
    
- 点击缩略图后共享元素组件从PageOne被迁移至PageTwo，随后触发由PageOne至PageTwo的自定义转场动画，即PageTwo的共享元素组件从原来的缩略图状态做动画到全屏状态。
    
- 由全屏状态返回到缩略图时，触发由PageTwo至PageOne的自定义转场动画，即PageTwo的共享元素组件从全屏状态做动画到原PageOne的缩略图状态，转场结束后共享元素组件从PageTwo被迁移回PageOne。
    

1. ├──entry/src/main/ets                 // 代码区
2. │  ├──CustomTransition
3. │  │  ├──AnimationProperties.ets      // 一镜到底转场动画封装
4. │  │  └──CustomNavigationUtils.ets    // Navigation自定义转场动画配置
5. │  ├──entryability
6. │  │  └──EntryAbility.ets             // 程序入口类
7. │  ├──NodeContainer
8. │  │  └──CustomComponent.ets          // 自定义占位节点
9. │  ├──pages
10. │  │  ├──Index.ets                    // 导航页面
11. │  │  ├──PageOne.ets                  // 缩略图页面
12. │  │  └──PageTwo.ets                  // 全屏展开页面
13. │  └──utils
14. │     ├──ComponentAttrUtils.ets       // 组件位置获取
15. │     └──WindowUtils.ets              // 窗口信息
16. └──entry/src/main/resources           // 资源文件

17. // Index.ets
18. import { AnimateCallback, CustomTransition } from '../CustomTransition/CustomNavigationUtils';

19. const TAG: string = 'Index';

20. @Entry
21. @Component
22. struct Index {
23.   private pageInfos: NavPathStack = new NavPathStack();
24.   // 允许进行自定义转场的页面名称
25.   private allowedCustomTransitionFromPageName: string[] = ['PageOne'];
26.   private allowedCustomTransitionToPageName: string[] = ['PageTwo'];

27.   aboutToAppear(): void {
28.     this.pageInfos.pushPath({ name: 'PageOne' });
29.   }

30.   private isCustomTransitionEnabled(fromName: string, toName: string): boolean {
31.     // 点击和返回均需要进行自定义转场，因此需要分别判断
32.     if ((this.allowedCustomTransitionFromPageName.includes(fromName)
33.       && this.allowedCustomTransitionToPageName.includes(toName))
34.       || (this.allowedCustomTransitionFromPageName.includes(toName)
35.         && this.allowedCustomTransitionToPageName.includes(fromName))) {
36.       return true;
37.     }
38.     return false;
39.   }

40.   build() {
41.     Navigation(this.pageInfos)
42.       .hideNavBar(true)
43.       .customNavContentTransition((from: NavContentInfo, to: NavContentInfo, operation: NavigationOperation) => {
44.         if ((!from || !to) || (!from.name || !to.name)) {
45.           return undefined;
46.         }

47.         // 通过from和to的name对自定义转场路由进行管控
48.         if (!this.isCustomTransitionEnabled(from.name, to.name)) {
49.           return undefined;
50.         }

51.         // 需要对转场页面是否注册了animation进行判断，来决定是否进行自定义转场
52.         let fromParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(from.index);
53.         let toParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(to.index);
54.         if (!fromParam.animation || !toParam.animation) {
55.           return undefined;
56.         }

57.         // 一切判断完成后，构造customAnimation给系统侧调用，执行自定义转场动画
58.         let customAnimation: NavigationAnimatedTransition = {
59.           onTransitionEnd: (isSuccess: boolean) => {
60.             console.info(TAG, `current transition result is ${isSuccess}`);
61.           },
62.           timeout: 2000,
63.           transition: (transitionProxy: NavigationTransitionProxy) => {
64.             console.info(TAG, 'trigger transition callback');
65.             if (fromParam.animation) {
66.               fromParam.animation(operation == NavigationOperation.PUSH, true, transitionProxy);
67.             }
68.             if (toParam.animation) {
69.               toParam.animation(operation == NavigationOperation.PUSH, false, transitionProxy);
70.             }
71.           }
72.         };
73.         return customAnimation;
74.       })
75.   }
76. }

77. // PageOne.ets
78. import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
79. import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
80. import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
81. import { WindowUtils } from '../utils/WindowUtils';

82. @Builder
83. export function PageOneBuilder() {
84.   PageOne();
85. }

86. @Component
87. export struct PageOne {
88.   private pageInfos: NavPathStack = new NavPathStack();
89.   private pageId: number = -1;
90.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

91.   aboutToAppear(): void {
92.     let node = getMyNode();
93.     if (node == undefined) {
94.       // 新建自定义节点
95.       createMyNode(this.getUIContext());
96.     }
97.     this.myNodeController = getMyNode();
98.   }

99.   private doFinishTransition(): void {
100.     // PageTwo结束转场时将节点从PageTwo迁移回PageOne
101.     this.myNodeController = getMyNode();
102.   }

103.   private registerCustomTransition(): void {
104.     // 注册自定义动画协议
105.     CustomTransition.getInstance().registerNavParam(this.pageId,
106.       (isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {}, 500);
107.   }

108.   private onCardClicked(): void {
109.     let cardItemInfo: RectInfoInPx =
110.       ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), 'card');
111.     let param: Record<string, Object> = {};
112.     param['cardItemInfo'] = cardItemInfo;
113.     param['doDefaultTransition'] = (myController: MyNodeController) => {
114.       this.doFinishTransition()
115.     };
116.     this.pageInfos.pushPath({ name: 'PageTwo', param: param });
117.     // 自定义节点从PageOne下树
118.     if (this.myNodeController != undefined) {
119.       (this.myNodeController as MyNodeController).onRemove();
120.     }
121.   }

122.   build() {
123.     NavDestination() {
124.       Stack() {
125.         Column({ space: 20 }) {
126.           Row({ space: 10 }) {
127.             // 图片使用Resource资源，需用户自定义
128.             Image($r("app.media.avatar"))
129.               .size({ width: 50, height: 50 })
130.               .borderRadius(25)
131.               .clip(true)

132.             Text('Alice')
133.           }
134.           .justifyContent(FlexAlign.Start)

135.           Text('你好世界')

136.           NodeContainer(this.myNodeController)
137.             .size({ width: 320, height: 250 })
138.             .onClick(() => {
139.               this.onCardClicked()
140.             })
141.         }
142.         .alignItems(HorizontalAlign.Start)
143.         .margin(30)
144.       }
145.     }
146.     .onReady((context: NavDestinationContext) => {
147.       this.pageInfos = context.pathStack;
148.       this.pageId = this.pageInfos.getAllPathName().length - 1;
149.       this.registerCustomTransition();
150.     })
151.     .onDisAppear(() => {
152.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
153.       // 自定义节点从PageOne下树
154.       if (this.myNodeController != undefined) {
155.         (this.myNodeController as MyNodeController).onRemove();
156.       }
157.     })
158.   }
159. }

160. // PageTwo.ets
161. import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
162. import { AnimationProperties } from '../CustomTransition/AnimationProperties';
163. import { RectInfoInPx } from '../utils/ComponentAttrUtils';
164. import { getMyNode, MyNodeController } from '../NodeContainer/CustomComponent';

165. @Builder
166. export function PageTwoBuilder() {
167.   PageTwo();
168. }

169. @Component
170. export struct PageTwo {
171.   @State pageInfos: NavPathStack = new NavPathStack();
172.   @State animationProperties: AnimationProperties = new AnimationProperties(this.getUIContext());
173.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

174.   private pageId: number = -1;

175.   private shouldDoDefaultTransition: boolean = false;
176.   private prePageDoFinishTransition: () => void = () => {};
177.   private cardItemInfo: RectInfoInPx = new RectInfoInPx();

178.   @StorageProp('windowSizeChanged') @Watch('unRegisterNavParam') windowSizeChangedTime: number = 0;
179.   @StorageProp('onConfigurationUpdate') @Watch('unRegisterNavParam') onConfigurationUpdateTime: number = 0;

180.   aboutToAppear(): void {
181.     // 迁移自定义节点至当前页面
182.     this.myNodeController = getMyNode();
183.   }

184.   private unRegisterNavParam(): void {
185.     this.shouldDoDefaultTransition = true;
186.   }

187.   private onBackPressed(): boolean {
188.     if (this.shouldDoDefaultTransition) {
189.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
190.       this.pageInfos.pop();
191.       this.prePageDoFinishTransition();
192.       this.shouldDoDefaultTransition = false;
193.       return true;
194.     }
195.     this.pageInfos.pop();
196.     return true;
197.   }

198.   build() {
199.     NavDestination() {
200.       // Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
201.       Stack({ alignContent: Alignment.TopStart }) {
202.         Stack({ alignContent: Alignment.TopStart }) {
203.           Column({space: 20}) {
204.             NodeContainer(this.myNodeController)
205.             if (this.animationProperties.showDetailContent)
206.               Text('展开态内容')
207.                 .fontSize(20)
208.                 .transition(TransitionEffect.OPACITY)
209.                 .margin(30)
210.           }
211.           .alignItems(HorizontalAlign.Start)
212.         }
213.         .position({ y: this.animationProperties.positionValue })
214.       }
215.       .scale({ x: this.animationProperties.scaleValue, y: this.animationProperties.scaleValue })
216.       .translate({ x: this.animationProperties.translateX, y: this.animationProperties.translateY })
217.       .width(this.animationProperties.clipWidth)
218.       .height(this.animationProperties.clipHeight)
219.       .borderRadius(this.animationProperties.radius)
220.       // expandSafeArea使得Stack做沉浸式效果，向上扩到状态栏，向下扩到导航条
221.       .expandSafeArea([SafeAreaType.SYSTEM])
222.       // 对高度进行裁切
223.       .clip(true)
224.     }
225.     .backgroundColor(this.animationProperties.navDestinationBgColor)
226.     .hideTitleBar(true)
227.     .onReady((context: NavDestinationContext) => {
228.       this.pageInfos = context.pathStack;
229.       this.pageId = this.pageInfos.getAllPathName().length - 1;
230.       let param = context.pathInfo?.param as Record<string, Object>;
231.       this.prePageDoFinishTransition = param['doDefaultTransition'] as () => void;
232.       this.cardItemInfo = param['cardItemInfo'] as RectInfoInPx;
233.       CustomTransition.getInstance().registerNavParam(this.pageId,
234.         (isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {
235.           this.animationProperties.doAnimation(
236.             this.cardItemInfo, isPush, isExit, transitionProxy, 0,
237.             this.prePageDoFinishTransition, this.myNodeController);
238.         }, 500);
239.     })
240.     .onBackPressed(() => {
241.       return this.onBackPressed();
242.     })
243.     .onDisAppear(() => {
244.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
245.     })
246.   }
247. }

248. // CustomNavigationUtils.ets
249. // 配置Navigation自定义转场动画
250. export interface AnimateCallback {
251.   animation: ((isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void | undefined)
252.     | undefined;
253.   timeout: (number | undefined) | undefined;
254. }

255. const customTransitionMap: Map<number, AnimateCallback> = new Map();

256. export class CustomTransition {
257.   private constructor() {};

258.   static delegate = new CustomTransition();

259.   static getInstance() {
260.     return CustomTransition.delegate;
261.   }

262.   // 注册页面的动画回调，name是注册页面的动画的回调
263.   // animationCallback是需要执行的动画内容，timeout是转场结束的超时时间
264.   registerNavParam(
265.     name: number,
266.     animationCallback: (operation: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void,
267.     timeout: number): void {
268.     if (customTransitionMap.has(name)) {
269.       let param = customTransitionMap.get(name);
270.       if (param != undefined) {
271.         param.animation = animationCallback;
272.         param.timeout = timeout;
273.         return;
274.       }
275.     }
276.     let params: AnimateCallback = { timeout: timeout, animation: animationCallback };
277.     customTransitionMap.set(name, params);
278.   }

279.   unRegisterNavParam(name: number): void {
280.     customTransitionMap.delete(name);
281.   }

282.   getAnimateParam(name: number): AnimateCallback {
283.     let result: AnimateCallback = {
284.       animation: customTransitionMap.get(name)?.animation,
285.       timeout: customTransitionMap.get(name)?.timeout,
286.     };
287.     return result;
288.   }
289. }

290. // 工程配置文件module.json5中配置 {"routerMap": "$profile:route_map"}
291. // route_map.json
292. {
293.   "routerMap": [
294.     {
295.       "name": "PageOne",
296.       "pageSourceFile": "src/main/ets/pages/PageOne.ets",
297.       "buildFunction": "PageOneBuilder"
298.     },
299.     {
300.       "name": "PageTwo",
301.       "pageSourceFile": "src/main/ets/pages/PageTwo.ets",
302.       "buildFunction": "PageTwoBuilder"
303.     }
304.   ]
305. }

306. // AnimationProperties.ets
307. // 一镜到底转场动画封装
308. import { curves, UIContext } from '@kit.ArkUI';
309. import { RectInfoInPx } from '../utils/ComponentAttrUtils';
310. import { WindowUtils } from '../utils/WindowUtils';
311. import { MyNodeController } from '../NodeContainer/CustomComponent';

312. const TAG: string = 'AnimationProperties';

313. const DEVICE_BORDER_RADIUS: number = 34;

314. // 将自定义一镜到底转场动画进行封装，其他界面也需要做自定义一镜到底转场的话，可以直接复用，减少工作量
315. @Observed
316. export class AnimationProperties {
317.   public navDestinationBgColor: ResourceColor = Color.Transparent;
318.   public translateX: number = 0;
319.   public translateY: number = 0;
320.   public scaleValue: number = 1;
321.   public clipWidth: Dimension = 0;
322.   public clipHeight: Dimension = 0;
323.   public radius: number = 0;
324.   public positionValue: number = 0;
325.   public showDetailContent: boolean = false;
326.   private uiContext: UIContext;

327.   constructor(uiContext: UIContext) {
328.     this.uiContext = uiContext
329.   }

330.   public doAnimation(cardItemInfo_px: RectInfoInPx, isPush: boolean, isExit: boolean,
331.                      transitionProxy: NavigationTransitionProxy, extraTranslateValue: number, prePageOnFinish: (index: MyNodeController) => void, myNodeController: MyNodeController | undefined): void {
332.     // 首先计算卡片的宽高与窗口宽高的比例
333.     let widthScaleRatio = cardItemInfo_px.width / WindowUtils.windowWidth_px;
334.     let heightScaleRatio = cardItemInfo_px.height / WindowUtils.windowHeight_px;
335.     let isUseWidthScale = widthScaleRatio > heightScaleRatio;
336.     let initScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;

337.     let initTranslateX: number = 0;
338.     let initTranslateY: number = 0;
339.     let initClipWidth: Dimension = 0;
340.     let initClipHeight: Dimension = 0;
341.     // 使得PageTwo卡片向上扩到状态栏
342.     let initPositionValue: number = -this.uiContext.px2vp(WindowUtils.topAvoidAreaHeight_px + extraTranslateValue);

343.     if (isUseWidthScale) {
344.       initTranslateX = this.uiContext.px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px - cardItemInfo_px.width) / 2);
345.       initClipWidth = '100%';
346.       initClipHeight = this.uiContext.px2vp((cardItemInfo_px.height) / initScale);
347.       initTranslateY = this.uiContext.px2vp(cardItemInfo_px.top - ((this.uiContext.vp2px(initClipHeight) - this.uiContext.vp2px(initClipHeight) * initScale) / 2));
348.     } else {
349.       initTranslateY = this.uiContext.px2vp(cardItemInfo_px.top - (WindowUtils.windowHeight_px - cardItemInfo_px.height) / 2);
350.       initClipHeight = '100%';
351.       initClipWidth = this.uiContext.px2vp((cardItemInfo_px.width) / initScale);
352.       initTranslateX = this.uiContext.px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px / 2 - cardItemInfo_px.width / 2));
353.     }

354.     // 转场动画开始前通过计算scale、translate、position和clip height & width，确定节点迁移前后位置一致
355.     console.info(TAG, 'initScale: ' + initScale + ' initTranslateX ' + initTranslateX +
356.     ' initTranslateY ' + initTranslateY + ' initClipWidth ' + initClipWidth +
357.     ' initClipHeight ' + initClipHeight + ' initPositionValue ' + initPositionValue);
358.     // 转场至新页面
359.     if (isPush && !isExit) {
360.       this.scaleValue = initScale;
361.       this.translateX = initTranslateX;
362.       this.clipWidth = initClipWidth;
363.       this.clipHeight = initClipHeight;
364.       this.translateY = initTranslateY;
365.       this.positionValue = initPositionValue;

366.       this.uiContext?.animateTo({
367.         curve: curves.interpolatingSpring(0, 1, 328, 36),
368.         onFinish: () => {
369.           if (transitionProxy) {
370.             transitionProxy.finishTransition();
371.           }
372.         }
373.       }, () => {
374.         this.scaleValue = 1.0;
375.         this.translateX = 0;
376.         this.translateY = 0;
377.         this.clipWidth = '100%';
378.         this.clipHeight = '100%';
379.         // 页面圆角与系统圆角一致
380.         this.radius = DEVICE_BORDER_RADIUS;
381.         this.showDetailContent = true;
382.       })

383.       this.uiContext?.animateTo({
384.         duration: 100,
385.         curve: Curve.Sharp,
386.       }, () => {
387.         // 页面由透明逐渐变为设置背景色
388.         this.navDestinationBgColor = '#00ffffff';
389.       })

390.       // 返回旧页面
391.     } else if (!isPush && isExit) {

392.       this.uiContext?.animateTo({
393.         duration: 350,
394.         curve: Curve.EaseInOut,
395.         onFinish: () => {
396.           if (transitionProxy) {
397.             transitionProxy.finishTransition();
398.           }
399.           prePageOnFinish(myNodeController);
400.           // 自定义节点从PageTwo下树
401.           if (myNodeController != undefined) {
402.             (myNodeController as MyNodeController).onRemove();
403.           }
404.         }
405.       }, () => {
406.         this.scaleValue = initScale;
407.         this.translateX = initTranslateX;
408.         this.translateY = initTranslateY;
409.         this.radius = 0;
410.         this.clipWidth = initClipWidth;
411.         this.clipHeight = initClipHeight;
412.         this.showDetailContent = false;
413.       })

414.       this.uiContext?.animateTo({
415.         duration: 200,
416.         delay: 150,
417.         curve: Curve.Friction,
418.       }, () => {
419.         this.navDestinationBgColor = Color.Transparent;
420.       })
421.     }
422.   }
423. }

424. // ComponentAttrUtils.ets
425. // 获取组件相对窗口的位置
426. import { componentUtils, UIContext } from '@kit.ArkUI';
427. import { JSON } from '@kit.ArkTS';

428. export class ComponentAttrUtils {
429.   // 根据组件的id获取组件的位置信息
430.   public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
431.     if (!context || !id) {
432.       throw Error('object is empty');
433.     }
434.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

435.     if (!componentInfo) {
436.       throw Error('object is empty');
437.     }

438.     let rstRect: RectInfoInPx = new RectInfoInPx();
439.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
440.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
441.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
442.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
443.     rstRect.right =
444.       componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
445.     rstRect.bottom =
446.       componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
447.     rstRect.width = rstRect.right - rstRect.left;
448.     rstRect.height = rstRect.bottom - rstRect.top;
449.     return {
450.       left: rstRect.left,
451.       right: rstRect.right,
452.       top: rstRect.top,
453.       bottom: rstRect.bottom,
454.       width: rstRect.width,
455.       height: rstRect.height
456.     }
457.   }
458. }

459. export class RectInfoInPx {
460.   left: number = 0;
461.   top: number = 0;
462.   right: number = 0;
463.   bottom: number = 0;
464.   width: number = 0;
465.   height: number = 0;
466. }

467. export class RectJson {
468.   $rect: Array<number> = [];
469. }

470. // WindowUtils.ets
471. // 窗口信息
472. import { window } from '@kit.ArkUI';

473. export class WindowUtils {
474.   public static window: window.Window;
475.   public static windowWidth_px: number;
476.   public static windowHeight_px: number;
477.   public static topAvoidAreaHeight_px: number;
478.   public static navigationIndicatorHeight_px: number;
479. }

480. // EntryAbility.ets
481. // 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取

482. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
483. import { hilog } from '@kit.PerformanceAnalysisKit';
484. import { display, window } from '@kit.ArkUI';
485. import { WindowUtils } from '../utils/WindowUtils';

486. const TAG: string = 'EntryAbility';

487. export default class EntryAbility extends UIAbility {
488.   private currentBreakPoint: string = '';

489.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
490.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
491.   }

492.   onDestroy(): void {
493.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
494.   }

495.   onWindowStageCreate(windowStage: window.WindowStage): void {
496.     // Main window is created, set main page for this ability
497.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

498.     // 获取窗口宽高
499.     WindowUtils.window = windowStage.getMainWindowSync();
500.     WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
501.     WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;

502.     this.updateBreakpoint(WindowUtils.windowWidth_px);

503.     // 获取上方避让区(状态栏等)高度
504.     let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
505.     WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;

506.     // 获取导航条高度
507.     let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
508.     WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;

509.     hilog.info(0x0000, TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
510.     WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);

511.     // 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
512.     try {
513.       WindowUtils.window.on('windowSizeChange', (data) => {
514.         hilog.info(0x0000, TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
515.         WindowUtils.windowWidth_px = data.width;
516.         WindowUtils.windowHeight_px = data.height;
517.         this.updateBreakpoint(data.width);
518.         AppStorage.setOrCreate('windowSizeChanged', Date.now())
519.       })

520.       WindowUtils.window.on('avoidAreaChange', (data) => {
521.         if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
522.           let topRectHeight = data.area.topRect.height;
523.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
524.           WindowUtils.topAvoidAreaHeight_px = topRectHeight;
525.         } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
526.           let bottomRectHeight = data.area.bottomRect.height;
527.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
528.           WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
529.         }
530.       })
531.     } catch (exception) {
532.       hilog.error(0x0000, TAG, `register failed. code: ${exception.code}, message: ${exception.message}`);
533.     }

534.     windowStage.loadContent('pages/Index', (err) => {
535.       if (err.code) {
536.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
537.         return;
538.       }
539.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
540.     });
541.   }

542.   updateBreakpoint(width: number) {
543.     let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
544.     let newBreakPoint: string = '';
545.     if (windowWidthVp < 400) {
546.       newBreakPoint = 'xs';
547.     } else if (windowWidthVp < 600) {
548.       newBreakPoint = 'sm';
549.     } else if (windowWidthVp < 800) {
550.       newBreakPoint = 'md';
551.     } else {
552.       newBreakPoint = 'lg';
553.     }
554.     if (this.currentBreakPoint !== newBreakPoint) {
555.       this.currentBreakPoint = newBreakPoint;
556.       // 使用状态变量记录当前断点值
557.       AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
558.     }
559.   }

560.   onWindowStageDestroy(): void {
561.     // Main window is destroyed, release UI related resources
562.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
563.   }

564.   onForeground(): void {
565.     // Ability has brought to foreground
566.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
567.   }

568.   onBackground(): void {
569.     // Ability has back to background
570.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
571.   }
572. }

573. // CustomComponent.ets
574. // 自定义占位节点，跨容器迁移能力
575. import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';

576. @Builder
577. function CardBuilder() {
578.   // 图片使用Resource资源，需用户自定义
579.   Image($r("app.media.card"))
580.     .width('100%')
581.     .id('card')
582. }

583. export class MyNodeController extends NodeController {
584.   private CardNode: BuilderNode<[]> | null = null;
585.   private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
586.   private needCreate: boolean = false;
587.   private isRemove: boolean = false;

588.   constructor(create: boolean) {
589.     super();
590.     this.needCreate = create;
591.   }

592.   makeNode(uiContext: UIContext): FrameNode | null {
593.     if(this.isRemove == true){
594.       return null;
595.     }
596.     if (this.needCreate && this.CardNode == null) {
597.       this.CardNode = new BuilderNode(uiContext);
598.       this.CardNode.build(this.wrapBuilder)
599.     }
600.     if (this.CardNode == null) {
601.       return null;
602.     }
603.     return this.CardNode!.getFrameNode()!;
604.   }

605.   getNode(): BuilderNode<[]> | null {
606.     return this.CardNode;
607.   }

608.   setNode(node: BuilderNode<[]> | null) {
609.     this.CardNode = node;
610.     this.rebuild();
611.   }

612.   onRemove() {
613.     this.isRemove = true;
614.     this.rebuild();
615.     this.isRemove = false;
616.   }

617.   init(uiContext: UIContext) {
618.     this.CardNode = new BuilderNode(uiContext);
619.     this.CardNode.build(this.wrapBuilder)
620.   }
621. }

622. let myNode: MyNodeController | undefined;

623. export const createMyNode =
624.   (uiContext: UIContext) => {
625.     myNode = new MyNodeController(false);
626.     myNode.init(uiContext);
627.   }

628. export const getMyNode = (): MyNodeController | undefined => {
629.   return myNode;
630. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.91962943741384209044607278822523:50001231000000:2800:8DFAE46CA0C1C9EEEA6A76B7605F719C3543BF27EC4EE3857F1BF851396FE47F.gif)

### 结合BindSheet使用

想实现半模态转场（[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#bindsheet)）的同时，组件从初始界面做一镜到底动画到半模态页面的效果，可以使用这样的设计思路。将[SheetOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#sheetoptions)中的mode设置为SheetMode.EMBEDDED，该模式下新起的页面可以覆盖在半模态弹窗上，页面返回后该半模态依旧存在，半模态面板内容不丢失。在半模态转场的同时设置一全模态转场（[bindContentCover](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-modal-transition#bindcontentcover)）页面无转场出现，该页面仅有需要做共享元素转场的组件，通过属性动画，展示组件从初始界面至半模态页面的一镜到底动效，并在动画结束时关闭页面，并将该组件迁移至半模态页面。

以点击图片展开半模态页的场景为例，实现步骤为：

- 在初始界面挂载半模态转场和全模态转场两个页面，半模态页按需布局，全模态页面仅放置一镜到底动效需要的组件，抓取布局信息，使其初始位置为初始界面图片的位置。点击初始界面图片时，同时触发半模态和全模态页面出现，因设置为SheetMode.EMBEDDED模式，此时全模态页面层级最高。
    
- 设置不可见的占位图片置于半模态页上，作为一镜到底动效结束时图片的终止位置。利用[布局回调](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-inspector)监听该占位图片布局完成的时候，此时执行回调抓取占位图片的位置信息，随后全模态页面上的图片利用属性动画开始进行共享元素转场。
    
- 全模态页面的动画结束时触发结束回调，关闭全模态页面，将共享元素图片的节点迁移至半模态页面，替换占位图片。
    
- 需注意，半模态页面的弹起高度不同，其页面起始位置也有所不同，而全模态则是全屏显示，两者存在一高度差，做一镜到底动画时，需要计算差值并进行修正，具体可见demo。
    
- 还可以配合一镜到底动画，给初始界面图片也增加一个从透明到出现的动画，使得动效更为流畅。
    

1. ├──entry/src/main/ets                 // 代码区
2. │  ├──entryability
3. │  │  └──EntryAbility.ets             // 程序入口类
4. │  ├──NodeContainer
5. │  │  └──CustomComponent.ets          // 自定义占位节点
6. │  ├──pages
7. │  │  └──Index.ets                    // 进行共享元素转场的主页面
8. │  └──utils
9. │     ├──ComponentAttrUtils.ets       // 组件位置获取
10. │     └──WindowUtils.ets              // 窗口信息
11. └──entry/src/main/resources           // 资源文件

12. // index.ets
13. import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
14. import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
15. import { WindowUtils } from '../utils/WindowUtils';
16. import { inspector } from '@kit.ArkUI'

17. class AnimationInfo {
18.   scale: number = 0;
19.   translateX: number = 0;
20.   translateY: number = 0;
21.   clipWidth: Dimension = 0;
22.   clipHeight: Dimension = 0;
23. }

24. @Entry
25. @Component
26. struct Index {
27.   @State isShowSheet: boolean = false;
28.   @State isShowImage: boolean = false;
29.   @State isShowOverlay: boolean = false;
30.   @State isAnimating: boolean = false;
31.   @State isEnabled: boolean = true;

32.   @State scaleValue: number = 0;
33.   @State translateX: number = 0;
34.   @State translateY: number = 0;
35.   @State clipWidth: Dimension = 0;
36.   @State clipHeight: Dimension = 0;
37.   @State radius: number = 0;
38.   // 原图的透明度
39.   @State opacityDegree: number = 1;

40.   // 抓取照片原位置信息
41.   private originInfo: AnimationInfo = new AnimationInfo;
42.   // 抓取照片在半模态页上位置信息
43.   private targetInfo: AnimationInfo = new AnimationInfo;
44.   // 半模态高度
45.   private bindSheetHeight: number = 450;
46.   // 半模态上图片圆角
47.   private sheetRadius: number = 20;

48.   // 设置半模态上图片的布局监听
49.   listener:inspector.ComponentObserver = this.getUIContext().getUIInspector().createComponentObserver('target');
50.   aboutToAppear(): void {
51.     // 设置半模态上图片的布局完成回调
52.     let onLayoutComplete:()=>void=():void=>{
53.       // 目标图片布局完成时抓取布局信息
54.       this.targetInfo = this.calculateData('target');
55.       // 仅半模态正确布局且此时无动画时触发一镜到底动画
56.       if (this.targetInfo.scale != 0 && this.targetInfo.clipWidth != 0 && this.targetInfo.clipHeight != 0 && !this.isAnimating) {
57.         this.isAnimating = true;
58.         // 用于一镜到底的模态页的属性动画
59.         this.getUIContext()?.animateTo({
60.           duration: 1000,
61.           curve: Curve.Friction,
62.           onFinish: () => {
63.             // 模态转场页（overlay）上的自定义节点下树
64.             this.isShowOverlay = false;
65.             // 半模态上的自定义节点上树，由此完成节点迁移
66.             this.isShowImage = true;
67.           }
68.         }, () => {
69.           this.scaleValue = this.targetInfo.scale;
70.           this.translateX = this.targetInfo.translateX;
71.           this.clipWidth = this.targetInfo.clipWidth;
72.           this.clipHeight = this.targetInfo.clipHeight;
73.           // 修正因半模态高度和缩放导致的高度差
74.           this.translateY = this.targetInfo.translateY +
75.             (this.getUIContext().px2vp(WindowUtils.windowHeight_px) - this.bindSheetHeight
76.               - this.getUIContext().px2vp(WindowUtils.navigationIndicatorHeight_px) - this.getUIContext().px2vp(WindowUtils.topAvoidAreaHeight_px));
77.           // 修正因缩放导致的圆角差异
78.           this.radius = this.sheetRadius / this.scaleValue
79.         })
80.         // 原图从透明到出现的动画
81.         this.getUIContext()?.animateTo({
82.           duration: 2000,
83.           curve: Curve.Friction,
84.         }, () => {
85.           this.opacityDegree = 1;
86.         })
87.       }
88.     }
89.     // 打开布局监听
90.     this.listener.on('layout', onLayoutComplete)
91.   }

92.   // 获取对应id的组件相对窗口左上角的属性
93.   calculateData(id: string): AnimationInfo {
94.     let itemInfo: RectInfoInPx =
95.       ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), id);
96.     // 首先计算图片的宽高与窗口宽高的比例
97.     let widthScaleRatio = itemInfo.width / WindowUtils.windowWidth_px;
98.     let heightScaleRatio = itemInfo.height / WindowUtils.windowHeight_px;
99.     let isUseWidthScale = widthScaleRatio > heightScaleRatio;
100.     let itemScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;
101.     let itemTranslateX: number = 0;
102.     let itemClipWidth: Dimension = 0;
103.     let itemClipHeight: Dimension = 0;
104.     let itemTranslateY: number = 0;

105.     if (isUseWidthScale) {
106.       itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px - itemInfo.width) / 2);
107.       itemClipWidth = '100%';
108.       itemClipHeight = this.getUIContext().px2vp((itemInfo.height) / itemScale);
109.       itemTranslateY = this.getUIContext().px2vp(itemInfo.top - ((this.getUIContext().vp2px(itemClipHeight) - this.getUIContext().vp2px(itemClipHeight) * itemScale) / 2));
110.     } else {
111.       itemTranslateY = this.getUIContext().px2vp(itemInfo.top - (WindowUtils.windowHeight_px - itemInfo.height) / 2);
112.       itemClipHeight = '100%';
113.       itemClipWidth = this.getUIContext().px2vp((itemInfo.width) / itemScale);
114.       itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px / 2 - itemInfo.width / 2));
115.     }

116.     return {
117.       scale: itemScale,
118.       translateX: itemTranslateX ,
119.       translateY: itemTranslateY,
120.       clipWidth: itemClipWidth,
121.       clipHeight: itemClipHeight,
122.     }
123.   }

124.   // 照片页
125.   build() {
126.     Column() {
127.       Text('照片')
128.         .textAlign(TextAlign.Start)
129.         .width('100%')
130.         .fontSize(30)
131.         .padding(20)
132.       // 图片使用Resource资源，需用户自定义
133.       Image($r("app.media.flower"))
134.         .opacity(this.opacityDegree)
135.         .width('90%')
136.         .id('origin')// 挂载半模态页
137.         .enabled(this.isEnabled)
138.         .onClick(() => {
139.           // 获取原始图像的位置信息，将模态页上图片移动缩放至该位置
140.           this.originInfo = this.calculateData('origin');
141.           this.scaleValue = this.originInfo.scale;
142.           this.translateX = this.originInfo.translateX;
143.           this.translateY = this.originInfo.translateY;
144.           this.clipWidth = this.originInfo.clipWidth;
145.           this.clipHeight = this.originInfo.clipHeight;
146.           this.radius = 0;
147.           this.opacityDegree = 0;
148.           // 启动半模态页和模态页
149.           this.isShowSheet = true;
150.           this.isShowOverlay = true;
151.           // 设置原图为不可交互抗打断
152.           this.isEnabled = false;
153.         })
154.     }
155.     .width('100%')
156.     .height('100%')
157.     .padding({ top: 20 })
158.     .alignItems(HorizontalAlign.Center)
159.     .bindSheet(this.isShowSheet, this.mySheet(), {
160.       // Embedded模式使得其他页面可以高于半模态页
161.       mode: SheetMode.EMBEDDED,
162.       height: this.bindSheetHeight,
163.       onDisappear: () => {
164.         // 保证半模态消失时状态正确
165.         this.isShowImage = false;
166.         this.isShowSheet = false;
167.         // 设置一镜到底动画又进入可触发状态
168.         this.isAnimating = false;
169.         // 原图重新变为可交互状态
170.         this.isEnabled = true;
171.       }
172.     }) // 挂载模态页作为一镜到底动画的实现页
173.     .bindContentCover(this.isShowOverlay, this.overlayNode(), {
174.       // 模态页面设置为无转场
175.       transition: TransitionEffect.IDENTITY,
176.     })
177.   }

178.   // 半模态页面
179.   @Builder
180.   mySheet() {
181.     Column({space: 20}) {
182.       Text('半模态页面')
183.         .fontSize(30)
184.       Row({space: 40}) {
185.         Column({space: 20}) {
186.           ForEach([1, 2, 3, 4], () => {
187.             Stack()
188.               .backgroundColor(Color.Pink)
189.               .borderRadius(20)
190.               .width(60)
191.               .height(60)
192.           })
193.         }
194.         Column() {
195.           if (this.isShowImage) {
196.             // 半模态页面的自定义图片节点
197.             ImageNode()
198.           }
199.           else {
200.             // 抓取布局和占位用，实际不显示
201.             // 图片使用Resource资源，需用户自定义
202.             Image($r("app.media.flower"))
203.               .visibility(Visibility.Hidden)
204.           }
205.         }
206.         .height(300)
207.         .width(200)
208.         .borderRadius(20)
209.         .clip(true)
210.         .id('target')
211.       }
212.       .alignItems(VerticalAlign.Top)
213.     }
214.     .alignItems(HorizontalAlign.Start)
215.     .height('100%')
216.     .width('100%')
217.     .margin(40)
218.   }

219.   @Builder
220.   overlayNode() {
221.     // Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
222.     Stack({ alignContent: Alignment.TopStart }) {
223.       ImageNode()
224.     }
225.     .scale({ x: this.scaleValue, y: this.scaleValue, centerX: undefined, centerY: undefined})
226.     .translate({ x: this.translateX, y: this.translateY })
227.     .width(this.clipWidth)
228.     .height(this.clipHeight)
229.     .borderRadius(this.radius)
230.     .clip(true)
231.   }
232. }

233. @Component
234. struct ImageNode {
235.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

236.   aboutToAppear(): void {
237.     // 获取自定义节点
238.     let node = getMyNode();
239.     if (node == undefined) {
240.       // 新建自定义节点
241.       createMyNode(this.getUIContext());
242.     }
243.     this.myNodeController = getMyNode();
244.   }

245.   aboutToDisappear(): void {
246.     if (this.myNodeController != undefined) {
247.       // 节点下树
248.       this.myNodeController.onRemove();
249.     }
250.   }
251.   build() {
252.     NodeContainer(this.myNodeController)
253.   }
254. }

255. // CustomComponent.ets
256. // 自定义占位节点，跨容器迁移能力
257. import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';

258. @Builder
259. function CardBuilder() {
260.   // 图片使用Resource资源，需用户自定义
261.   Image($r("app.media.flower"))
262.     // 避免第一次加载图片时图片闪烁
263.     .syncLoad(true)
264. }

265. export class MyNodeController extends NodeController {
266.   private CardNode: BuilderNode<[]> | null = null;
267.   private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
268.   private needCreate: boolean = false;
269.   private isRemove: boolean = false;

270.   constructor(create: boolean) {
271.     super();
272.     this.needCreate = create;
273.   }

274.   makeNode(uiContext: UIContext): FrameNode | null {
275.     if(this.isRemove == true){
276.       return null;
277.     }
278.     if (this.needCreate && this.CardNode == null) {
279.       this.CardNode = new BuilderNode(uiContext);
280.       this.CardNode.build(this.wrapBuilder)
281.     }
282.     if (this.CardNode == null) {
283.       return null;
284.     }
285.     return this.CardNode!.getFrameNode()!;
286.   }

287.   getNode(): BuilderNode<[]> | null {
288.     return this.CardNode;
289.   }

290.   setNode(node: BuilderNode<[]> | null) {
291.     this.CardNode = node;
292.     this.rebuild();
293.   }

294.   onRemove() {
295.     this.isRemove = true;
296.     this.rebuild();
297.     this.isRemove = false;
298.   }

299.   init(uiContext: UIContext) {
300.     this.CardNode = new BuilderNode(uiContext);
301.     this.CardNode.build(this.wrapBuilder)
302.   }
303. }

304. let myNode: MyNodeController | undefined;

305. export const createMyNode =
306.   (uiContext: UIContext) => {
307.     myNode = new MyNodeController(false);
308.     myNode.init(uiContext);
309.   }

310. export const getMyNode = (): MyNodeController | undefined => {
311.   return myNode;
312. }

313. // ComponentAttrUtils.ets
314. // 获取组件相对窗口的位置
315. import { componentUtils, UIContext } from '@kit.ArkUI';
316. import { JSON } from '@kit.ArkTS';

317. export class ComponentAttrUtils {
318.   // 根据组件的id获取组件的位置信息
319.   public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
320.     if (!context || !id) {
321.       throw Error('object is empty');
322.     }
323.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

324.     if (!componentInfo) {
325.       throw Error('object is empty');
326.     }

327.     let rstRect: RectInfoInPx = new RectInfoInPx();
328.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
329.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
330.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
331.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
332.     rstRect.right =
333.       componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
334.     rstRect.bottom =
335.       componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
336.     rstRect.width = rstRect.right - rstRect.left;
337.     rstRect.height = rstRect.bottom - rstRect.top;
338.     return {
339.       left: rstRect.left,
340.       right: rstRect.right,
341.       top: rstRect.top,
342.       bottom: rstRect.bottom,
343.       width: rstRect.width,
344.       height: rstRect.height
345.     }
346.   }
347. }

348. export class RectInfoInPx {
349.   left: number = 0;
350.   top: number = 0;
351.   right: number = 0;
352.   bottom: number = 0;
353.   width: number = 0;
354.   height: number = 0;
355. }

356. export class RectJson {
357.   $rect: Array<number> = [];
358. }

359. // WindowUtils.ets
360. // 窗口信息
361. import { window } from '@kit.ArkUI';

362. export class WindowUtils {
363.   public static window: window.Window;
364.   public static windowWidth_px: number;
365.   public static windowHeight_px: number;
366.   public static topAvoidAreaHeight_px: number;
367.   public static navigationIndicatorHeight_px: number;
368. }

369. // EntryAbility.ets
370. // 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取

371. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
372. import { hilog } from '@kit.PerformanceAnalysisKit';
373. import { display, window } from '@kit.ArkUI';
374. import { WindowUtils } from '../utils/WindowUtils';

375. const TAG: string = 'EntryAbility';

376. export default class EntryAbility extends UIAbility {
377.   private currentBreakPoint: string = '';

378.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
379.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
380.   }

381.   onDestroy(): void {
382.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
383.   }

384.   onWindowStageCreate(windowStage: window.WindowStage): void {
385.     // Main window is created, set main page for this ability
386.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

387.     // 获取窗口宽高
388.     WindowUtils.window = windowStage.getMainWindowSync();
389.     WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
390.     WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;

391.     this.updateBreakpoint(WindowUtils.windowWidth_px);

392.     // 获取上方避让区(状态栏等)高度
393.     let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
394.     WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;

395.     // 获取导航条高度
396.     let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
397.     WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;

398.     hilog.info(0x0000, TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
399.     WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);

400.     // 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
401.     try {
402.       WindowUtils.window.on('windowSizeChange', (data) => {
403.         hilog.info(0x0000, TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
404.         WindowUtils.windowWidth_px = data.width;
405.         WindowUtils.windowHeight_px = data.height;
406.         this.updateBreakpoint(data.width);
407.         AppStorage.setOrCreate('windowSizeChanged', Date.now())
408.       })

409.       WindowUtils.window.on('avoidAreaChange', (data) => {
410.         if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
411.           let topRectHeight = data.area.topRect.height;
412.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
413.           WindowUtils.topAvoidAreaHeight_px = topRectHeight;
414.         } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
415.           let bottomRectHeight = data.area.bottomRect.height;
416.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
417.           WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
418.         }
419.       })
420.     } catch (exception) {
421.       hilog.error(0x0000, TAG, `register failed. code: ${exception.code}, message: ${exception.message}`);
422.     }

423.     windowStage.loadContent('pages/Index', (err) => {
424.       if (err.code) {
425.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
426.         return;
427.       }
428.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
429.     });
430.   }

431.   updateBreakpoint(width: number) {
432.     let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
433.     let newBreakPoint: string = '';
434.     if (windowWidthVp < 400) {
435.       newBreakPoint = 'xs';
436.     } else if (windowWidthVp < 600) {
437.       newBreakPoint = 'sm';
438.     } else if (windowWidthVp < 800) {
439.       newBreakPoint = 'md';
440.     } else {
441.       newBreakPoint = 'lg';
442.     }
443.     if (this.currentBreakPoint !== newBreakPoint) {
444.       this.currentBreakPoint = newBreakPoint;
445.       // 使用状态变量记录当前断点值
446.       AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
447.     }
448.   }

449.   onWindowStageDestroy(): void {
450.     // Main window is destroyed, release UI related resources
451.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
452.   }

453.   onForeground(): void {
454.     // Ability has brought to foreground
455.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
456.   }

457.   onBackground(): void {
458.     // Ability has back to background
459.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
460.   }
461. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.94596976349835209240042454924339:50001231000000:2800:4A1587C908876454A8D1E02A27656B0A047FB4D15668A8CE38F4B2DBB5B3C7B5.gif)

## 使用geometryTransition共享元素转场

[geometryTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-geometrytransition)用于组件内隐式共享元素转场，在视图状态切换过程中提供丝滑的上下文继承过渡体验。

geometryTransition的使用方式为对需要添加一镜到底动效的两个组件使用geometryTransition接口绑定同一id，这样在其中一个组件消失同时另一个组件创建出现的时候，系统会对二者添加一镜到底动效。

geometryTransition绑定两个对象的实现方式使得geometryTransition区别于其他方法，最适合用于两个不同对象之间完成一镜到底。

### geometryTransition的简单使用

对于同一个页面中的两个元素的一镜到底效果，geometryTransition接口的简单使用示例如下：

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct IfElseGeometryTransition {
5.   @State isShow: boolean = false;

6.   build() {
7.     Stack({ alignContent: Alignment.Center }) {
8.       if (this.isShow) {
9.         // 图片使用Resource资源，需用户自定义
10.         Image($r('app.media.spring'))
11.           .autoResize(false)
12.           .clip(true)
13.           .width(200)
14.           .height(200)
15.           .borderRadius(100)
16.           .geometryTransition("picture")
17.           .transition(TransitionEffect.OPACITY)
18.           // 在打断场景下，即动画过程中点击页面触发下一次转场，如果不加id，则会出现重影
19.           // 加了id之后，新建的spring图片会复用之前的spring图片节点，不会重新创建节点，也就不会有重影问题
20.           // 加id的规则为加在if和else下的第一个节点上，有多个并列节点则也需要进行添加
21.           .id('item1')
22.       } else {
23.         // geometryTransition此处绑定的是容器，那么容器内的子组件需设为相对布局跟随父容器变化，
24.         // 套多层容器为了说明相对布局约束传递
25.         Column() {
26.           Column() {
27.             // 图片使用Resource资源，需用户自定义
28.             Image($r('app.media.sky'))
29.               .size({ width: '100%', height: '100%' })
30.           }
31.           .size({ width: '100%', height: '100%' })
32.         }
33.         .width(100)
34.         .height(100)
35.         // geometryTransition会同步圆角，但仅限于geometryTransition绑定处，此处绑定的是容器
36.         // 则对容器本身有圆角同步而不会操作容器内部子组件的borderRadius
37.         .borderRadius(50)
38.         .clip(true)
39.         .geometryTransition("picture")
40.         // transition保证节点离场不被立即析构，设置通用转场效果
41.         .transition(TransitionEffect.OPACITY)
42.         .position({ x: 40, y: 40 })
43.         .id('item2')
44.       }
45.     }
46.     .onClick(() => {
47.       this.getUIContext()?.animateTo({
48.         curve: curves.springMotion()
49.       }, () => {
50.         this.isShow = !this.isShow;
51.       })
52.     })
53.     .size({ width: '100%', height: '100%' })
54.   }
55. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.34247257179854547412558413214758:50001231000000:2800:7C08D34AEAB1EE500B2DA23B310AD59E21FB7C992DC92A3666BC87240F20409A.gif)

### geometryTransition结合模态转场使用

更多的场景中，需要对一个页面的元素与另一个页面的元素添加一镜到底动效。可以通过geometryTransition搭配模态转场接口实现。以点击头像弹出个人信息页的demo为例：

1. class PostData {
2.   // 图片使用Resource资源，需用户自定义
3.   avatar: Resource = $r('app.media.flower');
4.   name: string = '';
5.   message: string = '';
6.   images: Resource[] = [];
7. }

8. @Entry
9. @Component
10. struct Index {
11.   @State isPersonalPageShow: boolean = false;
12.   @State selectedIndex: number = 0;
13.   @State alphaValue: number = 1;

14.   // 数组中图片均使用Resource资源，需用户自定义
15.   private allPostData: PostData[] = [
16.     { avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
17.       images: [$r('app.media.spring'), $r('app.media.tree')] },
18.     { avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
19.       images: [$r('app.media.island')] },
20.     { avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
21.       images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];

22.   private onAvatarClicked(index: number): void {
23.     this.selectedIndex = index;
24.     this.getUIContext()?.animateTo({
25.       duration: 350,
26.       curve: Curve.Friction
27.     }, () => {
28.       this.isPersonalPageShow = !this.isPersonalPageShow;
29.       this.alphaValue = 0;
30.     });
31.   }

32.   private onPersonalPageBack(index: number): void {
33.     this.getUIContext()?.animateTo({
34.       duration: 350,
35.       curve: Curve.Friction
36.     }, () => {
37.       this.isPersonalPageShow = !this.isPersonalPageShow;
38.       this.alphaValue = 1;
39.     });
40.   }

41.   @Builder
42.   PersonalPageBuilder(index: number) {
43.     Column({ space: 20 }) {
44.       Image(this.allPostData[index].avatar)
45.         .size({ width: 200, height: 200 })
46.         .borderRadius(100)
47.         // 头像配置共享元素效果，与点击的头像的id匹配
48.         .geometryTransition(index.toString())
49.         .clip(true)
50.         .transition(TransitionEffect.opacity(0.99))

51.       Text(this.allPostData[index].name)
52.         .font({ size: 30, weight: 600 })
53.         // 对文本添加出现转场效果
54.         .transition(TransitionEffect.asymmetric(
55.           TransitionEffect.OPACITY
56.             .combine(TransitionEffect.translate({ y: 100 })),
57.           TransitionEffect.OPACITY.animation({ duration: 0 })
58.         ))

59.       Text('你好，我是' + this.allPostData[index].name)
60.         // 对文本添加出现转场效果
61.         .transition(TransitionEffect.asymmetric(
62.           TransitionEffect.OPACITY
63.             .combine(TransitionEffect.translate({ y: 100 })),
64.           TransitionEffect.OPACITY.animation({ duration: 0 })
65.         ))
66.     }
67.     .padding({ top: 20 })
68.     .size({ width: 360, height: 780 })
69.     .backgroundColor(Color.White)
70.     .onClick(() => {
71.       this.onPersonalPageBack(index);
72.     })
73.     .transition(TransitionEffect.asymmetric(
74.       TransitionEffect.opacity(0.99),
75.       TransitionEffect.OPACITY
76.     ))
77.   }

78.   build() {
79.     Column({ space: 20 }) {
80.       ForEach(this.allPostData, (postData: PostData, index: number) => {
81.         Column() {
82.           Post({ data: postData, index: index, onAvatarClicked: (index: number) => { this.onAvatarClicked(index) } })
83.         }
84.         .width('100%')
85.       }, (postData: PostData, index: number) => index.toString())
86.     }
87.     .size({ width: '100%', height: '100%' })
88.     .backgroundColor('#40808080')
89.     .bindContentCover(this.isPersonalPageShow,
90.       this.PersonalPageBuilder(this.selectedIndex), { modalTransition: ModalTransition.NONE })
91.     .opacity(this.alphaValue)
92.   }
93. }

94. @Component
95. export default struct  Post {
96.   @Prop data: PostData;
97.   @Prop index: number;

98.   @State expandImageSize: number = 100;
99.   @State avatarSize: number = 50;

100.   private onAvatarClicked: (index: number) => void = (index: number) => { };

101.   build() {
102.     Column({ space: 20 }) {
103.       Row({ space: 10 }) {
104.         Image(this.data.avatar)
105.           .size({ width: this.avatarSize, height: this.avatarSize })
106.           .borderRadius(this.avatarSize / 2)
107.           .clip(true)
108.           .onClick(() => {
109.             this.onAvatarClicked(this.index);
110.           })
111.           // 对头像绑定共享元素转场的id
112.           .geometryTransition(this.index.toString(), {follow:true})
113.           .transition(TransitionEffect.OPACITY.animation({ duration: 350, curve: Curve.Friction }))

114.         Text(this.data.name)
115.       }
116.       .justifyContent(FlexAlign.Start)

117.       Text(this.data.message)

118.       Row({ space: 15 }) {
119.         ForEach(this.data.images, (imageResource: Resource, index: number) => {
120.           Image(imageResource)
121.             .size({ width: 100, height: 100 })
122.         }, (imageResource: Resource, index: number) => index.toString())
123.       }
124.     }
125.     .backgroundColor(Color.White)
126.     .size({ width: '100%', height: 250 })
127.     .alignItems(HorizontalAlign.Start)
128.     .padding({ left: 10, top: 10 })
129.   }
130. }

效果为点击主页的头像后，弹出模态页面显示个人信息，并且两个页面之间的头像做一镜到底动效：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.40028410023183083819362411137140:50001231000000:2800:C4A113ACE78D678023273FD86D3A9BE07ECFCE51EE0C62D4BEB9DCB8658A89F8.gif)

## 示例代码

- [转场动效合集](https://gitcode.com/harmonyos_samples/transitions-collection)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-modal-transition "模态转场")
# 共享元素转场 (一镜到底)

更新时间: 2025-12-16 16:40

共享元素转场是一种界面切换时对相同或者相似的两个元素做的一种位置和大小匹配的过渡动画效果，也称一镜到底动效。

如下例所示，在点击图片后，该图片消失，同时在另一个位置出现新的图片，二者之间内容相同，可以对它们添加一镜到底动效。左图为不添加一镜到底动效的效果，右图为添加一镜到底动效的效果，一镜到底的效果能够让二者的出现消失产生联动，使得内容切换过程显得灵动自然而不生硬。

|   |   |
|---|---|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.84094530939537589914493896349658:50001231000000:2800:37C5C7D9D6216F417E0A207CD22D2E4BF08403AE4B85D14972E1DCBF1A62FB3E.gif)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.80553205120654277749869978432078:50001231000000:2800:8DF360AC7C09D418081F02CFA9CF50983AC6EC9432CB42A053DA9C03ECBE3378.gif)|

一镜到底的动效有多种实现方式，在实际开发过程中，应根据具体场景选择合适的方法进行实现。

以下是不同实现方式的对比：

|一镜到底实现方式|特点|适用场景|
|:--|:--|:--|
|不新建容器直接变化原容器|不发生路由跳转，需要在一个组件中实现展开及关闭两种状态的布局，展开后组件层级不变。|适用于转场开销小的简单场景，如点开页面无需加载大量数据及组件。|
|新建容器并跨容器迁移组件|通过使用NodeController，将组件从一个容器迁移到另一个容器，在开始迁移时，需要根据前后两个布局的位置大小等信息对组件添加位移及缩放，确保迁移开始时组件能够对齐初始布局，避免出现视觉上的跳变现象。之后再添加动画将位移及缩放等属性复位，实现组件从初始布局到目标布局的一镜到底过渡效果。|适用于新建对象开销大的场景，如视频直播组件点击转为全屏等。|
|使用geometryTransition共享元素转场|利用系统能力，转场前后两个组件调用geometryTransition接口绑定同一id，同时将转场逻辑置于animateTo动画闭包内，这样系统侧会自动为二者添加一镜到底的过渡效果。|系统将调整绑定的两个组件的宽高及位置至相同值，并切换二者的透明度，以实现一镜到底过渡效果。因此，为了实现流畅的动画效果，需要确保对绑定geometryTransition的节点添加宽高动画不会有跳变。此方式适用于创建新节点开销小的场景。|

## 不新建容器并直接变化原容器

该方法不新建容器，通过在已有容器上增删组件触发[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)，搭配组件[属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis)实现一镜到底效果。

对于同一个容器展开，容器内兄弟组件消失或者出现的场景，可通过对同一个容器展开前后进行宽高位置变化并配置属性动画，对兄弟组件配置出现消失转场动画实现一镜到底效果。基本步骤为：

1. 构建需要展开的页面，并通过状态变量构建好普通状态和展开状态的界面。
    
2. 将需要展开的页面展开，通过状态变量控制兄弟组件消失或出现，并通过绑定出现消失转场实现兄弟组件转场效果。
    

以点击卡片后显示卡片内容详情场景为例：

1. class PostData {
2.   // 图片使用Resource资源，需用户自定义
3.   avatar: Resource = $r('app.media.flower');
4.   name: string = '';
5.   message: string = '';
6.   images: Resource[] = [];
7. }

8. @Entry
9. @Component
10. struct Index {
11.   @State isExpand: boolean = false;
12.   @State @Watch('onItemClicked') selectedIndex: number = -1;

13.   // 数组中图片均使用Resource资源，需用户自定义
14.   private allPostData: PostData[] = [
15.     { avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
16.       images: [$r('app.media.spring'), $r('app.media.tree')] },
17.     { avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
18.       images: [$r('app.media.island')] },
19.     { avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
20.       images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];

21.   private onItemClicked(): void {
22.     if (this.selectedIndex < 0) {
23.       return;
24.     }
25.     this.getUIContext()?.animateTo({
26.       duration: 350,
27.       curve: Curve.Friction
28.     }, () => {
29.       this.isExpand = !this.isExpand;
30.     });
31.   }

32.   build() {
33.     Column({ space: 20 }) {
34.       ForEach(this.allPostData, (postData: PostData, index: number) => {
35.         // 当点击了某个post后，会使其余的post消失下树
36.         if (!this.isExpand || this.selectedIndex === index) {
37.           Column() {
38.             Post({ data: postData, selectedIndex: this.selectedIndex, index: index })
39.           }
40.           .width('100%')
41.           // 对出现消失的post添加透明度转场和位移转场效果
42.           .transition(TransitionEffect.OPACITY
43.             .combine(TransitionEffect.translate({ y: index < this.selectedIndex ? -250 : 250 }))
44.             .animation({ duration: 350, curve: Curve.Friction}))
45.         }
46.       }, (postData: PostData, index: number) => index.toString())
47.     }
48.     .size({ width: '100%', height: '100%' })
49.     .backgroundColor('#40808080')
50.   }
51. }

52. @Component
53. export default struct  Post {
54.   @Link selectedIndex: number;

55.   @Prop data: PostData;
56.   @Prop index: number;

57.   @State itemHeight: number = 250;
58.   @State isExpand: boolean = false;
59.   @State expandImageSize: number = 100;
60.   @State avatarSize: number = 50;

61.   build() {
62.     Column({ space: 20 }) {
63.       Row({ space: 10 }) {
64.         Image(this.data.avatar)
65.           .size({ width: this.avatarSize, height: this.avatarSize })
66.           .borderRadius(this.avatarSize / 2)
67.           .clip(true)

68.         Text(this.data.name)
69.       }
70.       .justifyContent(FlexAlign.Start)

71.       Text(this.data.message)

72.       Row({ space: 15 }) {
73.         ForEach(this.data.images, (imageResource: Resource, index: number) => {
74.           Image(imageResource)
75.             .size({ width: this.expandImageSize, height: this.expandImageSize })
76.         }, (imageResource: Resource, index: number) => index.toString())
77.       }

78.       // 展开态下组件增加的内容
79.       if (this.isExpand) {
80.         Column() {
81.           Text('评论区')
82.             // 对评论区文本添加出现消失转场效果
83.             .transition( TransitionEffect.OPACITY
84.               .animation({ duration: 350, curve: Curve.Friction }))
85.             .padding({ top: 10 })
86.         }
87.         .transition(TransitionEffect.asymmetric(
88.           TransitionEffect.opacity(0.99)
89.             .animation({ duration: 350, curve: Curve.Friction }),
90.           TransitionEffect.OPACITY.animation({ duration: 0 })
91.         ))
92.         .size({ width: '100%'})
93.       }
94.     }
95.     .backgroundColor(Color.White)
96.     .size({ width: '100%', height: this.itemHeight })
97.     .alignItems(HorizontalAlign.Start)
98.     .padding({ left: 10, top: 10 })
99.     .onClick(() => {
100.       this.selectedIndex = -1;
101.       this.selectedIndex = this.index;
102.       this.getUIContext()?.animateTo({
103.         duration: 350,
104.         curve: Curve.Friction
105.       }, () => {
106.         // 对展开的post做宽高动画，并对头像尺寸和图片尺寸加动画
107.         this.isExpand = !this.isExpand;
108.         this.itemHeight = this.isExpand ? 780 : 250;
109.         this.avatarSize = this.isExpand ? 75: 50;
110.         this.expandImageSize = (this.isExpand && this.data.images.length > 0)
111.           ? (360 - (this.data.images.length + 1) * 15) / this.data.images.length : 100;
112.       })
113.     })
114.   }
115. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.11573830513638335466236997937071:50001231000000:2800:71C86D5867B7E0F69C74F660D5E5B70D3B2064A2C5A5EAEA4901D8C75E8E2298.gif)

## 新建容器并跨容器迁移组件

通过[NodeContainer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-nodecontainer)[自定义占位节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-place-holder)，利用[NodeController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontroller)实现组件的跨节点迁移，配合属性动画给组件的迁移过程赋予一镜到底效果。这种一镜到底的实现方式可以结合多种转场方式使用，如导航转场（[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)）、半模态转场（[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#bindsheet)）等。

### 结合Stack使用

可以利用Stack内后定义组件在最上方的特性控制组件在跨节点迁移后位z序最高，以展开收起卡片的场景为例，实现步骤为：

- 展开卡片时，获取节点A的位置信息，将其中的组件迁移到与节点A位置一致的节点B处，节点B的层级高于节点A。
    
- 对节点B添加属性动画，使之展开并运动到展开后的位置，完成一镜到底的动画效果。
    
- 收起卡片时，对节点B添加属性动画，使之收起并运动到收起时的位置，即节点A的位置，实现一镜到底的动画效果。
    
- 在动画结束时利用回调将节点B中的组件迁移回节点A处。
    

1. // Index.ets
2. import { createPostNode, getPostNode, PostNode } from "./PostNode";
3. import { componentUtils, curves, UIContext } from '@kit.ArkUI';

4. @Entry
5. @Component
6. struct Index {
7.   // 新建一镜到底动画类
8.   private uiContext: UIContext = this.getUIContext();
9.   @State animationProperties: AnimationProperties = new AnimationProperties(this.uiContext);
10.   private listArray: Array<number> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

11.   build() {
12.     // 卡片折叠态，展开态的共同父组件
13.     Stack() {
14.       List({ space: 20 }) {
15.         ForEach(this.listArray, (item: number) => {
16.           ListItem() {
17.             // 卡片折叠态
18.             PostItem({ index: item, animationProperties: this.animationProperties })
19.           }
20.         })
21.       }
22.       .clip(false)
23.       .alignListItem(ListItemAlign.Center)

24.       if (this.animationProperties.isExpandPageShow) {
25.         // 卡片展开态
26.         ExpandPage({ animationProperties: this.animationProperties })
27.       }
28.     }
29.     .key('rootStack')
30.     .enabled(this.animationProperties.isEnabled)
31.   }
32. }

33. @Component
34. struct PostItem {
35.   @Prop index: number
36.   @Link animationProperties: AnimationProperties;
37.   @State nodeController: PostNode | undefined = undefined;
38.   // 折叠时详细内容隐藏
39.   private showDetailContent: boolean = false;

40.   aboutToAppear(): void {
41.     this.nodeController = createPostNode(this.getUIContext(), this.index.toString(), this.showDetailContent);
42.     if (this.nodeController != undefined) {
43.       // 设置回调，当卡片从展开态回到折叠态时触发
44.       this.nodeController.setCallback(this.resetNode.bind(this));
45.     }
46.   }

47.   resetNode() {
48.     this.nodeController = getPostNode(this.index.toString());
49.   }

50.   build() {
51.     Stack() {
52.       NodeContainer(this.nodeController)
53.     }
54.     .width('100%')
55.     .height(100)
56.     .key(this.index.toString())
57.     .onClick(() => {
58.       if (this.nodeController != undefined) {
59.         // 卡片从折叠态节点下树
60.         this.nodeController.onRemove();
61.       }
62.       // 触发卡片从折叠到展开态的动画
63.       this.animationProperties.expandAnimation(this.index);
64.     })
65.   }
66. }

67. @Component
68. struct ExpandPage {
69.   @Link animationProperties: AnimationProperties;
70.   @State nodeController: PostNode | undefined = undefined;
71.   // 展开时详细内容出现
72.   private showDetailContent: boolean = true;

73.   aboutToAppear(): void {
74.     // 获取对应序号的卡片组件
75.     this.nodeController = getPostNode(this.animationProperties.curIndex.toString())
76.     // 更新为详细内容出现
77.     this.nodeController?.update(this.animationProperties.curIndex.toString(), this.showDetailContent)
78.   }

79.   build() {
80.     Stack() {
81.       NodeContainer(this.nodeController)
82.     }
83.     .width('100%')
84.     .height(this.animationProperties.changedHeight ? '100%' : 100)
85.     .translate({ x: this.animationProperties.translateX, y: this.animationProperties.translateY })
86.     .position({ x: this.animationProperties.positionX, y: this.animationProperties.positionY })
87.     .onClick(() => {
88.       this.getUIContext()?.animateTo({ curve: curves.springMotion(0.6, 0.9),
89.         onFinish: () => {
90.           if (this.nodeController != undefined) {
91.             // 执行回调，折叠态节点获取卡片组件
92.             this.nodeController.callCallback();
93.             // 当前展开态节点的卡片组件下树
94.             this.nodeController.onRemove();
95.           }
96.           // 卡片展开态节点下树
97.           this.animationProperties.isExpandPageShow = false;
98.           this.animationProperties.isEnabled = true;
99.         }
100.       }, () => {
101.         // 卡片从展开态回到折叠态
102.         this.animationProperties.isEnabled = false;
103.         this.animationProperties.translateX = 0;
104.         this.animationProperties.translateY = 0;
105.         this.animationProperties.changedHeight = false;
106.         // 更新为详细内容消失
107.         this.nodeController?.update(this.animationProperties.curIndex.toString(), false);
108.       })
109.     })
110.   }
111. }

112. class RectInfo {
113.   left: number = 0;
114.   top: number = 0;
115.   right: number = 0;
116.   bottom: number = 0;
117.   width: number = 0;
118.   height: number = 0;
119. }

120. // 封装的一镜到底动画类
121. @Observed
122. class AnimationProperties {
123.   public isExpandPageShow: boolean = false;
124.   // 控制组件是否响应点击事件
125.   public isEnabled: boolean = true;
126.   // 展开卡片的序号
127.   public curIndex: number = -1;
128.   public translateX: number = 0;
129.   public translateY: number = 0;
130.   public positionX: number = 0;
131.   public positionY: number = 0;
132.   public changedHeight: boolean = false;
133.   private calculatedTranslateX: number = 0;
134.   private calculatedTranslateY: number = 0;
135.   // 设置卡片展开后相对父组件的位置
136.   private expandTranslateX: number = 0;
137.   private expandTranslateY: number = 0;
138.   private uiContext: UIContext;

139.   constructor(uiContext: UIContext) {
140.     this.uiContext = uiContext
141.   }

142.   public expandAnimation(index: number): void {
143.     // 记录展开态卡片的序号
144.     if (index != undefined) {
145.       this.curIndex = index;
146.     }
147.     // 计算折叠态卡片相对父组件的位置
148.     this.calculateData(index.toString());
149.     // 展开态卡片上树
150.     this.isExpandPageShow = true;
151.     // 卡片展开的属性动画
152.     this.uiContext?.animateTo({ curve: curves.springMotion(0.6, 0.9)
153.     }, () => {
154.       this.translateX = this.calculatedTranslateX;
155.       this.translateY = this.calculatedTranslateY;
156.       this.changedHeight = true;
157.     })
158.   }

159.   // 获取需要跨节点迁移的组件的位置，及迁移前后节点的公共父节点的位置，用以计算做动画组件的动画参数
160.   public calculateData(key: string): void {
161.     let clickedImageInfo = this.getRectInfoById(this.uiContext, key);
162.     let rootStackInfo = this.getRectInfoById(this.uiContext, 'rootStack');
163.     this.positionX = this.uiContext.px2vp(clickedImageInfo.left - rootStackInfo.left);
164.     this.positionY = this.uiContext.px2vp(clickedImageInfo.top - rootStackInfo.top);
165.     this.calculatedTranslateX = this.uiContext.px2vp(rootStackInfo.left - clickedImageInfo.left) + this.expandTranslateX;
166.     this.calculatedTranslateY = this.uiContext.px2vp(rootStackInfo.top - clickedImageInfo.top) + this.expandTranslateY;
167.   }

168.   // 根据组件的id获取组件的位置信息
169.   private getRectInfoById(context: UIContext, id: string): RectInfo {
170.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

171.     if (!componentInfo) {
172.       throw Error('object is empty');
173.     }

174.     let rstRect: RectInfo = new RectInfo();
175.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
176.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
177.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
178.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
179.     rstRect.right =
180.     componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
181.     rstRect.bottom =
182.     componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
183.     rstRect.width = rstRect.right - rstRect.left;
184.     rstRect.height = rstRect.bottom - rstRect.top;

185.     return {
186.       left: rstRect.left,
187.       right: rstRect.right,
188.       top: rstRect.top,
189.       bottom: rstRect.bottom,
190.       width: rstRect.width,
191.       height: rstRect.height
192.     }
193.   }
194. }

195. // PostNode.ets
196. // 跨容器迁移能力
197. import { UIContext, curves, NodeController, BuilderNode, FrameNode } from '@kit.ArkUI';

198. class Data {
199.   item: string | null = null
200.   isExpand: boolean = false
201. }

202. @Builder
203. function PostBuilder(data: Data) {
204.   // 跨容器迁移组件置于@Builder内
205.   Column() {
206.       Row() {
207.         Row()
208.           .backgroundColor(Color.Pink)
209.           .borderRadius(20)
210.           .width(80)
211.           .height(80)

212.         Column() {
213.           Text('点击展开 Item ' + data.item)
214.             .fontSize(20)
215.           Text('共享元素转场')
216.             .fontSize(12)
217.             .fontColor(0x909399)
218.         }
219.         .alignItems(HorizontalAlign.Start)
220.         .justifyContent(FlexAlign.SpaceAround)
221.         .margin({ left: 10 })
222.         .height(80)
223.       }
224.       .width('90%')
225.       .height(100)
226.       // 展开后显示细节内容
227.       if (data.isExpand) {
228.         Row() {
229.           Text('展开态')
230.             .fontSize(28)
231.             .fontColor(0x909399)
232.             .textAlign(TextAlign.Center)
233.             .transition(TransitionEffect.OPACITY.animation({ curve: curves.springMotion(0.6, 0.9) }))
234.         }
235.         .width('90%')
236.         .justifyContent(FlexAlign.Center)
237.       }
238.     }
239.     .width('90%')
240.     .height('100%')
241.     .alignItems(HorizontalAlign.Center)
242.     .borderRadius(10)
243.     .margin({ top: 15 })
244.     .backgroundColor(Color.White)
245.     .shadow({
246.       radius: 20,
247.       color: 0x909399,
248.       offsetX: 20,
249.       offsetY: 10
250.     })
251. }

252. class __InternalValue__ {
253.   flag:boolean =false;
254. };

255. export class PostNode extends NodeController {
256.   private node: BuilderNode<Data[]> | null = null;
257.   private isRemove: __InternalValue__ = new __InternalValue__();
258.   private callback: Function | undefined = undefined
259.   private data: Data | null = null

260.   makeNode(uiContext: UIContext): FrameNode | null {
261.     if(this.isRemove.flag == true){
262.       return null;
263.     }
264.     if (this.node != null) {
265.       return this.node.getFrameNode();
266.     }

267.     return null;
268.   }

269.   init(uiContext: UIContext, id: string, isExpand: boolean) {
270.     if (this.node != null) {
271.       return;
272.     }
273.     // 创建节点，需要uiContext
274.     this.node = new BuilderNode(uiContext)
275.     // 创建离线组件
276.     this.data = { item: id, isExpand: isExpand }
277.     this.node.build(wrapBuilder<Data[]>(PostBuilder), this.data)
278.   }

279.   update(id: string, isExpand: boolean) {
280.     if (this.node !== null) {
281.       // 调用update进行更新。
282.       this.data = { item: id, isExpand: isExpand }
283.       this.node.update(this.data);
284.     }
285.   }

286.   setCallback(callback: Function | undefined) {
287.     this.callback = callback
288.   }

289.   callCallback() {
290.     if (this.callback != undefined) {
291.       this.callback();
292.     }
293.   }

294.   onRemove(){
295.     this.isRemove.flag = true;
296.     // 组件迁移出节点时触发重建
297.     this.rebuild();
298.     this.isRemove.flag = false;
299.   }
300. }

301. let gNodeMap: Map<string, PostNode | undefined> = new Map();

302. export const createPostNode =
303.   (uiContext: UIContext, id: string, isExpand: boolean): PostNode | undefined => {
304.     let node = new PostNode();
305.     node.init(uiContext, id, isExpand);
306.     gNodeMap.set(id, node);
307.     return node;
308.   }

309. export const getPostNode = (id: string): PostNode | undefined => {
310.   if (!gNodeMap.has(id)) {
311.     return undefined
312.   }
313.   return gNodeMap.get(id);
314. }

315. export const deleteNode = (id: string) => {
316.   gNodeMap.delete(id)
317. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.37240076024957776115084098912993:50001231000000:2800:B9E792E963226DA984B2911D76846EF0920C29BA99A6C95FAE354FC23729B429.gif)

### 结合Navigation使用

可以利用[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)的自定义导航转场动画能力（[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)，可参考Navigation[示例3](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B3%E8%AE%BE%E7%BD%AE%E5%8F%AF%E4%BA%A4%E4%BA%92%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB)）实现一镜到底动效。共享元素转场期间，组件由消失页面迁移至出现页面。

以展开收起缩略图的场景为例，实现步骤为：

- 通过customNavContentTransition配置PageOne与PageTwo的自定义导航转场动画。
    
- 自定义的共享元素转场效果由属性动画实现，具体实现方式为抓取页面内组件相对窗口的位置信息从而正确匹配组件在PageOne与PageTwo的位置、缩放等，即动画开始和结束的属性信息。
    
- 点击缩略图后共享元素组件从PageOne被迁移至PageTwo，随后触发由PageOne至PageTwo的自定义转场动画，即PageTwo的共享元素组件从原来的缩略图状态做动画到全屏状态。
    
- 由全屏状态返回到缩略图时，触发由PageTwo至PageOne的自定义转场动画，即PageTwo的共享元素组件从全屏状态做动画到原PageOne的缩略图状态，转场结束后共享元素组件从PageTwo被迁移回PageOne。
    

1. ├──entry/src/main/ets                 // 代码区
2. │  ├──CustomTransition
3. │  │  ├──AnimationProperties.ets      // 一镜到底转场动画封装
4. │  │  └──CustomNavigationUtils.ets    // Navigation自定义转场动画配置
5. │  ├──entryability
6. │  │  └──EntryAbility.ets             // 程序入口类
7. │  ├──NodeContainer
8. │  │  └──CustomComponent.ets          // 自定义占位节点
9. │  ├──pages
10. │  │  ├──Index.ets                    // 导航页面
11. │  │  ├──PageOne.ets                  // 缩略图页面
12. │  │  └──PageTwo.ets                  // 全屏展开页面
13. │  └──utils
14. │     ├──ComponentAttrUtils.ets       // 组件位置获取
15. │     └──WindowUtils.ets              // 窗口信息
16. └──entry/src/main/resources           // 资源文件

17. // Index.ets
18. import { AnimateCallback, CustomTransition } from '../CustomTransition/CustomNavigationUtils';

19. const TAG: string = 'Index';

20. @Entry
21. @Component
22. struct Index {
23.   private pageInfos: NavPathStack = new NavPathStack();
24.   // 允许进行自定义转场的页面名称
25.   private allowedCustomTransitionFromPageName: string[] = ['PageOne'];
26.   private allowedCustomTransitionToPageName: string[] = ['PageTwo'];

27.   aboutToAppear(): void {
28.     this.pageInfos.pushPath({ name: 'PageOne' });
29.   }

30.   private isCustomTransitionEnabled(fromName: string, toName: string): boolean {
31.     // 点击和返回均需要进行自定义转场，因此需要分别判断
32.     if ((this.allowedCustomTransitionFromPageName.includes(fromName)
33.       && this.allowedCustomTransitionToPageName.includes(toName))
34.       || (this.allowedCustomTransitionFromPageName.includes(toName)
35.         && this.allowedCustomTransitionToPageName.includes(fromName))) {
36.       return true;
37.     }
38.     return false;
39.   }

40.   build() {
41.     Navigation(this.pageInfos)
42.       .hideNavBar(true)
43.       .customNavContentTransition((from: NavContentInfo, to: NavContentInfo, operation: NavigationOperation) => {
44.         if ((!from || !to) || (!from.name || !to.name)) {
45.           return undefined;
46.         }

47.         // 通过from和to的name对自定义转场路由进行管控
48.         if (!this.isCustomTransitionEnabled(from.name, to.name)) {
49.           return undefined;
50.         }

51.         // 需要对转场页面是否注册了animation进行判断，来决定是否进行自定义转场
52.         let fromParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(from.index);
53.         let toParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(to.index);
54.         if (!fromParam.animation || !toParam.animation) {
55.           return undefined;
56.         }

57.         // 一切判断完成后，构造customAnimation给系统侧调用，执行自定义转场动画
58.         let customAnimation: NavigationAnimatedTransition = {
59.           onTransitionEnd: (isSuccess: boolean) => {
60.             console.info(TAG, `current transition result is ${isSuccess}`);
61.           },
62.           timeout: 2000,
63.           transition: (transitionProxy: NavigationTransitionProxy) => {
64.             console.info(TAG, 'trigger transition callback');
65.             if (fromParam.animation) {
66.               fromParam.animation(operation == NavigationOperation.PUSH, true, transitionProxy);
67.             }
68.             if (toParam.animation) {
69.               toParam.animation(operation == NavigationOperation.PUSH, false, transitionProxy);
70.             }
71.           }
72.         };
73.         return customAnimation;
74.       })
75.   }
76. }

77. // PageOne.ets
78. import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
79. import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
80. import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
81. import { WindowUtils } from '../utils/WindowUtils';

82. @Builder
83. export function PageOneBuilder() {
84.   PageOne();
85. }

86. @Component
87. export struct PageOne {
88.   private pageInfos: NavPathStack = new NavPathStack();
89.   private pageId: number = -1;
90.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

91.   aboutToAppear(): void {
92.     let node = getMyNode();
93.     if (node == undefined) {
94.       // 新建自定义节点
95.       createMyNode(this.getUIContext());
96.     }
97.     this.myNodeController = getMyNode();
98.   }

99.   private doFinishTransition(): void {
100.     // PageTwo结束转场时将节点从PageTwo迁移回PageOne
101.     this.myNodeController = getMyNode();
102.   }

103.   private registerCustomTransition(): void {
104.     // 注册自定义动画协议
105.     CustomTransition.getInstance().registerNavParam(this.pageId,
106.       (isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {}, 500);
107.   }

108.   private onCardClicked(): void {
109.     let cardItemInfo: RectInfoInPx =
110.       ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), 'card');
111.     let param: Record<string, Object> = {};
112.     param['cardItemInfo'] = cardItemInfo;
113.     param['doDefaultTransition'] = (myController: MyNodeController) => {
114.       this.doFinishTransition()
115.     };
116.     this.pageInfos.pushPath({ name: 'PageTwo', param: param });
117.     // 自定义节点从PageOne下树
118.     if (this.myNodeController != undefined) {
119.       (this.myNodeController as MyNodeController).onRemove();
120.     }
121.   }

122.   build() {
123.     NavDestination() {
124.       Stack() {
125.         Column({ space: 20 }) {
126.           Row({ space: 10 }) {
127.             // 图片使用Resource资源，需用户自定义
128.             Image($r("app.media.avatar"))
129.               .size({ width: 50, height: 50 })
130.               .borderRadius(25)
131.               .clip(true)

132.             Text('Alice')
133.           }
134.           .justifyContent(FlexAlign.Start)

135.           Text('你好世界')

136.           NodeContainer(this.myNodeController)
137.             .size({ width: 320, height: 250 })
138.             .onClick(() => {
139.               this.onCardClicked()
140.             })
141.         }
142.         .alignItems(HorizontalAlign.Start)
143.         .margin(30)
144.       }
145.     }
146.     .onReady((context: NavDestinationContext) => {
147.       this.pageInfos = context.pathStack;
148.       this.pageId = this.pageInfos.getAllPathName().length - 1;
149.       this.registerCustomTransition();
150.     })
151.     .onDisAppear(() => {
152.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
153.       // 自定义节点从PageOne下树
154.       if (this.myNodeController != undefined) {
155.         (this.myNodeController as MyNodeController).onRemove();
156.       }
157.     })
158.   }
159. }

160. // PageTwo.ets
161. import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
162. import { AnimationProperties } from '../CustomTransition/AnimationProperties';
163. import { RectInfoInPx } from '../utils/ComponentAttrUtils';
164. import { getMyNode, MyNodeController } from '../NodeContainer/CustomComponent';

165. @Builder
166. export function PageTwoBuilder() {
167.   PageTwo();
168. }

169. @Component
170. export struct PageTwo {
171.   @State pageInfos: NavPathStack = new NavPathStack();
172.   @State animationProperties: AnimationProperties = new AnimationProperties(this.getUIContext());
173.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

174.   private pageId: number = -1;

175.   private shouldDoDefaultTransition: boolean = false;
176.   private prePageDoFinishTransition: () => void = () => {};
177.   private cardItemInfo: RectInfoInPx = new RectInfoInPx();

178.   @StorageProp('windowSizeChanged') @Watch('unRegisterNavParam') windowSizeChangedTime: number = 0;
179.   @StorageProp('onConfigurationUpdate') @Watch('unRegisterNavParam') onConfigurationUpdateTime: number = 0;

180.   aboutToAppear(): void {
181.     // 迁移自定义节点至当前页面
182.     this.myNodeController = getMyNode();
183.   }

184.   private unRegisterNavParam(): void {
185.     this.shouldDoDefaultTransition = true;
186.   }

187.   private onBackPressed(): boolean {
188.     if (this.shouldDoDefaultTransition) {
189.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
190.       this.pageInfos.pop();
191.       this.prePageDoFinishTransition();
192.       this.shouldDoDefaultTransition = false;
193.       return true;
194.     }
195.     this.pageInfos.pop();
196.     return true;
197.   }

198.   build() {
199.     NavDestination() {
200.       // Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
201.       Stack({ alignContent: Alignment.TopStart }) {
202.         Stack({ alignContent: Alignment.TopStart }) {
203.           Column({space: 20}) {
204.             NodeContainer(this.myNodeController)
205.             if (this.animationProperties.showDetailContent)
206.               Text('展开态内容')
207.                 .fontSize(20)
208.                 .transition(TransitionEffect.OPACITY)
209.                 .margin(30)
210.           }
211.           .alignItems(HorizontalAlign.Start)
212.         }
213.         .position({ y: this.animationProperties.positionValue })
214.       }
215.       .scale({ x: this.animationProperties.scaleValue, y: this.animationProperties.scaleValue })
216.       .translate({ x: this.animationProperties.translateX, y: this.animationProperties.translateY })
217.       .width(this.animationProperties.clipWidth)
218.       .height(this.animationProperties.clipHeight)
219.       .borderRadius(this.animationProperties.radius)
220.       // expandSafeArea使得Stack做沉浸式效果，向上扩到状态栏，向下扩到导航条
221.       .expandSafeArea([SafeAreaType.SYSTEM])
222.       // 对高度进行裁切
223.       .clip(true)
224.     }
225.     .backgroundColor(this.animationProperties.navDestinationBgColor)
226.     .hideTitleBar(true)
227.     .onReady((context: NavDestinationContext) => {
228.       this.pageInfos = context.pathStack;
229.       this.pageId = this.pageInfos.getAllPathName().length - 1;
230.       let param = context.pathInfo?.param as Record<string, Object>;
231.       this.prePageDoFinishTransition = param['doDefaultTransition'] as () => void;
232.       this.cardItemInfo = param['cardItemInfo'] as RectInfoInPx;
233.       CustomTransition.getInstance().registerNavParam(this.pageId,
234.         (isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {
235.           this.animationProperties.doAnimation(
236.             this.cardItemInfo, isPush, isExit, transitionProxy, 0,
237.             this.prePageDoFinishTransition, this.myNodeController);
238.         }, 500);
239.     })
240.     .onBackPressed(() => {
241.       return this.onBackPressed();
242.     })
243.     .onDisAppear(() => {
244.       CustomTransition.getInstance().unRegisterNavParam(this.pageId);
245.     })
246.   }
247. }

248. // CustomNavigationUtils.ets
249. // 配置Navigation自定义转场动画
250. export interface AnimateCallback {
251.   animation: ((isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void | undefined)
252.     | undefined;
253.   timeout: (number | undefined) | undefined;
254. }

255. const customTransitionMap: Map<number, AnimateCallback> = new Map();

256. export class CustomTransition {
257.   private constructor() {};

258.   static delegate = new CustomTransition();

259.   static getInstance() {
260.     return CustomTransition.delegate;
261.   }

262.   // 注册页面的动画回调，name是注册页面的动画的回调
263.   // animationCallback是需要执行的动画内容，timeout是转场结束的超时时间
264.   registerNavParam(
265.     name: number,
266.     animationCallback: (operation: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void,
267.     timeout: number): void {
268.     if (customTransitionMap.has(name)) {
269.       let param = customTransitionMap.get(name);
270.       if (param != undefined) {
271.         param.animation = animationCallback;
272.         param.timeout = timeout;
273.         return;
274.       }
275.     }
276.     let params: AnimateCallback = { timeout: timeout, animation: animationCallback };
277.     customTransitionMap.set(name, params);
278.   }

279.   unRegisterNavParam(name: number): void {
280.     customTransitionMap.delete(name);
281.   }

282.   getAnimateParam(name: number): AnimateCallback {
283.     let result: AnimateCallback = {
284.       animation: customTransitionMap.get(name)?.animation,
285.       timeout: customTransitionMap.get(name)?.timeout,
286.     };
287.     return result;
288.   }
289. }

290. // 工程配置文件module.json5中配置 {"routerMap": "$profile:route_map"}
291. // route_map.json
292. {
293.   "routerMap": [
294.     {
295.       "name": "PageOne",
296.       "pageSourceFile": "src/main/ets/pages/PageOne.ets",
297.       "buildFunction": "PageOneBuilder"
298.     },
299.     {
300.       "name": "PageTwo",
301.       "pageSourceFile": "src/main/ets/pages/PageTwo.ets",
302.       "buildFunction": "PageTwoBuilder"
303.     }
304.   ]
305. }

306. // AnimationProperties.ets
307. // 一镜到底转场动画封装
308. import { curves, UIContext } from '@kit.ArkUI';
309. import { RectInfoInPx } from '../utils/ComponentAttrUtils';
310. import { WindowUtils } from '../utils/WindowUtils';
311. import { MyNodeController } from '../NodeContainer/CustomComponent';

312. const TAG: string = 'AnimationProperties';

313. const DEVICE_BORDER_RADIUS: number = 34;

314. // 将自定义一镜到底转场动画进行封装，其他界面也需要做自定义一镜到底转场的话，可以直接复用，减少工作量
315. @Observed
316. export class AnimationProperties {
317.   public navDestinationBgColor: ResourceColor = Color.Transparent;
318.   public translateX: number = 0;
319.   public translateY: number = 0;
320.   public scaleValue: number = 1;
321.   public clipWidth: Dimension = 0;
322.   public clipHeight: Dimension = 0;
323.   public radius: number = 0;
324.   public positionValue: number = 0;
325.   public showDetailContent: boolean = false;
326.   private uiContext: UIContext;

327.   constructor(uiContext: UIContext) {
328.     this.uiContext = uiContext
329.   }

330.   public doAnimation(cardItemInfo_px: RectInfoInPx, isPush: boolean, isExit: boolean,
331.                      transitionProxy: NavigationTransitionProxy, extraTranslateValue: number, prePageOnFinish: (index: MyNodeController) => void, myNodeController: MyNodeController | undefined): void {
332.     // 首先计算卡片的宽高与窗口宽高的比例
333.     let widthScaleRatio = cardItemInfo_px.width / WindowUtils.windowWidth_px;
334.     let heightScaleRatio = cardItemInfo_px.height / WindowUtils.windowHeight_px;
335.     let isUseWidthScale = widthScaleRatio > heightScaleRatio;
336.     let initScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;

337.     let initTranslateX: number = 0;
338.     let initTranslateY: number = 0;
339.     let initClipWidth: Dimension = 0;
340.     let initClipHeight: Dimension = 0;
341.     // 使得PageTwo卡片向上扩到状态栏
342.     let initPositionValue: number = -this.uiContext.px2vp(WindowUtils.topAvoidAreaHeight_px + extraTranslateValue);

343.     if (isUseWidthScale) {
344.       initTranslateX = this.uiContext.px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px - cardItemInfo_px.width) / 2);
345.       initClipWidth = '100%';
346.       initClipHeight = this.uiContext.px2vp((cardItemInfo_px.height) / initScale);
347.       initTranslateY = this.uiContext.px2vp(cardItemInfo_px.top - ((this.uiContext.vp2px(initClipHeight) - this.uiContext.vp2px(initClipHeight) * initScale) / 2));
348.     } else {
349.       initTranslateY = this.uiContext.px2vp(cardItemInfo_px.top - (WindowUtils.windowHeight_px - cardItemInfo_px.height) / 2);
350.       initClipHeight = '100%';
351.       initClipWidth = this.uiContext.px2vp((cardItemInfo_px.width) / initScale);
352.       initTranslateX = this.uiContext.px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px / 2 - cardItemInfo_px.width / 2));
353.     }

354.     // 转场动画开始前通过计算scale、translate、position和clip height & width，确定节点迁移前后位置一致
355.     console.info(TAG, 'initScale: ' + initScale + ' initTranslateX ' + initTranslateX +
356.     ' initTranslateY ' + initTranslateY + ' initClipWidth ' + initClipWidth +
357.     ' initClipHeight ' + initClipHeight + ' initPositionValue ' + initPositionValue);
358.     // 转场至新页面
359.     if (isPush && !isExit) {
360.       this.scaleValue = initScale;
361.       this.translateX = initTranslateX;
362.       this.clipWidth = initClipWidth;
363.       this.clipHeight = initClipHeight;
364.       this.translateY = initTranslateY;
365.       this.positionValue = initPositionValue;

366.       this.uiContext?.animateTo({
367.         curve: curves.interpolatingSpring(0, 1, 328, 36),
368.         onFinish: () => {
369.           if (transitionProxy) {
370.             transitionProxy.finishTransition();
371.           }
372.         }
373.       }, () => {
374.         this.scaleValue = 1.0;
375.         this.translateX = 0;
376.         this.translateY = 0;
377.         this.clipWidth = '100%';
378.         this.clipHeight = '100%';
379.         // 页面圆角与系统圆角一致
380.         this.radius = DEVICE_BORDER_RADIUS;
381.         this.showDetailContent = true;
382.       })

383.       this.uiContext?.animateTo({
384.         duration: 100,
385.         curve: Curve.Sharp,
386.       }, () => {
387.         // 页面由透明逐渐变为设置背景色
388.         this.navDestinationBgColor = '#00ffffff';
389.       })

390.       // 返回旧页面
391.     } else if (!isPush && isExit) {

392.       this.uiContext?.animateTo({
393.         duration: 350,
394.         curve: Curve.EaseInOut,
395.         onFinish: () => {
396.           if (transitionProxy) {
397.             transitionProxy.finishTransition();
398.           }
399.           prePageOnFinish(myNodeController);
400.           // 自定义节点从PageTwo下树
401.           if (myNodeController != undefined) {
402.             (myNodeController as MyNodeController).onRemove();
403.           }
404.         }
405.       }, () => {
406.         this.scaleValue = initScale;
407.         this.translateX = initTranslateX;
408.         this.translateY = initTranslateY;
409.         this.radius = 0;
410.         this.clipWidth = initClipWidth;
411.         this.clipHeight = initClipHeight;
412.         this.showDetailContent = false;
413.       })

414.       this.uiContext?.animateTo({
415.         duration: 200,
416.         delay: 150,
417.         curve: Curve.Friction,
418.       }, () => {
419.         this.navDestinationBgColor = Color.Transparent;
420.       })
421.     }
422.   }
423. }

424. // ComponentAttrUtils.ets
425. // 获取组件相对窗口的位置
426. import { componentUtils, UIContext } from '@kit.ArkUI';
427. import { JSON } from '@kit.ArkTS';

428. export class ComponentAttrUtils {
429.   // 根据组件的id获取组件的位置信息
430.   public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
431.     if (!context || !id) {
432.       throw Error('object is empty');
433.     }
434.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

435.     if (!componentInfo) {
436.       throw Error('object is empty');
437.     }

438.     let rstRect: RectInfoInPx = new RectInfoInPx();
439.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
440.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
441.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
442.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
443.     rstRect.right =
444.       componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
445.     rstRect.bottom =
446.       componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
447.     rstRect.width = rstRect.right - rstRect.left;
448.     rstRect.height = rstRect.bottom - rstRect.top;
449.     return {
450.       left: rstRect.left,
451.       right: rstRect.right,
452.       top: rstRect.top,
453.       bottom: rstRect.bottom,
454.       width: rstRect.width,
455.       height: rstRect.height
456.     }
457.   }
458. }

459. export class RectInfoInPx {
460.   left: number = 0;
461.   top: number = 0;
462.   right: number = 0;
463.   bottom: number = 0;
464.   width: number = 0;
465.   height: number = 0;
466. }

467. export class RectJson {
468.   $rect: Array<number> = [];
469. }

470. // WindowUtils.ets
471. // 窗口信息
472. import { window } from '@kit.ArkUI';

473. export class WindowUtils {
474.   public static window: window.Window;
475.   public static windowWidth_px: number;
476.   public static windowHeight_px: number;
477.   public static topAvoidAreaHeight_px: number;
478.   public static navigationIndicatorHeight_px: number;
479. }

480. // EntryAbility.ets
481. // 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取

482. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
483. import { hilog } from '@kit.PerformanceAnalysisKit';
484. import { display, window } from '@kit.ArkUI';
485. import { WindowUtils } from '../utils/WindowUtils';

486. const TAG: string = 'EntryAbility';

487. export default class EntryAbility extends UIAbility {
488.   private currentBreakPoint: string = '';

489.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
490.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
491.   }

492.   onDestroy(): void {
493.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
494.   }

495.   onWindowStageCreate(windowStage: window.WindowStage): void {
496.     // Main window is created, set main page for this ability
497.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

498.     // 获取窗口宽高
499.     WindowUtils.window = windowStage.getMainWindowSync();
500.     WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
501.     WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;

502.     this.updateBreakpoint(WindowUtils.windowWidth_px);

503.     // 获取上方避让区(状态栏等)高度
504.     let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
505.     WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;

506.     // 获取导航条高度
507.     let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
508.     WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;

509.     hilog.info(0x0000, TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
510.     WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);

511.     // 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
512.     try {
513.       WindowUtils.window.on('windowSizeChange', (data) => {
514.         hilog.info(0x0000, TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
515.         WindowUtils.windowWidth_px = data.width;
516.         WindowUtils.windowHeight_px = data.height;
517.         this.updateBreakpoint(data.width);
518.         AppStorage.setOrCreate('windowSizeChanged', Date.now())
519.       })

520.       WindowUtils.window.on('avoidAreaChange', (data) => {
521.         if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
522.           let topRectHeight = data.area.topRect.height;
523.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
524.           WindowUtils.topAvoidAreaHeight_px = topRectHeight;
525.         } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
526.           let bottomRectHeight = data.area.bottomRect.height;
527.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
528.           WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
529.         }
530.       })
531.     } catch (exception) {
532.       hilog.error(0x0000, TAG, `register failed. code: ${exception.code}, message: ${exception.message}`);
533.     }

534.     windowStage.loadContent('pages/Index', (err) => {
535.       if (err.code) {
536.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
537.         return;
538.       }
539.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
540.     });
541.   }

542.   updateBreakpoint(width: number) {
543.     let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
544.     let newBreakPoint: string = '';
545.     if (windowWidthVp < 400) {
546.       newBreakPoint = 'xs';
547.     } else if (windowWidthVp < 600) {
548.       newBreakPoint = 'sm';
549.     } else if (windowWidthVp < 800) {
550.       newBreakPoint = 'md';
551.     } else {
552.       newBreakPoint = 'lg';
553.     }
554.     if (this.currentBreakPoint !== newBreakPoint) {
555.       this.currentBreakPoint = newBreakPoint;
556.       // 使用状态变量记录当前断点值
557.       AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
558.     }
559.   }

560.   onWindowStageDestroy(): void {
561.     // Main window is destroyed, release UI related resources
562.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
563.   }

564.   onForeground(): void {
565.     // Ability has brought to foreground
566.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
567.   }

568.   onBackground(): void {
569.     // Ability has back to background
570.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
571.   }
572. }

573. // CustomComponent.ets
574. // 自定义占位节点，跨容器迁移能力
575. import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';

576. @Builder
577. function CardBuilder() {
578.   // 图片使用Resource资源，需用户自定义
579.   Image($r("app.media.card"))
580.     .width('100%')
581.     .id('card')
582. }

583. export class MyNodeController extends NodeController {
584.   private CardNode: BuilderNode<[]> | null = null;
585.   private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
586.   private needCreate: boolean = false;
587.   private isRemove: boolean = false;

588.   constructor(create: boolean) {
589.     super();
590.     this.needCreate = create;
591.   }

592.   makeNode(uiContext: UIContext): FrameNode | null {
593.     if(this.isRemove == true){
594.       return null;
595.     }
596.     if (this.needCreate && this.CardNode == null) {
597.       this.CardNode = new BuilderNode(uiContext);
598.       this.CardNode.build(this.wrapBuilder)
599.     }
600.     if (this.CardNode == null) {
601.       return null;
602.     }
603.     return this.CardNode!.getFrameNode()!;
604.   }

605.   getNode(): BuilderNode<[]> | null {
606.     return this.CardNode;
607.   }

608.   setNode(node: BuilderNode<[]> | null) {
609.     this.CardNode = node;
610.     this.rebuild();
611.   }

612.   onRemove() {
613.     this.isRemove = true;
614.     this.rebuild();
615.     this.isRemove = false;
616.   }

617.   init(uiContext: UIContext) {
618.     this.CardNode = new BuilderNode(uiContext);
619.     this.CardNode.build(this.wrapBuilder)
620.   }
621. }

622. let myNode: MyNodeController | undefined;

623. export const createMyNode =
624.   (uiContext: UIContext) => {
625.     myNode = new MyNodeController(false);
626.     myNode.init(uiContext);
627.   }

628. export const getMyNode = (): MyNodeController | undefined => {
629.   return myNode;
630. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.91962943741384209044607278822523:50001231000000:2800:8DFAE46CA0C1C9EEEA6A76B7605F719C3543BF27EC4EE3857F1BF851396FE47F.gif)

### 结合BindSheet使用

想实现半模态转场（[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#bindsheet)）的同时，组件从初始界面做一镜到底动画到半模态页面的效果，可以使用这样的设计思路。将[SheetOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#sheetoptions)中的mode设置为SheetMode.EMBEDDED，该模式下新起的页面可以覆盖在半模态弹窗上，页面返回后该半模态依旧存在，半模态面板内容不丢失。在半模态转场的同时设置一全模态转场（[bindContentCover](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-modal-transition#bindcontentcover)）页面无转场出现，该页面仅有需要做共享元素转场的组件，通过属性动画，展示组件从初始界面至半模态页面的一镜到底动效，并在动画结束时关闭页面，并将该组件迁移至半模态页面。

以点击图片展开半模态页的场景为例，实现步骤为：

- 在初始界面挂载半模态转场和全模态转场两个页面，半模态页按需布局，全模态页面仅放置一镜到底动效需要的组件，抓取布局信息，使其初始位置为初始界面图片的位置。点击初始界面图片时，同时触发半模态和全模态页面出现，因设置为SheetMode.EMBEDDED模式，此时全模态页面层级最高。
    
- 设置不可见的占位图片置于半模态页上，作为一镜到底动效结束时图片的终止位置。利用[布局回调](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-inspector)监听该占位图片布局完成的时候，此时执行回调抓取占位图片的位置信息，随后全模态页面上的图片利用属性动画开始进行共享元素转场。
    
- 全模态页面的动画结束时触发结束回调，关闭全模态页面，将共享元素图片的节点迁移至半模态页面，替换占位图片。
    
- 需注意，半模态页面的弹起高度不同，其页面起始位置也有所不同，而全模态则是全屏显示，两者存在一高度差，做一镜到底动画时，需要计算差值并进行修正，具体可见demo。
    
- 还可以配合一镜到底动画，给初始界面图片也增加一个从透明到出现的动画，使得动效更为流畅。
    

1. ├──entry/src/main/ets                 // 代码区
2. │  ├──entryability
3. │  │  └──EntryAbility.ets             // 程序入口类
4. │  ├──NodeContainer
5. │  │  └──CustomComponent.ets          // 自定义占位节点
6. │  ├──pages
7. │  │  └──Index.ets                    // 进行共享元素转场的主页面
8. │  └──utils
9. │     ├──ComponentAttrUtils.ets       // 组件位置获取
10. │     └──WindowUtils.ets              // 窗口信息
11. └──entry/src/main/resources           // 资源文件

12. // index.ets
13. import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
14. import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
15. import { WindowUtils } from '../utils/WindowUtils';
16. import { inspector } from '@kit.ArkUI'

17. class AnimationInfo {
18.   scale: number = 0;
19.   translateX: number = 0;
20.   translateY: number = 0;
21.   clipWidth: Dimension = 0;
22.   clipHeight: Dimension = 0;
23. }

24. @Entry
25. @Component
26. struct Index {
27.   @State isShowSheet: boolean = false;
28.   @State isShowImage: boolean = false;
29.   @State isShowOverlay: boolean = false;
30.   @State isAnimating: boolean = false;
31.   @State isEnabled: boolean = true;

32.   @State scaleValue: number = 0;
33.   @State translateX: number = 0;
34.   @State translateY: number = 0;
35.   @State clipWidth: Dimension = 0;
36.   @State clipHeight: Dimension = 0;
37.   @State radius: number = 0;
38.   // 原图的透明度
39.   @State opacityDegree: number = 1;

40.   // 抓取照片原位置信息
41.   private originInfo: AnimationInfo = new AnimationInfo;
42.   // 抓取照片在半模态页上位置信息
43.   private targetInfo: AnimationInfo = new AnimationInfo;
44.   // 半模态高度
45.   private bindSheetHeight: number = 450;
46.   // 半模态上图片圆角
47.   private sheetRadius: number = 20;

48.   // 设置半模态上图片的布局监听
49.   listener:inspector.ComponentObserver = this.getUIContext().getUIInspector().createComponentObserver('target');
50.   aboutToAppear(): void {
51.     // 设置半模态上图片的布局完成回调
52.     let onLayoutComplete:()=>void=():void=>{
53.       // 目标图片布局完成时抓取布局信息
54.       this.targetInfo = this.calculateData('target');
55.       // 仅半模态正确布局且此时无动画时触发一镜到底动画
56.       if (this.targetInfo.scale != 0 && this.targetInfo.clipWidth != 0 && this.targetInfo.clipHeight != 0 && !this.isAnimating) {
57.         this.isAnimating = true;
58.         // 用于一镜到底的模态页的属性动画
59.         this.getUIContext()?.animateTo({
60.           duration: 1000,
61.           curve: Curve.Friction,
62.           onFinish: () => {
63.             // 模态转场页（overlay）上的自定义节点下树
64.             this.isShowOverlay = false;
65.             // 半模态上的自定义节点上树，由此完成节点迁移
66.             this.isShowImage = true;
67.           }
68.         }, () => {
69.           this.scaleValue = this.targetInfo.scale;
70.           this.translateX = this.targetInfo.translateX;
71.           this.clipWidth = this.targetInfo.clipWidth;
72.           this.clipHeight = this.targetInfo.clipHeight;
73.           // 修正因半模态高度和缩放导致的高度差
74.           this.translateY = this.targetInfo.translateY +
75.             (this.getUIContext().px2vp(WindowUtils.windowHeight_px) - this.bindSheetHeight
76.               - this.getUIContext().px2vp(WindowUtils.navigationIndicatorHeight_px) - this.getUIContext().px2vp(WindowUtils.topAvoidAreaHeight_px));
77.           // 修正因缩放导致的圆角差异
78.           this.radius = this.sheetRadius / this.scaleValue
79.         })
80.         // 原图从透明到出现的动画
81.         this.getUIContext()?.animateTo({
82.           duration: 2000,
83.           curve: Curve.Friction,
84.         }, () => {
85.           this.opacityDegree = 1;
86.         })
87.       }
88.     }
89.     // 打开布局监听
90.     this.listener.on('layout', onLayoutComplete)
91.   }

92.   // 获取对应id的组件相对窗口左上角的属性
93.   calculateData(id: string): AnimationInfo {
94.     let itemInfo: RectInfoInPx =
95.       ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), id);
96.     // 首先计算图片的宽高与窗口宽高的比例
97.     let widthScaleRatio = itemInfo.width / WindowUtils.windowWidth_px;
98.     let heightScaleRatio = itemInfo.height / WindowUtils.windowHeight_px;
99.     let isUseWidthScale = widthScaleRatio > heightScaleRatio;
100.     let itemScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;
101.     let itemTranslateX: number = 0;
102.     let itemClipWidth: Dimension = 0;
103.     let itemClipHeight: Dimension = 0;
104.     let itemTranslateY: number = 0;

105.     if (isUseWidthScale) {
106.       itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px - itemInfo.width) / 2);
107.       itemClipWidth = '100%';
108.       itemClipHeight = this.getUIContext().px2vp((itemInfo.height) / itemScale);
109.       itemTranslateY = this.getUIContext().px2vp(itemInfo.top - ((this.getUIContext().vp2px(itemClipHeight) - this.getUIContext().vp2px(itemClipHeight) * itemScale) / 2));
110.     } else {
111.       itemTranslateY = this.getUIContext().px2vp(itemInfo.top - (WindowUtils.windowHeight_px - itemInfo.height) / 2);
112.       itemClipHeight = '100%';
113.       itemClipWidth = this.getUIContext().px2vp((itemInfo.width) / itemScale);
114.       itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px / 2 - itemInfo.width / 2));
115.     }

116.     return {
117.       scale: itemScale,
118.       translateX: itemTranslateX ,
119.       translateY: itemTranslateY,
120.       clipWidth: itemClipWidth,
121.       clipHeight: itemClipHeight,
122.     }
123.   }

124.   // 照片页
125.   build() {
126.     Column() {
127.       Text('照片')
128.         .textAlign(TextAlign.Start)
129.         .width('100%')
130.         .fontSize(30)
131.         .padding(20)
132.       // 图片使用Resource资源，需用户自定义
133.       Image($r("app.media.flower"))
134.         .opacity(this.opacityDegree)
135.         .width('90%')
136.         .id('origin')// 挂载半模态页
137.         .enabled(this.isEnabled)
138.         .onClick(() => {
139.           // 获取原始图像的位置信息，将模态页上图片移动缩放至该位置
140.           this.originInfo = this.calculateData('origin');
141.           this.scaleValue = this.originInfo.scale;
142.           this.translateX = this.originInfo.translateX;
143.           this.translateY = this.originInfo.translateY;
144.           this.clipWidth = this.originInfo.clipWidth;
145.           this.clipHeight = this.originInfo.clipHeight;
146.           this.radius = 0;
147.           this.opacityDegree = 0;
148.           // 启动半模态页和模态页
149.           this.isShowSheet = true;
150.           this.isShowOverlay = true;
151.           // 设置原图为不可交互抗打断
152.           this.isEnabled = false;
153.         })
154.     }
155.     .width('100%')
156.     .height('100%')
157.     .padding({ top: 20 })
158.     .alignItems(HorizontalAlign.Center)
159.     .bindSheet(this.isShowSheet, this.mySheet(), {
160.       // Embedded模式使得其他页面可以高于半模态页
161.       mode: SheetMode.EMBEDDED,
162.       height: this.bindSheetHeight,
163.       onDisappear: () => {
164.         // 保证半模态消失时状态正确
165.         this.isShowImage = false;
166.         this.isShowSheet = false;
167.         // 设置一镜到底动画又进入可触发状态
168.         this.isAnimating = false;
169.         // 原图重新变为可交互状态
170.         this.isEnabled = true;
171.       }
172.     }) // 挂载模态页作为一镜到底动画的实现页
173.     .bindContentCover(this.isShowOverlay, this.overlayNode(), {
174.       // 模态页面设置为无转场
175.       transition: TransitionEffect.IDENTITY,
176.     })
177.   }

178.   // 半模态页面
179.   @Builder
180.   mySheet() {
181.     Column({space: 20}) {
182.       Text('半模态页面')
183.         .fontSize(30)
184.       Row({space: 40}) {
185.         Column({space: 20}) {
186.           ForEach([1, 2, 3, 4], () => {
187.             Stack()
188.               .backgroundColor(Color.Pink)
189.               .borderRadius(20)
190.               .width(60)
191.               .height(60)
192.           })
193.         }
194.         Column() {
195.           if (this.isShowImage) {
196.             // 半模态页面的自定义图片节点
197.             ImageNode()
198.           }
199.           else {
200.             // 抓取布局和占位用，实际不显示
201.             // 图片使用Resource资源，需用户自定义
202.             Image($r("app.media.flower"))
203.               .visibility(Visibility.Hidden)
204.           }
205.         }
206.         .height(300)
207.         .width(200)
208.         .borderRadius(20)
209.         .clip(true)
210.         .id('target')
211.       }
212.       .alignItems(VerticalAlign.Top)
213.     }
214.     .alignItems(HorizontalAlign.Start)
215.     .height('100%')
216.     .width('100%')
217.     .margin(40)
218.   }

219.   @Builder
220.   overlayNode() {
221.     // Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
222.     Stack({ alignContent: Alignment.TopStart }) {
223.       ImageNode()
224.     }
225.     .scale({ x: this.scaleValue, y: this.scaleValue, centerX: undefined, centerY: undefined})
226.     .translate({ x: this.translateX, y: this.translateY })
227.     .width(this.clipWidth)
228.     .height(this.clipHeight)
229.     .borderRadius(this.radius)
230.     .clip(true)
231.   }
232. }

233. @Component
234. struct ImageNode {
235.   @State myNodeController: MyNodeController | undefined = new MyNodeController(false);

236.   aboutToAppear(): void {
237.     // 获取自定义节点
238.     let node = getMyNode();
239.     if (node == undefined) {
240.       // 新建自定义节点
241.       createMyNode(this.getUIContext());
242.     }
243.     this.myNodeController = getMyNode();
244.   }

245.   aboutToDisappear(): void {
246.     if (this.myNodeController != undefined) {
247.       // 节点下树
248.       this.myNodeController.onRemove();
249.     }
250.   }
251.   build() {
252.     NodeContainer(this.myNodeController)
253.   }
254. }

255. // CustomComponent.ets
256. // 自定义占位节点，跨容器迁移能力
257. import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';

258. @Builder
259. function CardBuilder() {
260.   // 图片使用Resource资源，需用户自定义
261.   Image($r("app.media.flower"))
262.     // 避免第一次加载图片时图片闪烁
263.     .syncLoad(true)
264. }

265. export class MyNodeController extends NodeController {
266.   private CardNode: BuilderNode<[]> | null = null;
267.   private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
268.   private needCreate: boolean = false;
269.   private isRemove: boolean = false;

270.   constructor(create: boolean) {
271.     super();
272.     this.needCreate = create;
273.   }

274.   makeNode(uiContext: UIContext): FrameNode | null {
275.     if(this.isRemove == true){
276.       return null;
277.     }
278.     if (this.needCreate && this.CardNode == null) {
279.       this.CardNode = new BuilderNode(uiContext);
280.       this.CardNode.build(this.wrapBuilder)
281.     }
282.     if (this.CardNode == null) {
283.       return null;
284.     }
285.     return this.CardNode!.getFrameNode()!;
286.   }

287.   getNode(): BuilderNode<[]> | null {
288.     return this.CardNode;
289.   }

290.   setNode(node: BuilderNode<[]> | null) {
291.     this.CardNode = node;
292.     this.rebuild();
293.   }

294.   onRemove() {
295.     this.isRemove = true;
296.     this.rebuild();
297.     this.isRemove = false;
298.   }

299.   init(uiContext: UIContext) {
300.     this.CardNode = new BuilderNode(uiContext);
301.     this.CardNode.build(this.wrapBuilder)
302.   }
303. }

304. let myNode: MyNodeController | undefined;

305. export const createMyNode =
306.   (uiContext: UIContext) => {
307.     myNode = new MyNodeController(false);
308.     myNode.init(uiContext);
309.   }

310. export const getMyNode = (): MyNodeController | undefined => {
311.   return myNode;
312. }

313. // ComponentAttrUtils.ets
314. // 获取组件相对窗口的位置
315. import { componentUtils, UIContext } from '@kit.ArkUI';
316. import { JSON } from '@kit.ArkTS';

317. export class ComponentAttrUtils {
318.   // 根据组件的id获取组件的位置信息
319.   public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
320.     if (!context || !id) {
321.       throw Error('object is empty');
322.     }
323.     let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);

324.     if (!componentInfo) {
325.       throw Error('object is empty');
326.     }

327.     let rstRect: RectInfoInPx = new RectInfoInPx();
328.     const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
329.     const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
330.     rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
331.     rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
332.     rstRect.right =
333.       componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
334.     rstRect.bottom =
335.       componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
336.     rstRect.width = rstRect.right - rstRect.left;
337.     rstRect.height = rstRect.bottom - rstRect.top;
338.     return {
339.       left: rstRect.left,
340.       right: rstRect.right,
341.       top: rstRect.top,
342.       bottom: rstRect.bottom,
343.       width: rstRect.width,
344.       height: rstRect.height
345.     }
346.   }
347. }

348. export class RectInfoInPx {
349.   left: number = 0;
350.   top: number = 0;
351.   right: number = 0;
352.   bottom: number = 0;
353.   width: number = 0;
354.   height: number = 0;
355. }

356. export class RectJson {
357.   $rect: Array<number> = [];
358. }

359. // WindowUtils.ets
360. // 窗口信息
361. import { window } from '@kit.ArkUI';

362. export class WindowUtils {
363.   public static window: window.Window;
364.   public static windowWidth_px: number;
365.   public static windowHeight_px: number;
366.   public static topAvoidAreaHeight_px: number;
367.   public static navigationIndicatorHeight_px: number;
368. }

369. // EntryAbility.ets
370. // 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取

371. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
372. import { hilog } from '@kit.PerformanceAnalysisKit';
373. import { display, window } from '@kit.ArkUI';
374. import { WindowUtils } from '../utils/WindowUtils';

375. const TAG: string = 'EntryAbility';

376. export default class EntryAbility extends UIAbility {
377.   private currentBreakPoint: string = '';

378.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
379.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
380.   }

381.   onDestroy(): void {
382.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
383.   }

384.   onWindowStageCreate(windowStage: window.WindowStage): void {
385.     // Main window is created, set main page for this ability
386.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

387.     // 获取窗口宽高
388.     WindowUtils.window = windowStage.getMainWindowSync();
389.     WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
390.     WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;

391.     this.updateBreakpoint(WindowUtils.windowWidth_px);

392.     // 获取上方避让区(状态栏等)高度
393.     let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
394.     WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;

395.     // 获取导航条高度
396.     let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
397.     WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;

398.     hilog.info(0x0000, TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
399.     WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);

400.     // 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
401.     try {
402.       WindowUtils.window.on('windowSizeChange', (data) => {
403.         hilog.info(0x0000, TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
404.         WindowUtils.windowWidth_px = data.width;
405.         WindowUtils.windowHeight_px = data.height;
406.         this.updateBreakpoint(data.width);
407.         AppStorage.setOrCreate('windowSizeChanged', Date.now())
408.       })

409.       WindowUtils.window.on('avoidAreaChange', (data) => {
410.         if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
411.           let topRectHeight = data.area.topRect.height;
412.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
413.           WindowUtils.topAvoidAreaHeight_px = topRectHeight;
414.         } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
415.           let bottomRectHeight = data.area.bottomRect.height;
416.           hilog.info(0x0000, TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
417.           WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
418.         }
419.       })
420.     } catch (exception) {
421.       hilog.error(0x0000, TAG, `register failed. code: ${exception.code}, message: ${exception.message}`);
422.     }

423.     windowStage.loadContent('pages/Index', (err) => {
424.       if (err.code) {
425.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
426.         return;
427.       }
428.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
429.     });
430.   }

431.   updateBreakpoint(width: number) {
432.     let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
433.     let newBreakPoint: string = '';
434.     if (windowWidthVp < 400) {
435.       newBreakPoint = 'xs';
436.     } else if (windowWidthVp < 600) {
437.       newBreakPoint = 'sm';
438.     } else if (windowWidthVp < 800) {
439.       newBreakPoint = 'md';
440.     } else {
441.       newBreakPoint = 'lg';
442.     }
443.     if (this.currentBreakPoint !== newBreakPoint) {
444.       this.currentBreakPoint = newBreakPoint;
445.       // 使用状态变量记录当前断点值
446.       AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
447.     }
448.   }

449.   onWindowStageDestroy(): void {
450.     // Main window is destroyed, release UI related resources
451.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
452.   }

453.   onForeground(): void {
454.     // Ability has brought to foreground
455.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
456.   }

457.   onBackground(): void {
458.     // Ability has back to background
459.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
460.   }
461. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.94596976349835209240042454924339:50001231000000:2800:4A1587C908876454A8D1E02A27656B0A047FB4D15668A8CE38F4B2DBB5B3C7B5.gif)

## 使用geometryTransition共享元素转场

[geometryTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-geometrytransition)用于组件内隐式共享元素转场，在视图状态切换过程中提供丝滑的上下文继承过渡体验。

geometryTransition的使用方式为对需要添加一镜到底动效的两个组件使用geometryTransition接口绑定同一id，这样在其中一个组件消失同时另一个组件创建出现的时候，系统会对二者添加一镜到底动效。

geometryTransition绑定两个对象的实现方式使得geometryTransition区别于其他方法，最适合用于两个不同对象之间完成一镜到底。

### geometryTransition的简单使用

对于同一个页面中的两个元素的一镜到底效果，geometryTransition接口的简单使用示例如下：

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct IfElseGeometryTransition {
5.   @State isShow: boolean = false;

6.   build() {
7.     Stack({ alignContent: Alignment.Center }) {
8.       if (this.isShow) {
9.         // 图片使用Resource资源，需用户自定义
10.         Image($r('app.media.spring'))
11.           .autoResize(false)
12.           .clip(true)
13.           .width(200)
14.           .height(200)
15.           .borderRadius(100)
16.           .geometryTransition("picture")
17.           .transition(TransitionEffect.OPACITY)
18.           // 在打断场景下，即动画过程中点击页面触发下一次转场，如果不加id，则会出现重影
19.           // 加了id之后，新建的spring图片会复用之前的spring图片节点，不会重新创建节点，也就不会有重影问题
20.           // 加id的规则为加在if和else下的第一个节点上，有多个并列节点则也需要进行添加
21.           .id('item1')
22.       } else {
23.         // geometryTransition此处绑定的是容器，那么容器内的子组件需设为相对布局跟随父容器变化，
24.         // 套多层容器为了说明相对布局约束传递
25.         Column() {
26.           Column() {
27.             // 图片使用Resource资源，需用户自定义
28.             Image($r('app.media.sky'))
29.               .size({ width: '100%', height: '100%' })
30.           }
31.           .size({ width: '100%', height: '100%' })
32.         }
33.         .width(100)
34.         .height(100)
35.         // geometryTransition会同步圆角，但仅限于geometryTransition绑定处，此处绑定的是容器
36.         // 则对容器本身有圆角同步而不会操作容器内部子组件的borderRadius
37.         .borderRadius(50)
38.         .clip(true)
39.         .geometryTransition("picture")
40.         // transition保证节点离场不被立即析构，设置通用转场效果
41.         .transition(TransitionEffect.OPACITY)
42.         .position({ x: 40, y: 40 })
43.         .id('item2')
44.       }
45.     }
46.     .onClick(() => {
47.       this.getUIContext()?.animateTo({
48.         curve: curves.springMotion()
49.       }, () => {
50.         this.isShow = !this.isShow;
51.       })
52.     })
53.     .size({ width: '100%', height: '100%' })
54.   }
55. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.34247257179854547412558413214758:50001231000000:2800:7C08D34AEAB1EE500B2DA23B310AD59E21FB7C992DC92A3666BC87240F20409A.gif)

### geometryTransition结合模态转场使用

更多的场景中，需要对一个页面的元素与另一个页面的元素添加一镜到底动效。可以通过geometryTransition搭配模态转场接口实现。以点击头像弹出个人信息页的demo为例：

1. class PostData {
2.   // 图片使用Resource资源，需用户自定义
3.   avatar: Resource = $r('app.media.flower');
4.   name: string = '';
5.   message: string = '';
6.   images: Resource[] = [];
7. }

8. @Entry
9. @Component
10. struct Index {
11.   @State isPersonalPageShow: boolean = false;
12.   @State selectedIndex: number = 0;
13.   @State alphaValue: number = 1;

14.   // 数组中图片均使用Resource资源，需用户自定义
15.   private allPostData: PostData[] = [
16.     { avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
17.       images: [$r('app.media.spring'), $r('app.media.tree')] },
18.     { avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
19.       images: [$r('app.media.island')] },
20.     { avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
21.       images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];

22.   private onAvatarClicked(index: number): void {
23.     this.selectedIndex = index;
24.     this.getUIContext()?.animateTo({
25.       duration: 350,
26.       curve: Curve.Friction
27.     }, () => {
28.       this.isPersonalPageShow = !this.isPersonalPageShow;
29.       this.alphaValue = 0;
30.     });
31.   }

32.   private onPersonalPageBack(index: number): void {
33.     this.getUIContext()?.animateTo({
34.       duration: 350,
35.       curve: Curve.Friction
36.     }, () => {
37.       this.isPersonalPageShow = !this.isPersonalPageShow;
38.       this.alphaValue = 1;
39.     });
40.   }

41.   @Builder
42.   PersonalPageBuilder(index: number) {
43.     Column({ space: 20 }) {
44.       Image(this.allPostData[index].avatar)
45.         .size({ width: 200, height: 200 })
46.         .borderRadius(100)
47.         // 头像配置共享元素效果，与点击的头像的id匹配
48.         .geometryTransition(index.toString())
49.         .clip(true)
50.         .transition(TransitionEffect.opacity(0.99))

51.       Text(this.allPostData[index].name)
52.         .font({ size: 30, weight: 600 })
53.         // 对文本添加出现转场效果
54.         .transition(TransitionEffect.asymmetric(
55.           TransitionEffect.OPACITY
56.             .combine(TransitionEffect.translate({ y: 100 })),
57.           TransitionEffect.OPACITY.animation({ duration: 0 })
58.         ))

59.       Text('你好，我是' + this.allPostData[index].name)
60.         // 对文本添加出现转场效果
61.         .transition(TransitionEffect.asymmetric(
62.           TransitionEffect.OPACITY
63.             .combine(TransitionEffect.translate({ y: 100 })),
64.           TransitionEffect.OPACITY.animation({ duration: 0 })
65.         ))
66.     }
67.     .padding({ top: 20 })
68.     .size({ width: 360, height: 780 })
69.     .backgroundColor(Color.White)
70.     .onClick(() => {
71.       this.onPersonalPageBack(index);
72.     })
73.     .transition(TransitionEffect.asymmetric(
74.       TransitionEffect.opacity(0.99),
75.       TransitionEffect.OPACITY
76.     ))
77.   }

78.   build() {
79.     Column({ space: 20 }) {
80.       ForEach(this.allPostData, (postData: PostData, index: number) => {
81.         Column() {
82.           Post({ data: postData, index: index, onAvatarClicked: (index: number) => { this.onAvatarClicked(index) } })
83.         }
84.         .width('100%')
85.       }, (postData: PostData, index: number) => index.toString())
86.     }
87.     .size({ width: '100%', height: '100%' })
88.     .backgroundColor('#40808080')
89.     .bindContentCover(this.isPersonalPageShow,
90.       this.PersonalPageBuilder(this.selectedIndex), { modalTransition: ModalTransition.NONE })
91.     .opacity(this.alphaValue)
92.   }
93. }

94. @Component
95. export default struct  Post {
96.   @Prop data: PostData;
97.   @Prop index: number;

98.   @State expandImageSize: number = 100;
99.   @State avatarSize: number = 50;

100.   private onAvatarClicked: (index: number) => void = (index: number) => { };

101.   build() {
102.     Column({ space: 20 }) {
103.       Row({ space: 10 }) {
104.         Image(this.data.avatar)
105.           .size({ width: this.avatarSize, height: this.avatarSize })
106.           .borderRadius(this.avatarSize / 2)
107.           .clip(true)
108.           .onClick(() => {
109.             this.onAvatarClicked(this.index);
110.           })
111.           // 对头像绑定共享元素转场的id
112.           .geometryTransition(this.index.toString(), {follow:true})
113.           .transition(TransitionEffect.OPACITY.animation({ duration: 350, curve: Curve.Friction }))

114.         Text(this.data.name)
115.       }
116.       .justifyContent(FlexAlign.Start)

117.       Text(this.data.message)

118.       Row({ space: 15 }) {
119.         ForEach(this.data.images, (imageResource: Resource, index: number) => {
120.           Image(imageResource)
121.             .size({ width: 100, height: 100 })
122.         }, (imageResource: Resource, index: number) => index.toString())
123.       }
124.     }
125.     .backgroundColor(Color.White)
126.     .size({ width: '100%', height: 250 })
127.     .alignItems(HorizontalAlign.Start)
128.     .padding({ left: 10, top: 10 })
129.   }
130. }

效果为点击主页的头像后，弹出模态页面显示个人信息，并且两个页面之间的头像做一镜到底动效：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164048.40028410023183083819362411137140:50001231000000:2800:C4A113ACE78D678023273FD86D3A9BE07ECFCE51EE0C62D4BEB9DCB8658A89F8.gif)

## 示例代码

- [转场动效合集](https://gitcode.com/harmonyos_samples/transitions-collection)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-modal-transition "模态转场")
# 组件动画

更新时间: 2025-12-16 16:39

ArkUI为组件提供了通用的属性动画和转场动画能力的同时，还为一些组件提供了默认的动画效果。例如，[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)的滑动动效、[Button](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button)的点击动效，是组件自带的默认动画效果。在组件默认动画效果的基础上，开发者还可以通过属性动画和转场动画对容器组件内的子组件动效进行定制。

## 使用组件默认动画

组件默认动效具备以下功能：

- 提示用户当前状态，例如用户点击Button组件时，Button组件默认变灰，用户即确定完成选中操作。
    
- 提升界面精致程度和生动性。
    
- 减少开发者工作量，例如列表滑动组件自带滑动动效，开发者直接调用即可。
    

更多效果，可以参考[组件说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flex)。

示例代码和效果如下。

1. @Entry
2. @Component
3. struct ComponentDemo {
4.   build() {
5.     Row() {
6.       Checkbox({ name: 'checkbox1', group: 'checkboxGroup' })
7.         .select(true)
8.         .shape(CheckBoxShape.CIRCLE)
9.         .size({ width: 50, height: 50 })
10.     }
11.     .width('100%')
12.     .height('100%')
13.     .justifyContent(FlexAlign.Center)
14.   }
15. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163958.23852542924478288284862011880707:50001231000000:2800:43FD354B966B4AA2DED55E5749F5291B647FC145F5B88FCBE0420848DB6390BE.gif)

## 打造组件定制化动效

部分组件支持通过[属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-overview)和[转场动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-transition-overview)自定义组件子Item的动效，实现定制化动画效果。例如，[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)组件中可对各个子组件在滑动时的动画效果进行定制。

- 在滑动或者点击操作时通过改变各个Scroll子组件的仿射属性来实现各种效果。
    
- 如果要在滑动过程中定制动效，可在滑动回调onScroll中监控滑动距离，并计算每个组件的仿射属性。也可以自己定义手势，通过手势监控位置，手动调用ScrollTo改变滑动位置。
    
- 在滑动回调onScrollStop或手势结束回调中对滑动的最终位置进行微调。
    

定制Scroll组件滑动动效示例代码和效果如下。

1. import { curves, window, display, mediaquery, UIContext } from '@kit.ArkUI';
2. import { UIAbility } from '@kit.AbilityKit';

3. export default class GlobalContext extends AppStorage {
4.   static mainWin: window.Window | undefined = undefined;
5.   static mainWindowSize: window.Size | undefined = undefined;
6. }
7. /**
8.  * 窗口、屏幕相关信息管理类
9.  */
10. export class WindowManager {
11.   private static instance: WindowManager | null = null;
12.   private displayInfo: display.Display | null = null;
13.   private uiContext: UIContext;
14.   private orientationListener: mediaquery.MediaQueryListener;

15.   constructor(uiContext: UIContext) {
16.     this.uiContext = uiContext
17.     this.orientationListener = this.uiContext.getMediaQuery().matchMediaSync('(orientation: landscape)');
18.     this.orientationListener.on('change', (mediaQueryResult: mediaquery.MediaQueryResult) => {
19.       this.onPortrait(mediaQueryResult)
20.     })
21.     this.loadDisplayInfo()
22.   }

23.   /**
24.    * 设置主window窗口
25.    * @param win 当前app窗口
26.    */
27.   setMainWin(win: window.Window) {
28.     if (win == null) {
29.       return
30.     }
31.     GlobalContext.mainWin = win;
32.     win.on("windowSizeChange", (data: window.Size) => {
33.       if (GlobalContext.mainWindowSize == undefined || GlobalContext.mainWindowSize == null) {
34.         GlobalContext.mainWindowSize = data;
35.       } else {
36.         if (GlobalContext.mainWindowSize.width == data.width && GlobalContext.mainWindowSize.height == data.height) {
37.           return
38.         }
39.         GlobalContext.mainWindowSize = data;
40.       }

41.       let winWidth = this.getMainWindowWidth();
42.       AppStorage.setOrCreate<number>('mainWinWidth', winWidth)
43.       let winHeight = this.getMainWindowHeight();
44.       AppStorage.setOrCreate<number>('mainWinHeight', winHeight)
45.       let context: UIAbility = new UIAbility()
46.       context.context.eventHub.emit("windowSizeChange", winWidth, winHeight)
47.     })
48.   }

49.   static getInstance(uiContext: UIContext): WindowManager {
50.     if (WindowManager.instance == null) {
51.       WindowManager.instance = new WindowManager(uiContext);
52.     }
53.     return WindowManager.instance
54.   }

55.   private onPortrait(mediaQueryResult: mediaquery.MediaQueryResult) {
56.     if (mediaQueryResult.matches == AppStorage.get<boolean>('isLandscape')) {
57.       return
58.     }
59.     AppStorage.setOrCreate<boolean>('isLandscape', mediaQueryResult.matches)
60.     this.loadDisplayInfo()
61.   }

62.   /**
63.    * 切换屏幕方向
64.    * @param ori 常量枚举值：window.Orientation
65.    */
66.   changeOrientation(ori: window.Orientation) {
67.     if (GlobalContext.mainWin != null) {
68.       GlobalContext.mainWin.setPreferredOrientation(ori)
69.     }
70.   }

71.   private loadDisplayInfo() {
72.     this.displayInfo = display.getDefaultDisplaySync()
73.     AppStorage.setOrCreate<number>('displayWidth', this.getDisplayWidth())
74.     AppStorage.setOrCreate<number>('displayHeight', this.getDisplayHeight())
75.   }

76.   /**
77.    * 获取main窗口宽度，单位vp
78.    */
79.   getMainWindowWidth(): number {
80.     return GlobalContext.mainWindowSize != null ? this.uiContext.px2vp(GlobalContext.mainWindowSize.width) : 0
81.   }

82.   /**
83.    * 获取main窗口高度，单位vp
84.    */
85.   getMainWindowHeight(): number {
86.     return GlobalContext.mainWindowSize != null ? this.uiContext.px2vp(GlobalContext.mainWindowSize.height) : 0
87.   }

88.   /**
89.    * 获取屏幕宽度，单位vp
90.    */
91.   getDisplayWidth(): number {
92.     return this.displayInfo != null ? this.uiContext.px2vp(this.displayInfo.width) : 0
93.   }

94.   /**
95.    * 获取屏幕高度，单位vp
96.    */
97.   getDisplayHeight(): number {
98.     return this.displayInfo != null ? this.uiContext.px2vp(this.displayInfo.height) : 0
99.   }

100.   /**
101.    * 释放资源
102.    */
103.   release() {
104.     if (this.orientationListener) {
105.       this.orientationListener.off('change', (mediaQueryResult: mediaquery.MediaQueryResult) => {
106.         this.onPortrait(mediaQueryResult)
107.       })
108.     }
109.     if (GlobalContext.mainWin != null) {
110.       GlobalContext.mainWin.off('windowSizeChange')
111.     }
112.     WindowManager.instance = null;
113.   }
114. }

115. /**
116.  * 封装任务卡片信息数据类
117.  */
118. export class TaskData {
119.   bgColor: Color | string | Resource = Color.White;
120.   index: number = 0;
121.   taskInfo: string = 'music';

122.   constructor(bgColor: Color | string | Resource, index: number, taskInfo: string) {
123.     this.bgColor = bgColor;
124.     this.index = index;
125.     this.taskInfo = taskInfo;
126.   }
127. }

128. export const taskDataArr: Array<TaskData> =
129.   [
130.     new TaskData('#317AF7', 0, 'music'),
131.     new TaskData('#D94838', 1, 'mall'),
132.     new TaskData('#DB6B42', 2, 'photos'),
133.     new TaskData('#5BA854', 3, 'setting'),
134.     new TaskData('#317AF7', 4, 'call'),
135.     new TaskData('#D94838', 5, 'music'),
136.     new TaskData('#DB6B42', 6, 'mall'),
137.     new TaskData('#5BA854', 7, 'photos'),
138.     new TaskData('#D94838', 8, 'setting'),
139.     new TaskData('#DB6B42', 9, 'call'),
140.     new TaskData('#5BA854', 10, 'music')

141.   ];

142. @Entry
143. @Component
144. export struct TaskSwitchMainPage {
145.   displayWidth: number = WindowManager.getInstance(this.getUIContext()).getDisplayWidth();
146.   scroller: Scroller = new Scroller();
147.   cardSpace: number = 0; // 卡片间距
148.   cardWidth: number = this.displayWidth / 2 - this.cardSpace / 2; // 卡片宽度
149.   cardHeight: number = 400; // 卡片高度
150.   cardPosition: Array<number> = []; // 卡片初始位置
151.   clickIndex: boolean = false;
152.   @State taskViewOffsetX: number = 0;
153.   @State cardOffset: number = this.displayWidth / 4;
154.   lastCardOffset: number = this.cardOffset;
155.   startTime: number | undefined = undefined

156.   // 每个卡片初始位置
157.   aboutToAppear() {
158.     for (let i = 0; i < taskDataArr.length; i++) {
159.       this.cardPosition[i] = i * (this.cardWidth + this.cardSpace);
160.     }
161.   }

162.   // 每个卡片位置
163.   getProgress(index: number): number {
164.     let progress = (this.cardOffset + this.cardPosition[index] - this.taskViewOffsetX + this.cardWidth / 2) / this.displayWidth;
165.     return progress
166.   }

167.   build() {
168.     Stack({ alignContent: Alignment.Bottom }) {
169.       // 背景
170.       Column()
171.         .width('100%')
172.         .height('100%')
173.         .backgroundColor(0xF0F0F0)

174.       // 滑动组件
175.       Scroll(this.scroller) {
176.         Row({ space: this.cardSpace }) {
177.           ForEach(taskDataArr, (item: TaskData, index) => {
178.             Column()
179.               .width(this.cardWidth)
180.               .height(this.cardHeight)
181.               .backgroundColor(item.bgColor)
182.               .borderStyle(BorderStyle.Solid)
183.               .borderWidth(1)
184.               .borderColor(0xAFEEEE)
185.               .borderRadius(15)
186.                 // 计算子组件的仿射属性
187.               .scale((this.getProgress(index) >= 0.4 && this.getProgress(index) <= 0.6) ?
188.                 {
189.                   x: 1.1 - Math.abs(0.5 - this.getProgress(index)),
190.                   y: 1.1 - Math.abs(0.5 - this.getProgress(index))
191.                 } :
192.                 { x: 1, y: 1 })
193.               .animation({ curve: Curve.Smooth })
194.                 // 滑动动画
195.               .translate({ x: this.cardOffset })
196.               .animation({ curve: curves.springMotion() })
197.               .zIndex((this.getProgress(index) >= 0.4 && this.getProgress(index) <= 0.6) ? 2 : 1)
198.           }, (item: TaskData) => item.toString())
199.         }
200.         .width((this.cardWidth + this.cardSpace) * (taskDataArr.length + 1))
201.         .height('100%')
202.       }
203.       .gesture(
204.         GestureGroup(GestureMode.Parallel,
205.           PanGesture({ direction: PanDirection.Horizontal, distance: 5 })
206.             .onActionStart((event: GestureEvent | undefined) => {
207.               if (event) {
208.                 this.startTime = event.timestamp;
209.               }
210.             })
211.             .onActionUpdate((event: GestureEvent | undefined) => {
212.               if (event) {
213.                 this.cardOffset = this.lastCardOffset + event.offsetX;
214.               }
215.             })
216.             .onActionEnd((event: GestureEvent | undefined) => {
217.               if (event) {
218.                 let time = 0
219.                 if (this.startTime) {
220.                   time = event.timestamp - this.startTime;
221.                 }
222.                 let speed = event.offsetX / (time / 1000000000);
223.                 let moveX = Math.pow(speed, 2) / 7000 * (speed > 0 ? 1 : -1);

224.                 this.cardOffset += moveX;
225.                 // 左滑大于最右侧位置
226.                 let cardOffsetMax = -(taskDataArr.length - 1) * (this.displayWidth / 2);
227.                 if (this.cardOffset < cardOffsetMax) {
228.                   this.cardOffset = cardOffsetMax;
229.                 }
230.                 // 右滑大于最左侧位置
231.                 if (this.cardOffset > this.displayWidth / 4) {
232.                   this.cardOffset = this.displayWidth / 4;
233.                 }

234.                 // 左右滑动距离不满足/满足切换关系时，补位/退回
235.                 let remainMargin = this.cardOffset % (this.displayWidth / 2);
236.                 if (remainMargin < 0) {
237.                   remainMargin = this.cardOffset % (this.displayWidth / 2) + this.displayWidth / 2;
238.                 }
239.                 if (remainMargin <= this.displayWidth / 4) {
240.                   this.cardOffset += this.displayWidth / 4 - remainMargin;
241.                 } else {
242.                   this.cardOffset -= this.displayWidth / 4 - (this.displayWidth / 2 - remainMargin);
243.                 }

244.                 // 记录本次滑动偏移量
245.                 this.lastCardOffset = this.cardOffset;
246.               }
247.             })
248.         ), GestureMask.IgnoreInternal)
249.       .scrollable(ScrollDirection.Horizontal)
250.       .scrollBar(BarState.Off)

251.       // 滑动到首尾位置
252.       Button('Move to first/last')
253.         .backgroundColor(0x888888)
254.         .margin({ bottom: 30 })
255.         .onClick(() => {
256.           this.clickIndex = !this.clickIndex;

257.           if (this.clickIndex) {
258.             this.cardOffset = this.displayWidth / 4;
259.           } else {
260.             this.cardOffset = this.displayWidth / 4 - (taskDataArr.length - 1) * this.displayWidth / 2;
261.           }
262.           this.lastCardOffset = this.cardOffset;
263.         })
264.     }
265.     .width('100%')
266.     .height('100%')
267.   }
268. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163958.04376694864743590252857681818047:50001231000000:2800:3CD65768366AA9CF91D80740C0C3DFED0FA16BF7AAD5B2F73213ECC4239E418C.gif)

通过animateTo可以实现将List中指定的Item替换到首位，List中其余Item依次向下排列。定制List组件动态替换动效的示例代码和效果如下。

1. import { curves, AnimatorResult } from '@kit.ArkUI';

2. // 该接口控制列表项视觉属性
3. class ListItemModify implements AttributeModifier<ListItemAttribute> {
4.   public offsetY: number = 0;

5.   applyNormalAttribute(instance: ListItemAttribute): void {
6.     instance.translate({ y: this.offsetY }) // Y轴位移
7.   }
8. }

9. @Observed
10. class DragSortCtrl<T> {
11.   private arr: Array<T>
12.   private modify: Array<ListItemModify>
13.   private uiContext: UIContext; // 新增UIContext成员
14.   private dragRefOffset: number = 0
15.   offsetY: number = 0
16.   private ITEM_INTV: number = 0

17.   constructor(arr: Array<T>, intv: number, uiContext: UIContext) {
18.     this.arr = arr;
19.     this.uiContext = uiContext;
20.     this.modify = new Array<ListItemModify>()
21.     this.ITEM_INTV = intv
22.     arr.forEach(() => {
23.       this.modify.push(new ListItemModify())
24.     })
25.   }

26.   itemMove(index: number, newIndex: number): void {
27.     let tmp = this.arr.splice(index, 1) // 移除当前传入的index
28.     this.arr.splice(newIndex, 0, tmp[0]) // 将当前移除的index插入到数组前一个位置
29.     let tmp2 = this.modify.splice(index, 1)
30.     this.modify.splice(newIndex, 0, tmp2[0])
31.   }

32.   setDragRef(item: T): void {
33.     this.dragRefOffset = 0
34.   }

35.   onMove(item: T, offset: number) {
36.     this.offsetY = offset - this.dragRefOffset // 逐帧计算传入的offect，每满足一个item高度时，进入下方if逻辑，更新dragRefOffset的值
37.     let index = this.arr.indexOf(item) // 在数组中查找传入的item
38.     this.modify[index].offsetY = this.offsetY
39.     if (this.offsetY < -this.ITEM_INTV / 2) { // 通过判断使指定的item逐一移动到首位
40.       // 使用interpolatingSpring曲线生成弹簧动画
41.       this.uiContext.animateTo({ curve: curves.interpolatingSpring(0, 1, 400, 38) }, () => {
42.         this.offsetY += this.ITEM_INTV // 调整偏移量实现平滑移动
43.         this.dragRefOffset -= this.ITEM_INTV // 移动的总偏移量
44.         console.info(`item offsetY ${this.offsetY} dragRefOffset ${this.dragRefOffset}`);
45.         this.itemMove(index, index - 1) // 执行列表项位置交换
46.       })
47.     }
48.   }

49.   getModify(item: T): ListItemModify {
50.     let index = this.arr.indexOf(item)
51.     return this.modify[index]
52.   }
53. }

54. @Entry
55. @Component
56. struct ListAutoSortExample {
57.   @State private arr: Array<number> = [0, 1, 2, 3, 4, 5]
58.   @State dragSortCtrl: DragSortCtrl<number> = new DragSortCtrl<number>(this.arr, 120, this.getUIContext())
59.   @State firstListItemGroupCount: number = 3
60.   private listScroll: ListScroller = new ListScroller()
61.   private backAnimator: AnimatorResult | null = null

62.   @Builder
63.   itemEnd(item: number, index: number) {
64.     Row() {
65.       Button("To TOP").margin("4vp").onClick(() => {
66.         console.info(`item number item ${item} index ${index}`);
67.         this.listScroll.closeAllSwipeActions({
68.           onFinish: () => {
69.             this.dragSortCtrl.setDragRef(item)
70.             let length = 120 * (this.arr.indexOf(item))
71.             this.backAnimator = this.getUIContext()?.createAnimator({ // 创建弹簧动画
72.               duration: 1000,
73.               easing: "interpolating-spring(0, 1, 150, 24)",
74.               delay: 0,
75.               fill: "none",
76.               direction: "normal",
77.               iterations: 1,
78.               begin: 0,
79.               end: -length
80.             })
81.             this.backAnimator.onFrame = (value) => { // 逐帧回调更新位置
82.               this.dragSortCtrl.onMove(item, value) // 处理list的移动替换动效
83.             }
84.             this.backAnimator.onFinish = () => {}
85.             this.backAnimator.play() // 启动动画
86.           }
87.         })
88.       })
89.     }.padding("4vp").justifyContent(FlexAlign.SpaceEvenly)
90.   }

91.   @Builder
92.   header(title: string) {
93.     Row() {
94.       Text(title)
95.     }
96.   }

97.   build() {
98.     Row() {
99.       Column() {
100.         List({ space: 20, scroller: this.listScroll }) {
101.           ListItemGroup({ header: this.header('first ListItemGroup'), space: 20 }) {
102.             ForEach(this.arr, (item: number, index) => {
103.               if (index < this.firstListItemGroupCount) {
104.                 ListItem() {
105.                   Text('' + item)
106.                     .width('100%')
107.                     .height(100)
108.                     .fontSize(16)
109.                     .borderRadius(10)
110.                     .textAlign(TextAlign.Center)
111.                     .backgroundColor(0xFFFFFF)
112.                 }
113.                 .swipeAction({
114.                   end: this.itemEnd(item, index)
115.                 })
116.                 .clip(true)
117.                 .attributeModifier(this.dragSortCtrl.getModify(item)) // 动态设置属性修改
118.                 .borderRadius(10)
119.                 .margin({ left: 20, right: 20 })
120.               }
121.             })
122.           }
123.           ListItemGroup({ header: this.header('second ListItemGroup'), space: 20 }) {
124.             ForEach(this.arr, (item: number, index) => {
125.               if (index > this.firstListItemGroupCount - 1) {
126.                 ListItem() {
127.                   Text('' + item)
128.                     .width('100%')
129.                     .height(100)
130.                     .fontSize(16)
131.                     .borderRadius(10)
132.                     .textAlign(TextAlign.Center)
133.                     .backgroundColor(0xFFFFFF)
134.                 }
135.                 .swipeAction({
136.                   end: this.itemEnd(item, index)
137.                 })
138.                 .clip(true)
139.                 .attributeModifier(this.dragSortCtrl.getModify(item))
140.                 .borderRadius(10)
141.                 .margin({ left: 20, right: 20 })
142.               }
143.             })
144.           }
145.         }
146.         .padding({ top: 20 })
147.         .height("100%")
148.       }
149.     }.backgroundColor(0xDCDCDC)
150.   }
151. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163958.21510600702767326847769447368826:50001231000000:2800:1015C7DCB44259A11CF2AEF94F6C48E8E78F7AFCFA589CBF4785074E272A7046.gif)

## 示例代码

- [动效案例合集](https://gitcode.com/harmonyos_samples/animation-collection)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-particle-animation "粒子动画")
# 组件动画

更新时间: 2025-12-16 16:39

ArkUI为组件提供了通用的属性动画和转场动画能力的同时，还为一些组件提供了默认的动画效果。例如，[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)的滑动动效、[Button](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button)的点击动效，是组件自带的默认动画效果。在组件默认动画效果的基础上，开发者还可以通过属性动画和转场动画对容器组件内的子组件动效进行定制。

## 使用组件默认动画

组件默认动效具备以下功能：

- 提示用户当前状态，例如用户点击Button组件时，Button组件默认变灰，用户即确定完成选中操作。
    
- 提升界面精致程度和生动性。
    
- 减少开发者工作量，例如列表滑动组件自带滑动动效，开发者直接调用即可。
    

更多效果，可以参考[组件说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flex)。

示例代码和效果如下。

1. @Entry
2. @Component
3. struct ComponentDemo {
4.   build() {
5.     Row() {
6.       Checkbox({ name: 'checkbox1', group: 'checkboxGroup' })
7.         .select(true)
8.         .shape(CheckBoxShape.CIRCLE)
9.         .size({ width: 50, height: 50 })
10.     }
11.     .width('100%')
12.     .height('100%')
13.     .justifyContent(FlexAlign.Center)
14.   }
15. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163958.23852542924478288284862011880707:50001231000000:2800:43FD354B966B4AA2DED55E5749F5291B647FC145F5B88FCBE0420848DB6390BE.gif)

## 打造组件定制化动效

部分组件支持通过[属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-overview)和[转场动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-transition-overview)自定义组件子Item的动效，实现定制化动画效果。例如，[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)组件中可对各个子组件在滑动时的动画效果进行定制。

- 在滑动或者点击操作时通过改变各个Scroll子组件的仿射属性来实现各种效果。
    
- 如果要在滑动过程中定制动效，可在滑动回调onScroll中监控滑动距离，并计算每个组件的仿射属性。也可以自己定义手势，通过手势监控位置，手动调用ScrollTo改变滑动位置。
    
- 在滑动回调onScrollStop或手势结束回调中对滑动的最终位置进行微调。
    

定制Scroll组件滑动动效示例代码和效果如下。

1. import { curves, window, display, mediaquery, UIContext } from '@kit.ArkUI';
2. import { UIAbility } from '@kit.AbilityKit';

3. export default class GlobalContext extends AppStorage {
4.   static mainWin: window.Window | undefined = undefined;
5.   static mainWindowSize: window.Size | undefined = undefined;
6. }
7. /**
8.  * 窗口、屏幕相关信息管理类
9.  */
10. export class WindowManager {
11.   private static instance: WindowManager | null = null;
12.   private displayInfo: display.Display | null = null;
13.   private uiContext: UIContext;
14.   private orientationListener: mediaquery.MediaQueryListener;

15.   constructor(uiContext: UIContext) {
16.     this.uiContext = uiContext
17.     this.orientationListener = this.uiContext.getMediaQuery().matchMediaSync('(orientation: landscape)');
18.     this.orientationListener.on('change', (mediaQueryResult: mediaquery.MediaQueryResult) => {
19.       this.onPortrait(mediaQueryResult)
20.     })
21.     this.loadDisplayInfo()
22.   }

23.   /**
24.    * 设置主window窗口
25.    * @param win 当前app窗口
26.    */
27.   setMainWin(win: window.Window) {
28.     if (win == null) {
29.       return
30.     }
31.     GlobalContext.mainWin = win;
32.     win.on("windowSizeChange", (data: window.Size) => {
33.       if (GlobalContext.mainWindowSize == undefined || GlobalContext.mainWindowSize == null) {
34.         GlobalContext.mainWindowSize = data;
35.       } else {
36.         if (GlobalContext.mainWindowSize.width == data.width && GlobalContext.mainWindowSize.height == data.height) {
37.           return
38.         }
39.         GlobalContext.mainWindowSize = data;
40.       }

41.       let winWidth = this.getMainWindowWidth();
42.       AppStorage.setOrCreate<number>('mainWinWidth', winWidth)
43.       let winHeight = this.getMainWindowHeight();
44.       AppStorage.setOrCreate<number>('mainWinHeight', winHeight)
45.       let context: UIAbility = new UIAbility()
46.       context.context.eventHub.emit("windowSizeChange", winWidth, winHeight)
47.     })
48.   }

49.   static getInstance(uiContext: UIContext): WindowManager {
50.     if (WindowManager.instance == null) {
51.       WindowManager.instance = new WindowManager(uiContext);
52.     }
53.     return WindowManager.instance
54.   }

55.   private onPortrait(mediaQueryResult: mediaquery.MediaQueryResult) {
56.     if (mediaQueryResult.matches == AppStorage.get<boolean>('isLandscape')) {
57.       return
58.     }
59.     AppStorage.setOrCreate<boolean>('isLandscape', mediaQueryResult.matches)
60.     this.loadDisplayInfo()
61.   }

62.   /**
63.    * 切换屏幕方向
64.    * @param ori 常量枚举值：window.Orientation
65.    */
66.   changeOrientation(ori: window.Orientation) {
67.     if (GlobalContext.mainWin != null) {
68.       GlobalContext.mainWin.setPreferredOrientation(ori)
69.     }
70.   }

71.   private loadDisplayInfo() {
72.     this.displayInfo = display.getDefaultDisplaySync()
73.     AppStorage.setOrCreate<number>('displayWidth', this.getDisplayWidth())
74.     AppStorage.setOrCreate<number>('displayHeight', this.getDisplayHeight())
75.   }

76.   /**
77.    * 获取main窗口宽度，单位vp
78.    */
79.   getMainWindowWidth(): number {
80.     return GlobalContext.mainWindowSize != null ? this.uiContext.px2vp(GlobalContext.mainWindowSize.width) : 0
81.   }

82.   /**
83.    * 获取main窗口高度，单位vp
84.    */
85.   getMainWindowHeight(): number {
86.     return GlobalContext.mainWindowSize != null ? this.uiContext.px2vp(GlobalContext.mainWindowSize.height) : 0
87.   }

88.   /**
89.    * 获取屏幕宽度，单位vp
90.    */
91.   getDisplayWidth(): number {
92.     return this.displayInfo != null ? this.uiContext.px2vp(this.displayInfo.width) : 0
93.   }

94.   /**
95.    * 获取屏幕高度，单位vp
96.    */
97.   getDisplayHeight(): number {
98.     return this.displayInfo != null ? this.uiContext.px2vp(this.displayInfo.height) : 0
99.   }

100.   /**
101.    * 释放资源
102.    */
103.   release() {
104.     if (this.orientationListener) {
105.       this.orientationListener.off('change', (mediaQueryResult: mediaquery.MediaQueryResult) => {
106.         this.onPortrait(mediaQueryResult)
107.       })
108.     }
109.     if (GlobalContext.mainWin != null) {
110.       GlobalContext.mainWin.off('windowSizeChange')
111.     }
112.     WindowManager.instance = null;
113.   }
114. }

115. /**
116.  * 封装任务卡片信息数据类
117.  */
118. export class TaskData {
119.   bgColor: Color | string | Resource = Color.White;
120.   index: number = 0;
121.   taskInfo: string = 'music';

122.   constructor(bgColor: Color | string | Resource, index: number, taskInfo: string) {
123.     this.bgColor = bgColor;
124.     this.index = index;
125.     this.taskInfo = taskInfo;
126.   }
127. }

128. export const taskDataArr: Array<TaskData> =
129.   [
130.     new TaskData('#317AF7', 0, 'music'),
131.     new TaskData('#D94838', 1, 'mall'),
132.     new TaskData('#DB6B42', 2, 'photos'),
133.     new TaskData('#5BA854', 3, 'setting'),
134.     new TaskData('#317AF7', 4, 'call'),
135.     new TaskData('#D94838', 5, 'music'),
136.     new TaskData('#DB6B42', 6, 'mall'),
137.     new TaskData('#5BA854', 7, 'photos'),
138.     new TaskData('#D94838', 8, 'setting'),
139.     new TaskData('#DB6B42', 9, 'call'),
140.     new TaskData('#5BA854', 10, 'music')

141.   ];

142. @Entry
143. @Component
144. export struct TaskSwitchMainPage {
145.   displayWidth: number = WindowManager.getInstance(this.getUIContext()).getDisplayWidth();
146.   scroller: Scroller = new Scroller();
147.   cardSpace: number = 0; // 卡片间距
148.   cardWidth: number = this.displayWidth / 2 - this.cardSpace / 2; // 卡片宽度
149.   cardHeight: number = 400; // 卡片高度
150.   cardPosition: Array<number> = []; // 卡片初始位置
151.   clickIndex: boolean = false;
152.   @State taskViewOffsetX: number = 0;
153.   @State cardOffset: number = this.displayWidth / 4;
154.   lastCardOffset: number = this.cardOffset;
155.   startTime: number | undefined = undefined

156.   // 每个卡片初始位置
157.   aboutToAppear() {
158.     for (let i = 0; i < taskDataArr.length; i++) {
159.       this.cardPosition[i] = i * (this.cardWidth + this.cardSpace);
160.     }
161.   }

162.   // 每个卡片位置
163.   getProgress(index: number): number {
164.     let progress = (this.cardOffset + this.cardPosition[index] - this.taskViewOffsetX + this.cardWidth / 2) / this.displayWidth;
165.     return progress
166.   }

167.   build() {
168.     Stack({ alignContent: Alignment.Bottom }) {
169.       // 背景
170.       Column()
171.         .width('100%')
172.         .height('100%')
173.         .backgroundColor(0xF0F0F0)

174.       // 滑动组件
175.       Scroll(this.scroller) {
176.         Row({ space: this.cardSpace }) {
177.           ForEach(taskDataArr, (item: TaskData, index) => {
178.             Column()
179.               .width(this.cardWidth)
180.               .height(this.cardHeight)
181.               .backgroundColor(item.bgColor)
182.               .borderStyle(BorderStyle.Solid)
183.               .borderWidth(1)
184.               .borderColor(0xAFEEEE)
185.               .borderRadius(15)
186.                 // 计算子组件的仿射属性
187.               .scale((this.getProgress(index) >= 0.4 && this.getProgress(index) <= 0.6) ?
188.                 {
189.                   x: 1.1 - Math.abs(0.5 - this.getProgress(index)),
190.                   y: 1.1 - Math.abs(0.5 - this.getProgress(index))
191.                 } :
192.                 { x: 1, y: 1 })
193.               .animation({ curve: Curve.Smooth })
194.                 // 滑动动画
195.               .translate({ x: this.cardOffset })
196.               .animation({ curve: curves.springMotion() })
197.               .zIndex((this.getProgress(index) >= 0.4 && this.getProgress(index) <= 0.6) ? 2 : 1)
198.           }, (item: TaskData) => item.toString())
199.         }
200.         .width((this.cardWidth + this.cardSpace) * (taskDataArr.length + 1))
201.         .height('100%')
202.       }
203.       .gesture(
204.         GestureGroup(GestureMode.Parallel,
205.           PanGesture({ direction: PanDirection.Horizontal, distance: 5 })
206.             .onActionStart((event: GestureEvent | undefined) => {
207.               if (event) {
208.                 this.startTime = event.timestamp;
209.               }
210.             })
211.             .onActionUpdate((event: GestureEvent | undefined) => {
212.               if (event) {
213.                 this.cardOffset = this.lastCardOffset + event.offsetX;
214.               }
215.             })
216.             .onActionEnd((event: GestureEvent | undefined) => {
217.               if (event) {
218.                 let time = 0
219.                 if (this.startTime) {
220.                   time = event.timestamp - this.startTime;
221.                 }
222.                 let speed = event.offsetX / (time / 1000000000);
223.                 let moveX = Math.pow(speed, 2) / 7000 * (speed > 0 ? 1 : -1);

224.                 this.cardOffset += moveX;
225.                 // 左滑大于最右侧位置
226.                 let cardOffsetMax = -(taskDataArr.length - 1) * (this.displayWidth / 2);
227.                 if (this.cardOffset < cardOffsetMax) {
228.                   this.cardOffset = cardOffsetMax;
229.                 }
230.                 // 右滑大于最左侧位置
231.                 if (this.cardOffset > this.displayWidth / 4) {
232.                   this.cardOffset = this.displayWidth / 4;
233.                 }

234.                 // 左右滑动距离不满足/满足切换关系时，补位/退回
235.                 let remainMargin = this.cardOffset % (this.displayWidth / 2);
236.                 if (remainMargin < 0) {
237.                   remainMargin = this.cardOffset % (this.displayWidth / 2) + this.displayWidth / 2;
238.                 }
239.                 if (remainMargin <= this.displayWidth / 4) {
240.                   this.cardOffset += this.displayWidth / 4 - remainMargin;
241.                 } else {
242.                   this.cardOffset -= this.displayWidth / 4 - (this.displayWidth / 2 - remainMargin);
243.                 }

244.                 // 记录本次滑动偏移量
245.                 this.lastCardOffset = this.cardOffset;
246.               }
247.             })
248.         ), GestureMask.IgnoreInternal)
249.       .scrollable(ScrollDirection.Horizontal)
250.       .scrollBar(BarState.Off)

251.       // 滑动到首尾位置
252.       Button('Move to first/last')
253.         .backgroundColor(0x888888)
254.         .margin({ bottom: 30 })
255.         .onClick(() => {
256.           this.clickIndex = !this.clickIndex;

257.           if (this.clickIndex) {
258.             this.cardOffset = this.displayWidth / 4;
259.           } else {
260.             this.cardOffset = this.displayWidth / 4 - (taskDataArr.length - 1) * this.displayWidth / 2;
261.           }
262.           this.lastCardOffset = this.cardOffset;
263.         })
264.     }
265.     .width('100%')
266.     .height('100%')
267.   }
268. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163958.04376694864743590252857681818047:50001231000000:2800:3CD65768366AA9CF91D80740C0C3DFED0FA16BF7AAD5B2F73213ECC4239E418C.gif)

通过animateTo可以实现将List中指定的Item替换到首位，List中其余Item依次向下排列。定制List组件动态替换动效的示例代码和效果如下。

1. import { curves, AnimatorResult } from '@kit.ArkUI';

2. // 该接口控制列表项视觉属性
3. class ListItemModify implements AttributeModifier<ListItemAttribute> {
4.   public offsetY: number = 0;

5.   applyNormalAttribute(instance: ListItemAttribute): void {
6.     instance.translate({ y: this.offsetY }) // Y轴位移
7.   }
8. }

9. @Observed
10. class DragSortCtrl<T> {
11.   private arr: Array<T>
12.   private modify: Array<ListItemModify>
13.   private uiContext: UIContext; // 新增UIContext成员
14.   private dragRefOffset: number = 0
15.   offsetY: number = 0
16.   private ITEM_INTV: number = 0

17.   constructor(arr: Array<T>, intv: number, uiContext: UIContext) {
18.     this.arr = arr;
19.     this.uiContext = uiContext;
20.     this.modify = new Array<ListItemModify>()
21.     this.ITEM_INTV = intv
22.     arr.forEach(() => {
23.       this.modify.push(new ListItemModify())
24.     })
25.   }

26.   itemMove(index: number, newIndex: number): void {
27.     let tmp = this.arr.splice(index, 1) // 移除当前传入的index
28.     this.arr.splice(newIndex, 0, tmp[0]) // 将当前移除的index插入到数组前一个位置
29.     let tmp2 = this.modify.splice(index, 1)
30.     this.modify.splice(newIndex, 0, tmp2[0])
31.   }

32.   setDragRef(item: T): void {
33.     this.dragRefOffset = 0
34.   }

35.   onMove(item: T, offset: number) {
36.     this.offsetY = offset - this.dragRefOffset // 逐帧计算传入的offect，每满足一个item高度时，进入下方if逻辑，更新dragRefOffset的值
37.     let index = this.arr.indexOf(item) // 在数组中查找传入的item
38.     this.modify[index].offsetY = this.offsetY
39.     if (this.offsetY < -this.ITEM_INTV / 2) { // 通过判断使指定的item逐一移动到首位
40.       // 使用interpolatingSpring曲线生成弹簧动画
41.       this.uiContext.animateTo({ curve: curves.interpolatingSpring(0, 1, 400, 38) }, () => {
42.         this.offsetY += this.ITEM_INTV // 调整偏移量实现平滑移动
43.         this.dragRefOffset -= this.ITEM_INTV // 移动的总偏移量
44.         console.info(`item offsetY ${this.offsetY} dragRefOffset ${this.dragRefOffset}`);
45.         this.itemMove(index, index - 1) // 执行列表项位置交换
46.       })
47.     }
48.   }

49.   getModify(item: T): ListItemModify {
50.     let index = this.arr.indexOf(item)
51.     return this.modify[index]
52.   }
53. }

54. @Entry
55. @Component
56. struct ListAutoSortExample {
57.   @State private arr: Array<number> = [0, 1, 2, 3, 4, 5]
58.   @State dragSortCtrl: DragSortCtrl<number> = new DragSortCtrl<number>(this.arr, 120, this.getUIContext())
59.   @State firstListItemGroupCount: number = 3
60.   private listScroll: ListScroller = new ListScroller()
61.   private backAnimator: AnimatorResult | null = null

62.   @Builder
63.   itemEnd(item: number, index: number) {
64.     Row() {
65.       Button("To TOP").margin("4vp").onClick(() => {
66.         console.info(`item number item ${item} index ${index}`);
67.         this.listScroll.closeAllSwipeActions({
68.           onFinish: () => {
69.             this.dragSortCtrl.setDragRef(item)
70.             let length = 120 * (this.arr.indexOf(item))
71.             this.backAnimator = this.getUIContext()?.createAnimator({ // 创建弹簧动画
72.               duration: 1000,
73.               easing: "interpolating-spring(0, 1, 150, 24)",
74.               delay: 0,
75.               fill: "none",
76.               direction: "normal",
77.               iterations: 1,
78.               begin: 0,
79.               end: -length
80.             })
81.             this.backAnimator.onFrame = (value) => { // 逐帧回调更新位置
82.               this.dragSortCtrl.onMove(item, value) // 处理list的移动替换动效
83.             }
84.             this.backAnimator.onFinish = () => {}
85.             this.backAnimator.play() // 启动动画
86.           }
87.         })
88.       })
89.     }.padding("4vp").justifyContent(FlexAlign.SpaceEvenly)
90.   }

91.   @Builder
92.   header(title: string) {
93.     Row() {
94.       Text(title)
95.     }
96.   }

97.   build() {
98.     Row() {
99.       Column() {
100.         List({ space: 20, scroller: this.listScroll }) {
101.           ListItemGroup({ header: this.header('first ListItemGroup'), space: 20 }) {
102.             ForEach(this.arr, (item: number, index) => {
103.               if (index < this.firstListItemGroupCount) {
104.                 ListItem() {
105.                   Text('' + item)
106.                     .width('100%')
107.                     .height(100)
108.                     .fontSize(16)
109.                     .borderRadius(10)
110.                     .textAlign(TextAlign.Center)
111.                     .backgroundColor(0xFFFFFF)
112.                 }
113.                 .swipeAction({
114.                   end: this.itemEnd(item, index)
115.                 })
116.                 .clip(true)
117.                 .attributeModifier(this.dragSortCtrl.getModify(item)) // 动态设置属性修改
118.                 .borderRadius(10)
119.                 .margin({ left: 20, right: 20 })
120.               }
121.             })
122.           }
123.           ListItemGroup({ header: this.header('second ListItemGroup'), space: 20 }) {
124.             ForEach(this.arr, (item: number, index) => {
125.               if (index > this.firstListItemGroupCount - 1) {
126.                 ListItem() {
127.                   Text('' + item)
128.                     .width('100%')
129.                     .height(100)
130.                     .fontSize(16)
131.                     .borderRadius(10)
132.                     .textAlign(TextAlign.Center)
133.                     .backgroundColor(0xFFFFFF)
134.                 }
135.                 .swipeAction({
136.                   end: this.itemEnd(item, index)
137.                 })
138.                 .clip(true)
139.                 .attributeModifier(this.dragSortCtrl.getModify(item))
140.                 .borderRadius(10)
141.                 .margin({ left: 20, right: 20 })
142.               }
143.             })
144.           }
145.         }
146.         .padding({ top: 20 })
147.         .height("100%")
148.       }
149.     }.backgroundColor(0xDCDCDC)
150.   }
151. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163958.21510600702767326847769447368826:50001231000000:2800:1015C7DCB44259A11CF2AEF94F6C48E8E78F7AFCFA589CBF4785074E272A7046.gif)

## 示例代码

- [动效案例合集](https://gitcode.com/harmonyos_samples/animation-collection)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-particle-animation "粒子动画")
# 动画衔接

更新时间: 2025-12-16 16:40

UI界面除了运行动画之外，还承载着与用户进行实时交互的功能。当用户行为根据意图变化发生改变时，UI界面应做到即时响应。例如用户在应用启动过程中，上滑退出，那么启动动画应该立即过渡到退出动画，而不应该等启动动画完成后再退出，从而减少用户等待时间。对于桌面翻页类从跟手到离手触发动画的场景，离手后动画的初始速度应承继手势速度，避免由于速度不接续导致停顿感的产生。针对以上场景，系统已提供动画与动画、手势与动画之间的衔接能力，保证各类场景下动画平稳光滑地过渡的同时，尽可能降低开发难度。

假设对于某一可动画属性，存在正在运行的动画。当UI侧行为改变该属性终点值时，开发者仅需在[animateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation)动画闭包中改变属性值或者改变[animation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)接口作用的属性值，即可产生动画。系统会自动衔接之前的动画和当前的动画，开发者仅需要关注当前单次动画的实现。

示例如下。通过点击click，红色方块的缩放属性会发生变化。当连续快速点击click时，缩放属性的终点值连续发生变化，当前动画也会平滑过渡到朝着新的缩放属性终点值运动。

1. import { curves } from '@kit.ArkUI';

2. class SetAnimationVariables {
3.   isAnimation: boolean = true

4.   set(): void {
5.     this.isAnimation = !this.isAnimation;
6.   }
7. }

8. @Entry
9. @Component
10. struct AnimationToAnimationDemo {
11.   // 第一步：声明相关状态变量
12.   @State animationController: SetAnimationVariables = new SetAnimationVariables();

13.   build() {
14.     Column() {
15.       Text('ArkUI')
16.         .fontWeight(FontWeight.Bold)
17.         .fontSize(12)
18.         .fontColor(Color.White)
19.         .textAlign(TextAlign.Center)
20.         .borderRadius(10)
21.         .backgroundColor(0xf56c6c)
22.         .width(100)
23.         .height(100)
24.         .scale({
25.           // 第二步：将状态变量设置到相关可动画属性接口
26.           x: this.animationController.isAnimation ? 2 : 1,
27.           y: this.animationController.isAnimation ? 2 : 1
28.         })
29.         .animation({ curve: curves.springMotion(0.4, 0.8) }) // 第四步：通过animation接口开启动画，动画终点值改变时，系统自动添加衔接动画

30.       Button('Click')
31.         .margin({ top: 200 })
32.         .onClick(() => {
33.           // 第三步：通过点击事件改变状态变量值，影响可动画属性值
34.           this.animationController.set()
35.         })
36.     }
37.     .width('100%')
38.     .height('100%')
39.     .justifyContent(FlexAlign.Center)
40.   }
41. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.39327555370094609725779269563676:50001231000000:2800:DAB3F64524CA80256899BA20871519EF0D21501086079C147F68D81C5B57E1BC.gif)

## 手势与动画的衔接

使用滑动、捏合、旋转等手势的场景中，跟手过程中一般会触发属性的改变。离手后，这部分属性往往会继续发生变化，直到到达属性终点值。

离手阶段的属性变化初始速度应与离手前一刻的属性改变速度保持一致。如果离手后属性变化速度从0开始，就好像正在运行的汽车紧急刹车，造成观感上的骤变是用户和开发者都不希望看到的。

针对在[TapGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-tapgesture)和[动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animation)之间进行衔接的场景（如列表滑动），可以在跟手阶段每一次更改组件属性时，都使用跟手弹簧曲线的属性动画。离手时再用离手弹簧曲线产生离手阶段的属性动画。对于采用[springMotion](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-curve#curvesspringmotion9)曲线的动画，离手阶段动画将自动继承跟手阶段动画的速度，并以跟手动画当前位置为起点，运动到指定的属性终点。

示例代码如下，小球跟手运动。

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct SpringMotionDemo {
5.   // 第一步：声明相关状态变量
6.   @State positionX: number = 100;
7.   @State positionY: number = 100;
8.   diameter: number = 50;

9.   build() {
10.     Column() {
11.       Row() {
12.         Circle({ width: this.diameter, height: this.diameter })
13.           .fill(Color.Blue)
14.           .position({ x: this.positionX, y: this.positionY })// 第二步：将状态变量设置到相关可动画属性接口
15.           .onTouch((event?: TouchEvent) => {
16.             // 第三步：在跟手过程改变状态变量值，并且采用responsiveSpringMotion动画运动到新的值
17.             if (event) {
18.               if (event.type === TouchType.Move) {
19.                 // 跟手过程，使用responsiveSpringMotion曲线
20.                 this.getUIContext()?.animateTo({ curve: curves.responsiveSpringMotion() }, () => {
21.                   // 减去半径，以使球的中心运动到手指位置
22.                   this.positionX = event.touches[0].windowX - this.diameter / 2;
23.                   this.positionY = event.touches[0].windowY - this.diameter / 2;
24.                   console.info(`move, animateTo x:${this.positionX}, y:${this.positionY}`);
25.                 })
26.               } else if (event.type === TouchType.Up) {
27.                 // 第四步：在离手过程设定状态变量终点值，并且用springMotion动画运动到新的值，springMotion动画将继承跟手阶段的动画速度
28.                 this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
29.                   this.positionX = 100;
30.                   this.positionY = 100;
31.                   console.info(`touchUp, animateTo x:100, y:100`);
32.                 })
33.               }
34.             }
35.           })
36.       }
37.       .width("100%").height("80%")
38.       .clip(true) // 如果球超出父组件范围，使球不可见
39.       .backgroundColor(Color.Orange)

40.       Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Start, justifyContent: FlexAlign.Center }) {
41.         Text("拖动小球").fontSize(16)
42.       }
43.       .width("100%")

44.       Row() {
45.         Text('点击位置: [x: ' + Math.round(this.positionX) + ', y:' + Math.round(this.positionY) + ']').fontSize(16)
46.       }
47.       .padding(10)
48.       .width("100%")
49.     }.height('100%').width('100%')
50.   }
51. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.15017248156502437611341722077453:50001231000000:2800:DD9428C53B3EEE30168A2E20796F9237B9A4261045AC9BF75020D5772214F4F2.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-spring-curve "弹簧曲线")
# 动画衔接

更新时间: 2025-12-16 16:40

UI界面除了运行动画之外，还承载着与用户进行实时交互的功能。当用户行为根据意图变化发生改变时，UI界面应做到即时响应。例如用户在应用启动过程中，上滑退出，那么启动动画应该立即过渡到退出动画，而不应该等启动动画完成后再退出，从而减少用户等待时间。对于桌面翻页类从跟手到离手触发动画的场景，离手后动画的初始速度应承继手势速度，避免由于速度不接续导致停顿感的产生。针对以上场景，系统已提供动画与动画、手势与动画之间的衔接能力，保证各类场景下动画平稳光滑地过渡的同时，尽可能降低开发难度。

假设对于某一可动画属性，存在正在运行的动画。当UI侧行为改变该属性终点值时，开发者仅需在[animateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation)动画闭包中改变属性值或者改变[animation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)接口作用的属性值，即可产生动画。系统会自动衔接之前的动画和当前的动画，开发者仅需要关注当前单次动画的实现。

示例如下。通过点击click，红色方块的缩放属性会发生变化。当连续快速点击click时，缩放属性的终点值连续发生变化，当前动画也会平滑过渡到朝着新的缩放属性终点值运动。

1. import { curves } from '@kit.ArkUI';

2. class SetAnimationVariables {
3.   isAnimation: boolean = true

4.   set(): void {
5.     this.isAnimation = !this.isAnimation;
6.   }
7. }

8. @Entry
9. @Component
10. struct AnimationToAnimationDemo {
11.   // 第一步：声明相关状态变量
12.   @State animationController: SetAnimationVariables = new SetAnimationVariables();

13.   build() {
14.     Column() {
15.       Text('ArkUI')
16.         .fontWeight(FontWeight.Bold)
17.         .fontSize(12)
18.         .fontColor(Color.White)
19.         .textAlign(TextAlign.Center)
20.         .borderRadius(10)
21.         .backgroundColor(0xf56c6c)
22.         .width(100)
23.         .height(100)
24.         .scale({
25.           // 第二步：将状态变量设置到相关可动画属性接口
26.           x: this.animationController.isAnimation ? 2 : 1,
27.           y: this.animationController.isAnimation ? 2 : 1
28.         })
29.         .animation({ curve: curves.springMotion(0.4, 0.8) }) // 第四步：通过animation接口开启动画，动画终点值改变时，系统自动添加衔接动画

30.       Button('Click')
31.         .margin({ top: 200 })
32.         .onClick(() => {
33.           // 第三步：通过点击事件改变状态变量值，影响可动画属性值
34.           this.animationController.set()
35.         })
36.     }
37.     .width('100%')
38.     .height('100%')
39.     .justifyContent(FlexAlign.Center)
40.   }
41. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.39327555370094609725779269563676:50001231000000:2800:DAB3F64524CA80256899BA20871519EF0D21501086079C147F68D81C5B57E1BC.gif)

## 手势与动画的衔接

使用滑动、捏合、旋转等手势的场景中，跟手过程中一般会触发属性的改变。离手后，这部分属性往往会继续发生变化，直到到达属性终点值。

离手阶段的属性变化初始速度应与离手前一刻的属性改变速度保持一致。如果离手后属性变化速度从0开始，就好像正在运行的汽车紧急刹车，造成观感上的骤变是用户和开发者都不希望看到的。

针对在[TapGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-tapgesture)和[动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animation)之间进行衔接的场景（如列表滑动），可以在跟手阶段每一次更改组件属性时，都使用跟手弹簧曲线的属性动画。离手时再用离手弹簧曲线产生离手阶段的属性动画。对于采用[springMotion](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-curve#curvesspringmotion9)曲线的动画，离手阶段动画将自动继承跟手阶段动画的速度，并以跟手动画当前位置为起点，运动到指定的属性终点。

示例代码如下，小球跟手运动。

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct SpringMotionDemo {
5.   // 第一步：声明相关状态变量
6.   @State positionX: number = 100;
7.   @State positionY: number = 100;
8.   diameter: number = 50;

9.   build() {
10.     Column() {
11.       Row() {
12.         Circle({ width: this.diameter, height: this.diameter })
13.           .fill(Color.Blue)
14.           .position({ x: this.positionX, y: this.positionY })// 第二步：将状态变量设置到相关可动画属性接口
15.           .onTouch((event?: TouchEvent) => {
16.             // 第三步：在跟手过程改变状态变量值，并且采用responsiveSpringMotion动画运动到新的值
17.             if (event) {
18.               if (event.type === TouchType.Move) {
19.                 // 跟手过程，使用responsiveSpringMotion曲线
20.                 this.getUIContext()?.animateTo({ curve: curves.responsiveSpringMotion() }, () => {
21.                   // 减去半径，以使球的中心运动到手指位置
22.                   this.positionX = event.touches[0].windowX - this.diameter / 2;
23.                   this.positionY = event.touches[0].windowY - this.diameter / 2;
24.                   console.info(`move, animateTo x:${this.positionX}, y:${this.positionY}`);
25.                 })
26.               } else if (event.type === TouchType.Up) {
27.                 // 第四步：在离手过程设定状态变量终点值，并且用springMotion动画运动到新的值，springMotion动画将继承跟手阶段的动画速度
28.                 this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
29.                   this.positionX = 100;
30.                   this.positionY = 100;
31.                   console.info(`touchUp, animateTo x:100, y:100`);
32.                 })
33.               }
34.             }
35.           })
36.       }
37.       .width("100%").height("80%")
38.       .clip(true) // 如果球超出父组件范围，使球不可见
39.       .backgroundColor(Color.Orange)

40.       Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Start, justifyContent: FlexAlign.Center }) {
41.         Text("拖动小球").fontSize(16)
42.       }
43.       .width("100%")

44.       Row() {
45.         Text('点击位置: [x: ' + Math.round(this.positionX) + ', y:' + Math.round(this.positionY) + ']').fontSize(16)
46.       }
47.       .padding(10)
48.       .width("100%")
49.     }.height('100%').width('100%')
50.   }
51. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.15017248156502437611341722077453:50001231000000:2800:DD9428C53B3EEE30168A2E20796F9237B9A4261045AC9BF75020D5772214F4F2.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-spring-curve "弹簧曲线")
# 动画衔接

更新时间: 2025-12-16 16:40

UI界面除了运行动画之外，还承载着与用户进行实时交互的功能。当用户行为根据意图变化发生改变时，UI界面应做到即时响应。例如用户在应用启动过程中，上滑退出，那么启动动画应该立即过渡到退出动画，而不应该等启动动画完成后再退出，从而减少用户等待时间。对于桌面翻页类从跟手到离手触发动画的场景，离手后动画的初始速度应承继手势速度，避免由于速度不接续导致停顿感的产生。针对以上场景，系统已提供动画与动画、手势与动画之间的衔接能力，保证各类场景下动画平稳光滑地过渡的同时，尽可能降低开发难度。

假设对于某一可动画属性，存在正在运行的动画。当UI侧行为改变该属性终点值时，开发者仅需在[animateTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation)动画闭包中改变属性值或者改变[animation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)接口作用的属性值，即可产生动画。系统会自动衔接之前的动画和当前的动画，开发者仅需要关注当前单次动画的实现。

示例如下。通过点击click，红色方块的缩放属性会发生变化。当连续快速点击click时，缩放属性的终点值连续发生变化，当前动画也会平滑过渡到朝着新的缩放属性终点值运动。

1. import { curves } from '@kit.ArkUI';

2. class SetAnimationVariables {
3.   isAnimation: boolean = true

4.   set(): void {
5.     this.isAnimation = !this.isAnimation;
6.   }
7. }

8. @Entry
9. @Component
10. struct AnimationToAnimationDemo {
11.   // 第一步：声明相关状态变量
12.   @State animationController: SetAnimationVariables = new SetAnimationVariables();

13.   build() {
14.     Column() {
15.       Text('ArkUI')
16.         .fontWeight(FontWeight.Bold)
17.         .fontSize(12)
18.         .fontColor(Color.White)
19.         .textAlign(TextAlign.Center)
20.         .borderRadius(10)
21.         .backgroundColor(0xf56c6c)
22.         .width(100)
23.         .height(100)
24.         .scale({
25.           // 第二步：将状态变量设置到相关可动画属性接口
26.           x: this.animationController.isAnimation ? 2 : 1,
27.           y: this.animationController.isAnimation ? 2 : 1
28.         })
29.         .animation({ curve: curves.springMotion(0.4, 0.8) }) // 第四步：通过animation接口开启动画，动画终点值改变时，系统自动添加衔接动画

30.       Button('Click')
31.         .margin({ top: 200 })
32.         .onClick(() => {
33.           // 第三步：通过点击事件改变状态变量值，影响可动画属性值
34.           this.animationController.set()
35.         })
36.     }
37.     .width('100%')
38.     .height('100%')
39.     .justifyContent(FlexAlign.Center)
40.   }
41. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.39327555370094609725779269563676:50001231000000:2800:DAB3F64524CA80256899BA20871519EF0D21501086079C147F68D81C5B57E1BC.gif)

## 手势与动画的衔接

使用滑动、捏合、旋转等手势的场景中，跟手过程中一般会触发属性的改变。离手后，这部分属性往往会继续发生变化，直到到达属性终点值。

离手阶段的属性变化初始速度应与离手前一刻的属性改变速度保持一致。如果离手后属性变化速度从0开始，就好像正在运行的汽车紧急刹车，造成观感上的骤变是用户和开发者都不希望看到的。

针对在[TapGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-tapgesture)和[动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animation)之间进行衔接的场景（如列表滑动），可以在跟手阶段每一次更改组件属性时，都使用跟手弹簧曲线的属性动画。离手时再用离手弹簧曲线产生离手阶段的属性动画。对于采用[springMotion](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-curve#curvesspringmotion9)曲线的动画，离手阶段动画将自动继承跟手阶段动画的速度，并以跟手动画当前位置为起点，运动到指定的属性终点。

示例代码如下，小球跟手运动。

1. import { curves } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct SpringMotionDemo {
5.   // 第一步：声明相关状态变量
6.   @State positionX: number = 100;
7.   @State positionY: number = 100;
8.   diameter: number = 50;

9.   build() {
10.     Column() {
11.       Row() {
12.         Circle({ width: this.diameter, height: this.diameter })
13.           .fill(Color.Blue)
14.           .position({ x: this.positionX, y: this.positionY })// 第二步：将状态变量设置到相关可动画属性接口
15.           .onTouch((event?: TouchEvent) => {
16.             // 第三步：在跟手过程改变状态变量值，并且采用responsiveSpringMotion动画运动到新的值
17.             if (event) {
18.               if (event.type === TouchType.Move) {
19.                 // 跟手过程，使用responsiveSpringMotion曲线
20.                 this.getUIContext()?.animateTo({ curve: curves.responsiveSpringMotion() }, () => {
21.                   // 减去半径，以使球的中心运动到手指位置
22.                   this.positionX = event.touches[0].windowX - this.diameter / 2;
23.                   this.positionY = event.touches[0].windowY - this.diameter / 2;
24.                   console.info(`move, animateTo x:${this.positionX}, y:${this.positionY}`);
25.                 })
26.               } else if (event.type === TouchType.Up) {
27.                 // 第四步：在离手过程设定状态变量终点值，并且用springMotion动画运动到新的值，springMotion动画将继承跟手阶段的动画速度
28.                 this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
29.                   this.positionX = 100;
30.                   this.positionY = 100;
31.                   console.info(`touchUp, animateTo x:100, y:100`);
32.                 })
33.               }
34.             }
35.           })
36.       }
37.       .width("100%").height("80%")
38.       .clip(true) // 如果球超出父组件范围，使球不可见
39.       .backgroundColor(Color.Orange)

40.       Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Start, justifyContent: FlexAlign.Center }) {
41.         Text("拖动小球").fontSize(16)
42.       }
43.       .width("100%")

44.       Row() {
45.         Text('点击位置: [x: ' + Math.round(this.positionX) + ', y:' + Math.round(this.positionY) + ']').fontSize(16)
46.       }
47.       .padding(10)
48.       .width("100%")
49.     }.height('100%').width('100%')
50.   }
51. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.15017248156502437611341722077453:50001231000000:2800:DD9428C53B3EEE30168A2E20796F9237B9A4261045AC9BF75020D5772214F4F2.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-spring-curve "弹簧曲线")
# 帧动画（ohos.animator）

更新时间: 2025-12-16 16:40

帧动画具备逐帧回调的特性，便于开发者在每一帧中处理需调整的属性。通过向应用提供onFrame逐帧回调，帧动画使开发者能够在应用的每一帧设置属性值，从而实现组件属性值变化的自然过渡，营造出动画效果。帧动画接口详情可参考[@ohos.animator (动画)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-animator)。

与属性动画相比，帧动画能让开发者实时感知动画进程，即时调整UI值，具备事件即时响应和可暂停的优势，但在性能上略逊于属性动画。当属性动画能满足需求时，建议优先采用属性动画接口实现。属性动画接口可参考[实现属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis)。

|名称|实现方式|事件响应方式|可暂停|性能|
|:--|:--|:--|:--|:--|
|帧动画（ohos.animator）|开发者可每帧修改UI侧属性值，UI侧属性实时更新|实时响应|是|较差|
|属性动画|UI侧只计算动画最终状态，动画过程为渲染值在改变，UI侧一直为动画最终状态，不感知实时渲染值|按最终状态响应|否|较好|

如图所示，帧动画在动画过程中即可实时响应，而属性动画按最终状态响应。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.43222992106272924261018710616931:50001231000000:2800:8B5303C8EDA987BD488283B986ADEB6EBA2C70DA7E41AD9B208CD9238E917779.gif)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.13753761793821775371334758444016:50001231000000:2800:6E99E349ABB35971996874F1C54E897D7B4E265105E1EDF8DEE255BFCF6CE759.gif)

## 使用帧动画实现动画效果

使用如下步骤可以创建一个简单的animator，并且在每个帧回调中打印当前插值。

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 创建执行动画的对象。
    
    1. // 创建动画的初始参数
    2. let options: AnimatorOptions = {
    3.   duration: 1500,
    4.   easing: "friction",
    5.   delay: 0,
    6.   fill: "forwards",
    7.   direction: "normal",
    8.   iterations: 2,
    9.   // 动画onFrame 插值首帧值
    10.   begin: 200.0,
    11.   // 动画onFrame 插值尾帧值
    12.   end: 400.0
    13. };
    14. let result: AnimatorResult = this.getUIContext().createAnimator(options);
    15. // 设置接收到帧时回调，动画播放过程中每帧会调用onFrame回调
    16. result.onFrame = (value: number) => {
    17.   console.info("current value is :" + value);
    18. }
    
3. 播放动画。
    
    1. // 播放动画
    2. result.play();
    
4. 动画执行完成后手动释放AnimatorResult对象。
    
    1. // 释放动画对象
    2. result = undefined;
    

## 使用帧动画实现小球抛物运动

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 定义要做动画的组件。
    
    1. Button()
    2.   .width(60)
    3.   .height(60)
    4.   .translate({ x: this.translateX, y: this.translateY })
    
3. 在onPageShow中创建AnimatorResult对象。
    
    1. onPageShow(): void {
    2.   //创建animatorResult对象
    3.   this.animatorOptions = this.getUIContext().createAnimator(options);
    4.   this.animatorOptions.onFrame = (progress: number) => {
    5.     this.translateX = progress;
    6.     if (progress > this.topWidth && this.translateY < this.bottomHeight) {
    7.       this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
    8.     }
    9.   }
    10.   //动画取消时执行方法
    11.   this.animatorOptions.onCancel = () => {
    12.     this.animatorStatus = '取消';
    13.   }
    14.   //动画完成时执行方法
    15.   this.animatorOptions.onFinish = () => {
    16.     this.animatorStatus = '完成';
    17.   }
    18.   //动画重复播放时执行方法
    19.   this.animatorOptions.onRepeat = () => {
    20.     console.info("动画重复播放");
    21.   }
    22. }
    
4. 定义动画播放，重置，暂停的按钮。
    
    1. Button('播放').onClick(() => {
    2.   this.animatorOptions?.play();
    3.   this.animatorStatus = '播放中'
    4. }).width(80).height(35)
    5. Button("重置").onClick(() => {
    6.   this.translateX = 0;
    7.   this.translateY = 0;
    8. }).width(80).height(35)
    9. Button("暂停").onClick(() => {
    10.   this.animatorOptions?.pause();
    11.   this.animatorStatus = '暂停'
    12. }).width(80).height(35)
    
5. 在页面隐藏或销毁的生命周期中释放动画对象，避免内存泄漏。
    
    1. onPageHide(): void {
    2.   this.animatorOptions = undefined;
    3. }
    

完整示例如下。

1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct Index {
5.   @State animatorResult: AnimatorResult | undefined = undefined;
6.   @State animatorStatus: string = '创建';
7.   begin: number = 0;
8.   end: number = 300;
9.   topWidth: number = 150;
10.   bottomHeight: number = 100;
11.   g: number = 0.18;
12.   animatorOption: AnimatorOptions = {
13.     duration: 4000,
14.     delay: 0,
15.     easing: 'linear',
16.     iterations: 1,
17.     fill: "forwards",
18.     direction: 'normal',
19.     begin: this.begin,
20.     end: this.end
21.   };
22.   @State translateX: number = 0;
23.   @State translateY: number = 0;

24.   onPageShow(): void {
25.     this.animatorResult = this.getUIContext().createAnimator(this.animatorOption)
26.     this.animatorResult.onFrame = (progress: number) => {
27.       this.translateX = progress;
28.       if (progress > this.topWidth && this.translateY < this.bottomHeight) {
29.         this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
30.       }
31.     }
32.     this.animatorResult.onCancel = () => {
33.       this.animatorStatus = '取消';
34.     }
35.     this.animatorResult.onFinish = () => {
36.       this.animatorStatus = '完成';
37.     }
38.     this.animatorResult.onRepeat = () => {
39.       console.info("动画重复播放");
40.     }
41.   }

42.   onPageHide(): void {
43.     this.animatorResult = undefined;
44.   }

45.   build() {
46.     Column() {
47.       Column({ space: 30 }) {
48.         Button('播放').onClick(() => {
49.           this.animatorResult?.play();
50.           this.animatorStatus = '播放中';
51.         }).width(80).height(35)
52.         Button("重置").onClick(() => {
53.           this.translateX = 0;
54.           this.translateY = 0;
55.         }).width(80).height(35)
56.         Button("暂停").onClick(() => {
57.           this.animatorResult?.pause();
58.           this.animatorStatus = '暂停';
59.         }).width(80).height(35)
60.       }.width("100%").height('25%')

61.       Stack() {
62.         Button()
63.           .width(60)
64.           .height(60)
65.           .translate({ x: this.translateX, y: this.translateY })
66.       }
67.       .width("100%")
68.       .height('45%')
69.       .align(Alignment.Start)

70.       Text("当前动画状态为:" + this.animatorStatus)
71.     }.width("100%").height('100%')
72.   }
73. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.31586158596057301415786743100081:50001231000000:2800:AE011168DC66B2509E35663DB18FD25401254923736E07D01477063D758FD35B.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-color-effect "色彩")
# 帧动画（ohos.animator）

更新时间: 2025-12-16 16:40

帧动画具备逐帧回调的特性，便于开发者在每一帧中处理需调整的属性。通过向应用提供onFrame逐帧回调，帧动画使开发者能够在应用的每一帧设置属性值，从而实现组件属性值变化的自然过渡，营造出动画效果。帧动画接口详情可参考[@ohos.animator (动画)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-animator)。

与属性动画相比，帧动画能让开发者实时感知动画进程，即时调整UI值，具备事件即时响应和可暂停的优势，但在性能上略逊于属性动画。当属性动画能满足需求时，建议优先采用属性动画接口实现。属性动画接口可参考[实现属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis)。

|名称|实现方式|事件响应方式|可暂停|性能|
|:--|:--|:--|:--|:--|
|帧动画（ohos.animator）|开发者可每帧修改UI侧属性值，UI侧属性实时更新|实时响应|是|较差|
|属性动画|UI侧只计算动画最终状态，动画过程为渲染值在改变，UI侧一直为动画最终状态，不感知实时渲染值|按最终状态响应|否|较好|

如图所示，帧动画在动画过程中即可实时响应，而属性动画按最终状态响应。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.43222992106272924261018710616931:50001231000000:2800:8B5303C8EDA987BD488283B986ADEB6EBA2C70DA7E41AD9B208CD9238E917779.gif)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.13753761793821775371334758444016:50001231000000:2800:6E99E349ABB35971996874F1C54E897D7B4E265105E1EDF8DEE255BFCF6CE759.gif)

## 使用帧动画实现动画效果

使用如下步骤可以创建一个简单的animator，并且在每个帧回调中打印当前插值。

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 创建执行动画的对象。
    
    1. // 创建动画的初始参数
    2. let options: AnimatorOptions = {
    3.   duration: 1500,
    4.   easing: "friction",
    5.   delay: 0,
    6.   fill: "forwards",
    7.   direction: "normal",
    8.   iterations: 2,
    9.   // 动画onFrame 插值首帧值
    10.   begin: 200.0,
    11.   // 动画onFrame 插值尾帧值
    12.   end: 400.0
    13. };
    14. let result: AnimatorResult = this.getUIContext().createAnimator(options);
    15. // 设置接收到帧时回调，动画播放过程中每帧会调用onFrame回调
    16. result.onFrame = (value: number) => {
    17.   console.info("current value is :" + value);
    18. }
    
3. 播放动画。
    
    1. // 播放动画
    2. result.play();
    
4. 动画执行完成后手动释放AnimatorResult对象。
    
    1. // 释放动画对象
    2. result = undefined;
    

## 使用帧动画实现小球抛物运动

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 定义要做动画的组件。
    
    1. Button()
    2.   .width(60)
    3.   .height(60)
    4.   .translate({ x: this.translateX, y: this.translateY })
    
3. 在onPageShow中创建AnimatorResult对象。
    
    1. onPageShow(): void {
    2.   //创建animatorResult对象
    3.   this.animatorOptions = this.getUIContext().createAnimator(options);
    4.   this.animatorOptions.onFrame = (progress: number) => {
    5.     this.translateX = progress;
    6.     if (progress > this.topWidth && this.translateY < this.bottomHeight) {
    7.       this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
    8.     }
    9.   }
    10.   //动画取消时执行方法
    11.   this.animatorOptions.onCancel = () => {
    12.     this.animatorStatus = '取消';
    13.   }
    14.   //动画完成时执行方法
    15.   this.animatorOptions.onFinish = () => {
    16.     this.animatorStatus = '完成';
    17.   }
    18.   //动画重复播放时执行方法
    19.   this.animatorOptions.onRepeat = () => {
    20.     console.info("动画重复播放");
    21.   }
    22. }
    
4. 定义动画播放，重置，暂停的按钮。
    
    1. Button('播放').onClick(() => {
    2.   this.animatorOptions?.play();
    3.   this.animatorStatus = '播放中'
    4. }).width(80).height(35)
    5. Button("重置").onClick(() => {
    6.   this.translateX = 0;
    7.   this.translateY = 0;
    8. }).width(80).height(35)
    9. Button("暂停").onClick(() => {
    10.   this.animatorOptions?.pause();
    11.   this.animatorStatus = '暂停'
    12. }).width(80).height(35)
    
5. 在页面隐藏或销毁的生命周期中释放动画对象，避免内存泄漏。
    
    1. onPageHide(): void {
    2.   this.animatorOptions = undefined;
    3. }
    

完整示例如下。

1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct Index {
5.   @State animatorResult: AnimatorResult | undefined = undefined;
6.   @State animatorStatus: string = '创建';
7.   begin: number = 0;
8.   end: number = 300;
9.   topWidth: number = 150;
10.   bottomHeight: number = 100;
11.   g: number = 0.18;
12.   animatorOption: AnimatorOptions = {
13.     duration: 4000,
14.     delay: 0,
15.     easing: 'linear',
16.     iterations: 1,
17.     fill: "forwards",
18.     direction: 'normal',
19.     begin: this.begin,
20.     end: this.end
21.   };
22.   @State translateX: number = 0;
23.   @State translateY: number = 0;

24.   onPageShow(): void {
25.     this.animatorResult = this.getUIContext().createAnimator(this.animatorOption)
26.     this.animatorResult.onFrame = (progress: number) => {
27.       this.translateX = progress;
28.       if (progress > this.topWidth && this.translateY < this.bottomHeight) {
29.         this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
30.       }
31.     }
32.     this.animatorResult.onCancel = () => {
33.       this.animatorStatus = '取消';
34.     }
35.     this.animatorResult.onFinish = () => {
36.       this.animatorStatus = '完成';
37.     }
38.     this.animatorResult.onRepeat = () => {
39.       console.info("动画重复播放");
40.     }
41.   }

42.   onPageHide(): void {
43.     this.animatorResult = undefined;
44.   }

45.   build() {
46.     Column() {
47.       Column({ space: 30 }) {
48.         Button('播放').onClick(() => {
49.           this.animatorResult?.play();
50.           this.animatorStatus = '播放中';
51.         }).width(80).height(35)
52.         Button("重置").onClick(() => {
53.           this.translateX = 0;
54.           this.translateY = 0;
55.         }).width(80).height(35)
56.         Button("暂停").onClick(() => {
57.           this.animatorResult?.pause();
58.           this.animatorStatus = '暂停';
59.         }).width(80).height(35)
60.       }.width("100%").height('25%')

61.       Stack() {
62.         Button()
63.           .width(60)
64.           .height(60)
65.           .translate({ x: this.translateX, y: this.translateY })
66.       }
67.       .width("100%")
68.       .height('45%')
69.       .align(Alignment.Start)

70.       Text("当前动画状态为:" + this.animatorStatus)
71.     }.width("100%").height('100%')
72.   }
73. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.31586158596057301415786743100081:50001231000000:2800:AE011168DC66B2509E35663DB18FD25401254923736E07D01477063D758FD35B.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-color-effect "色彩")
# 帧动画（ohos.animator）

更新时间: 2025-12-16 16:40

帧动画具备逐帧回调的特性，便于开发者在每一帧中处理需调整的属性。通过向应用提供onFrame逐帧回调，帧动画使开发者能够在应用的每一帧设置属性值，从而实现组件属性值变化的自然过渡，营造出动画效果。帧动画接口详情可参考[@ohos.animator (动画)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-animator)。

与属性动画相比，帧动画能让开发者实时感知动画进程，即时调整UI值，具备事件即时响应和可暂停的优势，但在性能上略逊于属性动画。当属性动画能满足需求时，建议优先采用属性动画接口实现。属性动画接口可参考[实现属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis)。

|名称|实现方式|事件响应方式|可暂停|性能|
|:--|:--|:--|:--|:--|
|帧动画（ohos.animator）|开发者可每帧修改UI侧属性值，UI侧属性实时更新|实时响应|是|较差|
|属性动画|UI侧只计算动画最终状态，动画过程为渲染值在改变，UI侧一直为动画最终状态，不感知实时渲染值|按最终状态响应|否|较好|

如图所示，帧动画在动画过程中即可实时响应，而属性动画按最终状态响应。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.43222992106272924261018710616931:50001231000000:2800:8B5303C8EDA987BD488283B986ADEB6EBA2C70DA7E41AD9B208CD9238E917779.gif)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.13753761793821775371334758444016:50001231000000:2800:6E99E349ABB35971996874F1C54E897D7B4E265105E1EDF8DEE255BFCF6CE759.gif)

## 使用帧动画实现动画效果

使用如下步骤可以创建一个简单的animator，并且在每个帧回调中打印当前插值。

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 创建执行动画的对象。
    
    1. // 创建动画的初始参数
    2. let options: AnimatorOptions = {
    3.   duration: 1500,
    4.   easing: "friction",
    5.   delay: 0,
    6.   fill: "forwards",
    7.   direction: "normal",
    8.   iterations: 2,
    9.   // 动画onFrame 插值首帧值
    10.   begin: 200.0,
    11.   // 动画onFrame 插值尾帧值
    12.   end: 400.0
    13. };
    14. let result: AnimatorResult = this.getUIContext().createAnimator(options);
    15. // 设置接收到帧时回调，动画播放过程中每帧会调用onFrame回调
    16. result.onFrame = (value: number) => {
    17.   console.info("current value is :" + value);
    18. }
    
3. 播放动画。
    
    1. // 播放动画
    2. result.play();
    
4. 动画执行完成后手动释放AnimatorResult对象。
    
    1. // 释放动画对象
    2. result = undefined;
    

## 使用帧动画实现小球抛物运动

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 定义要做动画的组件。
    
    1. Button()
    2.   .width(60)
    3.   .height(60)
    4.   .translate({ x: this.translateX, y: this.translateY })
    
3. 在onPageShow中创建AnimatorResult对象。
    
    1. onPageShow(): void {
    2.   //创建animatorResult对象
    3.   this.animatorOptions = this.getUIContext().createAnimator(options);
    4.   this.animatorOptions.onFrame = (progress: number) => {
    5.     this.translateX = progress;
    6.     if (progress > this.topWidth && this.translateY < this.bottomHeight) {
    7.       this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
    8.     }
    9.   }
    10.   //动画取消时执行方法
    11.   this.animatorOptions.onCancel = () => {
    12.     this.animatorStatus = '取消';
    13.   }
    14.   //动画完成时执行方法
    15.   this.animatorOptions.onFinish = () => {
    16.     this.animatorStatus = '完成';
    17.   }
    18.   //动画重复播放时执行方法
    19.   this.animatorOptions.onRepeat = () => {
    20.     console.info("动画重复播放");
    21.   }
    22. }
    
4. 定义动画播放，重置，暂停的按钮。
    
    1. Button('播放').onClick(() => {
    2.   this.animatorOptions?.play();
    3.   this.animatorStatus = '播放中'
    4. }).width(80).height(35)
    5. Button("重置").onClick(() => {
    6.   this.translateX = 0;
    7.   this.translateY = 0;
    8. }).width(80).height(35)
    9. Button("暂停").onClick(() => {
    10.   this.animatorOptions?.pause();
    11.   this.animatorStatus = '暂停'
    12. }).width(80).height(35)
    
5. 在页面隐藏或销毁的生命周期中释放动画对象，避免内存泄漏。
    
    1. onPageHide(): void {
    2.   this.animatorOptions = undefined;
    3. }
    

完整示例如下。

1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct Index {
5.   @State animatorResult: AnimatorResult | undefined = undefined;
6.   @State animatorStatus: string = '创建';
7.   begin: number = 0;
8.   end: number = 300;
9.   topWidth: number = 150;
10.   bottomHeight: number = 100;
11.   g: number = 0.18;
12.   animatorOption: AnimatorOptions = {
13.     duration: 4000,
14.     delay: 0,
15.     easing: 'linear',
16.     iterations: 1,
17.     fill: "forwards",
18.     direction: 'normal',
19.     begin: this.begin,
20.     end: this.end
21.   };
22.   @State translateX: number = 0;
23.   @State translateY: number = 0;

24.   onPageShow(): void {
25.     this.animatorResult = this.getUIContext().createAnimator(this.animatorOption)
26.     this.animatorResult.onFrame = (progress: number) => {
27.       this.translateX = progress;
28.       if (progress > this.topWidth && this.translateY < this.bottomHeight) {
29.         this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
30.       }
31.     }
32.     this.animatorResult.onCancel = () => {
33.       this.animatorStatus = '取消';
34.     }
35.     this.animatorResult.onFinish = () => {
36.       this.animatorStatus = '完成';
37.     }
38.     this.animatorResult.onRepeat = () => {
39.       console.info("动画重复播放");
40.     }
41.   }

42.   onPageHide(): void {
43.     this.animatorResult = undefined;
44.   }

45.   build() {
46.     Column() {
47.       Column({ space: 30 }) {
48.         Button('播放').onClick(() => {
49.           this.animatorResult?.play();
50.           this.animatorStatus = '播放中';
51.         }).width(80).height(35)
52.         Button("重置").onClick(() => {
53.           this.translateX = 0;
54.           this.translateY = 0;
55.         }).width(80).height(35)
56.         Button("暂停").onClick(() => {
57.           this.animatorResult?.pause();
58.           this.animatorStatus = '暂停';
59.         }).width(80).height(35)
60.       }.width("100%").height('25%')

61.       Stack() {
62.         Button()
63.           .width(60)
64.           .height(60)
65.           .translate({ x: this.translateX, y: this.translateY })
66.       }
67.       .width("100%")
68.       .height('45%')
69.       .align(Alignment.Start)

70.       Text("当前动画状态为:" + this.animatorStatus)
71.     }.width("100%").height('100%')
72.   }
73. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.31586158596057301415786743100081:50001231000000:2800:AE011168DC66B2509E35663DB18FD25401254923736E07D01477063D758FD35B.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-color-effect "色彩")
# 帧动画（ohos.animator）

更新时间: 2025-12-16 16:40

帧动画具备逐帧回调的特性，便于开发者在每一帧中处理需调整的属性。通过向应用提供onFrame逐帧回调，帧动画使开发者能够在应用的每一帧设置属性值，从而实现组件属性值变化的自然过渡，营造出动画效果。帧动画接口详情可参考[@ohos.animator (动画)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-animator)。

与属性动画相比，帧动画能让开发者实时感知动画进程，即时调整UI值，具备事件即时响应和可暂停的优势，但在性能上略逊于属性动画。当属性动画能满足需求时，建议优先采用属性动画接口实现。属性动画接口可参考[实现属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-apis)。

|名称|实现方式|事件响应方式|可暂停|性能|
|:--|:--|:--|:--|:--|
|帧动画（ohos.animator）|开发者可每帧修改UI侧属性值，UI侧属性实时更新|实时响应|是|较差|
|属性动画|UI侧只计算动画最终状态，动画过程为渲染值在改变，UI侧一直为动画最终状态，不感知实时渲染值|按最终状态响应|否|较好|

如图所示，帧动画在动画过程中即可实时响应，而属性动画按最终状态响应。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.43222992106272924261018710616931:50001231000000:2800:8B5303C8EDA987BD488283B986ADEB6EBA2C70DA7E41AD9B208CD9238E917779.gif)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.13753761793821775371334758444016:50001231000000:2800:6E99E349ABB35971996874F1C54E897D7B4E265105E1EDF8DEE255BFCF6CE759.gif)

## 使用帧动画实现动画效果

使用如下步骤可以创建一个简单的animator，并且在每个帧回调中打印当前插值。

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 创建执行动画的对象。
    
    1. // 创建动画的初始参数
    2. let options: AnimatorOptions = {
    3.   duration: 1500,
    4.   easing: "friction",
    5.   delay: 0,
    6.   fill: "forwards",
    7.   direction: "normal",
    8.   iterations: 2,
    9.   // 动画onFrame 插值首帧值
    10.   begin: 200.0,
    11.   // 动画onFrame 插值尾帧值
    12.   end: 400.0
    13. };
    14. let result: AnimatorResult = this.getUIContext().createAnimator(options);
    15. // 设置接收到帧时回调，动画播放过程中每帧会调用onFrame回调
    16. result.onFrame = (value: number) => {
    17.   console.info("current value is :" + value);
    18. }
    
3. 播放动画。
    
    1. // 播放动画
    2. result.play();
    
4. 动画执行完成后手动释放AnimatorResult对象。
    
    1. // 释放动画对象
    2. result = undefined;
    

## 使用帧动画实现小球抛物运动

1. 引入相关依赖。
    
    1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
    
2. 定义要做动画的组件。
    
    1. Button()
    2.   .width(60)
    3.   .height(60)
    4.   .translate({ x: this.translateX, y: this.translateY })
    
3. 在onPageShow中创建AnimatorResult对象。
    
    1. onPageShow(): void {
    2.   //创建animatorResult对象
    3.   this.animatorOptions = this.getUIContext().createAnimator(options);
    4.   this.animatorOptions.onFrame = (progress: number) => {
    5.     this.translateX = progress;
    6.     if (progress > this.topWidth && this.translateY < this.bottomHeight) {
    7.       this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
    8.     }
    9.   }
    10.   //动画取消时执行方法
    11.   this.animatorOptions.onCancel = () => {
    12.     this.animatorStatus = '取消';
    13.   }
    14.   //动画完成时执行方法
    15.   this.animatorOptions.onFinish = () => {
    16.     this.animatorStatus = '完成';
    17.   }
    18.   //动画重复播放时执行方法
    19.   this.animatorOptions.onRepeat = () => {
    20.     console.info("动画重复播放");
    21.   }
    22. }
    
4. 定义动画播放，重置，暂停的按钮。
    
    1. Button('播放').onClick(() => {
    2.   this.animatorOptions?.play();
    3.   this.animatorStatus = '播放中'
    4. }).width(80).height(35)
    5. Button("重置").onClick(() => {
    6.   this.translateX = 0;
    7.   this.translateY = 0;
    8. }).width(80).height(35)
    9. Button("暂停").onClick(() => {
    10.   this.animatorOptions?.pause();
    11.   this.animatorStatus = '暂停'
    12. }).width(80).height(35)
    
5. 在页面隐藏或销毁的生命周期中释放动画对象，避免内存泄漏。
    
    1. onPageHide(): void {
    2.   this.animatorOptions = undefined;
    3. }
    

完整示例如下。

1. import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct Index {
5.   @State animatorResult: AnimatorResult | undefined = undefined;
6.   @State animatorStatus: string = '创建';
7.   begin: number = 0;
8.   end: number = 300;
9.   topWidth: number = 150;
10.   bottomHeight: number = 100;
11.   g: number = 0.18;
12.   animatorOption: AnimatorOptions = {
13.     duration: 4000,
14.     delay: 0,
15.     easing: 'linear',
16.     iterations: 1,
17.     fill: "forwards",
18.     direction: 'normal',
19.     begin: this.begin,
20.     end: this.end
21.   };
22.   @State translateX: number = 0;
23.   @State translateY: number = 0;

24.   onPageShow(): void {
25.     this.animatorResult = this.getUIContext().createAnimator(this.animatorOption)
26.     this.animatorResult.onFrame = (progress: number) => {
27.       this.translateX = progress;
28.       if (progress > this.topWidth && this.translateY < this.bottomHeight) {
29.         this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
30.       }
31.     }
32.     this.animatorResult.onCancel = () => {
33.       this.animatorStatus = '取消';
34.     }
35.     this.animatorResult.onFinish = () => {
36.       this.animatorStatus = '完成';
37.     }
38.     this.animatorResult.onRepeat = () => {
39.       console.info("动画重复播放");
40.     }
41.   }

42.   onPageHide(): void {
43.     this.animatorResult = undefined;
44.   }

45.   build() {
46.     Column() {
47.       Column({ space: 30 }) {
48.         Button('播放').onClick(() => {
49.           this.animatorResult?.play();
50.           this.animatorStatus = '播放中';
51.         }).width(80).height(35)
52.         Button("重置").onClick(() => {
53.           this.translateX = 0;
54.           this.translateY = 0;
55.         }).width(80).height(35)
56.         Button("暂停").onClick(() => {
57.           this.animatorResult?.pause();
58.           this.animatorStatus = '暂停';
59.         }).width(80).height(35)
60.       }.width("100%").height('25%')

61.       Stack() {
62.         Button()
63.           .width(60)
64.           .height(60)
65.           .translate({ x: this.translateX, y: this.translateY })
66.       }
67.       .width("100%")
68.       .height('45%')
69.       .align(Alignment.Start)

70.       Text("当前动画状态为:" + this.animatorStatus)
71.     }.width("100%").height('100%')
72.   }
73. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164007.31586158596057301415786743100081:50001231000000:2800:AE011168DC66B2509E35663DB18FD25401254923736E07D01477063D758FD35B.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-color-effect "色彩")