# Form Kit简介

更新时间: 2025-12-16 16:38

Form Kit（卡片开发服务）提供了一种在桌面、锁屏等系统应用上嵌入显示应用信息的开发框架和API，可以将应用内用户关注的重要信息或常用操作抽取到服务卡片（简称“卡片”）上，通过将卡片添加到桌面、锁屏等系统应用上，以达到信息展示、服务直达的便捷体验效果。

## 卡片使用场景

- 支持设备类型：手机、平板、PC/2in1、智慧屏、智能手表。轻量级智能穿戴设备不支持使用本Kit。
- 支持开发卡片应用类型：应用和元服务内均支持开发卡片。
- 支持卡片使用位置：用户可以在桌面、锁屏等系统应用上添加使用，不支持在普通应用内嵌入显示卡片。
- 卡片常见使用步骤：

1. 长按“桌面的应用图标”，弹出操作菜单。
2. 点击“卡片”选项，进入卡片管理页面，可以预览卡片。
3. 点击“添加到桌面”按钮，即可在桌面上看到新添加的卡片。

**图1** 卡片常见使用步骤

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163818.82401410042680105048710672164006:50001231000000:2800:8AA9AFD4DEA12AC5CDDADD9FE23BBB7B92B5CDA2310177F7CDF85EEF26A3A622.png)

## 服务卡片架构

**图2** 服务卡片架构

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163818.84458263332285328639062279031511:50001231000000:2800:236D5420034D4D4E5930362DE54E957E7DE6B51E4F0FE70734C1E4EAFBEEC991.png)

**卡片场景中涉及到的基本概念**

- 卡片使用方：如上图中的桌面，作为显示卡片内容的宿主应用，用于与用户直接进行交互，完成卡片添加、删除、显示功能，并能控制卡片在宿主中具体展示的位置。
- 卡片提供方：提供卡片的应用或元服务，是卡片功能的具体实现者，需要设计实现卡片UI、数据更新、以及点击交互处理功能。
- 卡片管理服务：操作系统内管理整机卡片信息的系统服务，作为卡片提供方和使用方的桥梁，向使用方提供卡片信息查询、添加、删除等能力，同时向提供方提供卡片被添加、被删除、刷新、点击事件等通知能力。

## 亮点/特征

- 信息呈现：将应用/元服务的重要信息以卡片形式展示在桌面，同时支持信息定时更新能力，用户可以随时查看关注的信息。
    
- 服务直达：通过点击卡片内按钮，就可以实现功能快捷操作，也支持点击后跳转到应用/元服务对应功能页，实现功能服务一步直达的效果。
    

## 开发模式

**模型选择**

当前系统中应用支持Stage和FA两种开发模型，所以Form Kit也同时支持开发者使用Stage模型和FA模型来开发卡片应用，但更推荐使用Stage模型。

**UI开发范式选择**

- Stage模型支持两种卡片UI开发方式，可以基于ArkTS声明式开发范式语言开发卡片（简称ArkTS卡片）、也可以基于兼容JS的类Web开发范式语言开发卡片（简称JS卡片）。
- FA模型仅支持基于类Web范式JS语言开发JS卡片。

ArkTS卡片与JS卡片具备不同的实现原理及特征，在场景能力上的差异如下表所示：

|类别|JS卡片|ArkTS卡片|
|:--|:--|:--|
|开发范式|类Web范式|声明式范式|
|组件能力|支持|支持|
|布局能力|支持|支持|
|事件能力|支持|支持|
|自定义动效|不支持|支持|
|自定义绘制|不支持|支持|
|逻辑代码执行|不支持|支持|

## 与相关Kit的关系

- Ability Kit: Form Kit内部实现依赖Ability Kit提供的Extension基础能力，与Ability Kit存在生命周期调度交互。
- ArkUI: Form Kit卡片提供方在卡片页面中可以使用ArkUI提供的部分组件、事件、动效、状态管理等能力。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/form-kit "Form Kit（卡片开发服务）")
# ArkTS卡片概述

更新时间: 2025-12-16 16:38

以下内容介绍基于ArkTS声明式开发范式语言开发卡片。

## 亮点/特征

1. 统一开发范式
    
    - ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。具体请参考图1 卡片工程结构对比。
    
    **图1** 卡片工程结构对比
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.62194770651905460634523076759309:50001231000000:2800:EE4BB65A8C455F8D2C859AF09B02922D14EE0EB213AAF4F13785F5D1955B9609.png)
    
2. 卡片能力增强
    
    - 新增了动效的能力：ArkTS卡片开放了[属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)和[显式动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation)的能力，使卡片的交互更加友好。
    - 新增了自定义绘制的能力：ArkTS卡片开放了[Canvas](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-components-canvas-canvas)画布组件的能力，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。
    - 允许卡片中运行逻辑代码：开放逻辑代码运行能力后，因此部分业务逻辑可以在内部实现，拓宽了卡片的业务适用场景。

## 实现原理

- 卡片使用方：显示卡片内容的宿主应用，控制卡片在宿主中展示的位置，当前仅系统应用可以作为卡片使用方。
    
- 卡片提供方：提供卡片显示内容的应用，控制卡片的显示内容、控件布局以及控件点击事件。
    
- 卡片管理服务：用于管理系统中所添加卡片的常驻代理服务，提供[formProvider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider)的接口能力，同时提供卡片对象的管理与使用以及卡片周期性刷新等能力。
    
- 卡片渲染服务：用于管理卡片渲染实例，渲染实例与卡片使用方的卡片组件一一绑定。卡片渲染服务根据form_config.json配置的卡片信息运行widget.abc文件的卡片页面代码进行渲染，并将渲染后的数据发送至卡片使用方对应的卡片组件。
    

**图2** ArkTS卡片实现原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.90634478561479179540388796069911:50001231000000:2800:AD62EE05E06D7AC06DD1842185B3759356F76A9A06247998087E08758BE08706.png)

**图3** ArkTS卡片渲染服务运行原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.88699572861507053673041028137086:50001231000000:2800:50D0D18018D50ABB455BC84DDE94C7A84A6D59221CA30DB3F9F6C97A5483BBC1.png)

与JS卡片相比，ArkTS卡片支持在卡片中运行逻辑代码，为确保ArkTS卡片发生问题后不影响卡片使用方应用的使用，ArkTS卡片新增了卡片渲染服务用于运行卡片页面代码widget.abc，卡片渲染服务由卡片管理服务管理。卡片使用方的每个卡片组件都对应了卡片渲染服务里的一个渲染实例，同一卡片提供方的渲染实例运行在同一个ArkTS虚拟机运行环境中，不同卡片提供方的渲染实例运行在不同的ArkTS虚拟机运行环境中，通过ArkTS虚拟机运行环境隔离不同卡片提供方卡片之间的资源与状态。开发过程中需要注意的是globalThis对象的使用，相同卡片提供方的卡片globalThis对象是同一个，不同卡片提供方的卡片globalThis对象是不同的。

## ArkTS卡片类型

ArkTS卡片分为动态卡片、静态卡片和互动卡片三种类型。

静态卡片整体的运行框架、渲染流程与动态卡片是一致的。主要区别在于，卡片渲染服务将卡片内容渲染完毕后，卡片使用方会使用最后一帧渲染的数据作为静态图片显示，其次卡片渲染服务中的卡片实例会释放该卡片的所有运行资源以节省内存。因此频繁的刷新会导致静态卡片运行时资源不断的创建和销毁，增加卡片功耗。

|卡片类型|支持的能力|适用场景|优缺点|
|:--|:--|:--|:--|
|静态卡片|仅支持UI组件和布局能力。|主要用于展示静态信息（UI相对固定），仅可以通过FormLink组件跳转到指定的UIAbility。|功能简单但可以有效控制内存开销。|
|动态卡片|除了支持UI组件和布局能力，还支持通用事件能力和自定义动效能力。|用于有复杂业务逻辑和交互的场景。例如：卡片页面图片的刷新、卡片内容的刷新等。|功能丰富但内存开销较大。|
|互动卡片|在动态卡片基础上，额外支持溢出动效能力。|用于有复杂业务逻辑和交互，需要执行溢出动效呈现更好视觉体验的场景。例如：桌面卡片游戏等。|功能丰富但内存开销较大。|

### 动态卡片

ArkTS卡片中提供了[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)接口用于卡片Card.ets和FormExtensionAbility之间的交互，当前支持router、message和call三种类型的事件，仅在卡片控件的点击事件中可以调用。

**图4** ArkTS事件交互实现原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.44381725285789926781128285193102:50001231000000:2800:B16B9F0165D8D6A238AA90D88693B2C29BF6F2E84FA71B8FFFA9D031D141002A.png)

动态卡片事件的主要使用场景如下：

- router事件：可以使用router事件跳转到应用自身的UIAbility，以完成点击卡片跳转应用内页面的交互功能。
- call事件：可以使用call事件拉起应用自身的UIAbility到后台，再通过UIAbility申请对应后台[长时任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/long-time-task-overview)完成音乐播放等功能。
- message事件：可以使用message拉起FormExtensionAbility，通过onFormEvent接口回调通知，以完成卡片内控件点击消息传递，从而更新卡片内容。

### 静态卡片

ArkTS卡片提供FormLink静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件。

请参见[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)。

### 互动卡片

从API version 20开始支持互动卡片，互动卡片提供溢出动效能力，并实现人机交互，提升信息提醒、浅层交互和可玩性。具体请参考[互动卡片概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform-overview)。

## 约束与限制

ArkTS卡片支持在UI内运行逻辑代码，相较于JS卡片具备了更加丰富的能力，但也增加了使用卡片进行恶意行为的风险。因为承载ArkTS卡片UI部分的widget.abc代码运行在系统公共的FRS进程内，并最终显示在卡片使用方应用中（一般为桌面应用），为确保系统渲染进程的稳定性、各卡片之间的隔离安全性，以及内存功耗等资源考虑，对ArkTS卡片UI可使用的能力做了以下约束：

- 当前仅支持基于ArkUI开发卡片，不支持跨平台开发。
    
- 当导入模块时，仅支持导入标识“支持在ArkTS卡片中使用”的模块。若使用了不支持使用的API，卡片加载显示异常。
    
- 支持导入[HAR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package)静态共享包，不支持导入[HSP](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp)动态共享包。
    
- 不支持使用native语言开发，不支持加载native so。
    
- 针对卡片UI页面开发，ArkTS卡片仅支持[声明式范式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-development-overview)的部分组件、事件、动效、数据管理、状态管理和API能力。对于支持在ArkTS卡片UI页面中使用的接口，会添加“卡片能力”的标记，如：从API version 12开始，该接口支持在ArkTS卡片中使用。
    
- 卡片组件内容的事件处理和卡片使用方的事件处理是独立的，为防止手势冲突，卡片内不支持左右滑动的控件。
    

除此之外，当前ArkTS卡片还存在如下约束：

- 不支持极速预览。
    
- 不支持断点调试能力。
    
- 不支持Hot Reload热重载。
    
- 不支持setTimeOut。
    
- DevEco Studio的相关约束请参考[使用约束](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-service-widget#section1181172254318)。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui "ArkTS卡片开发（推荐）")
# 创建ArkTS卡片

更新时间: 2025-12-16 16:38

ArkTS卡片有两种创建卡片包的方式。开发者在开发过程中任选其一即可。

方式一：卡片和应用共包方式，创建步骤请参考[共包方式创建卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation#%E6%96%B9%E5%BC%8F%E4%B8%80%E5%85%B1%E5%8C%85%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%8D%A1%E7%89%87)，此时卡片UI和应用代码在一个module内，最终编译产物也在同一个HAP包内。

方式二：独立卡片包方式，创建步骤请参考[独立包方式创建卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation#%E6%96%B9%E5%BC%8F%E4%BA%8C%E7%8B%AC%E7%AB%8B%E5%8C%85%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%8D%A1%E7%89%87)，此时卡片UI和应用代码在不同module内，最终编译产物分为卡片包和应用包。从API version 20开始支持。

ArkTS卡片创建完成，在开发卡片过程中，支持对卡片进行[实时预览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-service-widget#section18171652015)。

## 方式一：共包方式创建卡片

### 创建步骤

**1. 新建工程**

在DevEco Studio中，选择创建Application或Atomic Service工程，这两种都支持创建卡片。工程创建指导具体请参考[创建一个新的工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-create-new-project)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.21931855023049303573317246147201:50001231000000:2800:2A00E50A7E1AC090BC3403361F0E2B6591382BD0BCD6C1A3F7733588915D09B9.png)

说明

基于不同版本的DevEco Studio，请以实际界面为准。

**2. 新建卡片**

在已有的应用工程中，右键新建ArkTS卡片，具体操作如下。

- 选中entry目录单击右键选择【New】->【Service Widget】->【Dynamic Widget】。在API 10及以上 Stage模型的工程中，开发者可通过Service Widget菜单直接选择创建动态卡片（Dynamic Widget）或静态卡片（Static Widget）。创建卡片后，也可在卡片的[form_config.json配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)中，通过isDynamic参数修改卡片类型：isDynamic置空或赋值为“true”，则该卡片为[动态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E5%8A%A8%E6%80%81%E5%8D%A1%E7%89%87)；isDynamic赋值为"false"，则该卡片为[静态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E9%9D%99%E6%80%81%E5%8D%A1%E7%89%87)。静态卡片和动态卡片切换之后用户交互实现也需要修改，具体参考ArkTS卡片概述中的[动态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E5%8A%A8%E6%80%81%E5%8D%A1%E7%89%87)和[静态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E9%9D%99%E6%80%81%E5%8D%A1%E7%89%87)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.70262826869047640058956517260805:50001231000000:2800:544147A369EFEB9BB6782DC490DA50D4FCB2192388349FAA268FBED84D754092.png)
    
- 选择模板后，点击【Next】。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.00828047358509849341598491626102:50001231000000:2800:5FEB3B62B1AC7CB7E2CA841398D902468A0D84F4FF7D0351B8B10BBDA9005168.png)
    
- 在选择卡片的开发语言类型（Language）时，选择ArkTS选项。选择卡片支持的外观规格（Support dimension）时，选择期望的卡片尺寸，然后选择默认的外观规格（Default dimension），最后点击“Finish”，即可完成ArkTS卡片创建。详细的卡片外观规格可参考[form_config.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)配置文件，后续也可以在form_config.json配置文件中修改卡片规格。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.82904054302510247179690273204199:50001231000000:2800:1D9FC1E67907AE4B4570CDE098229B4EBCC21FF59E4B1E4AADFB2284293D2697.png)
    
    建议根据实际使用场景命名卡片名称，ArkTS卡片创建完成后，工程中会新增如下卡片相关文件：卡片生命周期管理文件（EntryFormAbility.ets）、卡片页面文件（WidgetCard.ets）和卡片配置文件（form_config.json）。填写卡片配置之后点击【Finish】。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.98763945484916052955797959782842:50001231000000:2800:77DBCE6C4C5AD67C8A8D04EDC801B11D9ABA45917E1BF7A3270648B30DAB0283.png)
    

### 工程结构介绍

**图1** ArkTS卡片工程目录、相关模块

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.52877771683760818171093660304732:50001231000000:2800:855A3A252E9B387A410BB250CAA18B6D1C89B741367D93B8A8A27D45FBF2EFAF.png)

- [FormExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability)：卡片扩展模块，提供卡片创建、销毁、刷新等生命周期回调。
    
- [FormExtensionContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-formextensioncontext)：FormExtensionAbility的上下文环境，提供FormExtensionAbility具有的接口和能力。
    
- [formProvider](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider)：提供了获取卡片信息、更新卡片、设置卡片更新时间等能力。
    
- [formInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-forminfo)：提供了卡片信息和状态等相关类型和枚举。
    
- [formBindingData](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formbindingdata)：提供卡片数据绑定的能力，包括FormBindingData对象的创建、相关信息的描述。
    
- [页面布局（WidgetCard.ets）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-page-overview)：基于ArkUI提供卡片UI开发能力。
    
    - [ArkTS卡片通用能力](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-page-overview#arkts%E5%8D%A1%E7%89%87%E6%94%AF%E6%8C%81%E7%9A%84%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%8A%9B)：提供了能在ArkTS卡片中使用的组件、属性和API。
    - [ArkTS卡片特有能力](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-overview)：postCardAction用于卡片内部和提供方应用间的交互，仅在卡片中可以调用。
- [卡片配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration)：包含FormExtensionAbility的配置和卡片的配置。
    
    - 在[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中的extensionAbilities标签下，配置FormExtensionAbility相关信息。
    - 在resources/base/profile/目录下的[form_config.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)配置文件中，配置卡片（WidgetCard.ets）相关信息。

## 方式二：独立包方式创建卡片

### 创建步骤

**1. 新建工程**

在DevEco Studio中，选择创建Application或Atomic Service工程，这两种都支持创建卡片。工程创建指导具体请参考[创建一个新的工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-create-new-project)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.83647775717451556986389728185174:50001231000000:2800:E67618AE8ED5A1087DBF6BFA16DF0485FB1A6346EAB3051C6168DB1F114B8DE9.png)

说明

基于不同版本的DevEco Studio，请以实际界面为准。

**2. 新建卡片**

- 选中entry目录单击右键选择【New】->【Service Widget】->【Dynamic Widget(Standalone)】。在Service Widget菜单可直接选择创建独立包的动态卡片（Dynamic Widget(standalone)）或静态卡片（Static Widget(standalone)）。创建服务卡片后，也可以在卡片的[form_config.json配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)中，通过isDynamic参数修改卡片类型：isDynamic置空或赋值为“true”，则该卡片为[动态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E5%8A%A8%E6%80%81%E5%8D%A1%E7%89%87)；isDynamic赋值为"false"，则该卡片为[静态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E9%9D%99%E6%80%81%E5%8D%A1%E7%89%87)。静态卡片和动态卡片切换之后用户交互实现也需要修改，具体参考ArkTS卡片概述中的[动态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E5%8A%A8%E6%80%81%E5%8D%A1%E7%89%87)和[静态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E9%9D%99%E6%80%81%E5%8D%A1%E7%89%87)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.74033162689184436929019615909756:50001231000000:2800:FAA557980525D27BAC613DE36F45D9F9B5C6A7C580C48B62F8CF747F66D0DDDF.png)
    
- 选择模板后，点击【Next】。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163836.03018610531581749683515899788998:50001231000000:2800:33F8E2A31E31399A04207A1D3B169784ACF8F41651C62687DE3FDF295C357399.png)
    
- 填写卡片配置之后点击【Finish】。卡片创建成功后，entry包中包含应用和卡片后端能力；library包中包含卡片UI侧能力。entry模块下的module.json5配置文件中的formWidgetModule字段需关联library模块，library模块下的module.json5配置文件中的formExtensionModule字段需关联entry模块，以实现卡片包和应用包相互关联。创建完成后，会自动生成配置文件并配置，后续也可以按照[卡片配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration)修改配置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163837.12964068004855755306163115130800:50001231000000:2800:10F99D7AD5AE5EDD20346A739423C4150F835B6802A86E7088FD4FAEC899796F.png)
    

### 工程结构介绍

独立卡片包与卡片共包方式创建卡片，仅工程结构存在差异，生成的文件是一致的，各文件具体内容请参考[共包方式工程结构介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation#%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D)。

**图2** 独立卡片包工程目录。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163837.19750906773960976994404456617819:50001231000000:2800:1470C8D3383A246343AF11CB197BF796F569F44B02F45F0C8232A194CB17ACF9.png)

说明

独立卡片包中应用包和卡片包为2个独立模块，因此需要关注同时安装的应用包和卡片包版本号一致。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview "ArkTS卡片概述")
# 配置ArkTS卡片的配置文件

更新时间: 2025-12-16 16:38

卡片相关的配置文件包括[FormExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability)配置和卡片配置。如果是[独立卡片包](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation)，还会包含[独立卡片包配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E7%8B%AC%E7%AB%8B%E5%8D%A1%E7%89%87%E5%8C%85%E9%85%8D%E7%BD%AE)。

说明

卡片五元组是确认卡片唯一的要素信息。五元组分别为bundleName、moduleName、abilityName、formName、formDimension。应用升级后如果五元组有改变，系统里面的对应卡片会被删除，对应卡片在屏幕上会消失。其中bundleName是[app.json5配置文件标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-configuration-file#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%87%E7%AD%BE)中bundleName配置项、moduleName是[module.json5配置文件标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%87%E7%AD%BE)中的name配置项、abilityName是[abilities标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)中的name配置项、formName是[配置文件字段说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)中的name配置项、formDimension对应的是[配置文件字段说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)中的supportDimensions配置项。

## FormExtensionAbility配置

卡片需要在[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)的extensionAbilities标签下，配置FormExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串 “ohos.extension.form”，资源为[卡片具体配置信息的资源索引](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E5%8D%A1%E7%89%87%E9%85%8D%E7%BD%AE)。

配置示例如下：

1. {
2.   "module": {
3.     // ...
4.     "extensionAbilities": [
5.      {
6.        "name": "EntryFormAbility",
7.        "srcEntry": "./ets/entryformability/EntryFormAbility.ets",
8.        "label": "$string:EntryFormAbility_label",
9.        "description": "$string:EntryFormAbility_desc",
10.        "type": "form",
11.        "metadata": [
12.          {
13.            "name": "ohos.extension.form",
14.            "resource": "$profile:form_config"
15.          }
16.        ]
17.      }
18.    ],
19.    "formWidgetModule": "library" // 只在独立卡片包形态中会使用，用来关联卡片包模块。
20.   }
21. }

## 独立卡片包配置

相对应地，在卡片包的[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中，formExtensionModule字段用来关联应用包的module。

配置示例如下：

1. {
2.   "module": {
3.     "name": "library",
4.     "type": "shared",
5.     "description": "$string:shared_desc",
6.     "deviceTypes": [
7.       "phone"
8.     ],
9.     "deliveryWithInstall": true,
10.     "formExtensionModule": "entry" // 只在独立卡片包形态中会使用，用来关联应用包模块。
11.   }
12. }

## 卡片配置

在上述FormExtensionAbility的元信息metadata配置项中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_config时，会使用开发视图的resources/base/profile/目录下的form_config.json作为卡片profile配置文件。在[创建卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation)时会自动生成form_config.json配置文件。

### 配置文件字段说明

**表1** 卡片form_config.json配置文件

|属性名称|含义|数据类型|是否可缺省|
|:--|:--|:--|:--|
|forms|表示应用的全部卡片配置信息。<br><br>最多支持配置16个卡片，若超过16个，则保留配置的前16个。|数组|否|
|name|表示卡片的名称，字符串最大长度为127字节。用于开发者区分不同的卡片。|字符串|否|
|displayName|表示卡片的展示名称。主要在卡片管理页面显示，对应卡片预览下[卡片管理页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/formkit-overview#%E5%8D%A1%E7%89%87%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)中的"cardName"，用于展示卡片信息，建议能够体现卡片的核心功能或用途。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最小长度为1字节，最大长度为30字节。|字符串|否|
|description|表示卡片的描述。用于在卡片管理页面展示卡片功能描述，对应卡片预览下[卡片管理页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/formkit-overview#%E5%8D%A1%E7%89%87%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)中的"This is a service widget."。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最大长度为255字节。|字符串|可缺省，缺省为空。|
|src|表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如："./ets/widget/pages/WidgetCard.ets"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如："./js/widget/pages/WidgetCard"。|字符串|否|
|uiSyntax|表示该卡片的类型，当前支持如下两种类型：<br><br>- arkts：当前卡片为ArkTS卡片。<br><br>- hml：当前卡片为JS卡片。|字符串|可缺省，缺省值为“hml”。|
|[window](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#window%E6%A0%87%E7%AD%BE)|用于定义与显示窗口相关的配置。<br><br>**说明：**<br><br>该字段仅对JS卡片生效。|对象|可缺省，缺省值见表2。|
|isDefault|表示该卡片是否为默认卡片(在卡片中心内希望优先展示的卡片)，每个应用有且只有一个默认卡片。<br><br>- true：默认卡片。<br><br>- false：非默认卡片。<br><br>**说明：**<br><br>1.如果本地调试时设置多个卡片为默认卡片，系统会选择第一个配置了isDefault为true的卡片为默认卡片。<br><br>2.应用上架时每个应用只允许配置一张默认卡片。|布尔值|否|
|colorMode(deprecated)|表示卡片的主题样式，取值范围如下：<br><br>- auto：跟随系统的颜色模式值选取主题。<br><br>- dark：深色主题。<br><br>- light：浅色主题。<br><br>**说明：**<br><br>1. 从API version 12开始支持该配置项，从API version 20开始废弃该配置项，卡片主题样式统一跟随系统的颜色模式。<br><br>2. 该字段仅对JS卡片生效。|字符串|可缺省，缺省值为“auto”。|
|supportDimensions|表示卡片支持的外观规格，取值范围：<br><br>- 1 * 1：表示1行1列的一宫格。<br><br>- 1 * 2：表示1行2列的二宫格。<br><br>- 2 * 2：表示2行2列的四宫格。<br><br>- 2 * 4：表示2行4列的八宫格。<br><br>- 2 * 3：表示2行3列的六宫格。<br><br>- 3 * 3：表示3行3列的九宫格。<br><br>- 4 * 4：表示4行4列的十六宫格。<br><br>- 6 * 4：表示6行4列的二十四宫格。<br><br>**说明**： 2 * 3和 3 * 3仅支持手表设备， 1 * 1只支持在锁屏上使用。|字符串数组|否|
|defaultDimension|表示卡片的默认尺寸，取值必须在该卡片supportDimensions配置的列表中。|字符串|否|
|updateEnabled|表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br><br>- true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br><br>- false：表示不支持周期性刷新。|布尔类型|否|
|scheduledUpdateTime|表示卡片的[定点刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-passive-refresh#%E5%8D%A1%E7%89%87%E5%AE%9A%E7%82%B9%E5%88%B7%E6%96%B0)的时刻，采用24小时制，精确到分钟，例如："10:30"。<br><br>**说明：**<br><br>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。|字符串|可缺省，缺省时不进行定点刷新。|
|updateDuration|表示[卡片定时刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-passive-refresh#%E5%8D%A1%E7%89%87%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0)的更新周期，单位为30分钟，取值为自然数。<br><br>当取值为0时，表示该参数不生效。<br><br>当取值为正整数N时，表示刷新周期为30*N分钟。<br><br>**说明：**<br><br>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。|数值|可缺省，缺省值为0。|
|formConfigAbility|表示桌面点击编辑后，需要拉起的ability路径，采用URI格式。|字符串|可缺省，缺省值为空。|
|metadata|表示卡片的自定义信息，参考[Metadata](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-bundlemanager-metadata)数组标签。|对象|可缺省，缺省值为空。|
|isDynamic|表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。<br><br>- true：为[动态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E5%8A%A8%E6%80%81%E5%8D%A1%E7%89%87) 。<br><br>- false：为[静态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E9%9D%99%E6%80%81%E5%8D%A1%E7%89%87)。|布尔类型|可缺省，缺省值为true。|
|fontScaleFollowSystem|表示卡片使用方设置此卡片的字体是否支持跟随系统变化。<br><br>- true：支持跟随系统字体大小变化。<br><br>- false：不支持跟随系统字体大小变化。|布尔类型|可缺省，缺省值为true。|
|supportShapes|表示卡片的显示形状，取值范围如下：<br><br>- rect：表示矩形卡片。<br><br>- circle：表示圆形卡片。|字符串数组|可缺省，缺省值为“rect”。|
|previewImages|表示卡片预览图, 与配置项supportDimensions一一对应。智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。|字符串|可缺省。|
|enableBlurBackground|表示卡片是否使用模糊背板。<br><br>- true：开启模糊背板。<br><br>- false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|
|renderingMode|表示卡片的渲染模式，取值范围如下：<br><br>- autoColor：自动模式，呈现效果可以根据卡片使用方确定最终是全彩模式还是单色模式，具体请参考[卡片色彩](https://developer.huawei.com/consumer/cn/doc/design-guides/system-features-service-widget-0000002087671904#section295mcpsimp)。该模式下卡片中的颜色和图片允许卡片使用方修改，卡片配置了该模式就可以添加到桌面或锁屏上。<br><br>- fullColor：全彩模式，具体请参考[卡片色彩](https://developer.huawei.com/consumer/cn/doc/design-guides/system-features-service-widget-0000002087671904#section295mcpsimp)。该模式下卡片中的颜色和图片不允许被卡片使用方修改，卡片配置了该模式就可以添加到桌面上。<br><br>- singleColor：单色模式，通过透明度和模糊区分元素，不使用任何色相，具体请参考[卡片色彩](https://developer.huawei.com/consumer/cn/doc/design-guides/system-features-service-widget-0000002087671904#section295mcpsimp)。该模式下卡片中的颜色和图片允许卡片使用方修改，卡片配置了该模式就可以添加到锁屏上。<br><br>**说明：**<br><br>从API version 15开始，支持该字段。|字符串|可缺省，缺省值为“fullColor”。|
|multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br><br>**说明：**<br><br>从API version 18开始，支持该字段。multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|
|conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br><br>- network：表示支持网络刷新。<br><br>**说明：**<br><br>从API version 18开始，支持该字段。|字符串|可缺省，缺省值为空字符串。|
|[funInteractionParams](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#funinteractionparams%E6%A0%87%E7%AD%BE)|趣味交互类型互动卡片扩展字段。从API version 20开始，支持该字段。|对象|可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|
|[sceneAnimationParams](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#sceneanimationparams%E6%A0%87%E7%AD%BE)|[场景动效类型互动卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform-sceneanimation-overview)扩展字段。从API version 20开始，支持该字段。|对象|可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|
|resizable|表示是否可以拖拽卡片调整大小。调整值必须在该卡片或者同groupId卡片的supportDimensions配置列表中。<br><br>- true：可以调整大小。<br><br>- false：不可以调整大小。<br><br>**说明：**<br><br>从API version 20开始，支持该字段。|布尔类型|可缺省，缺省值为false。|
|groupId|表示一组卡片的共同id。多张卡片的groupId相同且resizable为true时，多张卡片的supportDimensions配置共享。例如，卡片A和B的groupId相同且resizable均为true，则卡片A可以调整为卡片A和B的supportDimensions配置中的任意尺寸。<br><br>推荐多张卡片功能相同且需要调整卡片尺寸时配置。<br><br>**说明：**<br><br>从API version 20开始，支持该字段。|字符串|可缺省，缺省值为false。|

### window标签

此标签标识window对象的内部结构说明。只支持在JS卡片中使用。

|属性名称|含义|数据类型|是否可缺省|
|:--|:--|:--|:--|
|designWidth|标识页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。|数值|可缺省，缺省值为720px。|
|autoDesignWidth|标识页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。|布尔值|可缺省，缺省值为false。|

### funInteractionParams标签

此标签标识趣味交互类型互动卡片配置。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。

|名称|类型|必填|说明|
|:--|:--|:--|:--|
|abilityName|字符串|否|趣味交互场景LiveFormExtensionAbility名称，默认为空。|
|targetBundleName|字符串|是|趣味交互场景[主包包名](https://developer.huawei.com/consumer/cn/doc/quickApp-Guides/quickgame-independent-subpackage-0000002076341729)。|
|subBundleName|字符串|否|趣味交互场景[独立分包名](https://developer.huawei.com/consumer/cn/doc/quickApp-Guides/quickgame-independent-subpackage-0000002076341729)，默认为空。|
|keepStateDuration|数值|否|趣味交互场景无交互时，激活态保持时长。默认值为10000，单位ms。取值为[0,10000]的整数，超过取值范围则取默认值10000。|

1. {
2.   "forms": [
3.     {
4.        // ...
5.       "funInteractionParams": {
6.          "targetBundleName": "com.example.funInteraction",
7.          "subBundleName": "com.example.subFunInteraction"
8.       }
9.     }
10.   ]
11. }

### sceneAnimationParams标签

此标签标识场景动效类型互动卡片配置。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。

|名称|类型|必填|说明|
|:--|:--|:--|:--|
|abilityName|字符串|是|场景动效LiveFormExtensionAbility名称。|

1.    {
2.      "forms": [
3.        {
4.           // ...
5.          "sceneAnimationParams": {
6.             "abilityName": "MyLiveFormExtensionAbility"
7.          }
8.        }
9.      ]
10.    }

### 配置文件示例

1. {
2.   "forms": [
3.     {
4.       "name": "widget",
5.       "displayName": "$string:widget_display_name",
6.       "description": "$string:widget_desc",
7.       "src": "./ets/widget/pages/WidgetCard.ets",
8.       "uiSyntax": "arkts",
9.       "window": {
10.         "designWidth": 720,
11.         "autoDesignWidth": true
12.       },
13.       "renderingMode": "fullColor",
14.       "isDefault": true,
15.       "updateEnabled": true,
16.       "scheduledUpdateTime": "10:30",
17.       "updateDuration": 1,
18.       "defaultDimension": "2*2",
19.       "supportDimensions": [
20.         "2*2"
21.       ],
22.       "formConfigAbility": "ability://EntryAbility",
23.       "isDynamic": true,
24.       "metadata": []
25.     }
26.   ]
27. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation "创建ArkTS卡片")
# 管理ArkTS卡片生命周期

更新时间: 2025-12-16 16:38

创建ArkTS卡片，需实现[FormExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability)生命周期接口。

1. 在EntryFormAbility.ets中，导入相关模块。
    
    1. import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
    2. import { Configuration, Want } from '@kit.AbilityKit';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { hilog } from '@kit.PerformanceAnalysisKit';
    
2. 在EntryFormAbility.ets中，实现[FormExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability)生命周期接口，其中在onAddForm的入参[want](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-want)中可以通过[FormParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-forminfo#formparam)取出卡片的相关信息。
    
    1. const TAG: string = 'EntryFormAbility';
    2. const DOMAIN_NUMBER: number = 0xFF00;
    
    3. export default class EntryFormAbility extends FormExtensionAbility {
    4.   onAddForm(want: Want): formBindingData.FormBindingData {
    5.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onAddForm');
    6.     hilog.info(DOMAIN_NUMBER, TAG, want.parameters?.[formInfo.FormParam.NAME_KEY] as string);
    
    7.     // ...
    8.     // 卡片使用方创建卡片时触发，提供方需要返回卡片数据绑定类
    9.     let obj: Record<string, string> = {
    10.       'title': 'titleOnAddForm',
    11.       'detail': 'detailOnAddForm'
    12.     };
    13.     let formData: formBindingData.FormBindingData = formBindingData.createFormBindingData(obj);
    14.     return formData;
    15.   }
    
    16.   onCastToNormalForm(formId: string): void {
    17.     // 当前卡片使用方不会涉及该场景，无需实现该回调函数
    18.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onCastToNormalForm');
    19.   }
    
    20.   onUpdateForm(formId: string): void {
    21.     // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新
    22.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onUpdateForm');
    23.     let obj: Record<string, string> = {
    24.       'title': 'titleOnUpdateForm',
    25.       'detail': 'detailOnUpdateForm'
    26.     };
    27.     let formData: formBindingData.FormBindingData = formBindingData.createFormBindingData(obj);
    28.     formProvider.updateForm(formId, formData).catch((error: BusinessError) => {
    29.       hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] updateForm, error:' + JSON.stringify(error));
    30.     });
    31.   }
    
    32.   onChangeFormVisibility(newStatus: Record<string, number>): void {
    33.     // 卡片使用方发起可见或者不可见通知触发，提供方需要做相应的处理，仅系统应用生效
    34.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onChangeFormVisibility');
    35.   }
    
    36.   onFormEvent(formId: string, message: string): void {
    37.     // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发
    38.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onFormEvent');
    39.     // ...
    40.   }
    
    41.   onRemoveForm(formId: string): void {
    42.     // 删除卡片实例数据
    43.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onRemoveForm');
    44.     // 删除之前持久化的卡片实例数据
    45.     // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例
    46.   }
    
    47.   onConfigurationUpdate(config: Configuration) {
    48.     // 当前formExtensionAbility存活时更新系统配置信息时触发的回调。
    49.     // 需注意：formExtensionAbility创建后10秒内无操作将会被清理。
    50.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onConfigurationUpdate:' + JSON.stringify(config));
    51.   }
    
    52.   onAcquireFormState(want: Want) {
    53.     // 卡片提供方接收查询卡片状态通知接口，默认返回卡片初始状态。
    54.     return formInfo.FormState.READY;
    55.   }
    56. }
    

说明

FormExtensionAbility进程不能常驻后台，即在卡片生命周期回调函数中无法处理长时间的任务，在生命周期调度完成后会继续存在10秒，如10秒内没有新的生命周期回调触发则进程自动退出。针对可能需要10秒以上才能完成的业务逻辑，建议[拉起主应用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-overview)进行处理，处理完成后使用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)通知卡片进行刷新。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration "配置ArkTS卡片的配置文件")
# ArkTS卡片进程模型

更新时间: 2025-12-16 16:38

本文主要介绍，卡片从创建到显示整个过程中各个进程的含义。具体请参考卡片进程模型。

**图1** 卡片进程模型

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163848.57358544478580183758130933573066:50001231000000:2800:5FA2875984F6CBE4BA9D6F87DF79B19DCF9E5AB36944059B34E97598952C2586.png)

- 卡片使用方进程：显示卡片的宿主进程，例如桌面进程。
- 卡片渲染服务进程：系统内统一加载渲染卡片UI的进程，所有卡片渲染在同一个进程内，不同的应用卡片通过虚拟机隔离。
- 卡片管理服务进程：系统内统一卡片生命周期的系统[SA](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/serviceability-overview)服务。
- 卡片提供方进程：提供卡片的应用进程，包括应用自身UIAbility运行的主进程，以及卡片单独的[FormExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability)进程。两个进程之间内存隔离，但是共享相同的文件沙箱。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-lifecycle "管理ArkTS卡片生命周期")
# ArkTS卡片界面开发概述

更新时间: 2025-12-16 16:40

ArkTS卡片开发采用通用[ArkTS语言](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/learning-arkts)，开发者可以使用[ArkTS声明式开发范式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-development-overview)开发ArkTS卡片页面。

如下卡片页面由DevEco Studio模板自动生成，开发者可以根据自身的业务场景进行调整。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164018.75684607016612132553737715291668:50001231000000:2800:2DC066D0BEF8E79A8E84B8B412BE9B0E677A7B14441EBACE878B9E3ED113DB5F.png)

## ArkTS卡片支持的页面能力

ArkTS卡片具备JS卡片的全量能力，并且新增了动效能力和自定义绘制的能力，支持[ArkTS声明式开发范式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-development-overview)的部分组件、事件、动效、数据管理、状态管理能力。

对于支持在ArkTS卡片UI界面中使用的接口，会添加“卡片能力”的标记，如：从API version 12开始，该接口支持在ArkTS卡片中使用。同时请留意卡片场景下的能力差异说明。

例如：以下说明表示CircleShape可在ArkTS卡片中使用。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164018.42962224578892708967835986741307:50001231000000:2800:5029A01EDC4EEA57067A5B02ADBCAC3C53C84D397A9DA6090D4FD1340C1E4AF7.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-page "ArkTS卡片UI界面开发")
# ArkTS卡片为组件添加动效

更新时间: 2025-12-16 16:40

ArkTS卡片开放了使用动画效果的能力，支持[显式动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation)、[属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)、[组件内转场](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)能力。ArkTS卡片使用动画效果时具有以下限制：

**表1** 动效参数限制

|名称|参数说明|限制描述|
|:--|:--|:--|
|duration|动画播放时长|限制最长的动效播放时长为1秒，当设置大于1秒的时间时，动效时长仍为1秒。|
|tempo|动画播放速度|卡片中禁止设置此参数，使用默认值1。|
|delay|动画延迟执行的时长|卡片中禁止设置此参数，使用默认值0毫秒。|
|iterations|动画播放次数|卡片中禁止设置此参数，使用默认值1次。|

说明

静态卡片不支持使用动效能力。

## 组件自身动效

以下示例代码使用[animation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty)接口实现了按钮旋转的动画效果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164031.48071758974006517049202928639752:50001231000000:2800:4E9BDB6AFD0E16F57BFD7E4577B9C30381D7D775D84EEB2AF6EE8A680E23EB14.gif)

1. // entry/src/main/ets/widget/pages/WidgetCard.ets
2. @Entry
3. @Component
4. struct AnimationCard {
5.   @State rotateAngle: number = 0;

6.   build() {
7.     Row() {
8.       Button('change rotate angle')
9.         .height('20%')
10.         .width('90%')
11.         .margin('5%')
12.         .onClick(() => {
13.           this.rotateAngle = (this.rotateAngle === 0 ? 90 : 0);
14.         })
15.         .rotate({ angle: this.rotateAngle })
16.         .animation({
17.           curve: Curve.EaseOut,
18.           playMode: PlayMode.Normal,
19.         })
20.     }.height('100%').alignItems(VerticalAlign.Center)
21.   }
22. }

## 组件转场动效

以下示例代码使用[transition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)接口实现了在卡片内图片出现与消失的动画效果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164031.55403009320320471698991020316982:50001231000000:2800:D7DE32326C2EBEE100014C5EDEF3E3A64663364209CE6ECC7F86E23AA6E03CA4.gif)

1. // entry/src/main/ets/widget/pages/WidgetCard.ets
2. @Entry
3. @Component
4. struct TransitionEffectExample1 {
5.   @State flag: boolean = true;
6.   @State show: string = 'show';

7.   build() {
8.     Column() {
9.       Button(this.show).width(80).height(30).margin(30)
10.         .onClick(() => {
11.           // 点击Button控制Image的显示和消失
12.           if (this.flag) {
13.             this.show = 'hide';
14.           } else {
15.             this.show = 'show';
16.           }
17.           this.flag = !this.flag;
18.         })
19.       if (this.flag) {
20.         // Image的显示和消失配置为相同的过渡效果（出现和消失互为逆过程）
21.         // 出现时从指定的透明度为0、绕z轴旋转180°的状态，变为默认的透明度为1、旋转角为0的状态，透明度与旋转动画时长都为1000ms
22.         // 消失时从默认的透明度为1、旋转角为0的状态，变为指定的透明度为0、绕z轴旋转180°的状态，透明度与旋转动画时长都为1000ms
23.         // $r('app.media.testImg')需要替换开发者所需的图像资源文件
24.         Image($r('app.media.testImg')).width(200).height(200)
25.           .transition(TransitionEffect.OPACITY.animation({ duration: 1000, curve: Curve.Ease }).combine(
26.             TransitionEffect.rotate({ z: 1, angle: 180 })
27.           ))
28.       }
29.     }.width('100%')
30.   }
31. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-page-overview "ArkTS卡片界面开发概述")
# ArkTS卡片使用画布组件绘制自定义图形

更新时间: 2025-12-16 16:40

ArkTS卡片开放了自定义绘制的能力，在卡片上可以通过[Canvas](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-components-canvas-canvas)组件创建一块画布，然后通过[CanvasRenderingContext2D](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-canvasrenderingcontext2d)对象在画布上进行自定义图形的绘制，如下示例代码实现了在画布的中心绘制了一个笑脸。

1. @Entry
2. @Component
3. struct CustomCanvasDrawingCard {
4.   private canvasWidth: number = 0;
5.   private canvasHeight: number = 0;
6.   // 初始化CanvasRenderingContext2D和RenderingContextSettings
7.   private settings: RenderingContextSettings = new RenderingContextSettings(true);
8.   private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);

9.   build() {
10.     Column() {
11.       Row() {
12.         Canvas(this.context)
13.           .width('100%')
14.           .height('100%')
15.           .onReady(() => {
16.             // 在onReady回调中获取画布的实际宽和高
17.             this.canvasWidth = this.context.width;
18.             this.canvasHeight = this.context.height;
19.             // 绘制画布的背景
20.             this.context.fillStyle = '#EEF0FF';
21.             this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
22.             // 在画布的中心绘制一个圆
23.             this.context.beginPath();
24.             let radius = this.context.width / 3;
25.             let circleX = this.context.width / 2;
26.             let circleY = this.context.height / 2;
27.             this.context.moveTo(circleX - radius, circleY);
28.             this.context.arc(circleX, circleY, radius, 2 * Math.PI, 0, true);
29.             this.context.closePath();
30.             this.context.fillStyle = '#5A5FFF';
31.             this.context.fill();
32.             // 绘制笑脸的左眼
33.             let leftR = radius / 13;
34.             let leftX = circleX - (radius / 2.3);
35.             let leftY = circleY - (radius / 4.5);
36.             this.context.beginPath();
37.             this.context.arc(leftX, leftY, leftR, 0, 2 * Math.PI, true);
38.             this.context.closePath();
39.             this.context.strokeStyle = '#FFFFFF';
40.             this.context.lineWidth = 15;
41.             this.context.stroke();
42.             // 绘制笑脸的右眼
43.             let rightR = radius / 13;
44.             let rightX = circleX + (radius / 2.3);
45.             let rightY = circleY - (radius / 4.5);
46.             this.context.beginPath();
47.             this.context.arc(rightX, rightY, rightR, 0, 2 * Math.PI, true);
48.             this.context.closePath();
49.             this.context.strokeStyle = '#FFFFFF';
50.             this.context.lineWidth = 15;
51.             this.context.stroke();
52.             // 绘制笑脸的鼻子
53.             let startX = circleX;
54.             let startY = circleY - 20;
55.             this.context.beginPath();
56.             this.context.moveTo(startX, startY);
57.             this.context.lineTo(startX - 8, startY + 40);
58.             this.context.lineTo(startX + 8, startY + 40);
59.             this.context.strokeStyle = '#FFFFFF';
60.             this.context.lineWidth = 15;
61.             this.context.lineCap = 'round';
62.             this.context.lineJoin = 'round';
63.             this.context.stroke();
64.             // 绘制笑脸的嘴巴
65.             let mouthR = radius / 2;
66.             let mouthX = circleX;
67.             let mouthY = circleY + 10;
68.             this.context.beginPath();
69.             this.context.arc(mouthX, mouthY, mouthR, Math.PI / 1.4, Math.PI / 3.4, true);
70.             this.context.strokeStyle = '#FFFFFF';
71.             this.context.lineWidth = 15;
72.             this.context.stroke();
73.             this.context.closePath();
74.           })
75.       }
76.     }.height('100%').width('100%')
77.   }
78. }

运行效果如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.13854766190807021731382442646867:50001231000000:2800:D4D5C84E8925ABE384510976E75DFADD65600270F81A6AFFA9D188B4968CC396.jpeg)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-page-animation "ArkTS卡片为组件添加动效")
# ArkTS卡片界面适配深浅色模式

更新时间: 2025-12-16 16:40

当前系统存在深浅色两种显示模式，为了给用户更好的使用体验，保障卡片与页面视觉体验一致性，ArkTS卡片支持适配深浅色模式，具体请参考[应用深浅色适配](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ui-dark-light-color-adaptation)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-page-custom-drawing "ArkTS卡片使用画布组件绘制自定义图形")
# ArkTS卡片页面刷新概述

更新时间: 2025-12-16 16:40

卡片使用方（例如：桌面）和卡片提供方均可主动触发卡片页面刷新。此外，卡片管理服务会根据开发者声明的定时信息，按需通知卡片提供方进行卡片刷新。因此，卡片刷新方式包括：卡片提供方主动触发刷新、卡片使用方主动触发刷新以及卡片定时定点刷新。这些刷新方式均需由卡片提供方推送需要刷新的卡片数据。

## 卡片数据交互

ArkTS卡片管理服务支持卡片提供方（例如：应用）和卡片之间的数据交互。卡片通过[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)传递数据给卡片提供方，卡片提供方则通过[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口传递数据给卡片。卡片提供方将数据提供给卡片后，可以用于卡片页面刷新等。

由于卡片提供方和卡片为相互独立的进程，两者间的数据共享只能通过[LocalStorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage#localstorageprop)传递，不能使用getContext方法。因此卡片提供方推送数据后，卡片UI需要通过LocalStorageProp接收数据，且接收数据时，卡片数据会被转换成string类型。

## 页面刷新分类

根据触发方式的差异，卡片刷新分为主动刷新和被动刷新。

### 主动刷新

主动刷新包括卡片提供方主动刷新卡片和卡片使用方主动刷新卡片。开发指导请参考[ArkTS卡片主动刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-active-refresh)。

**图1 卡片提供方主动刷新卡片流程图**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164018.28898706915418466687838867508403:50001231000000:2800:01D2642CFB9055AE4A1576A870A64842F8D65FA2C2262701063731C58AD04C83.png)

卡片提供方应用运行过程中，如果识别到有要更新卡片数据的诉求，可以主动通过formProvider提供的[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口更新卡片。

**图2 卡片使用方主动刷新卡片流程图**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164018.36218248649348040192540505230991:50001231000000:2800:88D5C9FA64D07EBDE4B06E01086DF3DFE0CEB293F931CABC4507F26EE0AFEA07.png)

卡片使用方在运行过程中，如果检测到系统语言、深浅色有变化时，可以主动通过formHost提供的requestForm（仅支持系统应用使用）接口请求更新卡片，卡片管理服务会进而通知卡片提供方完成卡片更新。

### 被动刷新

被动刷新包括定时刷新、定点刷新。开发指导请参考[ArkTS卡片被动刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-passive-refresh)。

卡片定时刷新：表示在一定时间间隔内调用[onUpdateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonupdateform)的生命周期回调函数自动刷新卡片内容。

卡片定点刷新：表示在每天的某个特定时间点自动刷新卡片内容。

**图3 卡片管理服务通知卡片提供方定时定点刷新卡片流程图**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164018.81674959346995276896749520962003:50001231000000:2800:9DF5AC38C5D8D83893B582AFF90174A47FEB4C36F7785B1CDD68B1D554069310.png)

根据卡片提供方开发者提前配置声明的定时刷新信息，卡片管理服务会根据定时信息、卡片可见状态、刷新次数等因素综合判断是否需要通知卡片提供方更新卡片。

## 约束与限制

1. 卡片提供方仅允许刷新自己的卡片，其他提供方的卡片无法刷新。
2. 卡片使用方仅允许刷新添加到自己的卡片，添加到其他使用方的卡片无法刷新。
3. 从API version 20开始，如果卡片刷新的数据通过共享内存更新，刷新数据总大小不超过10MB，刷新图片数量不超过20张，API version 19及之前的版本，图片文件数量上限为5张，每张限制内存2MB，超出限制的图片会显示异常。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-interaction "ArkTS卡片页面刷新")
# ArkTS卡片主动刷新

更新时间: 2025-12-16 16:40

本文主要提供主动刷新的开发指导，刷新流程请参考[主动刷新概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-interaction-overview#%E4%B8%BB%E5%8A%A8%E5%88%B7%E6%96%B0)。

## 卡片提供方主动刷新卡片内容

卡片提供方可以通过[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口进行主动刷新。推荐与卡片生命周期回调[onFormEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonformevent)、[onUpdateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonupdateform)、[onAddForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonaddform)接口搭配使用。

### 开发步骤

下面给出一个示例，实现如下功能：卡片添加至桌面后，点击卡片上的刷新按钮，刷新卡片信息。

1. [创建卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation)。
    
2. 实现卡片布局，在卡片上添加一个刷新按钮，点击按钮后通过[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)接口，触发onFormEvent回调。
    
    1. // entry/src/main/ets/updatebymessage/pages/UpdateByMessageCard.ets
    2. let storageUpdateByMsg = new LocalStorage();
    
    3. @Entry(storageUpdateByMsg)
    4. @Component
    5. struct UpdateByMessageCard {
    6.   // 创建两个待刷新的Text，Text初始内容分别为'Title default'、'Description default'。资源文件定义请参见下方步骤4
    7.   @LocalStorageProp('title') title: ResourceStr = $r('app.string.default_title');
    8.   @LocalStorageProp('detail') detail: ResourceStr = $r('app.string.DescriptionDefault');
    
    9.   build() {
    10.     Column() {
    11.       Column() {
    12.         Text(this.title)
    13.           .fontColor('#FFFFFF')
    14.           .opacity(0.9)
    15.           .fontSize(14)
    16.           .margin({ top: '8%', left: '10%' })
    17.         Text(this.detail)
    18.           .fontColor('#FFFFFF')
    19.           .opacity(0.6)
    20.           .fontSize(12)
    21.           .margin({ top: '5%', left: '10%' })
    22.       }.width('100%').height('50%')
    23.       .alignItems(HorizontalAlign.Start)
    
    24.       Row() {
    25.         // 添加一个按钮，资源文件定义请参见下方步骤4
    26.         Button() {
    27.           Text($r('app.string.update'))
    28.             .fontColor('#45A6F4')
    29.             .fontSize(12)
    30.         }
    31.         .width(120)
    32.         .height(32)
    33.         .margin({ top: '30%', bottom: '10%' })
    34.         .backgroundColor('#FFFFFF')
    35.         .borderRadius(16)
    36.         .onClick(() => {
    37.           postCardAction(this, {
    38.             action: 'message',
    39.             params: { msgTest: 'messageEvent' }
    40.           });
    41.         })
    42.       }.width('100%').height('40%')
    43.       .justifyContent(FlexAlign.Center)
    44.     }
    45.     .width('100%')
    46.     .height('100%')
    47.     .alignItems(HorizontalAlign.Start)
    48.     .backgroundImage($r('app.media.CardEvent'))
    49.     .backgroundImageSize(ImageSize.Cover)
    50.   }
    51. }
    
3. 在onFormEvent回调函数的实现中，通过updateForm接口刷新卡片数据。
    
    1. // entry/src/main/ets/entryformability/EntryFormAbility.ts
    2. import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
    3. import { Configuration, Want } from '@kit.AbilityKit';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    5. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    6. const TAG: string = 'EntryFormAbility';
    7. const DOMAIN_NUMBER: number = 0xFF00;
    
    8. export default class EntryFormAbility extends FormExtensionAbility {
    9.   onAddForm(want: Want): formBindingData.FormBindingData {
    10.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onAddForm');
    11.     hilog.info(DOMAIN_NUMBER, TAG, want.parameters?.[formInfo.FormParam.NAME_KEY] as string);
    12.     let formData: Record<string, string> = { };
    13.     return formBindingData.createFormBindingData(formData);
    14.   }
    
    15.   onCastToNormalForm(formId: string): void {
    16.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onCastToNormalForm');
    17.   }
    
    18.   onUpdateForm(formId: string): void {
    19.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onUpdateForm');
    20.     // ...
    21.   }
    
    22.   onChangeFormVisibility(newStatus: Record<string, number>): void {
    23.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onChangeFormVisibility');
    24.   }
    
    25.   onFormEvent(formId: string, message: string): void {
    26.     hilog.info(DOMAIN_NUMBER, TAG, `FormAbility onFormEvent, formId = ${formId}, message: ${JSON.stringify(message)}`);
    27.     class FormDataClass {
    28.       // 定义Text刷新后的内容，分别为'Title Update'、'Description update success'
    29.       title: string = 'Title Update.';
    30.       detail: string = 'Description update success.';
    31.     }
    
    32.     let formData = new FormDataClass();
    33.     let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
    34.     formProvider.updateForm(formId, formInfo).then(() => {
    35.       hilog.info(DOMAIN_NUMBER, TAG, 'FormAbility updateForm success.');
    36.     }).catch((error: BusinessError) => {
    37.       hilog.error(DOMAIN_NUMBER, TAG, `Operation updateForm failed. Cause: ${JSON.stringify(error)}`);
    38.     });
    39.   }
    
    40.   onRemoveForm(formId: string): void {
    41.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onRemoveForm');
    42.   }
    
    43.   onConfigurationUpdate(config: Configuration) {
    44.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onConfigurationUpdate:' + JSON.stringify(config));
    45.   }
    
    46.   onAcquireFormState(want: Want): formInfo.FormState {
    47.     return formInfo.FormState.READY;
    48.   }
    49. }
    
4. 资源文件如下。
    
    1. // entry/src/main/resources/zh_CN/element/string.json
    2. {
    3.   "string": [
    4.     // ...
    5.     {
    6.       "name": "default_title",
    7.       "value": "Title default."
    8.     },
    9.     {
    10.       "name": "DescriptionDefault",
    11.       "value": "Description default."
    12.     },
    13.     {
    14.       "name": "update",
    15.       "value": "刷新"
    16.     }
    17.   ]
    18. }
    

### 运行结果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164031.03407409043857246856699310083255:50001231000000:2800:B4B6B54608FBC9E761C5AE915FA77773A1B53CA6152C0F9A52316FF82746C6C1.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-interaction-overview "ArkTS卡片页面刷新概述")
# ArkTS卡片被动刷新

更新时间: 2025-12-16 16:40

本文主要提供被动刷新的开发指导，刷新流程请参考[被动刷新概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-interaction-overview#%E8%A2%AB%E5%8A%A8%E5%88%B7%E6%96%B0)。

## 卡片定时刷新

当前卡片框架提供了如下两种按时间刷新卡片的方式：

- 定时刷新：表示在一定时间间隔内调用[onUpdateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonupdateform)的生命周期回调函数自动刷新卡片内容。可以在[form_config.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)配置文件的updateDuration字段中进行设置。例如，可以将updateDuration字段的值设置为2，表示刷新时间间隔为2个30分钟，即1小时。
    
    1. {
    2.   "forms": [
    3.     {
    4.       "name": "UpdateDuration",
    5.       "description": "$string:widget_updateduration_desc",
    6.       "src": "./ets/updateduration/pages/UpdateDurationCard.ets",
    7.       "uiSyntax": "arkts",
    8.       "window": {
    9.         "designWidth": 720,
    10.         "autoDesignWidth": true
    11.       },
    12.       "isDefault": true,
    13.       "updateEnabled": true,
    14.       "scheduledUpdateTime": "10:30",
    15.       "updateDuration": 2,
    16.       "defaultDimension": "2*2",
    17.       "supportDimensions": [
    18.         "2*2"
    19.       ]
    20.     }
    21.   ]
    22. }
    

说明

在使用定时刷新时，需要在form_config.json配置文件中设置updateEnabled字段为true，以启用周期性刷新功能。

- 下次刷新：表示指定卡片的下一次刷新时间。可以通过调用[setFormNextRefreshTime](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formprovidersetformnextrefreshtime)接口来实现。最短刷新时间为5分钟。例如，可以在接口调用后的5分钟内刷新卡片内容。
    
    1. import { FormExtensionAbility, formProvider } from '@kit.FormKit';
    2. import { hilog } from '@kit.PerformanceAnalysisKit';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. const TAG: string = 'UpdateByTimeFormAbility';
    5. const FIVE_MINUTE: number = 5;
    6. const DOMAIN_NUMBER: number = 0xFF00;
    
    7. export default class UpdateByTimeFormAbility extends FormExtensionAbility {
    8.   onFormEvent(formId: string, message: string): void {
    9.     // Called when a specified message event defined by the form provider is triggered.
    10.     hilog.info(DOMAIN_NUMBER, TAG, `FormAbility onFormEvent, formId = ${formId}, message: ${JSON.stringify(message)}`);
    11.     try {
    12.       // 设置过5分钟后更新卡片内容
    13.       formProvider.setFormNextRefreshTime(formId, FIVE_MINUTE, (err: BusinessError) => {
    14.         if (err) {
    15.           hilog.info(DOMAIN_NUMBER, TAG, `Failed to setFormNextRefreshTime. Code: ${err.code}, message: ${err.message}`);
    16.           return;
    17.         } else {
    18.           hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in setFormNextRefreshTiming.');
    19.         }
    20.       });
    21.     } catch (err) {
    22.       hilog.info(DOMAIN_NUMBER, TAG, `Failed to setFormNextRefreshTime. Code: ${(err as BusinessError).code}, message: ${(err as BusinessError).message}`);
    23.     }
    24.   }
    25.   // ...
    26. }
    

在触发定时、下次刷新后，系统会调用FormExtensionAbility的[onUpdateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonupdateform)生命周期回调，在回调中，可以使用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)进行提供方刷新卡片。onUpdateForm生命周期回调的使用请参见[卡片生命周期管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-lifecycle)。

**约束限制：**

1. 定时刷新有配额限制，每张卡片每天最多通过定时方式触发刷新50次，定时刷新次数可以通过修改[卡片配置项updateDuration字段](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)、或调用[setFormNextRefreshTime](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formprovidersetformnextrefreshtime)接口两种方式进行设置，当达到50次配额后，无法通过定时方式再次触发刷新，刷新次数会在每天的0点重置。
2. 当前定时刷新使用同一个计时器进行计时，因此卡片定时刷新的第一次刷新会有最多30分钟的偏差。比如第一张卡片A（每隔半小时刷新一次）在3点20分添加成功，定时器启动并每隔半小时触发一次事件，第二张卡片B(每隔半小时刷新一次)在3点40分添加成功，在3点50分定时器事件触发时，卡片A触发定时刷新，卡片B会在下次事件（4点20分）中才会触发。
3. 定时刷新在卡片可见情况下才会触发，在卡片不可见时仅会记录刷新动作和刷新数据，待可见时统一刷新布局。
4. 如果使能了卡片代理刷新，定时刷新和下次刷新不生效。

## 卡片定点刷新

当前卡片框架提供了如下两种定点刷新卡片的方式：

- 单定点刷新：表示在每天的某个特定时间点自动刷新卡片内容。可以在form_config.json配置文件中的scheduledUpdateTime字段中进行设置。例如，可以将刷新时间设置为每天的上午10点30分。
    
    1. {
    2.   "forms": [
    3.     {
    4.       "name": "ScheduledUpdateTime",
    5.       "description": "$string:widget_scheupdatetime_desc",
    6.       "src": "./ets/scheduledupdatetime/pages/ScheduledUpdateTimeCard.ets",
    7.       "uiSyntax": "arkts",
    8.       "window": {
    9.         "designWidth": 720,
    10.         "autoDesignWidth": true
    11.       },
    12.       "isDefault": true,
    13.       "updateEnabled": true,
    14.       "scheduledUpdateTime": "10:30",
    15.       "updateDuration": 0,
    16.       "defaultDimension": "2*2",
    17.       "supportDimensions": [
    18.         "2*2"
    19.       ]
    20.     }
    21.   ]
    22. }
    
- 多定点刷新：表示在每天的多个特定时间点自动刷新卡片内容。可以在form_config.json配置文件中的multiScheduledUpdateTime字段中进行设置，例如，可以将刷新时间设置为每天的上午11点30分和下午4点30分。
    
    1. {
    2.   "forms": [
    3.   {
    4.       "name": "ScheduledUpdateTime",
    5.       "description": "$string:widget_scheupdatetime_desc",
    6.       "src": "./ets/scheduledupdatetime/pages/ScheduledUpdateTimeCard.ets",
    7.       "uiSyntax": "arkts",
    8.       "window": {
    9.         "designWidth": 720,
    10.         "autoDesignWidth": true
    11.       },
    12.       "isDefault": true,
    13.       "updateEnabled": true,
    14.       "scheduledUpdateTime": "10:30",
    15.       "multiScheduledUpdateTime": "11:30,16:30",
    16.       "updateDuration": 0,
    17.       "defaultDimension": "2*2",
    18.       "supportDimensions": [
    19.         "2*2"
    20.       ]
    21.     }
    22.   ]
    23. }
    

在触发定点刷新后，系统会调用FormExtensionAbility的[onUpdateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonupdateform)生命周期回调，在回调中，可以使用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)进行提供方刷新卡片。onUpdateForm生命周期回调的使用请参见[卡片生命周期管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-lifecycle)。

说明

1. 当同时配置了定时刷新updateDuration和定点刷新scheduledUpdateTime时，定时刷新的优先级更高且定点刷新不会执行。如果想要配置定点刷新，则需要将updateDuration配置为0。
2. multiScheduledUpdateTime的配置最多可设置24个时间。
3. 同时配置了单定点和多定点刷新，多定点刷新配置生效，单定点刷新配置不生效。
4. 考虑到向前兼容的问题，尽量保留scheduledUpdateTime字段，不要直接删除。

**约束限制：**

1. 定点刷新在卡片可见情况下才会触发，在卡片不可见时仅会记录刷新动作和刷新数据，待可见时统一刷新布局。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-active-refresh "ArkTS卡片主动刷新")
# 刷新本地图片和网络图片

更新时间: 2025-12-16 16:40

在卡片上通常需要展示本地图片或从网络上下载的图片，获取本地图片和网络图片需要通过FormExtensionAbility来实现，如下示例代码介绍了如何在卡片上显示本地图片和网络图片。

1. 下载网络图片需要使用到网络能力，需要申请ohos.permission.INTERNET权限，配置方式请参见[声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions)。
    
2. 在EntryFormAbility中的onAddForm生命周期回调中实现本地文件的刷新。
    
    1. import { Want } from '@kit.AbilityKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { fileIo } from '@kit.CoreFileKit';
    4. import { formBindingData, FormExtensionAbility } from '@kit.FormKit';
    5. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    6. const TAG: string = 'WgtImgUpdateEntryFormAbility';
    7. const DOMAIN_NUMBER: number = 0xFF00;
    
    8. export default class WgtImgUpdateEntryFormAbility extends FormExtensionAbility {
    9.   // 在添加卡片时，打开一个本地图片并将图片内容传递给卡片页面显示
    10.   onAddForm(want: Want): formBindingData.FormBindingData {
    11.     // 假设在当前卡片应用的tmp目录下有一个本地图片：head.PNG
    12.     let tempDir = this.context.getApplicationContext().tempDir;
    13.     hilog.info(DOMAIN_NUMBER, TAG, `tempDir: ${tempDir}`);
    14.     let imgMap: Record<string, number> = {};
    15.     try {
    16.       // 打开本地图片并获取其打开后的fd, FormExtensionAbility进程销毁时释放
    17.       let file = fileIo.openSync(tempDir + '/' + 'head.PNG');
    18.       imgMap['imgBear'] = file.fd;
    19.     } catch (e) {
    20.       hilog.error(DOMAIN_NUMBER, TAG, `openSync failed: ${JSON.stringify(e as BusinessError)}`);
    21.     }
    
    22.     class FormDataClass {
    23.       text: string = 'Image: Bear';
    24.       loaded: boolean = true;
    25.       // 卡片需要显示图片场景, 必须和下列字段formImages 中的key 'imgBear' 相同。
    26.       imgName: string = 'imgBear';
    27.       // 卡片需要显示图片场景, 必填字段(formImages 不可缺省或改名), 'imgBear' 对应 fd
    28.       formImages: Record<string, number> = imgMap;
    29.     }
    
    30.     let formData = new FormDataClass();
    31.     // 将fd封装在formData中并返回至卡片页面
    32.     return formBindingData.createFormBindingData(formData);
    33.   }
    34.   //...
    35. }
    
3. 在EntryFormAbility中的onFormEvent生命周期回调中实现网络文件的刷新。
    
    1. import { BusinessError } from '@kit.BasicServicesKit';
    2. import { fileIo } from '@kit.CoreFileKit';
    3. import { formBindingData, FormExtensionAbility, formProvider } from '@kit.FormKit';
    4. import { http } from '@kit.NetworkKit';
    5. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    6. const TAG: string = 'WgtImgUpdateEntryFormAbility';
    7. const DOMAIN_NUMBER: number = 0xFF00;
    
    8. export default class WgtImgUpdateEntryFormAbility extends FormExtensionAbility {
    9.   async onFormEvent(formId: string, message: string): Promise<void> {
    10.     let param: Record<string, string> = {
    11.       'text': '刷新中...'
    12.     };
    13.     let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(param);
    14.     formProvider.updateForm(formId, formInfo);
    
    15.     // 注意：FormExtensionAbility在触发生命周期回调时被拉起，仅能在后台存在5秒
    16.     // 建议下载能快速下载完成的小文件，如在5秒内未下载完成，则此次网络图片无法刷新至卡片页面上
    17.     let netFile = 'https://cn-assets.gitee.com/assets/mini_app-e5eee5a21c552b69ae6bf2cf87406b59.jpg'; // 需要在此处使用真实的网络图片下载链接
    18.     let tempDir = this.context.getApplicationContext().tempDir;
    19.     let fileName = 'file' + Date.now();
    20.     let tmpFile = tempDir + '/' + fileName;
    21.     let imgMap: Record<string, number> = {};
    
    22.     class FormDataClass {
    23.       text: string = 'Image: Bear' + fileName;
    24.       loaded: boolean = true;
    25.       // 卡片需要显示图片场景, 必须和下列字段formImages 中的key fileName 相同。
    26.       imgName: string = fileName;
    27.       // 卡片需要显示图片场景, 必填字段(formImages 不可缺省或改名), fileName 对应 fd
    28.       formImages: Record<string, number> = imgMap;
    29.     }
    
    30.     let httpRequest = http.createHttp()
    31.     let data = await httpRequest.request(netFile);
    32.     if (data?.responseCode == http.ResponseCode.OK) {
    33.       try {
    34.         let imgFile = fileIo.openSync(tmpFile, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
    35.         imgMap[fileName] = imgFile.fd;
    36.         try{
    37.           let writeLen: number = await fileIo.write(imgFile.fd, data.result as ArrayBuffer);
    38.           hilog.info(DOMAIN_NUMBER, TAG, "write data to file succeed and size is:" + writeLen);
    39.           hilog.info(DOMAIN_NUMBER, TAG, 'ArkTSCard download complete: %{public}s', tmpFile);
    40.           try {
    41.             let formData = new FormDataClass();
    42.             let formInfo = formBindingData.createFormBindingData(formData);
    43.             await formProvider.updateForm(formId, formInfo);
    44.             hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'FormAbility updateForm success.');
    45.           } catch (error) {
    46.             hilog.error(DOMAIN_NUMBER, TAG, `FormAbility updateForm failed: ${JSON.stringify(error)}`);
    47.           }
    48.         } catch (err) {
    49.           hilog.error(DOMAIN_NUMBER, TAG, "write data to file failed with error message: " + err.message + ", error code: " + err.code);
    50.         } finally {
    51.           // 在fileIo.closeSync执行之前，确保formProvider.updateForm已执行完毕。
    52.           fileIo.closeSync(imgFile);
    53.         };
    54.       } catch (e) {
    55.         hilog.error(DOMAIN_NUMBER, TAG, `openSync failed: ${JSON.stringify(e as BusinessError)}`);
    56.       }
    
    57.     } else {
    58.       hilog.error(DOMAIN_NUMBER, TAG, `ArkTSCard download task failed`);
    59.       let param: Record<string, string> = {
    60.         'text': '刷新失败'
    61.       };
    62.       let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(param);
    63.       formProvider.updateForm(formId, formInfo);
    64.     }
    65.     httpRequest.destroy();
    66.   }
    67. }
    
4. 在卡片页面通过backgroundImage属性展示EntryFormAbility传递过来的卡片内容。
    
    1. let storageWidgetImageUpdate = new LocalStorage();
    
    2. @Entry(storageWidgetImageUpdate)
    3. @Component
    4. struct WidgetImageUpdateCard {
    5.   @LocalStorageProp('text') text: ResourceStr = $r('app.string.loading');
    6.   @LocalStorageProp('loaded') loaded: boolean = false;
    7.   @LocalStorageProp('imgName') imgName: ResourceStr = $r('app.string.imgName');
    
    8.   build() {
    9.     Column() {
    10.       Column() {
    11.         Text(this.text)
    12.           .fontColor('#FFFFFF')
    13.           .opacity(0.9)
    14.           .fontSize(12)
    15.           .textOverflow({ overflow: TextOverflow.Ellipsis })
    16.           .maxLines(1)
    17.           .margin({ top: '8%', left: '10%' })
    18.       }.width('100%').height('50%')
    19.       .alignItems(HorizontalAlign.Start)
    
    20.       Row() {
    21.         Button() {
    22.           Text($r('app.string.update'))
    23.             .fontColor('#45A6F4')
    24.             .fontSize(12)
    25.         }
    26.         .width(120)
    27.         .height(32)
    28.         .margin({ top: '30%', bottom: '10%' })
    29.         .backgroundColor('#FFFFFF')
    30.         .borderRadius(16)
    31.         .onClick(() => {
    32.           postCardAction(this, {
    33.             action: 'message',
    34.             params: {
    35.               info: 'refreshImage'
    36.             }
    37.           });
    38.         })
    39.       }.width('100%').height('40%')
    40.       .justifyContent(FlexAlign.Center)
    41.     }
    42.     .width('100%').height('100%')
    43.     .backgroundImage(this.loaded ? 'memory://' + this.imgName : $r('app.media.ImageDisp'))
    44.     .backgroundImageSize(ImageSize.Cover)
    45.   }
    46. }
    

说明

- Image组件通过入参(memory://fileName)中的(memory://)标识来进行远端内存图片显示，其中fileName需要和EntryFormAbility传递对象('formImages': {key: fd})中的key相对应。
    
- Image组件通过传入的参数是否有变化来决定是否刷新图片，因此EntryFormAbility每次传递过来的imgName都需要不同，连续传递两个相同的imgName时，图片不会刷新。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-passive-refresh "ArkTS卡片被动刷新")
# 根据卡片状态刷新不同内容

更新时间: 2025-12-16 16:40

相同的卡片可以添加到桌面上实现不同的功能，比如添加两张桌面的卡片，一张显示杭州的天气，一张显示北京的天气，设置每天早上7点触发定时刷新，卡片需要感知当前的配置是杭州还是北京，然后将对应城市的天气信息刷新到卡片上，以下示例介绍了如何根据卡片的状态动态选择需要刷新的内容。

- 卡片配置文件：配置每30分钟自动刷新。
    
    1. {
    2.   "forms": [
    3.     {
    4.       "name": "WidgetUpdateByStatus",
    5.       "description": "$string:UpdateByStatusFormAbility_desc",
    6.       "src": "./ets/widgetupdatebystatus/pages/WidgetUpdateByStatusCard.ets",
    7.       "uiSyntax": "arkts",
    8.       "window": {
    9.         "designWidth": 720,
    10.         "autoDesignWidth": true
    11.       },
    12.       "isDefault": true,
    13.       "updateEnabled": true,
    14.       "scheduledUpdateTime": "10:30",
    15.       "updateDuration": 1,
    16.       "defaultDimension": "2*2",
    17.       "supportDimensions": [
    18.         "2*2"
    19.       ]
    20.     }
    21.   ]
    22. }
    
- 卡片页面：卡片具备不同的状态选择，在不同的状态下需要刷新不同的内容，因此在状态发生变化时通过postCardAction通知EntryFormAbility。
    
    1. let storageUpdateByStatus = new LocalStorage();
    
    2. @Entry(storageUpdateByStatus)
    3. @Component
    4. struct WidgetUpdateByStatusCard {
    5.   // $r('app.string.to_be_refreshed')需要替换为开发者所需的资源文件
    6.   @LocalStorageProp('textA') textA: Resource = $r('app.string.to_be_refreshed');
    7.   @LocalStorageProp('textB') textB: Resource = $r('app.string.to_be_refreshed');
    8.   @State selectA: boolean = false;
    9.   @State selectB: boolean = false;
    
    10.   build() {
    11.     Column() {
    12.       Column() {
    13.         Row() {
    14.           Checkbox({ name: 'checkbox1', group: 'checkboxGroup' })
    15.             .padding(0)
    16.             .select(false)
    17.             .margin({ left: 26 })
    18.             .onChange((value: boolean) => {
    19.               this.selectA = value;
    20.               postCardAction(this, {
    21.                 action: 'message',
    22.                 params: {
    23.                   selectA: JSON.stringify(value)
    24.                 }
    25.               });
    26.             })
    27.           // $r('app.string.status_a')需要替换为开发者所需的资源文件
    28.           Text($r('app.string.status_a'))
    29.             .fontColor('#000000')
    30.             .opacity(0.9)
    31.             .fontSize(14)
    32.             .margin({ left: 8 })
    33.         }
    34.         .width('100%')
    35.         .padding(0)
    36.         .justifyContent(FlexAlign.Start)
    
    37.         Row() {
    38.           Checkbox({ name: 'checkbox2', group: 'checkboxGroup' })
    39.             .padding(0)
    40.             .select(false)
    41.             .margin({ left: 26 })
    42.             .onChange((value: boolean) => {
    43.               this.selectB = value;
    44.               postCardAction(this, {
    45.                 action: 'message',
    46.                 params: {
    47.                   selectB: JSON.stringify(value)
    48.                 }
    49.               });
    50.             })
    51.           // $r('app.string.status_b')需要替换为开发者所需的资源文件
    52.           Text($r('app.string.status_b'))
    53.             .fontColor('#000000')
    54.             .opacity(0.9)
    55.             .fontSize(14)
    56.             .margin({ left: 8 })
    57.         }
    58.         .width('100%')
    59.         .position({ y: 32 })
    60.         .padding(0)
    61.         .justifyContent(FlexAlign.Start)
    62.       }
    63.       .position({ y: 12 })
    
    64.       Column() {
    65.         Row() { // 选中状态A才会进行刷新的内容
    66.           Text($r('app.string.status_a'))
    67.             .fontColor('#000000')
    68.             .opacity(0.4)
    69.             .fontSize(12)
    
    70.           Text(this.textA)
    71.             .fontColor('#000000')
    72.             .opacity(0.4)
    73.             .fontSize(12)
    74.         }
    75.         .margin({ top: '12px', left: 26, right: '26px' })
    
    76.         Row() { // 选中状态B才会进行刷新的内容
    77.           Text($r('app.string.status_b'))
    78.             .fontColor('#000000')
    79.             .opacity(0.4)
    80.             .fontSize(12)
    81.           Text(this.textB)
    82.             .fontColor('#000000')
    83.             .opacity(0.4)
    84.             .fontSize(12)
    85.         }.margin({ top: '12px', bottom: '21px', left: 26, right: '26px' })
    86.       }
    87.       .margin({ top: 80 })
    88.       .width('100%')
    89.       .alignItems(HorizontalAlign.Start)
    90.     }.width('100%').height('100%')
    91.     // $r('app.media.CardUpdateByStatus')需要替换为开发者所需的资源文件
    92.     .backgroundImage($r('app.media.CardUpdateByStatus'))
    93.     .backgroundImageSize(ImageSize.Cover)
    94.   }
    95. }
    
- EntryFormAbility：将卡片的状态存储在本地数据库中，在刷新事件回调触发时，通过formId获取当前卡片的状态，然后根据卡片的状态选择不同的刷新内容。
    
    1. import { Want } from '@kit.AbilityKit';
    2. import { preferences } from '@kit.ArkData';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
    5. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    6. const TAG: string = 'UpdateByStatusFormAbility';
    7. const DOMAIN_NUMBER: number = 0xFF00;
    
    8. export default class UpdateByStatusFormAbility extends FormExtensionAbility {
    9.   onAddForm(want: Want): formBindingData.FormBindingData {
    10.     let formId: string = '';
    11.     if (want.parameters) {
    12.       formId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();
    13.       let promise: Promise<preferences.Preferences> = preferences.getPreferences(this.context, 'myStore');
    14.       promise.then(async (storeDB: preferences.Preferences) => {
    15.         hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences.');
    16.         await storeDB.put('A' + formId, 'false');
    17.         await storeDB.put('B' + formId, 'false');
    18.         await storeDB.flush();
    19.       }).catch((err: BusinessError) => {
    20.         hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);
    21.       });
    22.     }
    23.     let formData: Record<string, Object | string> = {};
    24.     return formBindingData.createFormBindingData(formData);
    25.   }
    
    26.   onRemoveForm(formId: string): void {
    27.     hilog.info(DOMAIN_NUMBER, TAG, 'onRemoveForm, formId:' + formId);
    28.     let promise = preferences.getPreferences(this.context, 'myStore');
    29.     promise.then(async (storeDB) => {
    30.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences.');
    31.       await storeDB.delete('A' + formId);
    32.       await storeDB.delete('B' + formId);
    33.     }).catch((err: BusinessError) => {
    34.     hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);
    35.     });
    36.   }
    
    37.   // 当前卡片使用方不会涉及该场景，无需实现该回调函数
    38.   onCastToNormalForm(formId: string): void { }
    
    39.   onUpdateForm(formId: string): void {
    40.     let promise: Promise<preferences.Preferences> = preferences.getPreferences(this.context, 'myStore');
    41.     promise.then(async (storeDB: preferences.Preferences) => {
    42.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences from onUpdateForm.');
    43.       let stateA = await storeDB.get('A' + formId, 'false');
    44.       let stateB = await storeDB.get('B' + formId, 'false');
    45.       // A状态选中则更新textA
    46.       if (stateA === 'true') {
    47.         let param: Record<string, string> = {
    48.           'textA': 'AAA'
    49.         };
    50.         let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(param);
    51.         await formProvider.updateForm(formId, formInfo);
    52.       }
    53.       // B状态选中则更新textB
    54.       if (stateB === 'true') {
    55.         let param: Record<string, string> = {
    56.           'textB': 'BBB'
    57.         };
    58.         let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(param);
    59.       await formProvider.updateForm(formId, formInfo);
    60.       }
    61.       hilog.info(DOMAIN_NUMBER, TAG, `Update form success stateA:${stateA} stateB:${stateB}.`);
    62.     }).catch((err: BusinessError) => {
    63.       hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);
    64.     });
    65.   }
    
    66.   onFormEvent(formId: string, message: string): void {
    67.     // 存放卡片状态
    68.     hilog.info(DOMAIN_NUMBER, TAG, 'onFormEvent formId:' + formId + 'msg:' + message);
    69.     let promise: Promise<preferences.Preferences> = preferences.getPreferences(this.context, 'myStore');
    70.     promise.then(async (storeDB: preferences.Preferences) => {
    71.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences.');
    72.       let msg: Record<string, string> = JSON.parse(message);
    73.       if (msg.selectA !== undefined) {
    74.         hilog.info(DOMAIN_NUMBER, TAG, 'onFormEvent selectA info:' + msg.selectA);
    75.         await storeDB.put('A' + formId, msg.selectA);
    76.       }
    77.       if (msg.selectB !== undefined) {
    78.         hilog.info(DOMAIN_NUMBER, TAG, 'onFormEvent selectB info:' + msg.selectB);
    79.         await storeDB.put('B' + formId, msg.selectB);
    80.       }
    81.       await storeDB.flush();
    82.     }).catch((err: BusinessError) => {
    83.       hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);
    84.     });
    85.   }
    86. }
    

说明

通过本地数据库进行卡片信息的持久化时，建议先在[**onAddForm**](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonaddform)生命周期进行卡片信息持久化；同时需要在卡片销毁(**[onRemoveForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonremoveform)**)时删除当前卡片存储的持久化信息，避免反复添加删除卡片导致数据库文件持续变大。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-image-update "刷新本地图片和网络图片")
# ArkTS卡片页面交互概述

更新时间: 2025-12-16 16:40

ArkTS卡片提供页面交互能力，包括卡片与卡片提供方（例如：应用）的页面跳转、卡片拉起卡片提供方进程、卡片与卡片提供方的消息传递。其中[动态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E5%8A%A8%E6%80%81%E5%8D%A1%E7%89%87)可以使用[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)接口、[静态卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-form-overview#%E9%9D%99%E6%80%81%E5%8D%A1%E7%89%87)使用[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)实现页面交互功能。并且postCardAction和FormLink，均支持router、message和call三种类型的事件，具体使用场景如下：

- [router事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-router)：可以使用router事件跳转到指定UIAbility，以完成点击卡片跳转至应用内页面的功能。对于非系统应用仅支持跳转到自己应用内的UIAbility。
- [call事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-call)：可以使用call事件拉起指定UIAbility到后台，再通过UIAbility申请对应后台长时任务完成音乐播放等功能。
- [message事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-formextensionability)：可以使用message拉起[FormExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability)，通过[onFormEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability#formextensionabilityonformevent)接口回调通知，以完成点击卡片控件后传递消息给应用的功能。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event "ArkTS卡片页面交互")
# 卡片跳转到应用页面（router事件）

更新时间: 2025-12-16 16:40

在动态卡片中使用[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)接口的router能力，能够快速拉起动态卡片提供方应用的指定UIAbility(页面)，因此UIAbility较多的应用往往会通过卡片提供不同的跳转按钮，实现一键直达的效果。例如相机卡片，卡片上提供拍照、录像等按钮，点击不同按钮将拉起相机应用的不同UIAbility，从而提升用户的体验。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164031.53912112940040858203973433339861:50001231000000:2800:384419D40A9D749CDDE49C0C98C9486B4849334FDA310AB75E33D52C28D88848.png)

说明

本文主要介绍动态卡片的事件开发。对于静态卡片，请参见[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)。

## 开发步骤

1. 创建动态卡片，在工程的entry模块中，新建名为WidgetEventRouterCard的ArkTS卡片。
    
2. 构建ArkTS卡片页面代码布局，卡片页面布局中有两个按钮，点击其中一个按钮时调用postCardAction向指定UIAbility发送router事件，并在事件内定义需要传递的内容。
    
    1. // src/main/ets/widgeteventrouter/pages/WidgetEventRouterCard.ets
    2. @Entry
    3. @Component
    4. struct WidgetEventRouterCard {
    5.   build() {
    6.     Column() {
    7.       Text($r('app.string.JumpLabel'))
    8.         .fontColor('#FFFFFF')
    9.         .opacity(0.9)
    10.         .fontSize(14)
    11.         .margin({ top: '8%', left: '10%' })
    12.       Row() {
    13.         Column() {
    14.           Button() {
    15.             Text($r('app.string.ButtonA_label'))
    16.               .fontColor('#45A6F4')
    17.               .fontSize(12)
    18.           }
    19.           .width(120)
    20.           .height(32)
    21.           .margin({ top: '20%' })
    22.           .backgroundColor('#FFFFFF')
    23.           .borderRadius(16)
    24.           .onClick(() => {
    25.             postCardAction(this, {
    26.               action: 'router',
    27.               abilityName: 'EntryAbility',
    28.               params: { targetPage: 'funA' }
    29.             });
    30.           })
    
    31.           Button() {
    32.             Text($r('app.string.ButtonB_label'))
    33.               .fontColor('#45A6F4')
    34.               .fontSize(12)
    35.           }
    36.           .width(120)
    37.           .height(32)
    38.           .margin({ top: '8%', bottom: '15vp' })
    39.           .backgroundColor('#FFFFFF')
    40.           .borderRadius(16)
    41.           .onClick(() => {
    42.             postCardAction(this, {
    43.               action: 'router',
    44.               abilityName: 'EntryAbility',
    45.               params: { targetPage: 'funB' }
    46.             });
    47.           })
    48.         }
    49.       }.width('100%').height('80%')
    50.       .justifyContent(FlexAlign.Center)
    51.     }
    52.     .width('100%')
    53.     .height('100%')
    54.     .alignItems(HorizontalAlign.Start)
    55.     .backgroundImage($r('app.media.CardEvent'))
    56.     .backgroundImageSize(ImageSize.Cover)
    57.   }
    58. }
    
3. 处理router事件，在UIAbility中接收router事件并获取参数，根据传递的params不同，选择拉起不同的页面。
    
    1. // src/main/ets/entryability/EntryAbility.ts
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    5. const TAG: string = 'EntryAbility';
    6. const DOMAIN_NUMBER: number = 0xFF00;
    
    7. export default class EntryAbility extends UIAbility {
    8.   private selectPage: string = 'funA';
    9.   private currentWindowStage: window.WindowStage | null = null;
    
    10.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    11.     // 获取router事件中传递的targetPage参数
    12.     hilog.info(DOMAIN_NUMBER, TAG, `Ability onCreate, ${JSON.stringify(want)}`);
    13.     if (want?.parameters?.params) {
    14.       // want.parameters.params对应postCardAction()中params内容
    15.       let params: Record<string, Object> = JSON.parse(want.parameters.params as string);
    16.       this.selectPage = params.targetPage as string;
    17.       hilog.info(DOMAIN_NUMBER, TAG, `onCreate selectPage: ${this.selectPage}`);
    18.     }
    19.   }
    
    20.   // 如果UIAbility已在后台运行，在收到router事件后会触发onNewWant生命周期回调
    21.   onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    22.     hilog.info(DOMAIN_NUMBER, TAG, `onNewWant Want: ${JSON.stringify(want)}`);
    23.     if (want?.parameters?.params) {
    24.       // want.parameters.params对应postCardAction()中params内容
    25.       let params: Record<string, Object> = JSON.parse(want.parameters.params as string);
    26.       this.selectPage = params.targetPage as string;
    27.       hilog.info(DOMAIN_NUMBER, TAG, `onNewWant selectPage: ${this.selectPage}`);
    28.     }
    29.     if (this.currentWindowStage !== null) {
    30.       this.onWindowStageCreate(this.currentWindowStage);
    31.     }
    32.   }
    
    33.   onWindowStageCreate(windowStage: window.WindowStage): void {
    34.     let targetPage: string;
    35.     // 根据传递的targetPage不同，选择拉起不同的页面
    36.     switch (this.selectPage) {
    37.       case 'funA':
    38.         targetPage = 'funpages/FunA';
    39.         break;
    40.       case 'funB':
    41.         targetPage = 'funpages/FunB';
    42.         break;
    43.       default:
    44.         targetPage = 'pages/Index';
    45.     }
    46.     if (this.currentWindowStage === null) {
    47.       this.currentWindowStage = windowStage;
    48.     }
    49.     windowStage.loadContent(targetPage, (err, data) => {
    50.       if (err.code) {
    51.         hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
    52.         return;
    53.       }
    54.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    55.     });
    56.   }
    57. }
    
4. 创建跳转后的UIAbility页面，新建FunA.ets和FunB.ets，构建页面布局。
    
    1. // src/main/ets/funpages/FunA.ets
    2. @Entry
    3. @Component
    4. struct FunA {
    5.   build() {
    6.     Column() {
    7.       Row() {
    8.         Text(($r('app.string.ButtonA_label')))
    9.           .fontSize(24)
    10.           .fontWeight(FontWeight.Bold)
    11.           .textAlign(TextAlign.Start)
    12.           .margin({ top: 12, bottom: 11, right: 24, left: 24 })
    13.       }
    14.       .width('100%')
    15.       .height(56)
    16.       .justifyContent(FlexAlign.Start)
    
    17.       Image($r('app.media.pic_empty'))
    18.         .width(120)
    19.         .height(120)
    20.         .margin({ top: 224 })
    
    21.       Text($r('app.string.NoContentAvailable'))
    22.         .fontSize(14)
    23.         .fontColor($r('app.color.text_color'))
    24.         .opacity(0.4)
    25.         .margin({ top: 8, bottom: 317, right: 152, left: 152 })
    26.     }
    27.     .width('100%')
    28.     .height('100%')
    29.   }
    30. }
    
    31. // src/main/ets/funpages/FunB.ets
    32. @Entry
    33. @Component
    34. struct FunB {
    35.   build() {
    36.     Column() {
    37.       Row() {
    38.         Text(($r('app.string.ButtonB_label')))
    39.           .fontSize(24)
    40.           .fontWeight(FontWeight.Bold)
    41.           .textAlign(TextAlign.Start)
    42.           .margin({ top: 12, bottom: 11, right: 24, left: 24 })
    43.       }
    44.       .width('100%')
    45.       .height(56)
    46.       .justifyContent(FlexAlign.Start)
    
    47.       Image($r('app.media.pic_empty'))
    48.         .width(120)
    49.         .height(120)
    50.         .margin({ top: 224 })
    
    51.       Text($r('app.string.NoContentAvailable'))
    52.         .fontSize(14)
    53.         .fontColor($r('app.color.text_color'))
    54.         .opacity(0.4)
    55.         .margin({ top: 8, bottom: 317, right: 152, left: 152 })
    56.     }
    57.     .width('100%')
    58.     .height('100%')
    59.   }
    60. }
    
5. 在resources/base/profile下的main_pages.json文件中配置FunA.ets和FunB.ets页面。
    
    1. // src/main/resources/base/profile/main_pages.json
    2. {
    3.     "src": [
    4.       "pages/Index",
    5.       "funpages/FunA",
    6.       "funpages/FunB"
    7.     ]
    8. }
    
6. 资源文件如下，请开发者替换为实际使用的资源。
    
    1. // src/main/resources/zh_CN/element/string.json
    2. {
    3.   "string": [
    4.     {
    5.       "name": "ButtonA_label",
    6.       "value": "FunA页面"
    7.     },
    8.     {
    9.       "name": "ButtonB_label",
    10.       "value": "FunB页面"
    11.     },
    12.     {
    13.       "name": "JumpLabel",
    14.       "value": "router事件跳转"
    15.     },
    16.     {
    17.       "name": "NoContentAvailable",
    18.       "value": "暂无内容"
    19.     }
    20.   ]
    21. }
    

## 运行效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164031.02740863136885216047858802719302:50001231000000:2800:3A3868B40548CC101BA719D942602FDF41F33022B2494DBB5763A19CBE93367E.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-overview "ArkTS卡片页面交互概述")
# 通过router或call事件刷新卡片内容

更新时间: 2025-12-16 16:40

使用router事件，点击卡片可拉起对应应用的UIAbility至前台，并刷新卡片。使用call事件，点击卡片可拉起对应应用的UIAbility至后台，并刷新卡片。在卡片页面中可以通过[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)接口触发router事件或者call事件拉起UIAbility，然后由UIAbility刷新卡片内容，下面是这种刷新方式的简单示例。

说明

本文主要介绍动态卡片的事件开发。对于静态卡片，请参见[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)。

## 通过router事件刷新卡片内容

- 在卡片页面代码文件中，通过注册Button的onClick点击事件回调并在回调中调用postCardAction接口，触发router事件拉起UIAbility至前台。
    
    1. let storageUpdateRouter = new LocalStorage();
    
    2. @Entry(storageUpdateRouter)
    3. @Component
    4. struct WidgetUpdateRouterCard {
    5.   @LocalStorageProp('routerDetail') routerDetail: ResourceStr = $r('app.string.init');
    
    6.   build() {
    7.     Column() {
    8.       Column() {
    9.         Text(this.routerDetail)
    10.           .fontColor('#FFFFFF')
    11.           .opacity(0.9)
    12.           .fontSize(14)
    13.           .margin({ top: '8%', left: '10%', right: '10%' })
    14.           .textOverflow({ overflow: TextOverflow.Ellipsis })
    15.           .maxLines(2)
    16.       }.width('100%').height('50%')
    17.       .alignItems(HorizontalAlign.Start)
    
    18.       Row() {
    19.         Button() {
    20.           Text($r('app.string.JumpLabel'))
    21.             .fontColor('#45A6F4')
    22.             .fontSize(12)
    23.         }
    24.         .width(120)
    25.         .height(32)
    26.         .margin({ top: '30%', bottom: '10%' })
    27.         .backgroundColor('#FFFFFF')
    28.         .borderRadius(16)
    29.         .onClick(() => {
    30.           postCardAction(this, {
    31.             action: 'router',
    32.             abilityName: 'WidgetEventRouterEntryAbility', // 只能跳转到当前应用下的UIAbility
    33.             params: {
    34.               routerDetail: 'RouterFromCard',
    35.             }
    36.           });
    37.         })
    38.       }.width('100%').height('40%')
    39.       .justifyContent(FlexAlign.Center)
    40.     }
    41.     .width('100%')
    42.     .height('100%')
    43.     .alignItems(HorizontalAlign.Start)
    44.     .backgroundImage($r('app.media.CardEvent'))
    45.     .backgroundImageSize(ImageSize.Cover)
    46.   }
    47. }
    
- 在UIAbility的onCreate或者onNewWant生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口刷新卡片。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { formBindingData, formInfo, formProvider } from '@kit.FormKit';
    5. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    6. const TAG: string = 'WidgetEventRouterEntryAbility';
    7. const DOMAIN_NUMBER: number = 0xFF00;
    
    8. export default class WidgetEventRouterEntryAbility extends UIAbility {
    9.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    10.     this.handleFormRouterEvent(want, 'onCreate');
    11.   }
    
    12.   handleFormRouterEvent(want: Want, source: string): void {
    13.     hilog.info(DOMAIN_NUMBER, TAG, `handleFormRouterEvent ${source}, Want: ${JSON.stringify(want)}`);
    14.     if (want.parameters && want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) {
    15.       let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();
    16.       // want.parameters.params 对应 postCardAction() 中 params 内容
    17.       let message: string = (JSON.parse(want.parameters?.params as string))?.routerDetail;
    18.       hilog.info(DOMAIN_NUMBER, TAG, `UpdateForm formId: ${curFormId}, message: ${message}`);
    19.       let formData: Record<string, string> = {
    20.         'routerDetail': message + ' ' + source + ' UIAbility', // 和卡片布局中对应
    21.       };
    22.       let formMsg = formBindingData.createFormBindingData(formData);
    23.       formProvider.updateForm(curFormId, formMsg).then((data) => {
    24.         hilog.info(DOMAIN_NUMBER, TAG, 'updateForm success.', JSON.stringify(data));
    25.       }).catch((error: BusinessError) => {
    26.         hilog.info(DOMAIN_NUMBER, TAG, 'updateForm failed.', JSON.stringify(error));
    27.       });
    28.     }
    29.   }
    
    30.   // 如果UIAbility已在后台运行，在收到Router事件后会触发onNewWant生命周期回调
    31.   onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    32.     hilog.info(DOMAIN_NUMBER, TAG, 'onNewWant Want:', JSON.stringify(want));
    33.     this.handleFormRouterEvent(want, 'onNewWant');
    34.   }
    
    35.   onWindowStageCreate(windowStage: window.WindowStage): void {
    
    36.     hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');
    
    37.     windowStage.loadContent('pages/Index', (err, data) => {
    38.       if (err.code) {
    39.         hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
    40.         return;
    41.       }
    42.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    43.     });
    44.   }
    45.   // ...
    46. }
    

## 通过call事件刷新卡片内容

- 在卡片页面代码文件中，通过注册Button的onClick点击事件回调并在回调中调用postCardAction接口，触发call事件拉起UIAbility至后台。
    
    1. let storageUpdateCall = new LocalStorage();
    
    2. @Entry(storageUpdateCall)
    3. @Component
    4. struct WidgetUpdateCallCard {
    5.   @LocalStorageProp('formId') formId: string = '12400633174999288';
    6.   @LocalStorageProp('calleeDetail') calleeDetail: ResourceStr = $r('app.string.init');
    
    7.   build() {
    8.     Column() {
    9.       Column() {
    10.           Text(this.calleeDetail)
    11.           .fontColor('#FFFFFF')
    12.           .opacity(0.9)
    13.           .fontSize(14)
    14.           .margin({ top: '8%', left: '10%' })
    15.       }.width('100%').height('50%')
    16.       .alignItems(HorizontalAlign.Start)
    
    17.       Row() {
    18.         Button() {
    19.           Text($r('app.string.CalleeJumpLabel'))
    20.             .fontColor('#45A6F4')
    21.             .fontSize(12)
    22.         }
    23.         .width(120)
    24.         .height(32)
    25.         .margin({ top: '30%', bottom: '10%' })
    26.         .backgroundColor('#FFFFFF')
    27.         .borderRadius(16)
    28.         .onClick(() => {
    29.           postCardAction(this, {
    30.             action: 'call',
    31.             abilityName: 'WidgetCalleeEntryAbility', // 只能拉起当前应用下的UIAbility
    32.             params: {
    33.               method: 'funA',
    34.               formId: this.formId,
    35.               calleeDetail: 'CallFrom'
    36.             }
    37.           });
    38.         })
    39.       }.width('100%').height('40%')
    40.       .justifyContent(FlexAlign.Center)
    41.     }
    42.     .width('100%')
    43.     .height('100%')
    44.     .alignItems(HorizontalAlign.Start)
    45.     .backgroundImage($r('app.media.CardEvent'))
    46.     .backgroundImageSize(ImageSize.Cover)
    47.   }
    48. }
    
- 在UIAbility的onCreate生命周期中监听call事件所需的方法，然后在对应方法中调用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口刷新卡片。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { formBindingData, formProvider } from '@kit.FormKit';
    5. import { rpc } from '@kit.IPCKit';
    6. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    7. const TAG: string = 'WidgetCalleeEntryAbility';
    8. const DOMAIN_NUMBER: number = 0xFF00;
    9. const MSG_SEND_METHOD: string = 'funA';
    10. const CONST_NUMBER_1: number = 1;
    
    11. class MyParcelable implements rpc.Parcelable {
    12.   num: number;
    13.   str: string;
    
    14.   constructor(num: number, str: string) {
    15.     this.num = num;
    16.     this.str = str;
    17.   };
    
    18.   marshalling(messageSequence: rpc.MessageSequence): boolean {
    19.     messageSequence.writeInt(this.num);
    20.     messageSequence.writeString(this.str);
    21.     return true;
    22.   };
    
    23.   unmarshalling(messageSequence: rpc.MessageSequence): boolean {
    24.     this.num = messageSequence.readInt();
    25.     this.str = messageSequence.readString();
    26.     return true;
    27.   };
    28. }
    
    29. // 在收到call事件后会触发callee监听的方法
    30. let funACall = (data: rpc.MessageSequence): MyParcelable => {
    31.   // 获取call事件中传递的所有参数
    32.   let params: Record<string, string> = JSON.parse(data.readString());
    33.   if (params.formId !== undefined) {
    34.     let curFormId: string = params.formId;
    35.     let message: string = params.calleeDetail;
    36.     hilog.info(DOMAIN_NUMBER, TAG, `UpdateForm formId: ${curFormId}, message: ${message}`);
    37.     let formData: Record<string, string> = {
    38.       'calleeDetail': message
    39.     };
    40.     let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
    41.     formProvider.updateForm(curFormId, formMsg).then((data) => {
    42.       hilog.info(DOMAIN_NUMBER, TAG, `updateForm success. ${JSON.stringify(data)}`);
    43.     }).catch((error: BusinessError) => {
    44.       hilog.error(DOMAIN_NUMBER, TAG, `updateForm failed: ${JSON.stringify(error)}`);
    45.     });
    46.   }
    47.   return new MyParcelable(CONST_NUMBER_1, 'aaa');
    48. };
    
    49. export default class WidgetCalleeEntryAbility extends UIAbility {
    50.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    51.     try {
    52.       // 监听call事件所需的方法
    53.       this.callee.on(MSG_SEND_METHOD, funACall);
    54.     } catch (error) {
    55.       hilog.error(DOMAIN_NUMBER, TAG, `${MSG_SEND_METHOD} register failed with error ${JSON.stringify(error)}`);
    56.     }
    57.   }
    
    58.   onWindowStageCreate(windowStage: window.WindowStage): void {
    59.     // Main window is created, set main page for this ability
    60.     hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');
    
    61.     windowStage.loadContent('pages/Index', (err, data) => {
    62.       if (err.code) {
    63.         hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
    64.         return;
    65.       }
    66.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    67.     });
    68.   }
    69. }
    
    要拉起UIAbility至后台，需要在module.json5配置文件中，配置ohos.permission.KEEP_BACKGROUND_RUNNING权限。
    
    70.   "requestPermissions":[
    71.       {
    72.       "name": "ohos.permission.KEEP_BACKGROUND_RUNNING"
    73.       }
    74.     ]
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-formextensionability "卡片传递消息给应用（message事件）")
# 通过router或call事件刷新卡片内容

更新时间: 2025-12-16 16:40

使用router事件，点击卡片可拉起对应应用的UIAbility至前台，并刷新卡片。使用call事件，点击卡片可拉起对应应用的UIAbility至后台，并刷新卡片。在卡片页面中可以通过[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)接口触发router事件或者call事件拉起UIAbility，然后由UIAbility刷新卡片内容，下面是这种刷新方式的简单示例。

说明

本文主要介绍动态卡片的事件开发。对于静态卡片，请参见[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)。

## 通过router事件刷新卡片内容

- 在卡片页面代码文件中，通过注册Button的onClick点击事件回调并在回调中调用postCardAction接口，触发router事件拉起UIAbility至前台。
    
    1. let storageUpdateRouter = new LocalStorage();
    
    2. @Entry(storageUpdateRouter)
    3. @Component
    4. struct WidgetUpdateRouterCard {
    5.   @LocalStorageProp('routerDetail') routerDetail: ResourceStr = $r('app.string.init');
    
    6.   build() {
    7.     Column() {
    8.       Column() {
    9.         Text(this.routerDetail)
    10.           .fontColor('#FFFFFF')
    11.           .opacity(0.9)
    12.           .fontSize(14)
    13.           .margin({ top: '8%', left: '10%', right: '10%' })
    14.           .textOverflow({ overflow: TextOverflow.Ellipsis })
    15.           .maxLines(2)
    16.       }.width('100%').height('50%')
    17.       .alignItems(HorizontalAlign.Start)
    
    18.       Row() {
    19.         Button() {
    20.           Text($r('app.string.JumpLabel'))
    21.             .fontColor('#45A6F4')
    22.             .fontSize(12)
    23.         }
    24.         .width(120)
    25.         .height(32)
    26.         .margin({ top: '30%', bottom: '10%' })
    27.         .backgroundColor('#FFFFFF')
    28.         .borderRadius(16)
    29.         .onClick(() => {
    30.           postCardAction(this, {
    31.             action: 'router',
    32.             abilityName: 'WidgetEventRouterEntryAbility', // 只能跳转到当前应用下的UIAbility
    33.             params: {
    34.               routerDetail: 'RouterFromCard',
    35.             }
    36.           });
    37.         })
    38.       }.width('100%').height('40%')
    39.       .justifyContent(FlexAlign.Center)
    40.     }
    41.     .width('100%')
    42.     .height('100%')
    43.     .alignItems(HorizontalAlign.Start)
    44.     .backgroundImage($r('app.media.CardEvent'))
    45.     .backgroundImageSize(ImageSize.Cover)
    46.   }
    47. }
    
- 在UIAbility的onCreate或者onNewWant生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口刷新卡片。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { formBindingData, formInfo, formProvider } from '@kit.FormKit';
    5. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    6. const TAG: string = 'WidgetEventRouterEntryAbility';
    7. const DOMAIN_NUMBER: number = 0xFF00;
    
    8. export default class WidgetEventRouterEntryAbility extends UIAbility {
    9.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    10.     this.handleFormRouterEvent(want, 'onCreate');
    11.   }
    
    12.   handleFormRouterEvent(want: Want, source: string): void {
    13.     hilog.info(DOMAIN_NUMBER, TAG, `handleFormRouterEvent ${source}, Want: ${JSON.stringify(want)}`);
    14.     if (want.parameters && want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) {
    15.       let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();
    16.       // want.parameters.params 对应 postCardAction() 中 params 内容
    17.       let message: string = (JSON.parse(want.parameters?.params as string))?.routerDetail;
    18.       hilog.info(DOMAIN_NUMBER, TAG, `UpdateForm formId: ${curFormId}, message: ${message}`);
    19.       let formData: Record<string, string> = {
    20.         'routerDetail': message + ' ' + source + ' UIAbility', // 和卡片布局中对应
    21.       };
    22.       let formMsg = formBindingData.createFormBindingData(formData);
    23.       formProvider.updateForm(curFormId, formMsg).then((data) => {
    24.         hilog.info(DOMAIN_NUMBER, TAG, 'updateForm success.', JSON.stringify(data));
    25.       }).catch((error: BusinessError) => {
    26.         hilog.info(DOMAIN_NUMBER, TAG, 'updateForm failed.', JSON.stringify(error));
    27.       });
    28.     }
    29.   }
    
    30.   // 如果UIAbility已在后台运行，在收到Router事件后会触发onNewWant生命周期回调
    31.   onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    32.     hilog.info(DOMAIN_NUMBER, TAG, 'onNewWant Want:', JSON.stringify(want));
    33.     this.handleFormRouterEvent(want, 'onNewWant');
    34.   }
    
    35.   onWindowStageCreate(windowStage: window.WindowStage): void {
    
    36.     hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');
    
    37.     windowStage.loadContent('pages/Index', (err, data) => {
    38.       if (err.code) {
    39.         hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
    40.         return;
    41.       }
    42.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    43.     });
    44.   }
    45.   // ...
    46. }
    

## 通过call事件刷新卡片内容

- 在卡片页面代码文件中，通过注册Button的onClick点击事件回调并在回调中调用postCardAction接口，触发call事件拉起UIAbility至后台。
    
    1. let storageUpdateCall = new LocalStorage();
    
    2. @Entry(storageUpdateCall)
    3. @Component
    4. struct WidgetUpdateCallCard {
    5.   @LocalStorageProp('formId') formId: string = '12400633174999288';
    6.   @LocalStorageProp('calleeDetail') calleeDetail: ResourceStr = $r('app.string.init');
    
    7.   build() {
    8.     Column() {
    9.       Column() {
    10.           Text(this.calleeDetail)
    11.           .fontColor('#FFFFFF')
    12.           .opacity(0.9)
    13.           .fontSize(14)
    14.           .margin({ top: '8%', left: '10%' })
    15.       }.width('100%').height('50%')
    16.       .alignItems(HorizontalAlign.Start)
    
    17.       Row() {
    18.         Button() {
    19.           Text($r('app.string.CalleeJumpLabel'))
    20.             .fontColor('#45A6F4')
    21.             .fontSize(12)
    22.         }
    23.         .width(120)
    24.         .height(32)
    25.         .margin({ top: '30%', bottom: '10%' })
    26.         .backgroundColor('#FFFFFF')
    27.         .borderRadius(16)
    28.         .onClick(() => {
    29.           postCardAction(this, {
    30.             action: 'call',
    31.             abilityName: 'WidgetCalleeEntryAbility', // 只能拉起当前应用下的UIAbility
    32.             params: {
    33.               method: 'funA',
    34.               formId: this.formId,
    35.               calleeDetail: 'CallFrom'
    36.             }
    37.           });
    38.         })
    39.       }.width('100%').height('40%')
    40.       .justifyContent(FlexAlign.Center)
    41.     }
    42.     .width('100%')
    43.     .height('100%')
    44.     .alignItems(HorizontalAlign.Start)
    45.     .backgroundImage($r('app.media.CardEvent'))
    46.     .backgroundImageSize(ImageSize.Cover)
    47.   }
    48. }
    
- 在UIAbility的onCreate生命周期中监听call事件所需的方法，然后在对应方法中调用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口刷新卡片。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { formBindingData, formProvider } from '@kit.FormKit';
    5. import { rpc } from '@kit.IPCKit';
    6. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    7. const TAG: string = 'WidgetCalleeEntryAbility';
    8. const DOMAIN_NUMBER: number = 0xFF00;
    9. const MSG_SEND_METHOD: string = 'funA';
    10. const CONST_NUMBER_1: number = 1;
    
    11. class MyParcelable implements rpc.Parcelable {
    12.   num: number;
    13.   str: string;
    
    14.   constructor(num: number, str: string) {
    15.     this.num = num;
    16.     this.str = str;
    17.   };
    
    18.   marshalling(messageSequence: rpc.MessageSequence): boolean {
    19.     messageSequence.writeInt(this.num);
    20.     messageSequence.writeString(this.str);
    21.     return true;
    22.   };
    
    23.   unmarshalling(messageSequence: rpc.MessageSequence): boolean {
    24.     this.num = messageSequence.readInt();
    25.     this.str = messageSequence.readString();
    26.     return true;
    27.   };
    28. }
    
    29. // 在收到call事件后会触发callee监听的方法
    30. let funACall = (data: rpc.MessageSequence): MyParcelable => {
    31.   // 获取call事件中传递的所有参数
    32.   let params: Record<string, string> = JSON.parse(data.readString());
    33.   if (params.formId !== undefined) {
    34.     let curFormId: string = params.formId;
    35.     let message: string = params.calleeDetail;
    36.     hilog.info(DOMAIN_NUMBER, TAG, `UpdateForm formId: ${curFormId}, message: ${message}`);
    37.     let formData: Record<string, string> = {
    38.       'calleeDetail': message
    39.     };
    40.     let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
    41.     formProvider.updateForm(curFormId, formMsg).then((data) => {
    42.       hilog.info(DOMAIN_NUMBER, TAG, `updateForm success. ${JSON.stringify(data)}`);
    43.     }).catch((error: BusinessError) => {
    44.       hilog.error(DOMAIN_NUMBER, TAG, `updateForm failed: ${JSON.stringify(error)}`);
    45.     });
    46.   }
    47.   return new MyParcelable(CONST_NUMBER_1, 'aaa');
    48. };
    
    49. export default class WidgetCalleeEntryAbility extends UIAbility {
    50.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    51.     try {
    52.       // 监听call事件所需的方法
    53.       this.callee.on(MSG_SEND_METHOD, funACall);
    54.     } catch (error) {
    55.       hilog.error(DOMAIN_NUMBER, TAG, `${MSG_SEND_METHOD} register failed with error ${JSON.stringify(error)}`);
    56.     }
    57.   }
    
    58.   onWindowStageCreate(windowStage: window.WindowStage): void {
    59.     // Main window is created, set main page for this ability
    60.     hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');
    
    61.     windowStage.loadContent('pages/Index', (err, data) => {
    62.       if (err.code) {
    63.         hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
    64.         return;
    65.       }
    66.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    67.     });
    68.   }
    69. }
    
    要拉起UIAbility至后台，需要在module.json5配置文件中，配置ohos.permission.KEEP_BACKGROUND_RUNNING权限。
    
    70.   "requestPermissions":[
    71.       {
    72.       "name": "ohos.permission.KEEP_BACKGROUND_RUNNING"
    73.       }
    74.     ]
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-formextensionability "卡片传递消息给应用（message事件）")
# 通过router或call事件刷新卡片内容

更新时间: 2025-12-16 16:40

使用router事件，点击卡片可拉起对应应用的UIAbility至前台，并刷新卡片。使用call事件，点击卡片可拉起对应应用的UIAbility至后台，并刷新卡片。在卡片页面中可以通过[postCardAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-postcardaction#postcardaction-1)接口触发router事件或者call事件拉起UIAbility，然后由UIAbility刷新卡片内容，下面是这种刷新方式的简单示例。

说明

本文主要介绍动态卡片的事件开发。对于静态卡片，请参见[FormLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-formlink)。

## 通过router事件刷新卡片内容

- 在卡片页面代码文件中，通过注册Button的onClick点击事件回调并在回调中调用postCardAction接口，触发router事件拉起UIAbility至前台。
    
    1. let storageUpdateRouter = new LocalStorage();
    
    2. @Entry(storageUpdateRouter)
    3. @Component
    4. struct WidgetUpdateRouterCard {
    5.   @LocalStorageProp('routerDetail') routerDetail: ResourceStr = $r('app.string.init');
    
    6.   build() {
    7.     Column() {
    8.       Column() {
    9.         Text(this.routerDetail)
    10.           .fontColor('#FFFFFF')
    11.           .opacity(0.9)
    12.           .fontSize(14)
    13.           .margin({ top: '8%', left: '10%', right: '10%' })
    14.           .textOverflow({ overflow: TextOverflow.Ellipsis })
    15.           .maxLines(2)
    16.       }.width('100%').height('50%')
    17.       .alignItems(HorizontalAlign.Start)
    
    18.       Row() {
    19.         Button() {
    20.           Text($r('app.string.JumpLabel'))
    21.             .fontColor('#45A6F4')
    22.             .fontSize(12)
    23.         }
    24.         .width(120)
    25.         .height(32)
    26.         .margin({ top: '30%', bottom: '10%' })
    27.         .backgroundColor('#FFFFFF')
    28.         .borderRadius(16)
    29.         .onClick(() => {
    30.           postCardAction(this, {
    31.             action: 'router',
    32.             abilityName: 'WidgetEventRouterEntryAbility', // 只能跳转到当前应用下的UIAbility
    33.             params: {
    34.               routerDetail: 'RouterFromCard',
    35.             }
    36.           });
    37.         })
    38.       }.width('100%').height('40%')
    39.       .justifyContent(FlexAlign.Center)
    40.     }
    41.     .width('100%')
    42.     .height('100%')
    43.     .alignItems(HorizontalAlign.Start)
    44.     .backgroundImage($r('app.media.CardEvent'))
    45.     .backgroundImageSize(ImageSize.Cover)
    46.   }
    47. }
    
- 在UIAbility的onCreate或者onNewWant生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口刷新卡片。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { formBindingData, formInfo, formProvider } from '@kit.FormKit';
    5. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    6. const TAG: string = 'WidgetEventRouterEntryAbility';
    7. const DOMAIN_NUMBER: number = 0xFF00;
    
    8. export default class WidgetEventRouterEntryAbility extends UIAbility {
    9.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    10.     this.handleFormRouterEvent(want, 'onCreate');
    11.   }
    
    12.   handleFormRouterEvent(want: Want, source: string): void {
    13.     hilog.info(DOMAIN_NUMBER, TAG, `handleFormRouterEvent ${source}, Want: ${JSON.stringify(want)}`);
    14.     if (want.parameters && want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) {
    15.       let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();
    16.       // want.parameters.params 对应 postCardAction() 中 params 内容
    17.       let message: string = (JSON.parse(want.parameters?.params as string))?.routerDetail;
    18.       hilog.info(DOMAIN_NUMBER, TAG, `UpdateForm formId: ${curFormId}, message: ${message}`);
    19.       let formData: Record<string, string> = {
    20.         'routerDetail': message + ' ' + source + ' UIAbility', // 和卡片布局中对应
    21.       };
    22.       let formMsg = formBindingData.createFormBindingData(formData);
    23.       formProvider.updateForm(curFormId, formMsg).then((data) => {
    24.         hilog.info(DOMAIN_NUMBER, TAG, 'updateForm success.', JSON.stringify(data));
    25.       }).catch((error: BusinessError) => {
    26.         hilog.info(DOMAIN_NUMBER, TAG, 'updateForm failed.', JSON.stringify(error));
    27.       });
    28.     }
    29.   }
    
    30.   // 如果UIAbility已在后台运行，在收到Router事件后会触发onNewWant生命周期回调
    31.   onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    32.     hilog.info(DOMAIN_NUMBER, TAG, 'onNewWant Want:', JSON.stringify(want));
    33.     this.handleFormRouterEvent(want, 'onNewWant');
    34.   }
    
    35.   onWindowStageCreate(windowStage: window.WindowStage): void {
    
    36.     hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');
    
    37.     windowStage.loadContent('pages/Index', (err, data) => {
    38.       if (err.code) {
    39.         hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
    40.         return;
    41.       }
    42.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    43.     });
    44.   }
    45.   // ...
    46. }
    

## 通过call事件刷新卡片内容

- 在卡片页面代码文件中，通过注册Button的onClick点击事件回调并在回调中调用postCardAction接口，触发call事件拉起UIAbility至后台。
    
    1. let storageUpdateCall = new LocalStorage();
    
    2. @Entry(storageUpdateCall)
    3. @Component
    4. struct WidgetUpdateCallCard {
    5.   @LocalStorageProp('formId') formId: string = '12400633174999288';
    6.   @LocalStorageProp('calleeDetail') calleeDetail: ResourceStr = $r('app.string.init');
    
    7.   build() {
    8.     Column() {
    9.       Column() {
    10.           Text(this.calleeDetail)
    11.           .fontColor('#FFFFFF')
    12.           .opacity(0.9)
    13.           .fontSize(14)
    14.           .margin({ top: '8%', left: '10%' })
    15.       }.width('100%').height('50%')
    16.       .alignItems(HorizontalAlign.Start)
    
    17.       Row() {
    18.         Button() {
    19.           Text($r('app.string.CalleeJumpLabel'))
    20.             .fontColor('#45A6F4')
    21.             .fontSize(12)
    22.         }
    23.         .width(120)
    24.         .height(32)
    25.         .margin({ top: '30%', bottom: '10%' })
    26.         .backgroundColor('#FFFFFF')
    27.         .borderRadius(16)
    28.         .onClick(() => {
    29.           postCardAction(this, {
    30.             action: 'call',
    31.             abilityName: 'WidgetCalleeEntryAbility', // 只能拉起当前应用下的UIAbility
    32.             params: {
    33.               method: 'funA',
    34.               formId: this.formId,
    35.               calleeDetail: 'CallFrom'
    36.             }
    37.           });
    38.         })
    39.       }.width('100%').height('40%')
    40.       .justifyContent(FlexAlign.Center)
    41.     }
    42.     .width('100%')
    43.     .height('100%')
    44.     .alignItems(HorizontalAlign.Start)
    45.     .backgroundImage($r('app.media.CardEvent'))
    46.     .backgroundImageSize(ImageSize.Cover)
    47.   }
    48. }
    
- 在UIAbility的onCreate生命周期中监听call事件所需的方法，然后在对应方法中调用[updateForm](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formproviderupdateform)接口刷新卡片。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { formBindingData, formProvider } from '@kit.FormKit';
    5. import { rpc } from '@kit.IPCKit';
    6. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    7. const TAG: string = 'WidgetCalleeEntryAbility';
    8. const DOMAIN_NUMBER: number = 0xFF00;
    9. const MSG_SEND_METHOD: string = 'funA';
    10. const CONST_NUMBER_1: number = 1;
    
    11. class MyParcelable implements rpc.Parcelable {
    12.   num: number;
    13.   str: string;
    
    14.   constructor(num: number, str: string) {
    15.     this.num = num;
    16.     this.str = str;
    17.   };
    
    18.   marshalling(messageSequence: rpc.MessageSequence): boolean {
    19.     messageSequence.writeInt(this.num);
    20.     messageSequence.writeString(this.str);
    21.     return true;
    22.   };
    
    23.   unmarshalling(messageSequence: rpc.MessageSequence): boolean {
    24.     this.num = messageSequence.readInt();
    25.     this.str = messageSequence.readString();
    26.     return true;
    27.   };
    28. }
    
    29. // 在收到call事件后会触发callee监听的方法
    30. let funACall = (data: rpc.MessageSequence): MyParcelable => {
    31.   // 获取call事件中传递的所有参数
    32.   let params: Record<string, string> = JSON.parse(data.readString());
    33.   if (params.formId !== undefined) {
    34.     let curFormId: string = params.formId;
    35.     let message: string = params.calleeDetail;
    36.     hilog.info(DOMAIN_NUMBER, TAG, `UpdateForm formId: ${curFormId}, message: ${message}`);
    37.     let formData: Record<string, string> = {
    38.       'calleeDetail': message
    39.     };
    40.     let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
    41.     formProvider.updateForm(curFormId, formMsg).then((data) => {
    42.       hilog.info(DOMAIN_NUMBER, TAG, `updateForm success. ${JSON.stringify(data)}`);
    43.     }).catch((error: BusinessError) => {
    44.       hilog.error(DOMAIN_NUMBER, TAG, `updateForm failed: ${JSON.stringify(error)}`);
    45.     });
    46.   }
    47.   return new MyParcelable(CONST_NUMBER_1, 'aaa');
    48. };
    
    49. export default class WidgetCalleeEntryAbility extends UIAbility {
    50.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    51.     try {
    52.       // 监听call事件所需的方法
    53.       this.callee.on(MSG_SEND_METHOD, funACall);
    54.     } catch (error) {
    55.       hilog.error(DOMAIN_NUMBER, TAG, `${MSG_SEND_METHOD} register failed with error ${JSON.stringify(error)}`);
    56.     }
    57.   }
    
    58.   onWindowStageCreate(windowStage: window.WindowStage): void {
    59.     // Main window is created, set main page for this ability
    60.     hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');
    
    61.     windowStage.loadContent('pages/Index', (err, data) => {
    62.       if (err.code) {
    63.         hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
    64.         return;
    65.       }
    66.       hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    67.     });
    68.   }
    69. }
    
    要拉起UIAbility至后台，需要在module.json5配置文件中，配置ohos.permission.KEEP_BACKGROUND_RUNNING权限。
    
    70.   "requestPermissions":[
    71.       {
    72.       "name": "ohos.permission.KEEP_BACKGROUND_RUNNING"
    73.       }
    74.     ]
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-event-formextensionability "卡片传递消息给应用（message事件）")
# 卡片编辑开发指导

更新时间: 2025-12-16 16:40

从API version 18开始，桌面提供统一的卡片编辑页，卡片提供方使用卡片框架提供的[FormEditExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formeditextensionability)开发卡片编辑功能。

## 开发步骤

1. 在工程的entry模块中，新建名为EntryFormEditAbility的代码文件。在EntryFormEditAbility文件中，实现[startSecondPage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-formeditextensioncontext#startsecondpage)方法，在[onSessionCreate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-uiextensionability#onsessioncreate)回调方法中，加载一级卡片编辑页，并将startSecondPage方法的实现传递给一级卡片编辑页。
    
    1. // src/main/ets/entryformeditability/EntryFormEditAbility.ets
    
    2. import { FormEditExtensionAbility } from '@kit.FormKit';
    3. import { Want,UIExtensionContentSession } from '@kit.AbilityKit';
    4. import { ExtensionEvent } from '../pages/model/ExtensionEvent';
    
    5. const TAG: string = 'FormEditDemo[EntryFormEditAbility] -->';
    6. export default class EntryFormEditAbility extends FormEditExtensionAbility {
    7.   onCreate() {
    8.     console.info(`${TAG} onCreate`);
    9.   }
    10.   onForeground(): void {
    11.     console.info(`${TAG} EntryFormEditAbility onForeground.....`);
    12.   }
    13.   onBackground(): void {
    14.     console.info(`${TAG} EntryFormEditAbility onBackground......`);
    15.   }
    16.   onDestroy(): void {
    17.     console.info(`${TAG} EntryFormEditAbility onDestroy......`);
    18.   }
    19.   onSessionCreate(want: Want, session: UIExtensionContentSession) {
    20.     console.info(`${TAG} onSessionCreate start..... want: ${JSON.stringify(want)}`);
    21.     let storage: LocalStorage = new LocalStorage();
    22.     let extensionEvent: ExtensionEvent = new ExtensionEvent();
    23.     extensionEvent.setStartSecondPage(() => this.startSecondPage());
    24.     storage.setOrCreate('extensionEvent', extensionEvent);
    25.     try {
    26.       session.loadContent('pages/Extension', storage);
    27.     } catch (e) {
    28.       console.error(`${TAG} EntryFormEditAbility loadContent err, want: ${JSON.stringify(e)}`);
    29.     }
    30.   }
    31.   onSessionDestroy(session: UIExtensionContentSession) {
    32.     console.info(`${TAG} onSessionDestroy`);
    33.   }
    34.   private startSecondPage(): void {
    35.     const bundleName: string = this.context.extensionAbilityInfo.bundleName;
    36.     const secPageAbilityName: string = 'FormEditSecPageAbility';
    37.     console.info(`${TAG} startSecondPage. bundleName: ${bundleName}, secPageAbilityName: ${secPageAbilityName}.`);
    38.     try {
    39.       this.context.startSecondPage({
    40.         bundleName: bundleName,
    41.         parameters: {
    42.           "secPageAbilityName": secPageAbilityName
    43.         }
    44.       });
    45.     } catch (err) {
    46.       console.error(`${TAG} startSecondPage failed: ${err}`);
    47.     }
    48.   }
    49. };
    
2. 新增Extension文件，用于展示卡片一级编辑页。
    
    1. // src/main/ets/pages/Extension.ets
    
    2. import { UIExtensionContentSession } from '@kit.AbilityKit';
    3. import { ExtensionEvent } from './model/ExtensionEvent';
    
    4. let storage = new LocalStorage();
    5. const TAG: string = 'FormEditDemo[Extension] -->';
    6. @Entry(storage)
    7. @Component
    8. struct Extension {
    9.   @State message: string = 'UIExtension Provider';
    10.   private session: UIExtensionContentSession | undefined = storage.get<UIExtensionContentSession>('session');
    11.   private extensionEvent: ExtensionEvent | undefined = storage.get<ExtensionEvent>('extensionEvent');
    12.   onPageShow() {
    13.     console.info(`${TAG} onPageShow. extensionEvent: ${JSON.stringify(this.extensionEvent)}, session: ${JSON.stringify(this.session)}.`);
    14.   }
    15.   build() {
    16.     Row() {
    17.       Column() {
    18.         Text(this.message)
    19.           .fontSize(20)
    20.           .fontWeight(FontWeight.Bold)
    21.           .textAlign(TextAlign.Center)
    22.         Button("添加")
    23.           .width('80%')
    24.           .type(ButtonType.Capsule)
    25.           .margin({
    26.             top: 20
    27.           })
    28.           .onClick(() => {
    29.             console.info(`${TAG} Button onClick`);
    30.             this.extensionEvent?.startFormEditSecondPage();
    31.           })
    32.       }
    33.     }
    34.     .justifyContent(FlexAlign.Center)
    35.     .width('100%')
    36.   }
    37. }
    
3. 新增ExtensionEvent文件，使用startFormEditSecondPage方法调用[startSecondPage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-formeditextensioncontext#startsecondpage)方法。
    
    1. // src/main/ets/pages/model/ExtensionEvent.ets
    
    2. const TAG: string = 'FormEditDemo[ExtensionEvent] -->';
    3. export class ExtensionEvent {
    4.   private startSecondPage: () => void = () => {
    5.     console.info(`${TAG} startSecondPage is empty!`);
    6.   };
    7.   public setStartSecondPage(startSecondPage: () => void) {
    8.     console.info(`${TAG} setStartSecondPage`);
    9.     this.startSecondPage = startSecondPage;
    10.   }
    11.   public startFormEditSecondPage(): void {
    12.     console.info(`${TAG} startFormEditSecondPage`);
    13.     this.startSecondPage();
    14.   }
    15. }
    
4. 在应用的[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)配置文件中添加卡片编辑配置信息。
    
    1. "extensionAbilities": [
    2.   // ...
    3.   {
    4.     "name": "EntryFormEditAbility",
    5.     "srcEntry": "./ets/entryformeditability/EntryFormEditAbility.ets",
    6.     "type": "formEdit"
    7.   }
    8. ]
    
5. 在卡片的[form_config.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)配置文件中添加formConfigAbility配置项信息。
    
    1. {
    2.   "forms": [
    3.     {
    4.       "name": "widget",
    5.       "displayName": "$string:widget_display_name",
    6.       "description": "$string:widget_desc",
    7.       "src": "./ets/widget/pages/WidgetCard.ets",
    8.       "uiSyntax": "arkts",
    9.       "formConfigAbility": "ability://EntryFormEditAbility",
    10.       "window": {
    11.         "designWidth": 720,
    12.         "autoDesignWidth": true
    13.       },
    14.       "colorMode": "auto",
    15.       "isDynamic": true,
    16.       "isDefault": true,
    17.       "updateEnabled": false,
    18.       "scheduledUpdateTime": "10:30",
    19.       "updateDuration": 1,
    20.       "defaultDimension": "1*2",
    21.       "supportDimensions": [
    22.         "1*2",
    23.         "2*2",
    24.         "2*4",
    25.         "4*4"
    26.       ]
    27.     }
    28.   ]
    29. }
    
6. 在开发视图的resource/base/profile/main_pages.json文件中，注册Extension页面文件。
    
    1. {
    2.   "src": [
    3.     "pages/Index",
    4.     "pages/Extension"
    5.   ]
    6. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/-ui-widget-event-formeditextensionability-overview "ArkTS卡片编辑概述")
# 卡片编辑开发指导

更新时间: 2025-12-16 16:40

从API version 18开始，桌面提供统一的卡片编辑页，卡片提供方使用卡片框架提供的[FormEditExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formeditextensionability)开发卡片编辑功能。

## 开发步骤

1. 在工程的entry模块中，新建名为EntryFormEditAbility的代码文件。在EntryFormEditAbility文件中，实现[startSecondPage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-formeditextensioncontext#startsecondpage)方法，在[onSessionCreate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-uiextensionability#onsessioncreate)回调方法中，加载一级卡片编辑页，并将startSecondPage方法的实现传递给一级卡片编辑页。
    
    1. // src/main/ets/entryformeditability/EntryFormEditAbility.ets
    
    2. import { FormEditExtensionAbility } from '@kit.FormKit';
    3. import { Want,UIExtensionContentSession } from '@kit.AbilityKit';
    4. import { ExtensionEvent } from '../pages/model/ExtensionEvent';
    
    5. const TAG: string = 'FormEditDemo[EntryFormEditAbility] -->';
    6. export default class EntryFormEditAbility extends FormEditExtensionAbility {
    7.   onCreate() {
    8.     console.info(`${TAG} onCreate`);
    9.   }
    10.   onForeground(): void {
    11.     console.info(`${TAG} EntryFormEditAbility onForeground.....`);
    12.   }
    13.   onBackground(): void {
    14.     console.info(`${TAG} EntryFormEditAbility onBackground......`);
    15.   }
    16.   onDestroy(): void {
    17.     console.info(`${TAG} EntryFormEditAbility onDestroy......`);
    18.   }
    19.   onSessionCreate(want: Want, session: UIExtensionContentSession) {
    20.     console.info(`${TAG} onSessionCreate start..... want: ${JSON.stringify(want)}`);
    21.     let storage: LocalStorage = new LocalStorage();
    22.     let extensionEvent: ExtensionEvent = new ExtensionEvent();
    23.     extensionEvent.setStartSecondPage(() => this.startSecondPage());
    24.     storage.setOrCreate('extensionEvent', extensionEvent);
    25.     try {
    26.       session.loadContent('pages/Extension', storage);
    27.     } catch (e) {
    28.       console.error(`${TAG} EntryFormEditAbility loadContent err, want: ${JSON.stringify(e)}`);
    29.     }
    30.   }
    31.   onSessionDestroy(session: UIExtensionContentSession) {
    32.     console.info(`${TAG} onSessionDestroy`);
    33.   }
    34.   private startSecondPage(): void {
    35.     const bundleName: string = this.context.extensionAbilityInfo.bundleName;
    36.     const secPageAbilityName: string = 'FormEditSecPageAbility';
    37.     console.info(`${TAG} startSecondPage. bundleName: ${bundleName}, secPageAbilityName: ${secPageAbilityName}.`);
    38.     try {
    39.       this.context.startSecondPage({
    40.         bundleName: bundleName,
    41.         parameters: {
    42.           "secPageAbilityName": secPageAbilityName
    43.         }
    44.       });
    45.     } catch (err) {
    46.       console.error(`${TAG} startSecondPage failed: ${err}`);
    47.     }
    48.   }
    49. };
    
2. 新增Extension文件，用于展示卡片一级编辑页。
    
    1. // src/main/ets/pages/Extension.ets
    
    2. import { UIExtensionContentSession } from '@kit.AbilityKit';
    3. import { ExtensionEvent } from './model/ExtensionEvent';
    
    4. let storage = new LocalStorage();
    5. const TAG: string = 'FormEditDemo[Extension] -->';
    6. @Entry(storage)
    7. @Component
    8. struct Extension {
    9.   @State message: string = 'UIExtension Provider';
    10.   private session: UIExtensionContentSession | undefined = storage.get<UIExtensionContentSession>('session');
    11.   private extensionEvent: ExtensionEvent | undefined = storage.get<ExtensionEvent>('extensionEvent');
    12.   onPageShow() {
    13.     console.info(`${TAG} onPageShow. extensionEvent: ${JSON.stringify(this.extensionEvent)}, session: ${JSON.stringify(this.session)}.`);
    14.   }
    15.   build() {
    16.     Row() {
    17.       Column() {
    18.         Text(this.message)
    19.           .fontSize(20)
    20.           .fontWeight(FontWeight.Bold)
    21.           .textAlign(TextAlign.Center)
    22.         Button("添加")
    23.           .width('80%')
    24.           .type(ButtonType.Capsule)
    25.           .margin({
    26.             top: 20
    27.           })
    28.           .onClick(() => {
    29.             console.info(`${TAG} Button onClick`);
    30.             this.extensionEvent?.startFormEditSecondPage();
    31.           })
    32.       }
    33.     }
    34.     .justifyContent(FlexAlign.Center)
    35.     .width('100%')
    36.   }
    37. }
    
3. 新增ExtensionEvent文件，使用startFormEditSecondPage方法调用[startSecondPage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-formeditextensioncontext#startsecondpage)方法。
    
    1. // src/main/ets/pages/model/ExtensionEvent.ets
    
    2. const TAG: string = 'FormEditDemo[ExtensionEvent] -->';
    3. export class ExtensionEvent {
    4.   private startSecondPage: () => void = () => {
    5.     console.info(`${TAG} startSecondPage is empty!`);
    6.   };
    7.   public setStartSecondPage(startSecondPage: () => void) {
    8.     console.info(`${TAG} setStartSecondPage`);
    9.     this.startSecondPage = startSecondPage;
    10.   }
    11.   public startFormEditSecondPage(): void {
    12.     console.info(`${TAG} startFormEditSecondPage`);
    13.     this.startSecondPage();
    14.   }
    15. }
    
4. 在应用的[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)配置文件中添加卡片编辑配置信息。
    
    1. "extensionAbilities": [
    2.   // ...
    3.   {
    4.     "name": "EntryFormEditAbility",
    5.     "srcEntry": "./ets/entryformeditability/EntryFormEditAbility.ets",
    6.     "type": "formEdit"
    7.   }
    8. ]
    
5. 在卡片的[form_config.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E)配置文件中添加formConfigAbility配置项信息。
    
    1. {
    2.   "forms": [
    3.     {
    4.       "name": "widget",
    5.       "displayName": "$string:widget_display_name",
    6.       "description": "$string:widget_desc",
    7.       "src": "./ets/widget/pages/WidgetCard.ets",
    8.       "uiSyntax": "arkts",
    9.       "formConfigAbility": "ability://EntryFormEditAbility",
    10.       "window": {
    11.         "designWidth": 720,
    12.         "autoDesignWidth": true
    13.       },
    14.       "colorMode": "auto",
    15.       "isDynamic": true,
    16.       "isDefault": true,
    17.       "updateEnabled": false,
    18.       "scheduledUpdateTime": "10:30",
    19.       "updateDuration": 1,
    20.       "defaultDimension": "1*2",
    21.       "supportDimensions": [
    22.         "1*2",
    23.         "2*2",
    24.         "2*4",
    25.         "4*4"
    26.       ]
    27.     }
    28.   ]
    29. }
    
6. 在开发视图的resource/base/profile/main_pages.json文件中，注册Extension页面文件。
    
    1. {
    2.   "src": [
    3.     "pages/Index",
    4.     "pages/Extension"
    5.   ]
    6. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/-ui-widget-event-formeditextensionability-overview "ArkTS卡片编辑概述")
# 应用内拉起卡片管理加桌

更新时间: 2025-12-16 16:40

从API version 18开始，Form Kit提供在应用内将ArkTS卡片添加到桌面的能力，以方便用户后续便捷查看信息或快速进入应用。

## 开发步骤

下面给出示例，实现如下功能：在应用内点击“添加卡片到桌面”按钮，拉起卡片管理页面。用户可在卡片管理页面，点击“添加至桌面”按钮，此时在桌面即可看到新添加的卡片。

1. [创建卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation)。
    
2. 通过[openFormManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#formprovideropenformmanager18)方法在应用内添加拉起卡片管理页面入口。
    
    1. // entry/src/main/ets/pages/Index.ets
    2. import { formProvider } from '@kit.FormKit';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { Want } from '@kit.AbilityKit';
    5. import { promptAction } from '@kit.ArkUI';
    
    6. @Entry
    7. @Component
    8. struct Index {
    
    9.   build() {
    10.     Row() {
    11.       Column() {
    12.         // 添加拉起卡片管理页面按钮
    13.         Button($r('app.string.open_form_manager_button'))
    14.           .onClick(() => {
    15.             const want: Want = {
    16.               bundleName: "com.example.openmanager",
    17.               abilityName: 'EntryFormAbility',
    18.               parameters: {
    19.                 'ohos.extra.param.key.form_dimension': 2,
    20.                 'ohos.extra.param.key.form_name': 'widget',
    21.                 'ohos.extra.param.key.module_name': 'entry'
    22.               },
    23.             };
    24.             try {
    25.               // 点击按钮后调用openFormManager方法，拉起卡片管理页面
    26.               formProvider.openFormManager(want);
    27.             } catch (error) {
    28.               promptAction.openToast({message: (error as BusinessError).message});
    29.               console.error(`catch error, code: ${(error as BusinessError).code}, message: ${(error as BusinessError).message})`);
    30.             }
    31.           })
    32.           .margin({ top: 10, bottom: 10 })
    33.       }
    34.       .width('100%')
    35.     }
    36.     .height('100%')
    37.   }
    38. }
    
    资源文件如下：
    
    39. // entry/src/main/resources/base/element/string.json
    40. {
    41.   "string": [
    42.     {
    43.       "name": "open_form_manager_button",
    44.       "value": "添加应用卡片到桌面"
    45.     }
    46.   ]
    47. }
    
3. 用户可在卡片管理页面，点击“添加至桌面”，此时在桌面即可看到新添加的卡片。结果示例如下。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164018.61129369441241761394688255334694:50001231000000:2800:031E9E6686404105197D9630C58DCDA733E182AD92B620B5C34764E1363421E9.gif)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-add "应用内请求卡片加桌")
# 互动卡片概述

更新时间: 2025-12-16 16:39

从API version 20开始，支持互动卡片。互动卡片提供卡片动效能力，例如卡片破框动效，丰富信息提醒、浅层交互功能，显著提升用户体验。

## 使用场景

互动卡片包含两种类型：趣味交互类型互动卡片和场景动效类型互动卡片。

### 趣味交互类型

趣味交互类型互动卡片，提供卡片小游戏功能，当用户点击卡片时，开始体验对应卡片小游戏。当前仅支持基于[快游戏](https://developer.huawei.com/consumer/cn/doc/quickApp-Guides/quickgame-interact-card-0000002045917828)开发。详细请参考[趣味交互类型互动卡片开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform-funinteraction-development)。

**图1** 趣味交互类型互动卡片样例

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163910.43384511149878260351097061639179:50001231000000:2800:90B39C38750782C35D3E46FFDB29B4EE3F477A2AE354D88B4CFA4706F4B6F470.gif)

### 场景动效类型

场景动效类型互动卡片支持实现动态效果。以天气卡片为例，当天气变为雷雨天气时，卡片激活并触发互动卡片动效。动效结束后，卡片恢复原有显示效果。详细信息请参考[场景动效类型互动卡片概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform-sceneanimation-overview)。

## 约束和限制

- 互动卡片作为卡片功能的增强，卡片自身业务不能强依赖互动卡片动效能力。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform "互动卡片开发")
# 互动卡片概述

更新时间: 2025-12-16 16:39

从API version 20开始，支持互动卡片。互动卡片提供卡片动效能力，例如卡片破框动效，丰富信息提醒、浅层交互功能，显著提升用户体验。

## 使用场景

互动卡片包含两种类型：趣味交互类型互动卡片和场景动效类型互动卡片。

### 趣味交互类型

趣味交互类型互动卡片，提供卡片小游戏功能，当用户点击卡片时，开始体验对应卡片小游戏。当前仅支持基于[快游戏](https://developer.huawei.com/consumer/cn/doc/quickApp-Guides/quickgame-interact-card-0000002045917828)开发。详细请参考[趣味交互类型互动卡片开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform-funinteraction-development)。

**图1** 趣味交互类型互动卡片样例

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163910.43384511149878260351097061639179:50001231000000:2800:90B39C38750782C35D3E46FFDB29B4EE3F477A2AE354D88B4CFA4706F4B6F470.gif)

### 场景动效类型

场景动效类型互动卡片支持实现动态效果。以天气卡片为例，当天气变为雷雨天气时，卡片激活并触发互动卡片动效。动效结束后，卡片恢复原有显示效果。详细信息请参考[场景动效类型互动卡片概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform-sceneanimation-overview)。

## 约束和限制

- 互动卡片作为卡片功能的增强，卡片自身业务不能强依赖互动卡片动效能力。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-liveform "互动卡片开发")
# JS卡片概述

更新时间: 2025-12-16 16:38

JS卡片是使用类Web范式（HML+CSS+JSON）开发页面的卡片，现在已经支持FA模型和Stage模型两种[应用模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-models)。开发指导请参见[JS卡片开发指导（Stage模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development)和[JS卡片开发指导（FA模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/widget-development-fa)。在开发新卡片时，推荐采用ArkTS声明式来构建UI，声明式和类web范式差异点可参考[ArkUI简介](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui-overview)。

## 实现原理

JS卡片实现原理如图1所示。

**图1** JS卡片实现原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.70554930569368628474781837731455:50001231000000:2800:1B7BB29F9DF0971AE99D1EE8793652B036F1E15F573DEAFBFB0172276DF2756C.png)

卡片使用方包含以下模块：

- 卡片使用：包含卡片的创建、删除、请求更新等操作。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的相关操作指令发送到卡片管理服务。
    

卡片管理服务包含以下模块：

- 周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。
    
- 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。
    
- 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。
    
- 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。
    
- 通信适配层：负责与卡片使用方和提供方进行RPC通信。
    

卡片提供方包含以下模块：

- 卡片服务：由卡片提供方开发者实现，开发者实现生命周期处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。
    
- 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。
    

说明

实际开发时只需要作为卡片提供方进行卡片内容的开发，卡片使用方和卡片管理服务由系统自动处理。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/form-js-ui "JS卡片开发")
# JS卡片概述

更新时间: 2025-12-16 16:38

JS卡片是使用类Web范式（HML+CSS+JSON）开发页面的卡片，现在已经支持FA模型和Stage模型两种[应用模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-models)。开发指导请参见[JS卡片开发指导（Stage模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development)和[JS卡片开发指导（FA模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/widget-development-fa)。在开发新卡片时，推荐采用ArkTS声明式来构建UI，声明式和类web范式差异点可参考[ArkUI简介](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui-overview)。

## 实现原理

JS卡片实现原理如图1所示。

**图1** JS卡片实现原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.70554930569368628474781837731455:50001231000000:2800:1B7BB29F9DF0971AE99D1EE8793652B036F1E15F573DEAFBFB0172276DF2756C.png)

卡片使用方包含以下模块：

- 卡片使用：包含卡片的创建、删除、请求更新等操作。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的相关操作指令发送到卡片管理服务。
    

卡片管理服务包含以下模块：

- 周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。
    
- 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。
    
- 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。
    
- 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。
    
- 通信适配层：负责与卡片使用方和提供方进行RPC通信。
    

卡片提供方包含以下模块：

- 卡片服务：由卡片提供方开发者实现，开发者实现生命周期处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。
    
- 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。
    

说明

实际开发时只需要作为卡片提供方进行卡片内容的开发，卡片使用方和卡片管理服务由系统自动处理。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/form-js-ui "JS卡片开发")
# JS卡片概述

更新时间: 2025-12-16 16:38

JS卡片是使用类Web范式（HML+CSS+JSON）开发页面的卡片，现在已经支持FA模型和Stage模型两种[应用模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-models)。开发指导请参见[JS卡片开发指导（Stage模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development)和[JS卡片开发指导（FA模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/widget-development-fa)。在开发新卡片时，推荐采用ArkTS声明式来构建UI，声明式和类web范式差异点可参考[ArkUI简介](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui-overview)。

## 实现原理

JS卡片实现原理如图1所示。

**图1** JS卡片实现原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.70554930569368628474781837731455:50001231000000:2800:1B7BB29F9DF0971AE99D1EE8793652B036F1E15F573DEAFBFB0172276DF2756C.png)

卡片使用方包含以下模块：

- 卡片使用：包含卡片的创建、删除、请求更新等操作。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的相关操作指令发送到卡片管理服务。
    

卡片管理服务包含以下模块：

- 周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。
    
- 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。
    
- 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。
    
- 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。
    
- 通信适配层：负责与卡片使用方和提供方进行RPC通信。
    

卡片提供方包含以下模块：

- 卡片服务：由卡片提供方开发者实现，开发者实现生命周期处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。
    
- 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。
    

说明

实际开发时只需要作为卡片提供方进行卡片内容的开发，卡片使用方和卡片管理服务由系统自动处理。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/form-js-ui "JS卡片开发")
# JS卡片概述

更新时间: 2025-12-16 16:38

JS卡片是使用类Web范式（HML+CSS+JSON）开发页面的卡片，现在已经支持FA模型和Stage模型两种[应用模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-models)。开发指导请参见[JS卡片开发指导（Stage模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development)和[JS卡片开发指导（FA模型）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/widget-development-fa)。在开发新卡片时，推荐采用ArkTS声明式来构建UI，声明式和类web范式差异点可参考[ArkUI简介](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui-overview)。

## 实现原理

JS卡片实现原理如图1所示。

**图1** JS卡片实现原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163829.70554930569368628474781837731455:50001231000000:2800:1B7BB29F9DF0971AE99D1EE8793652B036F1E15F573DEAFBFB0172276DF2756C.png)

卡片使用方包含以下模块：

- 卡片使用：包含卡片的创建、删除、请求更新等操作。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的相关操作指令发送到卡片管理服务。
    

卡片管理服务包含以下模块：

- 周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。
    
- 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。
    
- 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。
    
- 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。
    
- 通信适配层：负责与卡片使用方和提供方进行RPC通信。
    

卡片提供方包含以下模块：

- 卡片服务：由卡片提供方开发者实现，开发者实现生命周期处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。
    
- 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。
    
- 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。
    

说明

实际开发时只需要作为卡片提供方进行卡片内容的开发，卡片使用方和卡片管理服务由系统自动处理。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/form-js-ui "JS卡片开发")
# JS卡片开发指导（Stage模型）

更新时间: 2025-12-16 16:38

Stage模型是从API version 9开始支持，目前主推且会长期演进的模型。该模型采用面向对象的方式，将应用组件以类接口的形式开放给开发者，可以进行派生，利于扩展能力。

## 接口说明

FormExtensionAbility类拥有如下API接口，具体的API介绍详见[接口文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability)。

|接口名|描述|
|:--|:--|
|onAddForm(want: Want): formBindingData.FormBindingData|卡片提供方接收创建卡片的通知接口。|
|onCastToNormalForm(formId: string): void|卡片提供方接收临时卡片转常态卡片的通知接口。|
|onUpdateForm(formId: string, wantParams?: Record<string, Object>): void|卡片提供方接收更新卡片的通知接口。|
|onChangeFormVisibility(newStatus: Record<string, number>): void|卡片提供方接收修改可见性的通知接口。|
|onFormEvent(formId: string, message: string): void|卡片提供方接收处理卡片事件的通知接口。|
|onRemoveForm(formId: string): void|卡片提供方接收销毁卡片的通知接口。|
|onConfigurationUpdate(newConfig: Configuration): void|当系统配置更新时调用。|

formProvider类部分API接口如下，具体的API介绍详见[接口文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider)。

|接口名|描述|
|:--|:--|
|setFormNextRefreshTime(formId: string, minute: number, callback: AsyncCallback<void>): void|设置指定卡片的下一次更新时间，使用callback异步回调。|
|setFormNextRefreshTime(formId: string, minute: number): Promise<void>|设置指定卡片的下一次更新时间，使用Promise异步回调。|
|updateForm(formId: string, formBindingData: formBindingData.FormBindingData, callback: AsyncCallback<void>): void|更新指定的卡片，使用callback异步回调。|
|updateForm(formId: string, formBindingData: formBindingData.FormBindingData): Promise<void>|更新指定的卡片，使用Promise异步回调。|

formBindingData类部分API接口如下，具体的API介绍详见[接口文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formbindingdata)。

|接口名|描述|
|:--|:--|
|createFormBindingData(obj?: Object \| string): FormBindingData|创建一个FormBindingData对象。|

## 开发步骤

Stage卡片开发，即基于[Stage模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/stage-model-development-overview)的卡片提供方开发，主要涉及如下关键步骤：

- [创建卡片FormExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development#%E5%88%9B%E5%BB%BA%E5%8D%A1%E7%89%87formextensionability)：卡片生命周期回调函数FormExtensionAbility开发。
    
- [配置卡片配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development#%E9%85%8D%E7%BD%AE%E5%8D%A1%E7%89%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)：配置应用配置文件module.json5和profile配置文件。
    
- [卡片信息的持久化](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development#%E5%8D%A1%E7%89%87%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96)：对卡片信息进行持久化管理。
    
- [卡片数据交互](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development#%E5%8D%A1%E7%89%87%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92)：通过updateForm更新卡片显示的信息。
    
- [开发卡片页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development#%E5%BC%80%E5%8F%91%E5%8D%A1%E7%89%87%E9%A1%B5%E9%9D%A2)：使用HML+CSS+JSON开发JS卡片页面。
    
- [开发卡片事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-development#%E5%BC%80%E5%8F%91%E5%8D%A1%E7%89%87%E4%BA%8B%E4%BB%B6)：为卡片添加router事件和message事件。
    

### 创建卡片FormExtensionAbility

创建Stage模型的卡片，需实现FormExtensionAbility生命周期接口。先参考[DevEco Studio服务卡片开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-service-widget)生成服务卡片模板。

1. 在EntryFormAbility.ets中，导入相关模块。
    
    1. import { Want } from '@kit.AbilityKit';
    2. import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
    3. import { hilog } from '@kit.PerformanceAnalysisKit';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. const TAG: string = 'JsCardFormAbility';
    6. const DOMAIN_NUMBER: number = 0xFF00;
    
2. 在EntryFormAbility.ets中，实现FormExtension生命周期接口。
    
    1. export default class EntryFormAbility extends FormExtensionAbility {
    2.   onAddForm(want: Want): formBindingData.FormBindingData {
    3.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onAddForm');
    4.     // 使用方创建卡片时触发，提供方需要返回卡片数据绑定类
    5.     let obj: Record<string, string> = {
    6.       'title': 'titleOnCreate',
    7.       'detail': 'detailOnCreate'
    8.     };
    9.     let formData: formBindingData.FormBindingData = formBindingData.createFormBindingData(obj);
    10.     return formData;
    11.   }
    12.   onCastToNormalForm(formId: string): void {
    13.     // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理，当前卡片使用方不存在临时卡片场景
    14.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onCastToNormalForm');
    15.   }
    16.   onUpdateForm(formId: string): void {
    17.     // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新
    18.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onUpdateForm');
    19.     let obj: Record<string, string> = {
    20.       'title': 'titleOnUpdate',
    21.       'detail': 'detailOnUpdate'
    22.     };
    23.     let formData: formBindingData.FormBindingData = formBindingData.createFormBindingData(obj);
    24.     formProvider.updateForm(formId, formData).catch((error: BusinessError) => {
    25.       hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] updateForm, error:' + JSON.stringify(error));
    26.     });
    27.   }
    28.   onChangeFormVisibility(newStatus: Record<string, number>): void {
    29.     // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，仅系统应用生效
    30.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onChangeFormVisibility');
    31.     //...
    32.   }
    33.   onFormEvent(formId: string, message: string): void {
    34.     // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发
    35.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onFormEvent');
    36.   }
    37.   onRemoveForm(formId: string): void {
    38.     // 删除卡片实例数据
    39.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onRemoveForm');
    40.     //...
    41.   }
    42.   onAcquireFormState(want: Want): formInfo.FormState {
    43.     return formInfo.FormState.READY;
    44.   }
    45. }
    

说明

FormExtensionAbility不能常驻后台，即在卡片生命周期回调函数中无法处理长时间的任务。

### 配置卡片配置文件

1. 卡片需要在[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中的extensionAbilities标签下，配置ExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串"ohos.extension.form"，资源为卡片的具体配置信息的索引。
    
    配置示例如下：
    
    1. {
    2.   "module": {
    3.     // ...
    4.     "extensionAbilities": [
    5.       {
    6.         "name": "JsCardFormAbility",
    7.         "srcEntry": "./ets/jscardformability/JsCardFormAbility.ts",
    8.         "description": "$string:JSCardFormAbility_desc",
    9.         "label": "$string:JSCardFormAbility_label",
    10.         "type": "form",
    11.         "metadata": [
    12.           {
    13.             "name": "ohos.extension.form",
    14.             "resource": "$profile:form_jscard_config"
    15.           }
    16.         ]
    17.       }
    18.     ]
    19.   }
    20. }
    
2. 卡片的具体配置信息。在上述FormExtensionAbility的元信息（"metadata"配置项）中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_jscard_config时，会使用开发视图的resources/base/profile/目录下的form_jscard_config.json作为卡片profile配置文件。内部字段结构说明如下表所示。
    
    **表1** 卡片profile配置文件
    
    |属性名称|含义|数据类型|是否可缺省|
    |:--|:--|:--|:--|
    |name|表示卡片的类名，字符串最大长度为127字节。|字符串|否|
    |description|表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。|字符串|可缺省，缺省为空。|
    |src|表示卡片对应的UI代码的完整路径。|字符串|否|
    |window|用于定义与显示窗口相关的配置。|对象|可缺省。|
    |isDefault|表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br><br>- true：默认卡片。<br><br>- false：非默认卡片。|布尔值|否|
    |colorMode(deprecated)|表示卡片的主题样式，取值范围如下：<br><br>- auto：跟随系统的颜色模式值选取主题。<br><br>- dark：深色主题。<br><br>- light：浅色主题。<br><br>**说明：**<br><br>1. 从API version 12开始支持该配置项，从API version 20开始废弃该配置项，卡片主题样式统一跟随系统的颜色模式。|字符串|可缺省，缺省值为“auto”。|
    |supportDimensions|表示卡片支持的外观规格，取值范围：<br><br>- 1 * 1：表示1行1列的一宫格。<br><br>- 1 * 2：表示1行2列的二宫格。<br><br>- 2 * 2：表示2行2列的四宫格。<br><br>- 2 * 4：表示2行4列的八宫格。<br><br>- 2 * 3：表示2行3列的六宫格。<br><br>- 3 * 3：表示3行3列的九宫格。<br><br>- 4 * 4：表示4行4列的十六宫格。<br><br>- 6 * 4：表示6行4列的二十四宫格。<br><br>**说明**： 2 * 3和 3 * 3仅支持手表设备， 1 * 1只支持在锁屏上使用。|字符串数组|否|
    |defaultDimension|表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。|字符串|否|
    |updateEnabled|表示卡片是否支持周期性刷新，取值范围：<br><br>- true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。<br><br>- false：表示不支持周期性刷新。|布尔类型|否|
    |scheduledUpdateTime|表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br><br>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。|字符串|可缺省，缺省值为“0:0”。|
    |updateDuration|表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br><br>当取值为0时，表示该参数不生效。<br><br>当取值为正整数N时，表示刷新周期为30*N分钟。<br><br>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。|数值|可缺省，缺省值为“0”。|
    |formConfigAbility|表示卡片的配置跳转链接，采用URI格式。|字符串|可缺省，缺省值为空。|
    |formVisibleNotify|标识是否允许卡片使用卡片可见性通知。|字符串|可缺省，缺省值为空。|
    |metaData|表示卡片的自定义信息，包含customizeData数组标签。|对象|可缺省，缺省值为空。|
    
    配置示例如下：
    
    1. {
    2.   "forms": [
    3.     {
    4.       "name": "WidgetJS",
    5.       "description": "$string:JSCardEntryAbility_desc",
    6.       "src": "./js/WidgetJS/pages/index/index",
    7.       "window": {
    8.         "designWidth": 720,
    9.         "autoDesignWidth": true
    10.       },
    11.       "isDefault": true,
    12.       "updateEnabled": true,
    13.       "scheduledUpdateTime": "10:30",
    14.       "updateDuration": 1,
    15.       "defaultDimension": "2*2",
    16.       "supportDimensions": [
    17.         "2*2"
    18.       ]
    19.     }
    20.   ]
    21. }
    

### 卡片信息的持久化

因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息，且卡片管理服务支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。

1. import { common, Want } from '@kit.AbilityKit';
2. import { hilog } from '@kit.PerformanceAnalysisKit';
3. import { formBindingData, FormExtensionAbility } from '@kit.FormKit';
4. import { BusinessError } from '@kit.BasicServicesKit';
5. import { preferences } from '@kit.ArkData';

6. const TAG: string = 'JsCardFormAbility';
7. const DATA_STORAGE_PATH: string = '/data/storage/el2/base/haps/form_store';
8. const DOMAIN_NUMBER: number = 0xFF00;

9. let storeFormInfo = async (formId: string, formName: string, tempFlag: boolean, context: common.FormExtensionContext): Promise<void> => {
10.   // 此处仅对卡片ID：formId，卡片名：formName和是否为临时卡片：tempFlag进行了持久化
11.   let formInfo: Record<string, string | boolean | number> = {
12.     'formName': formName,
13.     'tempFlag': tempFlag,
14.     'updateCount': 0
15.   };
16.   try {
17.     const storage: preferences.Preferences = await preferences.getPreferences(context, DATA_STORAGE_PATH);
18.     // put form info
19.     await storage.put(formId, JSON.stringify(formInfo));
20.     hilog.info(DOMAIN_NUMBER, TAG, `[EntryFormAbility] storeFormInfo, put form info successfully, formId: ${formId}`);
21.     await storage.flush();
22.   } catch (err) {
23.     hilog.error(DOMAIN_NUMBER, TAG, `[EntryFormAbility] failed to storeFormInfo, err: ${JSON.stringify(err as BusinessError)}`);
24.   }
25. }

26. export default class JsCardFormAbility extends FormExtensionAbility {
27.   onAddForm(want: Want): formBindingData.FormBindingData {
28.     hilog.info(DOMAIN_NUMBER, TAG, '[JsCardFormAbility] onAddForm');

29.     if (want.parameters) {
30.       let formId = JSON.stringify(want.parameters['ohos.extra.param.key.form_identity']);
31.       let formName = JSON.stringify(want.parameters['ohos.extra.param.key.form_name']);
32.       let tempFlag = want.parameters['ohos.extra.param.key.form_temporary'] as boolean;
33.       // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用
34.       // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例
35.       storeFormInfo(formId, formName, tempFlag, this.context);
36.     }

37.     let obj: Record<string, string> = {
38.       'title': 'titleOnCreate',
39.       'detail': 'detailOnCreate'
40.     };
41.     let formData: formBindingData.FormBindingData = formBindingData.createFormBindingData(obj);
42.     return formData;
43.   }
44. }

且需要适配onRemoveForm卡片删除通知接口，在其中实现卡片实例数据的删除。

1. import { common } from '@kit.AbilityKit';
2. import { hilog } from '@kit.PerformanceAnalysisKit';
3. import { FormExtensionAbility } from '@kit.FormKit';
4. import { BusinessError } from '@kit.BasicServicesKit';
5. import { preferences } from '@kit.ArkData';

6. const TAG: string = 'JsCardFormAbility';
7. const DATA_STORAGE_PATH: string = '/data/storage/el2/base/haps/form_store';
8. const DOMAIN_NUMBER: number = 0xFF00;

9. let deleteFormInfo = async (formId: string, context: common.FormExtensionContext): Promise<void> => {
10.   try {
11.     const storage: preferences.Preferences = await preferences.getPreferences(context, DATA_STORAGE_PATH);
12.     // del form info
13.     await storage.delete(formId);
14.     hilog.info(DOMAIN_NUMBER, TAG, `[EntryFormAbility] deleteFormInfo, del form info successfully, formId: ${formId}`);
15.     await storage.flush();
16.   } catch (err) {
17.     hilog.error(DOMAIN_NUMBER, TAG, `[EntryFormAbility] failed to deleteFormInfo, err: ${JSON.stringify(err as BusinessError)}`);
18.   };
19. };

20. export default class JsCardFormAbility extends FormExtensionAbility {
21.   onRemoveForm(formId: string): void {
22.     // 删除卡片实例数据
23.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onRemoveForm');
24.     // 删除之前持久化的卡片实例数据
25.     // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例
26.     deleteFormInfo(formId, this.context);
27.   }
28. }

具体的持久化方法可以参考[轻量级数据存储开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-data-persistence-overview)。

需要注意的是，卡片使用方在请求卡片时传递给提供方应用的Want数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片：

- 常态卡片：卡片使用方会持久化的卡片。
    
- 临时卡片：卡片使用方不会持久化的卡片，当前卡片使用方不存在临时卡片场景。
    

由于临时卡片的数据具有非持久化的特殊性，某些场景例如卡片服务框架死亡重启，此时临时卡片数据在卡片管理服务中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。

### 卡片数据交互

当卡片应用需要更新数据时（如触发了定时更新或定点更新），卡片应用获取最新数据，并调用updateForm()接口主动触发卡片的更新。

1. import { hilog } from '@kit.PerformanceAnalysisKit';
2. import { formBindingData, FormExtensionAbility, formProvider } from '@kit.FormKit';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. const TAG: string = 'JsCardFormAbility';
5. const DOMAIN_NUMBER: number = 0xFF00;

6. export default class EntryFormAbility extends FormExtensionAbility {
7.   onUpdateForm(formId: string): void {
8.     // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新
9.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onUpdateForm');
10.     let obj: Record<string, string> = {
11.       'title': 'titleOnUpdate',
12.       'detail': 'detailOnUpdate'
13.     };
14.     let formData: formBindingData.FormBindingData = formBindingData.createFormBindingData(obj);
15.     formProvider.updateForm(formId, formData).catch((error: BusinessError) => {
16.       hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] updateForm, error:' + JSON.stringify(error));
17.     });
18.   }
19. }

### 开发卡片页面

开发者可以使用类Web范式（HML+CSS+JSON）开发JS卡片页面。生成如下卡片页面，可以这样配置卡片页面文件：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163837.69013065420717040418359779426280:50001231000000:2800:80FFB0F2B57BB4F67C59CB080DFC9969418F36F223FB7D91CB734AA594B31299.png)

- HML：使用类Web范式的组件描述卡片的页面信息。
    
    1. <div class="container">
    2.   <stack>
    3.     <div class="container-img">
    4.       <image src="/common/widget.png" class="bg-img"></image>
    5.     </div>
    6.     <div class="container-inner">
    7.       <text class="title">{{title}}</text>
    8.       <text class="detail_text" onclick="routerEvent">{{detail}}</text>
    9.     </div>
    10.   </stack>
    11. </div>
    
- CSS：HML中类Web范式组件的样式信息。
    
    1. .container {
    2.   flex-direction: column;
    3.   justify-content: center;
    4.   align-items: center;
    5. }
    
    6. .bg-img {
    7.   flex-shrink: 0;
    8.   height: 100%;
    9. }
    
    10. .container-inner {
    11.   flex-direction: column;
    12.   justify-content: flex-end;
    13.   align-items: flex-start;
    14.   height: 100%;
    15.   width: 100%;
    16.   padding: 12px;
    17. }
    
    18. .title {
    19.   font-size: 19px;
    20.   font-weight: bold;
    21.   color: white;
    22.   text-overflow: ellipsis;
    23.   max-lines: 1;
    24. }
    
    25. .detail_text {
    26.   font-size: 16px;
    27.   color: white;
    28.   opacity: 0.66;
    29.   text-overflow: ellipsis;
    30.   max-lines: 1;
    31.   margin-top: 6px;
    32. }
    
- JSON：卡片页面中的数据和事件交互。
    
    1. {
    2.   "data": {
    3.     "title": "TitleDefault",
    4.     "detail": "TextDefault"
    5.   },
    6.   "actions": {
    7.     "routerEvent": {
    8.       "action": "router",
    9.       "abilityName": "EntryAbility",
    10.       "params": {
    11.         "message": "add detail"
    12.       }
    13.     }
    14.   }
    15. }
    

### 开发卡片事件

卡片支持为组件设置交互事件（action），包括router事件和message事件，其中router事件用于UIAbility跳转，message事件用于卡片开发人员自定义点击事件。

关键步骤说明如下：

1. 在HML中为组件设置onclick属性，其值对应到JSON文件的actions字段中。
    
2. 设置router事件：
    
    - action属性值为"router"。
    - abilityName为跳转目标的UIAbility名（支持跳转FA模型的PageAbility组件和Stage模型的UIAbility组件），如目前DevEco Studio创建的Stage模型的UIAbility默认名为EntryAbility。
    - params为传递给跳转目标UIAbility的自定义参数，可以按需填写。其值可以在目标UIAbility启动时的want中的parameters里获取。如Stage模型MainAbility的onCreate生命周期里的入参want的parameters字段下获取到配置的参数。
3. 设置message事件：
    
    - action属性值为"message"。
    - params为message事件的用户自定义参数，可以按需填写。其值可以在卡片生命周期函数onFormEvent()中的message里获取。

示例如下。

- HML文件
    
    1. <div class="container">
    2.     <stack>
    3.         <div class="container-img">
    4.             <image src="/common/CardWebImg.png" class="bg-img"></image>
    5.             <image src="/common/CardWebImgMatrix.png"
    6.                    class="bottom-img"/>
    7.         </div>
    8.         <div class="container-inner">
    9.             <text class="title" onclick="routerEvent">{{ title }}</text>
    10.             <text class="detail_text" onclick="messageEvent">{{ detail }}</text>
    11.         </div>
    12.     </stack>
    13. </div>
    
- CSS文件
    
    1. .container {
    2.     flex-direction: column;
    3.     justify-content: center;
    4.     align-items: center;
    5. }
    
    6. .bg-img {
    7.     flex-shrink: 0;
    8.     height: 100%;
    9.     z-index: 1;
    10. }
    
    11. .bottom-img {
    12.     position: absolute;
    13.     width: 150px;
    14.     height: 56px;
    15.     top: 63%;
    16.     background-color: rgba(216, 216, 216, 0.15);
    17.     filter: blur(20px);
    18.     z-index: 2;
    19. }
    
    20. .container-inner {
    21.     flex-direction: column;
    22.     justify-content: flex-end;
    23.     align-items: flex-start;
    24.     height: 100%;
    25.     width: 100%;
    26.     padding: 12px;
    27. }
    
    28. .title {
    29.     font-family: HarmonyHeiTi-Medium;
    30.     font-size: 14px;
    31.     color: rgba(255, 255, 255, 0.90);
    32.     letter-spacing: 0.6px;
    33.     font-weight: 500;
    34.     width: 100%;
    35.     text-overflow: ellipsis;
    36.     max-lines: 1;
    37. }
    
    38. .detail_text {
    39.     font-family: HarmonyHeiTi;
    40.     font-size: 12px;
    41.     color: rgba(255, 255, 255, 0.60);
    42.     letter-spacing: 0.51px;
    43.     font-weight: 400;
    44.     text-overflow: ellipsis;
    45.     max-lines: 1;
    46.     margin-top: 6px;
    47.     width: 100%;
    48. }
    
- JSON文件
    
    1. {
    2.   "data": {
    3.     "title": "TitleDefault",
    4.     "detail": "TextDefault"
    5.   },
    6.   "actions": {
    7.     "routerEvent": {
    8.       "action": "router",
    9.       "abilityName": "JSCardEntryAbility",
    10.       "params": {
    11.         "info": "router info",
    12.         "message": "router message"
    13.       }
    14.     },
    15.     "messageEvent": {
    16.       "action": "message",
    17.       "params": {
    18.         "detail": "message detail"
    19.       }
    20.     }
    21.   }
    22. }
    
    说明：
    
    "data"中JSON Value支持多级嵌套数据，在更新数据时，需要注意携带完整数据。
    
    例如：当前卡片显示07.18日Mr.Zhang的课程信息，示例如下。
    
    1. "data": {
    2.     "Day": "07.18",
    3.     "teacher": {
    4.         "name": "Mr.Zhang",
    5.         "course": "Math"
    6.     }
    7. }
    
    当卡片内容需要更新为07.18日Mr.Li的课程信息时，需要传递待更新的完整数据，不能只传递单个数据项，如只传name或只传course，示例如下。
    
    8. "teacher": {
    9.     "name": "Mr.Li",
    10.     "course": "English"
    11. }
    
- 在UIAbility中接收router事件并获取参数
    
    1. import UIAbility from '@ohos.app.ability.UIAbility';
    2. import AbilityConstant from '@ohos.app.ability.AbilityConstant';
    3. import Want from '@ohos.app.ability.Want';
    4. import hilog from '@ohos.hilog';
    
    5. const TAG: string = 'EtsCardEntryAbility';
    6. const DOMAIN_NUMBER: number = 0xFF00;
    
    7. export default class EtsCardEntryAbility extends UIAbility {
    8.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    9.     if (want.parameters) {
    10.       let params: Record<string, Object> = JSON.parse(JSON.stringify(want.parameters.params));
    11.       // 获取router事件中传递的info参数
    12.       if (params.info === 'router info') {
    13.         // 执行业务逻辑
    14.         hilog.info(DOMAIN_NUMBER, TAG, `router info: ${params.info}`);
    15.       }
    16.       // 获取router事件中传递的message参数
    17.       if (params.message === 'router message') {
    18.         // 执行业务逻辑
    19.         hilog.info(DOMAIN_NUMBER, TAG, `router message: ${params.message}`);
    20.       }
    21.     }
    22.   }
    23. };
    
- 在FormExtensionAbility中接收message事件并获取参数
    
    1. import FormExtension from '@ohos.app.form.FormExtensionAbility';
    2. import hilog from '@ohos.hilog';
    
    3. const TAG: string = 'FormAbility';
    4. const DOMAIN_NUMBER: number = 0xFF00;
    
    5. export default class FormAbility extends FormExtension {
    6.   onFormEvent(formId: string, message: string): void {
    7.     // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发
    8.     hilog.info(DOMAIN_NUMBER, TAG, '[EntryFormAbility] onFormEvent');
    9.     // 获取message事件中传递的detail参数
    10.     let msg: Record<string, string> = JSON.parse(message);
    11.     if (msg.detail === 'message detail') {
    12.       // 执行业务逻辑
    13.       hilog.info(DOMAIN_NUMBER, TAG, 'message info:' + msg.detail);
    14.     }
    15.   }
    16. };
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/js-ui-widget-overview "JS卡片概述")
# IME Kit简介

更新时间: 2025-12-16 16:38

IME Kit 负责建立编辑框所在应用与输入法应用之间的通信通道，确保两者可以共同协作提供文本输入功能，也为系统应用提供管理输入法应用的能力。

## Kit使用场景

IME Kit提供输入法框架和输入法服务两类API。用于实现输入法应用，也可以用于实现自绘编辑框以及实现对输入法应用的控制。

## 框架原理

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163818.07955323548606164620983400530470:50001231000000:2800:B2B72EA42480851A812CAC56B8797645CEC997F87FAA504E0C3283B519F2CEB4.png)

## 功能特点

- 输入法应用：
    
    支持创建固定态、悬浮态、状态栏三种类型的Panel，可支持开发一个输入法应用同时部署在手机、平板等多设备中。
    
- 自定义编辑框：
    
    支持开发者自定义编辑框，实现绑定输入法应用，并实现输入法应用的文字输入、删除、选中、光标移动等操作。
    

## 能力范围

- 提供输入法服务相关API，用于输入法应用，包括：创建软键盘窗口、插入/删除字符、选中文本、监听物理键盘按键事件等。
    
- 提供输入法框架相关API，可用于自绘编辑框，包括绑定输入法，实现输入、删除、选中、光标移动等。
    
- 提供系统应用管理输入法应用能力，实现对输入法应用的控制，包括显示/隐藏输入法软键盘、切换输入法、获取所有输入法列表。
    

## 与相关Kit的关系

ArkUI: IME Kit在输入法软键盘和自绘编辑框时使用ArkUI提供的部分组件、事件、动效、状态管理等能力，例如Text、Button组件，onClick点击事件。

## 约束限制

针对切换输入法应用的系统API，需要申请系统权限，部分API仅支持当前输入法应用调用。

## IME Kit API参考

- [inputMethodEngine](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethodengine)
    
- [inputMethod](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethod)
    
- [InputMethodExtensionAbility](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethod-extension-ability)
    
- [InputMethodExtensionContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethod-extension-context)
    
- [inputMethodList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethodlist)
    
- [InputMethodSubtype](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethod-subtype)
    
- [inputMethod.Panel](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethod-panel)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ime-kit "IME Kit（输入法开发服务）")
