# 自定义节点常见问题

更新时间: 2025-12-16 16:39

本文档介绍自定义节点的常见问题并提供参考。

## 自定义组件的aboutToDisappear回调异常

**问题现象**

从API version 12开始，自定义节点的子节点在页面退出后未立即回调自定义组件的[aboutToDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttodisappear)方法。自定义组件的aboutToDisappear通常在其销毁的时候触发，页面销毁后未立即回调则说明该自定义组件在页面销毁后未立即销毁。

**可能原因**

- 自定义组件存在父节点且父节点未销毁。
- 自定义组件由[BuilderNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-arktsnode-buildernode)创建，该前端对象既未被回收，也未解除对后端自定义组件的引用。BuilderNode创建时，默认持有后端节点的强引用。
- 通过调用[OH_ArkUI_GetNodeHandleFromNapiValue](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-node-napi-h#oh_arkui_getnodehandlefromnapivalue)方法，可以获取BuilderNode或ComponentContent对象中的root节点，此操作会使后端节点的引用计数加一。
- 在[NodeContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontent)中，通过[addFrameNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontent#addframenode12)方法增加了对被添加的FrameNode对象节点的引用关系。然而，该NodeContent对象未被回收，且未通过[removeFrameNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontent#removeframenode12)接口删除所增加的引用关系。

**解决措施**

- 将需要释放的自定义组件从父节点上移除，排除父节点对自定义组件生命周期的影响。
- 自定义组件由[BuilderNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-arktsnode-buildernode)创建时，调用[dispose](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-buildernode#dispose12)接口，立即释放前端BuilderNode对象对于后端节点的强引用。
- 对于使用OH_ArkUI_GetNodeHandleFromNapiValue获取BuilderNode或ComponentContent对象的root节点，
    
    调用[disposenode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-arkui-nativemodule-arkui-nativenodeapi-1#disposenode)减少OH_ArkUI_GetNodeHandleFromNapiValue增加的引用计数。
    
- 未调用dispose时，当前端的BuilderNode对象在[GC](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/gc-introduction)中被回收会释放对后端根节点的引用。调试阶段可使用[hidumper](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hidumper)指令触发GC或[查询堆内存](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hidumper#%E6%9F%A5%E8%AF%A2%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86%E5%86%85%E5%AD%98)来分析引用关系。

**示例代码**

下文中，根节点表示BuilderNode的根节点，aboutToDisappear表示BuilderNode中构建的自定义组件（即BuilderNodePage）中的回调。

- 跳转至pageOneTmp页面后返回，通过指令触发GC，继续操作设备后可以看到aboutToDisappear回调。根节点相关的引用关系和解决方案：
    
    - NodeContent对根节点的引用关系：需要触发NodeContent对象的回收，或主动调用removeFrameNode接口。
    - 全局对象对BuilderNode的引用关系：通过[ArrayList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist)的[clear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist#clear)方法清除对BuilderNode的引用。
    - BuilderNode对象对根节点的引用关系：确保BuilderNode对象无其他引用关系，触发该对象的回收可以解除其对根节点的引用。
- 跳转至pageTwoTmp页面后返回，可以直接看到aboutToDisappear回调。根节点相关的引用关系以及解决方案：
    
    - NodeContent对根节点的引用关系：通过NodeContent的removeFrameNode接口解除引用关系。
    - BuilderNode对象对根节点的引用关系：通过BuilderNode的dispose接口直接解除引用关系。
- 跳转至pageThreeTmp页面后返回，可以直接看到aboutToDisappear回调。根节点相关的引用关系以及解决方案：
    
    - 根节点的父节点对其的引用关系：由于父节点为FrameNode对象对应的节点，可以直接通过FrameNode的removeChild方法解除引用关系。
    - BuilderNode对象对根节点的引用关系：通过BuilderNode的dispose接口直接解除引用关系。

1. import { BuilderNode, FrameNode, NodeContent } from '@kit.ArkUI';
2. import { ArrayList } from '@kit.ArkTS';

3. const CUSTOM_COMPONENT_CONT: string = "CustomComponentCont"
4. AppStorage.setOrCreate<number>(CUSTOM_COMPONENT_CONT, 0);
5. let globalBuilderNodeList: ArrayList<BuilderNode<[]>> = new ArrayList<BuilderNode<[]>>();

6. @Component
7. struct BuilderNodePage {
8.   aboutToAppear(): void {
9.     const count: number | undefined = AppStorage.get<number>(CUSTOM_COMPONENT_CONT);
10.     const current: number = count ? count + 1 : 1;
11.     AppStorage.setOrCreate<number>(CUSTOM_COMPONENT_CONT, current);
12.     console.info("BuilderNodePage", "aboutToAppear " + AppStorage.get<number>(CUSTOM_COMPONENT_CONT))
13.   }

14.   aboutToDisappear(): void {
15.     setTimeout(() => {
16.       const count: number | undefined = AppStorage.get<number>(CUSTOM_COMPONENT_CONT);
17.       console.info("BuilderNodePage", "aboutToDisappear " + count)
18.       const current: number = count ? count - 1 : -1;
19.       AppStorage.set<number>(CUSTOM_COMPONENT_CONT, current)
20.       console.info("BuilderNodePage", "aboutToDisappear " + AppStorage.get<number>(CUSTOM_COMPONENT_CONT))
21.     }, 1)
22.   }

23.   build() {
24.     Text("This is a BuilderNode")
25.   }
26. }

27. @Builder
28. function BuilderNodeBuilder() {
29.   BuilderNodePage();
30. }

31. @Entry
32. @Component
33. struct NavigationExample {
34.   @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack()
35.   private arr: number[] = [1, 2, 3];
36.   @StorageProp(CUSTOM_COMPONENT_CONT) customComponentCount: number | undefined =
37.     AppStorage.get<number>(CUSTOM_COMPONENT_CONT);

38.   @Builder
39.   pageMap(name: string) {
40.     if (name === "NavDestinationTitle1") {
41.       pageOneTmp();
42.     } else if (name === "NavDestinationTitle2") {
43.       pageTwoTmp();
44.     } else if (name === "NavDestinationTitle3") {
45.       pageThreeTmp();
46.     }
47.   }

48.   onPageShow(): void {
49.     console.info("NavigationExample " + this.customComponentCount);
50.   }

51.   build() {
52.     Column() {
53.       Navigation(this.pageInfos) {
54.         Text("BuilderNode中自定义组件的遗留数量 " + this.customComponentCount)
55.           .width("90%")
56.           .height(40)
57.           .backgroundColor('#FFFFFF')
58.         Button("移除全局引用")
59.           .onClick(() => {
60.             // 清除所有全局引用。
61.             // 可以使用hidumper指令触发GC验证引用关系是否清零。
62.             globalBuilderNodeList.clear();
63.           })
64.         List({ space: 12 }) {
65.           ForEach(this.arr, (item: number) => {
66.             ListItem() {
67.               Text("Page" + item)
68.                 .width("100%")
69.                 .height(72)
70.                 .backgroundColor('#FFFFFF')
71.                 .borderRadius(24)
72.                 .fontSize(16)
73.                 .fontWeight(500)
74.                 .textAlign(TextAlign.Center)
75.                 .onClick(() => {
76.                   this.pageInfos.pushPath({ name: "NavDestinationTitle" + item });
77.                 })
78.             }
79.           }, (item: number) => item.toString())
80.         }
81.         .width("100%")
82.         .margin({ top: 12 })
83.       }
84.       .title("主标题")
85.       .mode(NavigationMode.Stack)
86.       .navDestination(this.pageMap)
87.     }
88.     .height('100%')
89.     .width('100%')
90.     .backgroundColor('#F1F3F5')
91.   }
92. }

93. @Component
94. export struct pageOneTmp {
95.   @Consume('pageInfos') pageInfos: NavPathStack;
96.   private builderNode: BuilderNode<[]> = new BuilderNode(this.getUIContext());
97.   private content: NodeContent = new NodeContent();

98.   aboutToAppear(): void {
99.     console.info("pageOneTmp", "aboutToAppear")
100.     this.builderNode.build(wrapBuilder(BuilderNodeBuilder));
101.     if (this.builderNode.getFrameNode()) {
102.       this.content.addFrameNode(this.builderNode.getFrameNode());
103.     }
104.     // 添加全局引用，该对象在全局引用移除前无法被GC。
105.     globalBuilderNodeList.add(this.builderNode);
106.   }

107.   aboutToDisappear(): void {
108.     console.info("pageOneTmp", "aboutToDisappear")
109.   }

110.   build() {
111.     NavDestination() {
112.       Column() {
113.         Text("pageOneTmp")
114.         ContentSlot(this.content)
115.       }.width('100%').height('100%')
116.     }.title("NavDestinationTitle1")
117.     .onBackPressed(() => {
118.       const popDestinationInfo = this.pageInfos.pop(); // 弹出路由栈栈顶元素。
119.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
120.       return true;
121.     })
122.   }
123. }

124. @Component
125. export struct pageTwoTmp {
126.   @Consume('pageInfos') pageInfos: NavPathStack;
127.   private builderNode: BuilderNode<[]> = new BuilderNode(this.getUIContext());
128.   private content: NodeContent = new NodeContent();

129.   aboutToAppear(): void {
130.     console.info("pageTwoTmp", "aboutToAppear")
131.     this.builderNode!.build(wrapBuilder(BuilderNodeBuilder));
132.     if (this.builderNode!.getFrameNode()) {
133.       // 将BuilderNode的根节点挂载至NodeContent对象中。
134.       // 如果要触发builderNode的根节点的析构，需要主动从NodeContent对象中移除该节点，或者等待NodeContent对象被GC。
135.       // 否则，BuilderNode的根节点无法触发析构。
136.       this.content.addFrameNode(this.builderNode!.getFrameNode());
137.     }
138.   }

139.   aboutToDisappear(): void {
140.     console.info("pageTwoTmp", "aboutToDisappear")
141.     if (this.builderNode?.getFrameNode()) {
142.       // 将BuilderNode的根节点从NodeContent对象中移除。
143.       // 需要在BuilderNode的dispose操作之前执行，否则无法获得该BuilderNode的根节点。
144.       this.content.removeFrameNode(this.builderNode?.getFrameNode());
145.     }
146.     this.builderNode?.dispose();
147.   }

148.   build() {
149.     NavDestination() {
150.       Column() {
151.         Text("pageTwoTmp")
152.         ContentSlot(this.content)
153.       }.width('100%').height('100%')
154.     }.title("NavDestinationTitle2")
155.     .onBackPressed(() => {
156.       const popDestinationInfo = this.pageInfos.pop(); // 弹出路由栈栈顶元素。
157.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
158.       return true;
159.     })
160.   }
161. }

162. @Component
163. export struct pageThreeTmp {
164.   @Consume('pageInfos') pageInfos: NavPathStack;
165.   private builderNode: BuilderNode<[]> = new BuilderNode(this.getUIContext());
166.   private content: NodeContent = new NodeContent();
167.   private rootNode: FrameNode = new FrameNode(this.getUIContext());

168.   aboutToAppear(): void {
169.     console.info("pageThreeTmp", "aboutToAppear")
170.     this.builderNode!.build(wrapBuilder(BuilderNodeBuilder));
171.     if (this.builderNode!.getFrameNode()) {
172.       this.content.addFrameNode(this.rootNode);
173.       // BuilderNode的根节点被挂载至FrameNode对象对应的节点中。
174.       // BuilderNode的根节点如果要触发析构需要从主动从FrameNode对象对应的节点中移除，或者等待FrameNode对象对应的节点析构。
175.       // 否则，BuilderNode的根节点无法触发析构。
176.       this.rootNode.appendChild(this.builderNode.getFrameNode());
177.     }
178.   }

179.   aboutToDisappear(): void {
180.     console.info("pageThreeTmp", "aboutToDisappear")
181.     if (this.builderNode?.getFrameNode()) {
182.       // 将BuilderNode的根节点从FrameNode对象对应的节点中移除。
183.       // 需要在BuilderNode的dispose操作以及FrameNode对象dispose之前执行，否则无法获得他们对应的节点。
184.       this.rootNode.removeChild(this.builderNode?.getFrameNode());
185.     }
186.     this.builderNode?.dispose();
187.   }

188.   build() {
189.     NavDestination() {
190.       Column() {
191.         Text("pageThreeTmp")
192.         ContentSlot(this.content)
193.       }.width('100%').height('100%')
194.     }.title("NavDestinationTitle3")
195.     .onBackPressed(() => {
196.       const popDestinationInfo = this.pageInfos.pop(); // 弹出路由栈栈顶元素。
197.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
198.       return true;
199.     })
200.   }
201. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ui-development-faq "UI开发常见问题")
# 按钮与选择组件常见问题

更新时间: 2025-12-16 16:39

本文档介绍按钮与选择组件的常见问题并提供参考。

## Slider组件滑块与滑轨是如何对齐的

Slider的滑块与滑轨显示样式[SliderStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-slider#sliderstyle%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)有三种，其中SliderStyle.OutSet与SliderStyle.InSet存在滑块。Slider的滑动条进度为最小值时，滑块对齐方式如下：

SliderStyle.OutSet模式下，滑块的中心与滑轨的端点对齐，示例图如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163930.67130364015982334852552128768056:50001231000000:2800:8B0E9BC6DAAF682A6BC18CED16C54E42AD1DD7FE92F2E35EB998B92ABE6D938E.jpg)

SliderStyle.InSet模式下，滑块与滑轨的中心对齐，即距离端点滑轨高度的一半的位置，示例图如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163931.21377980005103997644290799434929:50001231000000:2800:288B3D10176F0105C3B18AD1FEB5EDDE80BE4847BB7D38C5F7A838E41846E578.jpg)

**示例**

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Column() {
6.       Slider({
7.         style: SliderStyle.OutSet
8.       })
9.         .blockSize({
10.           width: 20,
11.           height: 20
12.         })
13.         .trackThickness(50)
14.       Slider({
15.         style: SliderStyle.InSet
16.       })
17.         .blockSize({
18.           width: 20,
19.           height: 20
20.         })
21.         .trackThickness(50)
22.     }
23.     .height('100%')
24.     .width('100%')
25.   }
26. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-node-faq "自定义节点常见问题")
# 使用文本常见问题

更新时间: 2025-12-16 16:39

本文档介绍使用文本的常见问题并提供参考。

## 文本显示（Text/Span）常见问题

以下内容介绍了使用[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)和[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)组件进行文本显示时可能遇到的常见问题，包括文本截断、添加标签、显示表情等场景的处理方法。

### Text组件尾部省略号后为什么还有一段空白，没有占满组件宽度

**问题现象**

在Text组件上未设置宽度，当内容过长时，省略号与组件边缘之间会留有较大空白，且内容更新时省略号的位置会发生变化。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.68332835266137195621200814003632:50001231000000:2800:998CDDA95B7C05BA70C5127C0758C78EEF80B296EDE1DF5B254689872F8010C6.gif)

**原因分析**

当Text组件未设置宽度且内容超长时，组件宽度将采用父组件传递的布局约束的最大宽度。不同内容、不同的断词模式导致排版塑型结果不同，因此省略开始位置也会不同。

**解决措施**

设置[wordBreak](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#wordbreak11)属性为WordBreak.BREAK_ALL，任意2个字符间断行使文本内容尽量占满组件区域。

示例代码如下：

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '混合Hello World! honorificabilitudinitatibus!';

5.   build() {
6.     Column() {
7.       Text(this.message)
8.         .id('HelloWorld')
9.         .fontSize('25fp')
10.         .maxLines(1)
11.         .textOverflow({ overflow: TextOverflow.Ellipsis})
12.         .onClick(() => {
13.           this.message = 'Welcome try try try 1235628327434348';
14.         })
15.         .border({ width: 1})
16.         .wordBreak(WordBreak.BREAK_ALL) // 修改断词模式
17.     }
18.     .width(300)
19.     .border({ width: 1, color: Color.Blue})
20.     .margin({left: 30, top: 50})
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.09852442039365489862229270892499:50001231000000:2800:F330F3AEB6874DDE6516313B4D585596AC36988E9096D89D1A473596F93DF917.gif)

### Text组件如何实现行末展开样式

**解决措施**

自行测算截断字符，并在行末添加...展开或者...图标作为组件内容。实现方式请参考[属性字符串转Paragraph数组](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-measureutils#getparagraphs20)、[文本展开折叠](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-text-expand-collapse)。

### Text组件如何实现内容超长时自动显示省略样式吗？

**问题现象**

在固定尺寸的组件区域内，不同字号的内容显示的最大行数会有所不同。期望实现内容超长时自动显示省略样式，则无需设置固定的maxLines值。

**解决措施**

设置[heightAdaptivePolicy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#heightadaptivepolicy10)为TextHeightAdaptivePolicy.LAYOUT_CONSTRAINT_FIRST，该模式会删除超过布局约束的行，从而实现类似设置maxLines的效果。

示例代码如下：

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '混合Hello World! 多行文本 中英文数字混合 1282378283 ~';
5.   @State fontSize: number = 25;

6.   build() {
7.     Column({ space: 10 }) {
8.       Text(this.message)
9.         .id('HelloWorld')
10.         .fontSize(this.fontSize)
11.         .textOverflow({ overflow: TextOverflow.Ellipsis})
12.         .border({ width: 1})
13.         .heightAdaptivePolicy(TextHeightAdaptivePolicy.LAYOUT_CONSTRAINT_FIRST) // 调整自适应布局策略
14.         .width(300)
15.         .height(200)
16.       Row(){
17.         Button('fontSize+5')
18.           .onClick(()=>{
19.             this.fontSize += 5;
20.           })
21.         Button('fontSize-5')
22.           .onClick(()=>{
23.             this.fontSize -= 5;
24.           })
25.       }
26.     }
27.     .margin({left: 30, top: 50})
28.   }
29. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.28209714506333730659040082026520:50001231000000:2800:D57838D4C44539B4CFEF4D13AEB147D43818A72B372F21C5BCF13A21ACC7095D.gif)

### 在文本前后添加自定义标签

**问题现象**

如何在文本的前后各添加一个标签，例如“专题”或“Top1”，且这些标签的[背景样式](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-background)、[尺寸设置](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-size)需要能够自定义。

**解决措施一**

如果标签和中间的长文本需在同一行显示，开发者可能会考虑使用[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)实现，但是Span不支持设置尺寸。此时，可以在[弹性布局 (Flex)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-flex-layout)或者[Row](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-row)中放置标签和长文本，并为长文本设置[textOverflow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textoverflow)属性，以确保文本超长时能够自适应截断，显示在一行之内。

实现步骤：

1.将标签和长文本放在同一个沿水平方向布局的容器Row中。

2.中间长文本设置textOverflow属性为TextOverflow.Ellipsis，空间不足时截断文本，显示省略号。

实现案例请参考[实现热搜榜](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display#%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%90%9C%E6%A6%9C)，该示例中，文字“1”、“爆”就是“我是热搜词条”的两个标签。这种实现方式写法简便，适合单行文本添加标签的场景。

**解决措施二**

如果需在多行文本前后添加标签并且不截断文本，上述方案会导致三个Text中的文本不能对齐，因为多行文本会在Row的宽度内折行。此时，可以在[层叠布局 (Stack)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-stack-layout)中放置标签和长文本，给中间多行文本设置首行文本缩进距离[textIndent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textindent10)。多行文本后面的标签则需要通过[offset](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-location#offset)属性调整位置。这种实现方式，可以让三个Text组件中的文字水平对齐。实现步骤如下：

实现步骤：

1.将标签和长文本放在Stack中。

2.在组件显示之前的回调[aboutToAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear)中，使用[measureTextSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-measureutils#measuretextsize12)计算前标签的宽度，作为中间多行文本的首行缩进距离。

3.在组件显示之前的回调aboutToAppear中，通过[getparagraphs](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-measureutils#getparagraphs20)计算中间多行文本最后一行的宽度、除最后一行文本之外的高度，作为后标签的偏移量offset。

4.设置后标签相对于Stack左上角的偏移量。

示例：

1. import { LengthMetrics } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct Index {
5.   @State message: string = '这是一段长文本，超长部分折行，前后添加标签';
6.   @State frontTag: string = '前标签';
7.   @State backTag: string = '后标签';
8.   @State frontPaddingVp: number = 20;
9.   @State backPaddingVp: number = 10;
10.   @State fontTagWidthVp: Length = 0;
11.   @State backTagWidthVp: Length = 0;
12.   @State backOffsetVpX: Length = 0;
13.   @State backOffsetVpY: Length = 0;
14.   @State messageLines: number = 0;
15.   @State stackWidthVp: number = 300;

16.   // 显示之前，测算前后标签的位置，中间文本的缩进距离
17.   aboutToAppear(): void {
18.     // 计算前标签的宽度fontTagWidthVp，作为message的首行缩进距离
19.     let frontTagSize: SizeOptions = this.getUIContext().getMeasureUtils().measureTextSize({
20.       textContent: this.frontTag,
21.     });
22.     this.fontTagWidthVp = this.getUIContext().px2vp(Number(frontTagSize.width)) + this.frontPaddingVp * 2

23.     // 计算frontTag+message占据的行数
24.     let linesFrontTagPlusMessage = 0;
25.     let mutableStr = new MutableStyledString(this.message,
26.       [{
27.         start: 0,
28.         length: 1,
29.         styledKey: StyledStringKey.PARAGRAPH_STYLE,
30.         styledValue: new ParagraphStyle({ textIndent: LengthMetrics.vp(this.fontTagWidthVp) })
31.       }]
32.     )
33.     let paragraphArr = this.getUIContext()
34.       .getMeasureUtils()
35.       .getParagraphs(mutableStr, { constraintWidth: LengthMetrics.vp(this.stackWidthVp) });
36.     for (let i = 0; i < paragraphArr.length; ++i) {
37.       linesFrontTagPlusMessage += paragraphArr[i].getLineCount();
38.     }

39.     // 后标签offsetX的偏移量backOffsetVpX=frontTag+message最后一行的宽度
40.     this.backOffsetVpX =
41.       this.getUIContext().px2vp((paragraphArr[paragraphArr.length-1].getLineWidth(linesFrontTagPlusMessage - 1)))
42.     // 后标签offsetY的偏移量backOffsetVpY=frontTag+message总高度-最后一行的高度。
43.     let heightFrontTagPlusMessageVp = 0;
44.     for (let i = 0; i < paragraphArr.length; ++i) {
45.       heightFrontTagPlusMessageVp += this.getUIContext().px2vp(paragraphArr[i].getHeight());
46.     }
47.     let lastLineHeight =
48.       this.getUIContext().px2vp(paragraphArr[paragraphArr.length-1].getLineHeight(linesFrontTagPlusMessage - 1))
49.     this.backOffsetVpY = heightFrontTagPlusMessageVp - lastLineHeight
50.   }

51.   build() {
52.     Column({ space: 20 }) {
53.       Blank()
54.         .height(200)
55.       Stack() {
56.         Text(this.frontTag)
57.           .padding({ left: this.frontPaddingVp, right: this.frontPaddingVp })
58.           .backgroundColor('rgb(39, 135, 217)')
59.         Text(this.message)
60.           .textIndent(this.fontTagWidthVp)
61.           .padding(0)
62.         Text(this.backTag)
63.           .padding({ left: this.backPaddingVp, right: this.backPaddingVp })
64.           .backgroundColor('rgb(0, 74, 175)')
65.           .offset({
66.             x: this.backOffsetVpX,
67.             y: this.backOffsetVpY
68.           })
69.       }
70.       .alignContent(Alignment.TopStart) // 顶部起始端对齐
71.       .width(this.stackWidthVp)
72.     }
73.     .height('100%')
74.     .width('90%')
75.     .padding('5%')
76.   }
77. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.47863062994645489737157093983000:50001231000000:2800:2217D9185C2F749E22B0AE9CFE3A82747352432B18B7385187DA820FE3C77110.png)

### Text组件如何实现表情与文字一起显示

**问题现象**

emoji表情有时以表情符号的形式表示，如何将表情符号转换为emoji表情，并在Text组件中与文字一同显示？

**解决措施**

使用正则表达式解析表情符号，再将表情符号与图片资源建立映射，通过[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)和[ImageSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imagespan)同时展示表情和文字。

1. @Entry
2. @Component
3. struct TextExample {
4.   @State fulltext: string =
5.     '你好我是Text[grin]，你好我[rolling_on_the_floor_laughing]是Text，[slightly_smiling_face]你好我是Text[grin]';

6.   static classifyTextAndEmojis(input: string): Map<string, string[]> {
7.     const emojiRegex = /\[([a-zA-Z_]+)\]/g; // 根据实际情况编写正则表达式
8.     const resultMap = new Map<string, string[]>(); // 用map记录普通文本和表情
9.     resultMap.set('text', []);
10.     resultMap.set('emojis', []);

11.     let lastIndex = 0;
12.     let match: RegExpExecArray | null = null;

13.     while ((match = emojiRegex.exec(input)) !== null) {
14.       // 添加普通文本
15.       if (match.index > lastIndex) {
16.         resultMap.get('text')?.push(input.substring(lastIndex, match.index));
17.       }
18.       // 添加匹配到的表情
19.       resultMap.get('emojis')?.push(match[1]);
20.       lastIndex = match.index + match[0].length;
21.     }
22.     // 添加最后一段文本
23.     if (lastIndex < input.length) {
24.       resultMap.get('text')?.push(input.substring(lastIndex));
25.     }
26.     return resultMap;
27.   }

28.   static getEmojiImg(emojis: string[]): Resource[] { // 根据正则匹配结果返回自定义表情资源
29.     let emojisImg: Resource[] = []
30.     for (let i = 0; i < emojis.length; i++) {
31.       switch (emojis[i]) { // $r("...")需要替换为开发者所需的图像资源
32.         case 'rolling_on_the_floor_laughing':
33.           emojisImg.push($r("app.media.rolling_on_the_floor_laughing"))
34.         case 'slightly_smiling_face':
35.           emojisImg.push($r("app.media.slightly_smiling_face"))
36.         case 'grin':
37.           emojisImg.push($r("app.media.grin"))
38.         default:
39.       }
40.     }
41.     return emojisImg
42.   }

43.   build() {
44.     Column() {
45.       TextInput({
46.         placeholder: "用户输入带表情的文本，例如：你好[grin]"
47.       })
48.         .width('80%')
49.         .padding(10)
50.         .border({ width: 1, color: '#EEEEEE' })
51.         .onChange((value: string) => {
52.           // 输入变化时，更新 fulltext
53.           this.fulltext = value;
54.         });

55.       Text() {
56.         ForEach(TextExample.classifyTextAndEmojis(this.fulltext).get('text'),
57.           (item: string, index: number) => { // 展示文本和自定义表情资源
58.             Span(item)
59.               .fontSize(18)
60.               .fontColor('#666666')
61.               .fontWeight(FontWeight.Regular)

62.             ImageSpan(TextExample.getEmojiImg(
63.               TextExample.classifyTextAndEmojis(this.fulltext).get('emojis'))[index])
64.               .verticalAlign(ImageSpanAlignment.BOTTOM)
65.               .height(24)
66.           })
67.       }
68.       .width('80%')
69.       .padding(15)
70.     }
71.     .width('100%')
72.     .height('100%')
73.     .justifyContent(FlexAlign.Center)
74.     .alignItems(HorizontalAlign.Center)
75.     .padding(20)
76.   }
77. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.35257321205162451123819479723433:50001231000000:2800:09F61BFD43DAEEB226E77C2491A9C686211AB49EC69A49A856389BD2956C9277.png)

### 文本超长时如何展示

**问题现象**

Text组件中内容过多，超出父组件容器[Column](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-column)的高度，会导致文本溢出容器边界，如何让文本显示在父组件容器的区域内？

**解决措施一**

Text文本是自动折行的，当没有限制Text高度[height](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-size#height)时，Text高度在文本的行数增加时自动调整。可以通过设置[maxLines](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#maxlines)属性限制文本的最大行数，如果有多余的文本默认会被截断。也可以通过[textOverflow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textoverflow)属性来指定截断方式。

以下示例展示了限制Text组件不超过三行的场景。

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '这是一段超长文本'.repeat(50);

5.   build() {
6.     Column() {
7.       Text(this.message)
8.         .height('auto')
9.         .maxLines(3)
10.     }
11.     .height(200)
12.     .width('80%')
13.     .margin('10%')
14.     .borderWidth(1)
15.     .justifyContent(FlexAlign.Center)
16.   }
17. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.65131496798446420700597249384428:50001231000000:2800:2D3663BD9B34A5B76C686F11D47C694AFBF2135E43E7EA81FF733968AFDFE732.png)

**解决措施二**

上述方法会导致部分文本被裁剪掉，如果需要保留全部文本，可以把Text组件放在滚动容器[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)内，再通过手势滑动来浏览全部文本，具体示例如下：

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '这是一段超长文本'.repeat(50);

5.   build() {
6.     Column() {
7.       Scroll() {
8.         Text(this.message)
9.       }
10.       .scrollBar(BarState.Off)
11.     }
12.     .height(200)
13.     .width('80%')
14.     .margin('10%')
15.     .borderWidth(1)
16.     .justifyContent(FlexAlign.Center)
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.23087733798533254187563806915238:50001231000000:2800:786F665882148F88E477710783A12B0B40792CCD92C21B0E34F6D5C07D3C4A76.gif)

### selection如何触发弹出自定义菜单并设置菜单字体大小

**问题现象**

在[bindSelectionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#bindselectionmenu11)自定义选择菜单中，可通过TextResponseType设置文本选择菜单的响应类型。通过[selection](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#selection11)如何触发弹出自定义菜单并设置菜单字体大小。

**解决措施**

若希望由selection触发自定义菜单，可将TextResponseType设置为DEFAULT。同时，在[Menu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menu)组件上通过配置font属性，即可自定义菜单的字体大小，灵活适配界面设计需求。

1. // xxx.ets
2. @Entry
3. @Component
4. struct TextExample8 {
5.   controller: TextController = new TextController();
6.   options: TextOptions = { controller: this.controller };
7.   @State selectStart: number = 0;
8.   @State selectEnd: number = 0;

9.   build() {
10.     Column() {
11.       Column() {
12.         Text("TextTextTextText")
13.           .fontSize(14)
14.           .selection(this.selectStart, this.selectEnd)
15.           .copyOption(CopyOptions.InApp)
16.           .bindSelectionMenu(TextSpanType.TEXT, this.CustomMenu, TextResponseType.DEFAULT, {
17.             onDisappear: () => {
18.               this.selectStart = -1;
19.               this.selectEnd = -1;
20.             },
21.           })
22.           .textAlign(TextAlign.Center)
23.           .borderWidth(1)
24.           .borderColor(Color.Red)
25.         Button("Set selection")
26.           .onClick(() => {
27.             this.selectStart = 0;
28.             this.selectEnd = 10;
29.           })
30.           .fontSize(14)
31.           .margin({ top: 20 })
32.       }
33.       .width('100%')
34.       .padding({ top: 300 })
35.     }
36.     .height('100%')
37.   }

38.   @Builder
39.   CustomMenu() {
40.     Column() {
41.       Menu() {
42.         MenuItem({ content: "Item Content" })
43.         MenuItem({ content: "Item Content" })
44.         MenuItem({ content: "Item Content" })
45.       }
46.       .font({ size: 14 })
47.       .radius($r('sys.float.ohos_id_corner_radius_card'))
48.       .clip(true)
49.       .backgroundColor('#F0F0F0')
50.     }
51.   }
52. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.51972532304878820521458111019323:50001231000000:2800:96043393CB963272B1FC20592298BD4A4BE9685B166D0D2C53900AB47C9E9C99.gif)

### 如何屏蔽文本的长按手势

**问题现象**

配置[CopyOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#copyoptions9)将文本设置为可选择，此时长按文本会选择文字内容并弹出系统菜单，如何使长按手势不生效。

**解决措施**

想要使长按手势对文本不生效，可以设置触发时间小于系统菜单触发时间（500ms）的自定义长按手势。

1. // xxx.ets
2. @Entry
3. @Component
4. struct TextExample8 {
5.   build() {
6.     Column() {
7.       Text("TextTextTextText")
8.         .copyOption(CopyOptions.InApp)
9.         .gesture(LongPressGesture({ repeat: false, duration: 400 })
10.           .onAction(() => {
11.           }))
12.         .margin({
13.           top: 100,
14.           bottom: 100,
15.           left: 100,
16.           right: 100
17.         })
18.     }
19.     .height('100%')
20.   }
21. }

### 设置enableVariableFontWeight为true后字重不能跟随设置调节

**问题现象**

Text组件调用[fontWeight](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#fontweight12)接口，[FontSettingOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-text-common#fontsettingoptions12%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)类型的入参options设置enableVariableFontWeight值为true之后，在系统设置的“字体大小和界面缩放”页面中调节字体粗细，Text组件的字重不跟随变化。

**解决措施**

1. 如果需要Text组件字重跟随系统设置变化，需要在[configuration标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-configuration-file#configuration%E6%A0%87%E7%AD%BE)设置followSystem。
    
2. 字体配置项options控制是否启用可变字重调节。
    

- 当options的参数enableVariableFontWeight取值true时，启用可变字重调节。weight取值为[100, 900]范围内任意整数时，字重取值为weight。此时如果在设置中调节字体粗细，字重始终是开发者设置的数值weight，字体粗细不会变化。
    
- 当options的参数enableVariableFontWeight取值false时，禁用可变字重调节。weight取值为[100, 900]范围内的整百数值时，字重取值为weight。weight是非整百数值时，字重取默认值400。此时更改设置中的字体粗细，字重会随设置变化。此时如果在设置中调节字体粗细，字重会随设置变化。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-select-component-faq "按钮与选择组件常见问题")
# 窗口开发概述

更新时间: 2025-12-16 16:38

## 窗口模块的定义

窗口模块用于在同一块物理屏幕上，提供多个应用界面显示、交互的机制。

- 对应用开发者而言，窗口模块提供了界面显示和交互能力。
    
- 对终端用户而言，窗口模块提供了控制应用界面的方式。
    
- 对整个操作系统而言，窗口模块提供了不同应用界面的组织管理逻辑。
    

## 窗口模块的用途

在HarmonyOS中，窗口模块主要负责以下职责：

- **提供应用和系统界面的窗口对象。** 应用开发者通过窗口加载UI界面，实现界面显示功能。
    
- **组织不同窗口的显示关系，即维护不同窗口间的叠加层次和位置属性。** 应用和系统的窗口具有多种类型，不同类型的窗口具有不同的默认位置和叠加层次（Z轴高度）。同时，用户操作也可以在一定范围内对窗口的位置和叠加层次进行调整。
    
- **提供窗口装饰。窗口装饰指窗口标题栏和窗口边框。** 窗口标题栏通常包括窗口最大化、最小化及关闭按钮等界面元素，具有默认的点击行为，方便用户进行操作；窗口边框则方便用户对窗口进行拖拽缩放等行为。窗口装饰是系统的默认行为，开发者可选择启用/禁用，无需关注UI代码层面的实现。
    
- **提供窗口动效。** 在窗口显示、隐藏及窗口间切换时，窗口模块通常会添加动画效果，以使各个交互过程更加连贯流畅。在HarmonyOS中，应用窗口的动效为默认行为，不需要开发者进行设置或者修改。
    
- **指导输入事件分发。** 即根据当前窗口的状态或焦点，进行事件的分发。触摸和鼠标事件根据窗口的位置和尺寸进行分发，而键盘事件会被分发至焦点窗口。应用开发者可以通过窗口模块提供的接口设置窗口是否可以触摸和是否可以获焦。
    

## 基本概念

### 窗口类型

HarmonyOS的窗口模块将窗口界面分为系统窗口、应用窗口两种基本类型。

- **系统窗口**：系统窗口指完成系统特定功能的窗口。如音量条、壁纸、通知栏、状态栏、导航栏等。
- **应用窗口**：应用窗口区别于系统窗口，指与应用显示相关的窗口。根据显示内容的不同，应用窗口又分为应用主窗口、应用子窗口两种类型。
    - 应用主窗口：应用主窗口用于显示应用界面，会在“任务管理界面”显示。
    - 应用子窗口：应用子窗口用于显示应用的弹窗、悬浮窗等辅助窗口，不会在“任务管理界面”显示。应用子窗口的生命周期跟随应用主窗口。

### 应用窗口模式

应用窗口模式指应用主窗口启动时的显示方式。HarmonyOS目前支持全屏、分屏、自由窗口三种应用窗口模式。这种对多种应用窗口模式的支持能力，也称为操作系统的“多窗口能力”。

- **全屏**：应用主窗口启动时铺满整个屏幕。
- **分屏**：应用主窗口启动时占据屏幕的某个部分，当前支持二分屏。两个分屏窗口之间具有分界线，可通过拖拽分界线调整两个部分的窗口尺寸。
- **自由窗口**：自由窗口的大小和位置可自由改变。同一个屏幕上可同时显示多个自由窗口，这些自由窗口按照打开或者获取焦点的顺序在Z轴排布。当自由窗口被点击或触摸时，将导致其Z轴高度提升，并获取焦点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163826.10513793659738543538323512987448:50001231000000:2800:522E13584F8989E8ED8B604EBD15BE200C40282372F0B7F4A463C9CE30B9C3D3.png)

针对窗口模式的适配开发指导，具体可参考[窗口模式最佳实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-device-window-mode)。

## 实现原理

当前窗口的实现和开发与应用开发模型相关联，不同模型下的接口功能略有区别。当前应用开发模型分为FA模型和Stage模型。

两个模型的整体架构和设计思想，详见[应用模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-models)。

针对窗口开发，推荐使用Stage模型进行相关开发。

## 主窗口的生命周期

### 生命周期概述

在Stage模型下，一个UIAbility对应一个WindowStage，一个WindowStage对应一个应用主窗，UIAbility、WindowStage和应用主窗三者之间的关系如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.04132941078758715389357708364208:50001231000000:2800:295EBE5432140330896DD740BC8BEB22BBA3299398D1B72C887E7E55F846ECBC.png)

每个UIAbility实例都会与一个WindowStage类实例绑定，该类起到了应用进程内窗口管理器的作用。它包含一个主窗口，也就是说UIAbility实例通过WindowStage持有了一个主窗口，该主窗口为ArkUI提供了绘制区域，可以加载不同的ArkUI页面。

在Stage模型下，由UIAbility通过WindowStage管理主窗口并维护其生命周期，可以通过[onWindowStageCreate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-uiability#onwindowstagecreate)和[onWindowStageDestroy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-uiability#onwindowstagedestroy)接收主窗口创建和销毁的通知。详见：[UIAbility生命周期](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-lifecycle)。

### 生命周期状态

窗口在进入前台、前后台切换及退后台时，会触发窗口相应的生命周期状态变化。

Stage模型下主窗口的生命周期状态包括切到前台（SHOWN）、可交互状态（RESUMED）、不可交互状态（PAUSED）和切到后台（HIDDEN）。

- **SHOWN**：窗口进入到前台。当应用从后台切换至前台时，会触发SHOWN事件。
    
- **RESUMED**：窗口进入可交互状态。窗口到前台后会进入该状态，另外窗口恢复也会触发RESUMED事件。
    
- **PAUSED**：窗口进入不可交互状态。窗口在前台可见但是不可交互时，触发PAUSED事件。窗口会保持这种状态，直到重新恢复或退后台。如果窗口恢复，则会触发RESUMED事件，进入可交互状态。
    
- **HIDDEN**：窗口进入到后台。当应用从前台切换至后台时，会触发HIDDEN事件。
    

说明

RESUMED和PAUSED状态分别在窗口切换至前台和切换至后台时触发。但是在一些场景下，RESUMED和PAUSED状态触发会有差异。

- 在一些系统管控场景下会导致RESUMED和PAUSED事件差异，例如应用管控场景，应用窗口在切换至前台进入到认证界面时，触发PAUSED事件，认证通过后，触发RESUMED事件。

|**生命周期状态**|**触发场景举例**|
|:--|:--|
|SHOWN|例如：应用全屏启动、悬浮窗被拉起等。|
|RESUMED|例如：应用全屏启动、悬浮窗被拉起或应用上滑悬停后回到应用等。|
|PAUSED|例如：应用退后台回到桌面、应用全屏状态上滑跟手进入多任务或全屏状态下被系统管控等。|
|HIDDEN|例如：应用全屏状态上滑退后台回到桌面以及其他退后台或销毁等。|

应用主窗口生命周期事件流转关系如下图：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.99419053206282022216355800375231:50001231000000:2800:20ECDC1A6FF3B4B7707AAE396C8CE31C9C96E314193F330A545D6A49B99F0100.png)

**特殊场景**：存在应用被系统管控的场景，会导致应用在启动过程中或RESUMED状态下，进入PAUSED状态，并触发回调通知。

### 监听生命周期状态变化

如果需要感知应用主窗口生命周期变化，开发者可以使用下述注册监听接口来监听应用主窗口的生命周期变化。

- API version 20之前，通过调用[on('windowStageEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#onwindowstageevent9)注册WindowStage生命周期变化的监听，通过调用[off('windowStageEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#offwindowstageevent9)注销WindowStage生命周期变化的监听。本接口无法保证生命周期状态切换间的顺序，对于状态间的顺序有要求的情况下不建议使用。
- API version 20开始，通过调用[on('windowStageLifecycleEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#onwindowstagelifecycleevent20)注册WindowStage生命周期变化的监听，通过调用接口[off('windowStageLifecycleEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#offwindowstagelifecycleevent20)注销WindowStage生命周期变化的监听。本接口不提供WindowStage的获焦失焦状态监听，对于WindowStage获焦失焦状态有监听需求的情况下，推荐使用[on('windowEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#onwindowevent10)， 对生命周期状态间的顺序有要求的情况下建议使用本接口。

### 不同设备生命周期的差异化行为

在Stage模型下，应用主窗口从前台进入后台状态也会驱动UIAbility的生命周期。在该模型下，需要额外关注这个机制在不同类型产品的差异化行为。

- **Phone类型设备上**：窗口从前台进入后台状态，会驱动UIAbility到后台状态。
    
- **Tablet类型设备上：**
    
    - 针对不支持在2in1设备上运行的应用，或可同时支持在phone和2in1上运行的应用，窗口从前台进入后台状态，会驱动UIAbility为后台状态。
        
    - 针对不支持在phone设备上运行且支持在2in1设备上运行的应用，窗口从前台进入后台状态，不会驱动UIAbility为后台状态。
        
- **2in1类型设备上：**
    
    - 针对支持在phone设备运行的应用，窗口从前台进入后台状态，会驱动UIAbility为后台状态。
        
    - 针对不支持在phone设备运行的应用，窗口从前台进入后台状态，不会驱动UIAbility为后台状态。
        

## 约束与限制

- 在FA模型下，不支持系统窗口的相关开发。
    
- 窗口存在大小限制[WindowLimits](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-i#windowlimits11)，该限制由产品配置决定。未调用[setWindowLimits](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlimits11)配置过WindowLimits时，使用[getWindowLimits](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowlimits11)可获取系统限制，单位为px。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-manager "窗口管理")
# 管理应用窗口（Stage模型）

更新时间: 2025-12-16 16:38

## 基本概念

- 窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用的辅助窗口（子窗、全局悬浮窗等）和处于自由窗口下的应用主窗口无法使用沉浸式能力。
    
- 全局悬浮窗：全局悬浮窗是一种特殊的应用辅助窗口，具备在应用主窗口和对应Ability退至后台后仍然可以在前台显示的能力。全局悬浮窗可以用于应用退至后台后，使用小窗继续显示UI，例如音乐应用用于显示桌面歌词等。应用在创建全局悬浮窗前，需要申请对应的权限。
    

## 场景介绍

在Stage模型下，管理应用窗口的典型场景有：

- 设置应用主窗口属性及目标页面
    
- 设置应用子窗口属性及目标页面
    
- 体验窗口沉浸式能力
    
- 设置全局悬浮窗
    
- 监听窗口不可交互与可交互事件
    

以下分别介绍具体开发方式。

## 接口说明

上述场景涉及的常用接口如下表所示。更多API说明请参见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window)。

|实例名|接口名|描述|
|:--|:--|:--|
|WindowStage|getMainWindow(callback: AsyncCallback<Window>): void|获取WindowStage实例下的主窗口。<br><br>此接口仅可在Stage模型下使用。|
|WindowStage|loadContent(path: string, callback: AsyncCallback<void>): void|为当前WindowStage的主窗口加载具体页面。<br><br>其中path为要加载到窗口中的页面内容的路径，该路径需添加到工程的main_pages.json文件中。<br><br>此接口仅可在Stage模型下使用。|
|WindowStage|createSubWindow(name: string, callback: AsyncCallback<Window>): void|创建子窗口。<br><br>此接口仅可在Stage模型下使用。|
|WindowStage|on(eventType: 'windowStageEvent', callback: Callback<WindowStageEventType>): void|开启WindowStage生命周期变化的监听。<br><br>此接口仅可在Stage模型下使用。|
|window静态方法|createWindow(config: Configuration, callback: AsyncCallback<Window>): void|创建子窗口或者系统窗口。<br><br>-config：创建窗口时的参数。|
|Window|setUIContent(path: string, callback: AsyncCallback<void>): void|根据当前工程中某个页面的路径为窗口加载具体的页面内容。<br><br>其中path为要加载到窗口中的页面内容的路径，在Stage模型下该路径需添加到工程的main_pages.json文件中。|
|Window|setWindowBrightness(brightness: number, callback: AsyncCallback<void>): void|设置屏幕亮度值。|
|Window|setWindowTouchable(isTouchable: boolean, callback: AsyncCallback<void>): void|设置窗口是否为可触状态。true表示可触；false表示不可触。|
|Window|moveWindowTo(x: number, y: number, callback: AsyncCallback<void>): void|移动当前窗口位置。|
|Window|resize(width: number, height: number, callback: AsyncCallback<void>): void|改变当前窗口大小。|
|Window|setWindowLayoutFullScreen(isLayoutFullScreen: boolean): Promise<void>|设置主窗口或子窗口的布局是否为沉浸式布局。true表示沉浸式布局；false表示非沉浸式布局。|
|Window|setWindowSystemBarEnable(names: Array<'status'\|'navigation'>): Promise<void>|设置主窗口状态栏、底部导航（根据用户设置，可表现为导航条或三键导航栏）的可见模式，状态栏和底部导航通过status控制、navigation参数无效果。<br><br>例如，该参数设置为['status', 'navigation']，则全部显示；设置为[]，则不显示。|
|Window|setWindowSystemBarProperties(systemBarProperties: SystemBarProperties): Promise<void>|设置窗口内导航栏、状态栏属性。<br><br>systemBarProperties：导航栏、状态栏的属性集合。|
|Window|showWindow(callback: AsyncCallback<void>): void|显示当前窗口。|
|Window|on(type: 'touchOutside', callback: Callback<void>): void|开启本窗口区域外的点击事件的监听。|
|Window|destroyWindow(callback: AsyncCallback<void>): void|销毁当前窗口。|

## 设置应用主窗口

在Stage模型下，应用主窗口由UIAbility创建并维护生命周期。在UIAbility的onWindowStageCreate回调中，通过WindowStage获取应用主窗口，即可对其进行属性设置等操作。还可以在应用配置文件中设置应用主窗口的属性，如最大窗口宽度maxWindowWidth等，详见[module.json5配置文件中的abilities标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)。

### 开发步骤

1. 获取应用主窗口。
    
    通过getMainWindow接口获取应用主窗口。
    
2. 设置主窗口属性。
    
    可设置主窗口的背景色、亮度值、是否可触等多个属性，开发者可根据需要选择对应的接口。本示例以设置“是否可触”属性为例。
    
3. 为主窗口加载对应的目标页面。
    
    通过loadContent接口加载主窗口的目标页面。
    

4. import { UIAbility } from '@kit.AbilityKit';
5. import { window } from '@kit.ArkUI';
6. import { BusinessError } from '@kit.BasicServicesKit';

7. export default class EntryAbility extends UIAbility {
8.   onWindowStageCreate(windowStage: window.WindowStage) {
9.     // 1.获取应用主窗口。
10.     let windowClass: window.Window | null = null;
11.     windowStage.getMainWindow((err: BusinessError, data) => {
12.       let errCode: number = err.code;
13.       if (errCode) {
14.         console.error(`Failed to obtain the main window. Code:${err.code}, message:${err.message}`);
15.         return;
16.       }
17.       windowClass = data;
18.       console.info(`Succeeded in obtaining the main window. Result:${data}`);
19.       // 2.设置主窗口属性。以设置"是否可触"属性为例。
20.       let isTouchable: boolean = true;
21.       windowClass.setWindowTouchable(isTouchable, (err: BusinessError) => {
22.         let errCode: number = err.code;
23.         if (errCode) {
24.           console.error('Failed to set the window to be touchable. Cause:' + JSON.stringify(err));
25.           return;
26.         }
27.         console.info('Succeeded in setting the window to be touchable.');
28.       })
29.     })
30.     // 3.为主窗口加载对应的目标页面。
31.     windowStage.loadContent("pages/page2", (err: BusinessError) => {
32.       let errCode: number = err.code;
33.       if (errCode) {
34.         console.error('Failed to load the content. Cause:' + JSON.stringify(err));
35.         return;
36.       }
37.       console.info('Succeeded in loading the content.');
38.     });
39.   }
40. };

## 设置应用子窗口

开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。

说明

以下几种场景不建议使用子窗口，建议优先考虑使用控件[overlay](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-overlay)能力实现。

- 移动设备（手机、在非自由模式下的平板设备）场景下子窗不能超出处于悬浮窗模式、分屏模式的应用主窗口范围，与控件一致。
- 分屏窗口与自由窗口模式下，主窗口位置大小发生改变时控件实时跟随变化能力优于子窗。
- 部分设备平台下根据实际的系统配置限制，子窗只有系统默认的动效和圆角阴影，应用无法设置，自由度低。

### 开发步骤

1. 创建应用子窗口。
    
    通过createSubWindow接口创建应用子窗口。
    
    子窗口创建后默认是[沉浸式布局](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E6%B2%89%E6%B5%B8%E5%BC%8F%E5%B8%83%E5%B1%80)。
    
2. 设置子窗口属性。
    
    子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。
    
    在调用showWindow之前，建议设置子窗口的大小和位置。
    
    如果没有设置子窗口的大小，调用showWindow后:
    
    - [自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态下，默认子窗口大小为当前物理屏幕的大小。其中，[MateBook Fold折叠电脑](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-mate-book-fold)半折叠态下，默认子窗口大小为竖向展开态的物理屏幕大小。
    - 非自由窗口状态下，默认子窗口大小为主窗口大小。
3. 加载显示子窗口的具体内容。
    
    通过setUIContent和showWindow接口加载显示子窗口的具体内容。
    
4. 销毁子窗口。
    
    当不再需要某些子窗口时，可根据具体实现逻辑，使用destroyWindow接口销毁子窗口。
    

直接在onWindowStageCreate里面创建子窗口的整体示例代码如下：

1. import { UIAbility } from '@kit.AbilityKit';
2. import { window } from '@kit.ArkUI';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. let windowStage_: window.WindowStage | null = null;
5. let sub_windowClass: window.Window | null = null;

6. export default class EntryAbility extends UIAbility {
7.   showSubWindow() {
8.     // 1.创建应用子窗口。
9.     if (windowStage_ == null) {
10.       console.error('Failed to create the subwindow. Cause: windowStage_ is null');
11.     }
12.     else {
13.       windowStage_.createSubWindow("mySubWindow", (err: BusinessError, data) => {
14.         let errCode: number = err.code;
15.         if (errCode) {
16.           console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));
17.           return;
18.         }
19.         sub_windowClass = data;
20.         if (!sub_windowClass) {
21.           console.error('sub_windowClass is null');
22.           return;
23.         }
24.         console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));
25.         // 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。
26.         sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
27.           let errCode: number = err.code;
28.           if (errCode) {
29.             console.error('Failed to move the window. Cause:' + JSON.stringify(err));
30.             return;
31.           }
32.           console.info('Succeeded in moving the window.');
33.         });
34.         sub_windowClass.resize(500, 500, (err: BusinessError) => {
35.           let errCode: number = err.code;
36.           if (errCode) {
37.             console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
38.             return;
39.           }
40.           console.info('Succeeded in changing the window size.');
41.         });
42.         // 3.为子窗口加载对应的目标页面。
43.         sub_windowClass.setUIContent("pages/page3", (err: BusinessError) => {
44.           let errCode: number = err.code;
45.           if (errCode) {
46.             console.error('Failed to load the content. Cause:' + JSON.stringify(err));
47.             return;
48.           }
49.           console.info('Succeeded in loading the content.');
50.           if (!sub_windowClass) {
51.             console.error('sub_windowClass is null');
52.             return;
53.           }
54.           // 3.显示子窗口。
55.           sub_windowClass.showWindow((err: BusinessError) => {
56.             let errCode: number = err.code;
57.             if (errCode) {
58.               console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
59.               return;
60.             }
61.             console.info('Succeeded in showing the window.');
62.           });
63.         });
64.       })
65.     }
66.   }

67.   destroySubWindow() {
68.     if (!sub_windowClass) {
69.       console.error('sub_windowClass is null');
70.       return;
71.     }
72.     // 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。
73.     sub_windowClass.destroyWindow((err: BusinessError) => {
74.       let errCode: number = err.code;
75.       if (errCode) {
76.         console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
77.         return;
78.       }
79.       console.info('Succeeded in destroying the window.');
80.     });
81.   }

82.   onWindowStageCreate(windowStage: window.WindowStage) {
83.     windowStage_ = windowStage;
84.     // 开发者可以在适当的时机，如主窗口上按钮点击事件等，创建子窗口。并不一定需要在onWindowStageCreate调用，这里仅作展示
85.     this.showSubWindow();
86.   }

87.   onWindowStageDestroy() {
88.     // 开发者可以在适当的时机，如子窗口上点击关闭按钮等，销毁子窗口。并不一定需要在onWindowStageDestroy调用，这里仅作展示
89.     this.destroySubWindow();
90.   }
91. };

另外，也可以在某个page页面通过点击按钮创建子窗口，整体示例代码如下：

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';
4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage) {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       if (err.code) {
8.         console.error('Failed to load the content. Cause:' + JSON.stringify(err));
9.         return;
10.       }
11.       console.info('Succeeded in loading the content.');
12.     })

13.     // 给Index页面传递windowStage
14.     AppStorage.setOrCreate('windowStage', windowStage);
15.   }
16. }

17. // Index.ets
18. import { window } from '@kit.ArkUI';
19. import { BusinessError } from '@kit.BasicServicesKit';

20. let windowStage_: window.WindowStage | undefined = undefined;
21. let sub_windowClass: window.Window | undefined = undefined;
22. @Entry
23. @Component
24. struct Index {
25.   @State message: string = 'Hello World';
26.   private createSubWindow(){
27.     // 获取windowStage
28.     windowStage_ = AppStorage.get('windowStage');
29.     // 1.创建应用子窗口。
30.     if (windowStage_ == null) {
31.       console.error('Failed to create the subwindow. Cause: windowStage_ is null');
32.     }
33.     else {
34.       windowStage_.createSubWindow("mySubWindow", (err: BusinessError, data) => {
35.         let errCode: number = err.code;
36.         if (errCode) {
37.           console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));
38.           return;
39.         }
40.         sub_windowClass = data;
41.         if (!sub_windowClass) {
42.           console.error('sub_windowClass is null');
43.           return;
44.         }
45.         console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));
46.         // 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。
47.         sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
48.           let errCode: number = err.code;
49.           if (errCode) {
50.             console.error('Failed to move the window. Cause:' + JSON.stringify(err));
51.             return;
52.           }
53.           console.info('Succeeded in moving the window.');
54.         });
55.         sub_windowClass.resize(500, 500, (err: BusinessError) => {
56.           let errCode: number = err.code;
57.           if (errCode) {
58.             console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
59.             return;
60.           }
61.           console.info('Succeeded in changing the window size.');
62.         });
63.         // 3.为子窗口加载对应的目标页面。
64.         sub_windowClass.setUIContent("pages/subWindow", (err: BusinessError) => {
65.           let errCode: number = err.code;
66.           if (errCode) {
67.             console.error('Failed to load the content. Cause:' + JSON.stringify(err));
68.             return;
69.           }
70.           console.info('Succeeded in loading the content.');
71.           if (!sub_windowClass) {
72.             console.error('sub_windowClass is null');
73.             return;
74.           }
75.           // 3.显示子窗口。
76.           sub_windowClass.showWindow((err: BusinessError) => {
77.             let errCode: number = err.code;
78.             if (errCode) {
79.               console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
80.               return;
81.             }
82.             console.info('Succeeded in showing the window.');
83.           });
84.         });
85.       })
86.     }
87.   }
88.   private destroySubWindow(){
89.     if (!sub_windowClass) {
90.       console.error('sub_windowClass is null');
91.       return;
92.     }
93.     // 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。
94.     sub_windowClass.destroyWindow((err: BusinessError) => {
95.       let errCode: number = err.code;
96.       if (errCode) {
97.         console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
98.         return;
99.       }
100.       console.info('Succeeded in destroying the window.');
101.     });
102.   }
103.   build() {
104.     Row() {
105.       Column() {
106.         Text(this.message)
107.           .fontSize(50)
108.           .fontWeight(FontWeight.Bold)
109.         Button(){
110.           Text('CreateSubWindow')
111.           .fontSize(24)
112.           .fontWeight(FontWeight.Normal)
113.         }.width(220).height(68)
114.         .margin({left:10, top:60})
115.         .onClick(() => {
116.           this.createSubWindow()
117.         })
118.         Button(){
119.           Text('destroySubWindow')
120.           .fontSize(24)
121.           .fontWeight(FontWeight.Normal)
122.         }.width(220).height(68)
123.         .margin({left:10, top:60})
124.         .onClick(() => {
125.           this.destroySubWindow()
126.         })
127.       }
128.       .width('100%')
129.     }
130.     .height('100%')
131.   }
132. }

133. // subWindow.ets
134. @Entry
135. @Component
136. struct SubWindow {
137.   @State message: string = 'Hello subWindow';
138.   build() {
139.     Row() {
140.       Column() {
141.         Text(this.message)
142.           .fontSize(20)
143.           .fontWeight(FontWeight.Bold)
144.       }
145.       .width('100%')
146.     }
147.     .height('100%')
148.     .backgroundColor('#0D9FFB')
149.   }
150. }

## 体验窗口沉浸式能力

在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。从API version 10开始，沉浸式窗口默认配置为全屏大小并由组件模块控制布局，状态栏、导航栏背景颜色为透明，文字颜色为黑色；应用窗口调用setWindowLayoutFullScreen接口，设置为true表示由组件模块控制忽略状态栏、导航栏的沉浸式全屏布局，设置为false表示由组件模块控制避让状态栏、导航栏的非沉浸式全屏布局。

说明

当前沉浸式界面开发仅支持窗口级别的配置，暂不支持Page级别的配置。若有Page级别切换的需要，可以在页面生命周期开始，例如onPageShow中设置沉浸模式，然后在页面退出，例如onPageHide中恢复默认设置来实现。

### 开发步骤

1. 获取应用主窗口。
    
    通过getMainWindow接口获取应用主窗口。
    
2. 实现沉浸式效果。有以下两种方式：
    
    - 方式一：应用主窗口为全屏窗口时，调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。
        
    - 方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。
        
3. 加载显示沉浸式窗口的具体内容。
    
    通过loadContent接口加载沉浸式窗口的具体内容。
    

4. import { UIAbility } from '@kit.AbilityKit';
5. import { window } from '@kit.ArkUI';
6. import { BusinessError } from '@kit.BasicServicesKit';

7. export default class EntryAbility extends UIAbility {
8.   onWindowStageCreate(windowStage: window.WindowStage) {
9.     // 1.获取应用主窗口。
10.     let windowClass: window.Window | null = null;
11.     windowStage.getMainWindow((err: BusinessError, data) => {
12.       let errCode: number = err.code;
13.       if (errCode) {
14.         console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
15.         return;
16.       }
17.       windowClass = data;
18.       console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));

19.       // 2.实现沉浸式效果。方式一：设置导航栏、状态栏不显示。
20.       let names: Array<'status' | 'navigation'> = [];
21.       windowClass.setWindowSystemBarEnable(names)
22.         .then(() => {
23.           console.info('Succeeded in setting the system bar to be visible.');
24.         })
25.         .catch((err: BusinessError) => {
26.           console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));
27.         });
28.       // 2.实现沉浸式效果。方式二：设置窗口为全屏布局，配合设置导航栏、状态栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。
29.       let isLayoutFullScreen = true;
30.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen)
31.         .then(() => {
32.           console.info('Succeeded in setting the window layout to full-screen mode.');
33.         })
34.         .catch((err: BusinessError) => {
35.           console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
36.         });
37.       let sysBarProps: window.SystemBarProperties = {
38.         statusBarColor: '#ff00ff',
39.         navigationBarColor: '#00ff00',
40.         // 以下两个属性从API Version 8开始支持
41.         statusBarContentColor: '#ffffff',
42.         navigationBarContentColor: '#ffffff'
43.       };
44.       windowClass.setWindowSystemBarProperties(sysBarProps)
45.         .then(() => {
46.           console.info('Succeeded in setting the system bar properties.');
47.         })
48.         .catch((err: BusinessError) => {
49.           console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));
50.         });
51.     })
52.     // 3.为沉浸式窗口加载对应的目标页面。
53.     windowStage.loadContent("pages/page2", (err: BusinessError) => {
54.       let errCode: number = err.code;
55.       if (errCode) {
56.         console.error('Failed to load the content. Cause:' + JSON.stringify(err));
57.         return;
58.       }
59.       console.info('Succeeded in loading the content.');
60.     });
61.   }
62. };

## 设置全局悬浮窗（受限开放）

全局悬浮窗可以在已有的任务基础上，创建一个始终在前台显示的窗口。即使创建全局悬浮窗的任务退至后台，全局悬浮窗仍然可以在前台显示。通常全局悬浮窗位于所有应用窗口之上，开发者可以创建全局悬浮窗，并对全局悬浮窗进行属性设置等操作。

### 开发步骤

**前提条件：** 创建WindowType.TYPE_FLOAT即全局悬浮窗类型的窗口，需要申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，该权限为受控开放权限，仅符合[指定场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/restricted-permissions#ohospermissionsystem_float_window)的在2in1设备上的应用可申请该权限。申请方式请参考：[申请使用受限权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions-in-acl)。

在其他设备或场景下，请使用画中画功能，使用方式参考：[画中画开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-pipwindow)。

注意

如果应用未在应用市场（AGC）申请相应的权限证书，却试图在配置文件中声明此类权限，将会导致应用安装失败。

1. 创建全局悬浮窗。
    
    通过window.createWindow接口创建全局悬浮窗类型的窗口。
    
2. 对全局悬浮窗进行属性设置等操作。
    
    全局悬浮窗窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置全局悬浮窗背景色、亮度等属性。
    
3. 加载显示全局悬浮窗的具体内容。
    
    通过setUIContent和showWindow接口加载显示全局悬浮窗的具体内容。
    
4. 销毁全局悬浮窗。
    
    当不再需要全局悬浮窗时，可根据具体实现逻辑，使用destroyWindow接口销毁全局悬浮窗。
    

1. import { UIAbility } from '@kit.AbilityKit';
2. import { window } from '@kit.ArkUI';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage) {
6.     // 1.创建全局悬浮窗。
7.     let windowClass: window.Window | null = null;
8.     let config: window.Configuration = {
9.       name: "floatWindow", windowType: window.WindowType.TYPE_FLOAT, ctx: this.context
10.     };
11.     window.createWindow(config, (err: BusinessError, data) => {
12.       let errCode: number = err.code;
13.       if (errCode) {
14.         console.error('Failed to create the floatWindow. Cause: ' + JSON.stringify(err));
15.         return;
16.       }
17.       console.info('Succeeded in creating the floatWindow. Data: ' + JSON.stringify(data));
18.       windowClass = data;
19.       // 2.全局悬浮窗窗口创建成功后，设置全局悬浮窗的位置、大小及相关属性等。
20.       windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
21.         let errCode: number = err.code;
22.         if (errCode) {
23.           console.error('Failed to move the window. Cause:' + JSON.stringify(err));
24.           return;
25.         }
26.         console.info('Succeeded in moving the window.');
27.       });
28.       windowClass.resize(500, 500, (err: BusinessError) => {
29.         let errCode: number = err.code;
30.         if (errCode) {
31.           console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
32.           return;
33.         }
34.         console.info('Succeeded in changing the window size.');
35.       });
36.       // 3.为全局悬浮窗加载对应的目标页面。
37.       windowClass.setUIContent("pages/page4", (err: BusinessError) => {
38.         let errCode: number = err.code;
39.         if (errCode) {
40.           console.error('Failed to load the content. Cause:' + JSON.stringify(err));
41.           return;
42.         }
43.         console.info('Succeeded in loading the content.');
44.         // 3.显示全局悬浮窗。
45.         (windowClass as window.Window).showWindow((err: BusinessError) => {
46.           let errCode: number = err.code;
47.           if (errCode) {
48.             console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
49.             return;
50.           }
51.           console.info('Succeeded in showing the window.');
52.         });
53.       });
54.       // 4.销毁全局悬浮窗。当不再需要全局悬浮窗时，可根据具体实现逻辑，使用destroy对其进行销毁。
55.       windowClass.destroyWindow((err: BusinessError) => {
56.         let errCode: number = err.code;
57.         if (errCode) {
58.           console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
59.           return;
60.         }
61.         console.info('Succeeded in destroying the window.');
62.       });
63.     });
64.   }
65. };

## 监听窗口不可交互与可交互事件

应用在前台显示过程中可能会进入某些不可交互的场景，比较典型的是进入多任务界面。此时，对于一些应用可能需要选择暂停某个与用户正在交互的业务，如视频类应用暂停正在播放的视频或者相机暂停预览流等。而当该应用从多任务又切回前台时，又变成了可交互的状态，此时需要恢复被暂停中断的业务，如恢复视频播放或相机预览流等。

### 开发步骤

在创建WindowStage对象后可通过监听'windowStageEvent'事件类型，监听到窗口进入前台、后台、前台可交互、前台不可交互等事件，应用可根据这些上报的事件状态进行相应的业务处理。

1. import { UIAbility } from '@kit.AbilityKit';
2. import { window } from '@kit.ArkUI';

3. export default class EntryAbility extends UIAbility {
4.   onWindowStageCreate(windowStage: window.WindowStage) {
5.     try {
6.       windowStage.on('windowStageEvent', (data) => {
7.         console.info('Succeeded in enabling the listener for window stage event changes. Data: ' +
8.           JSON.stringify(data));

9.         // 根据事件状态类型选择进行相应的处理
10.         if (data === window.WindowStageEventType.SHOWN) {
11.           console.info('current window stage event is SHOWN');
12.           // 应用进入前台，默认为可交互状态
13.           // ...
14.         } else if (data === window.WindowStageEventType.HIDDEN) {
15.           console.info('current window stage event is HIDDEN');
16.           // 应用进入后台，默认为不可交互状态
17.           // ...
18.         } else if (data === window.WindowStageEventType.PAUSED) {
19.           console.info('current window stage event is PAUSED');
20.           // 前台应用进入多任务，转为不可交互状态
21.           // ...
22.         } else if (data === window.WindowStageEventType.RESUMED) {
23.           console.info('current window stage event is RESUMED');
24.           // 进入多任务后又继续返回前台时，恢复可交互状态
25.           // ...
26.         }

27.         // ...
28.       });
29.     } catch (exception) {
30.       console.error('Failed to enable the listener for window stage event changes. Cause:' +
31.         JSON.stringify(exception));
32.     }
33.   }
34. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-overview "窗口开发概述")
# 管理应用窗口（FA模型）

更新时间: 2025-12-16 16:38

## 基本概念

窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。

沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用子窗口（弹窗、悬浮窗口等辅助窗口）和处于自由窗口下的应用主窗口无法使用沉浸式能力。

说明

当前沉浸式界面开发仅支持窗口级别的配置，暂不支持Page级别的配置。若有Page级别切换的需要，可以在页面生命周期开始，例如onPageShow中设置沉浸模式，然后在页面退出，例如onPageHide中恢复默认设置来实现。

## 场景介绍

在FA模型下，管理应用窗口的典型场景有：

- 设置应用子窗口属性及目标页面
    
- 体验窗口沉浸式能力
    

以下分别介绍具体开发方式。

## 接口说明

上述场景涉及的常用接口如下表所示。更多API说明请参见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window)。

|实例名|接口名|描述|
|:--|:--|:--|
|window静态方法|createWindow(config: Configuration, callback: AsyncCallback<Window>): void|创建子窗口。<br><br>-config：创建窗口时的参数。|
|window静态方法|findWindow(name: string): Window|查找name所对应的窗口。|
|Window|setUIContent(path: string, callback: AsyncCallback<void>): void|根据当前工程中某个页面的路径为窗口加载具体的页面内容。<br><br>其中path为要加载到窗口中的页面内容的路径，在FA模型下该路径需添加到工程的config.json文件中。|
|Window|moveWindowTo(x: number, y: number, callback: AsyncCallback<void>): void|移动当前窗口位置。|
|Window|setWindowBrightness(brightness: number, callback: AsyncCallback<void>): void|设置屏幕亮度值。|
|Window|resize(width: number, height: number, callback: AsyncCallback<void>): void|改变当前窗口大小。|
|Window|setWindowLayoutFullScreen(isLayoutFullScreen: boolean): Promise<void>|设置主窗口或子窗口的布局是否为沉浸式布局。true表示沉浸式布局；false表示非沉浸式布局。|
|Window|setWindowSystemBarEnable(names: Array<'status'\|'navigation'>): Promise<void>|设置主窗口状态栏、底部导航（根据用户设置，可表现为导航条或三键导航栏）的可见模式，状态栏和底部导航通过status控制、navigation参数无效果。<br><br>例如，该参数设置为['status', 'navigation']，则全部显示；设置为[]，则不显示。|
|Window|setWindowSystemBarProperties(systemBarProperties: SystemBarProperties): Promise<void>|设置窗口内导航栏、状态栏属性。<br><br>systemBarProperties：导航栏、状态栏的属性集合。|
|Window|showWindow(callback: AsyncCallback<void>): void|显示当前窗口。|
|Window|on(type: 'touchOutside', callback: Callback<void>): void|开启本窗口区域外的点击事件的监听。|
|Window|destroyWindow(callback: AsyncCallback<void>): void|销毁当前窗口。|

## 设置应用子窗口

开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。

说明

以下几种场景不建议使用子窗口，建议优先考虑使用控件[overlay](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-overlay)能力实现。

- 移动设备（手机、在非自由模式下的平板设备）场景下子窗不能超出处于悬浮窗、分屏状态的主窗口范围，与控件一致。
- 分屏窗口与自由窗口模式下，主窗口位置大小发生改变时控件实时跟随变化能力优于子窗。
- 部分设备平台下根据实际的系统配置限制，子窗只有系统默认的动效和圆角阴影，应用无法设置，自由度低。

### 开发步骤

1. 创建/获取子窗口对象。
    
    - 可以通过window.createWindow接口创建子窗口。
        
        非[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态下，子窗口创建后默认是[沉浸式布局](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E6%B2%89%E6%B5%B8%E5%BC%8F%E5%B8%83%E5%B1%80)。
        
    
    自由窗口状态下，子窗口参数[decorEnabled](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-i#configuration9)为false时，子窗口创建后为沉浸式布局；子窗口参数decorEnabled为true，子窗口创建后为非沉浸式布局。
    
    - 也可以通过window.findWindow接口来查找已经创建的窗口从而得到子窗口。
    
    1. import { window } from '@kit.ArkUI';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
    3. let windowClass: window.Window | null = null;
    4. // 方式一：创建子窗口。
    5. let config: window.Configuration = { name: "subWindow", windowType: window.WindowType.TYPE_APP };
    6. window.createWindow(config, (err: BusinessError, data) => {
    7.   let errCode: number = err.code;
    8.   if (errCode) {
    9.     console.error(`Failed to create the subWindow. Code:${err.code}, message:${err.message}`);
    10.     return;
    11.   }
    12.   console.info('Succeeded in creating subWindow. Data: ' + JSON.stringify(data));
    13.   windowClass = data;
    14.   if (!windowClass) {
    15.    console.error('windowClass is null');
    16.    return;
    17.   }
    18. });
    19. // 方式二：查找得到子窗口。
    20. try {
    21.   windowClass = window.findWindow('subWindow');
    22. } catch (exception) {
    23.   console.error('Failed to find the Window. Cause: ' + JSON.stringify(exception));
    24. }
    
2. 设置子窗口属性。
    
    子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。
    
    1. // 移动子窗口位置。
    2. windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
    3.   let errCode: number = err.code;
    4.   if (errCode) {
    5.     console.error('Failed to move the window. Cause:' + JSON.stringify(err));
    6.     return;
    7.   }
    8.   console.info('Succeeded in moving the window.');
    9. });
    10. // 改变子窗口大小。
    11. windowClass.resize(500, 500, (err: BusinessError) => {
    12.   let errCode: number = err.code;
    13.   if (errCode) {
    14.     console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
    15.     return;
    16.   }
    17.   console.info('Succeeded in changing the window size.');
    18. });
    
3. 加载显示子窗口的具体内容。
    
    使用setUIContent和showWindow接口加载显示子窗口的具体内容。
    
    1. // 为子窗口加载对应的目标页面。
    2. windowClass.setUIContent("pages/page2", (err: BusinessError) => {
    3.   let errCode: number = err.code;
    4.   if (errCode) {
    5.     console.error('Failed to load the content. Cause: ' + JSON.stringify(err));
    6.     return;
    7.   }
    8.   console.info('Succeeded in loading the content.');
    9.   if (!windowClass) {
    10.     console.error('windowClass is null');
    11.     return;
    12.   }
    13.   // 显示子窗口。
    14.   windowClass.showWindow((err: BusinessError) => {
    15.     let errCode: number = err.code;
    16.     if (errCode) {
    17.       console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
    18.       return;
    19.     }
    20.     console.info('Succeeded in showing the window.');
    21.   });
    22. });
    
4. 销毁子窗口。
    
    当不再需要某些子窗口时，可根据场景的具体实现逻辑，使用destroyWindow接口销毁子窗口。
    
    1. // 销毁子窗口。当不再需要某些子窗口时，可根据场景的具体实现逻辑，使用destroy接口销毁子窗口。
    2. windowClass.destroyWindow((err: BusinessError) => {
    3.   let errCode: number = err.code;
    4.   if (errCode) {
    5.     console.error('Failed to destroy the subwindow. Cause:' + JSON.stringify(err));
    6.     return;
    7.   }
    8.   console.info('Succeeded in destroying the subwindow.');
    9. });
    

## 体验窗口沉浸式能力

在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。从API version 10开始，沉浸式窗口默认配置为全屏大小并由组件模块控制布局，状态栏、导航栏背景颜色为透明，文字颜色为黑色；应用窗口调用setWindowLayoutFullScreen接口，设置为true表示由组件模块控制忽略状态栏、导航栏的沉浸式全屏布局，设置为false表示由组件模块控制避让状态栏、导航栏的非沉浸式全屏布局。

### 开发步骤

1. 获取主窗口对象。
    
    说明
    
    沉浸式能力需要在成功获取应用主窗口对象的前提下进行。
    
    确保应用内最后显示的窗口为主窗口，然后再使用window.getLastWindow接口来获取得到主窗口。
    
    1. import { window } from '@kit.ArkUI';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
    3. let mainWindowClass: window.Window | null = null;
    
    4. // 获取主窗口。
    5. class BaseContext {
    6.   stageMode: boolean = false;
    7. }
    
    8. let context: BaseContext = { stageMode: false };
    9. window.getLastWindow(context, (err: BusinessError, data) => {
    10.   let errCode: number = err.code;
    11.   if (errCode) {
    12.     console.error('Failed to get the mainWindow. Cause: ' + JSON.stringify(err));
    13.     return;
    14.   }
    15.   console.info('Succeeded in getting mainWindow. Data: ' + JSON.stringify(data));
    16.   mainWindowClass = data;
    17.   if (!mainWindowClass) {
    18.    console.error('mainWindowClass is null');
    19.    return;
    20.   }
    21. });
    
2. 实现沉浸式效果。有以下两种方式：
    
    - 方式一：应用主窗口为全屏窗口时，调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。
    - 方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。
    
    1. // 实现沉浸式效果。方式一：设置导航栏、状态栏不显示。
    2. let names: Array<'status' | 'navigation'> = [];
    3. mainWindowClass.setWindowSystemBarEnable(names)
    4.  .then(() => {
    5.    console.info('Succeeded in setting the system bar to be visible.');
    6.  })
    7.  .catch((err: BusinessError) => {
    8.    console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));
    9.  });
    10. // 实现沉浸式效果。
    11. // 方式二：设置窗口为全屏布局，配合设置状态栏、导航栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。
    12. let isLayoutFullScreen: boolean = true;
    13. mainWindowClass.setWindowLayoutFullScreen(isLayoutFullScreen)
    14.  .then(() => {
    15.    console.info('Succeeded in setting the window layout to full-screen mode.');
    16.  })
    17.  .catch((err: BusinessError) => {
    18.    console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
    19.  });
    20. let sysBarProps: window.SystemBarProperties = {
    21.   statusBarColor: '#ff00ff',
    22.   navigationBarColor: '#00ff00',
    23.   // 以下两个属性从API Version8开始支持。
    24.   statusBarContentColor: '#ffffff',
    25.   navigationBarContentColor: '#ffffff'
    26. };
    27. mainWindowClass.setWindowSystemBarProperties(sysBarProps)
    28.  .then(() => {
    29.    console.info('Succeeded in setting the system bar properties.');
    30.  })
    31.  .catch((err: BusinessError) => {
    32.    console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));
    33.  });
    
3. 加载显示沉浸式窗口的具体内容。
    
    使用setUIContent和showWindow接口加载显示沉浸式窗口的具体内容。
    
    1. // 为沉浸式窗口加载对应的目标页面。
    2. mainWindowClass.setUIContent("pages/page3", (err: BusinessError) => {
    3.   let errCode: number = err.code;
    4.   if (errCode) {
    5.     console.error('Failed to load the content. Cause: ' + JSON.stringify(err));
    6.     return;
    7.   }
    8.   console.info('Succeeded in loading the content.');
    9.   if (!mainWindowClass) {
    10.    console.error('mainWindowClass is null');
    11.    return;
    12.   }
    13.   // 显示沉浸式窗口。
    14.   mainWindowClass.showWindow((err: BusinessError) => {
    15.     let errCode: number = err.code;
    16.     if (errCode) {
    17.       console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
    18.       return;
    19.     }
    20.     console.info('Succeeded in showing the window.');
    21.   });
    22. });
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-window-stage "管理应用窗口（Stage模型）")
# 窗口元数据配置

更新时间: 2025-12-16 16:38

## metadata标签

该标签标识HAP的自定义元信息，标签值为数组类型，包含name、value、resource三个子标签。

**表1** metadata标签说明

|属性名称|含义|数据类型|是否可缺省|
|:--|:--|:--|:--|
|name|标识数据项的名称，取值为长度不超过255字节的字符串。|字符串|该标签可缺省，缺省值为空。|
|value|标识数据项的值，取值为长度不超过255字节的字符串。|字符串|该标签可缺省，缺省值为空。|
|resource|标识了用户自定义数据，取值为长度不超过255字节的字符串，内容为该数据的资源索引，例如配置成$profile:shortcuts_config，表示指向了/resources/base/profile/shortcuts_config.json配置文件。|字符串|该标签可缺省，缺省值为空。|

下面给出几种metadata标签的使用场景及示例，开发者也可以根据实际需求自定义设置。

1. 使用metadata标签配置主窗口的默认大小和位置（单位为vp）。其中name取值及对应含义如下：
    
    - name取值为ohos.ability.window.height表示主窗口的默认高度，value表示高度大小。
    - name取值为ohos.ability.window.width表示主窗口的默认宽度，value表示宽度大小。
    - name取值为ohos.ability.window.left表示主窗口默认左边的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、left和right，默认值为left；当偏移量为0时可以省略。
    - name取值为ohos.ability.window.top表示主窗口顶部的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、top和bottom，默认值为top。如果对齐方式和偏移量同时省略，则按照系统默认的层叠规格处理。
2. 使用metadata标签配置[removeStartingWindow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#removestartingwindow14)接口的启用状态。配置项为：name取值enable.remove.starting.window，value取值true或false。true表示启用，false表示不启用。未配置时，默认为false。
    
3. 使用metadata标签配置主窗启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗最大化显示配置存在如下约束与限制：
    
    - 该配置项仅在PC/2in1设备上生效。
    - 若使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)的supportWindowModes属性，需要配置FULL_SCREEN选项，此时使用metadata标签配置主窗最大化启动生效，否则不生效。
    - 若使用[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)的supportWindowMode属性，需要配置fullscreen选项，此时使用metadata标签配置主窗最大化启动生效，否则不生效。
    - 主窗显示设置优先级排序为：全屏显示 > 使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)接口指定大小和位置 > 使用[setWindowRectAutoSave()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#setwindowrectautosave14)方法开启窗口尺寸记忆 > 使用metadata标签配置最大化 > 使用metadata标签配置大小和位置。全屏显示配置方法包括如下三种：
        1. 使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)的windowMode属性并将其配置为WINDOW_MODE_FULLSCREEN。
        2. 使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)的supportWindowModes属性，且只配置FULL_SCREEN选项。
        3. 使用[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)的supportWindowMode属性，且只配置fullscreen选项。
4. 使用metadata配置[自由多窗](https://developer.huawei.com/consumer/cn/doc/design-guides/pad-0000001823654157#section1768267204717)下的可支持窗口模式。配置项为：name为ohos.ability.window.supportWindowModeInFreeMultiWindow，value取值为：fullscreen（表示全屏模式）、split（表示分屏模式）、floating（表示悬浮窗模式）。value取值为字符串，可以配置多种模式，每个模式之间用逗号分隔开，不区分顺序，不添加空格，例如：fullscreen,split。仅在支持并处于[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态的设备上生效；在支持但不处于[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态的设备及不支持[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态的设备上配置不生效也不报错。
    
    自由多窗下的可支持窗口模式可以采用多种方法进行配置，配置优先级为：通过[SetSupportedWindowModes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#setsupportedwindowmodes15)接口配置 > 通过StartAbility配置[StartOption](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions#startoptions)中的SupportWindowMode > 使用metadata配置 > 配置module.json5中[abilities](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)标签下的SupportWindowMode属性。
    
    非自由多窗模式下只能通过配置module.json5中abilities标签下的SupportWindowMode属性配置窗口支持模式，其他配置方式均不生效。
    

1. {
2.   "module": {
3.     "abilities": [{
4.       "metadata": [{
5.         "name": "ability_metadata",
6.         "value": "a test demo for ability",
7.         "resource": "$profile:config_file"
8.       },
9.       {
10.         "name": "ability_metadata_2",
11.         "value": "a string test",
12.         "resource": "$profile:config_file"
13.       },
14.       {
15.         "name": "ohos.ability.window.height",
16.         "value": "987"
17.       },
18.       {
19.         "name": "ohos.ability.window.width",
20.         "value": "1300"
21.       },
22.       {
23.         "name": "ohos.ability.window.left",
24.         "value": "right-50"
25.       },
26.       {
27.         "name": "ohos.ability.window.top",
28.         "value": "center+50"
29.       },
30.       {
31.         "name": "ohos.ability.window.isMaximize",
32.         "value": "true"
33.       },
34.       {
35.         "name": "enable.remove.starting.window",
36.         "value": "true"
37.       }
38.       {
39.         "name": "ohos.ability.window.supportWindowModeInFreeMultiWindow",
40.         "value": "fullscreen,split,floating",
41.       }],
42.     }],

43.     "extensionAbilities": [{
44.       "metadata": [{
45.         "name": "extensionAbility_metadata",
46.         "value": "a test for extensionAbility",
47.         "resource": "$profile:config_file"
48.       },
49.       {
50.         "name": "extensionAbility_metadata_2",
51.         "value": "a string test",
52.         "resource": "$profile:config_file"
53.       }],
54.     }]
55.   }
56. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-rotation "窗口旋转")
# 窗口元数据配置

更新时间: 2025-12-16 16:38

## metadata标签

该标签标识HAP的自定义元信息，标签值为数组类型，包含name、value、resource三个子标签。

**表1** metadata标签说明

|属性名称|含义|数据类型|是否可缺省|
|:--|:--|:--|:--|
|name|标识数据项的名称，取值为长度不超过255字节的字符串。|字符串|该标签可缺省，缺省值为空。|
|value|标识数据项的值，取值为长度不超过255字节的字符串。|字符串|该标签可缺省，缺省值为空。|
|resource|标识了用户自定义数据，取值为长度不超过255字节的字符串，内容为该数据的资源索引，例如配置成$profile:shortcuts_config，表示指向了/resources/base/profile/shortcuts_config.json配置文件。|字符串|该标签可缺省，缺省值为空。|

下面给出几种metadata标签的使用场景及示例，开发者也可以根据实际需求自定义设置。

1. 使用metadata标签配置主窗口的默认大小和位置（单位为vp）。其中name取值及对应含义如下：
    
    - name取值为ohos.ability.window.height表示主窗口的默认高度，value表示高度大小。
    - name取值为ohos.ability.window.width表示主窗口的默认宽度，value表示宽度大小。
    - name取值为ohos.ability.window.left表示主窗口默认左边的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、left和right，默认值为left；当偏移量为0时可以省略。
    - name取值为ohos.ability.window.top表示主窗口顶部的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、top和bottom，默认值为top。如果对齐方式和偏移量同时省略，则按照系统默认的层叠规格处理。
2. 使用metadata标签配置[removeStartingWindow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#removestartingwindow14)接口的启用状态。配置项为：name取值enable.remove.starting.window，value取值true或false。true表示启用，false表示不启用。未配置时，默认为false。
    
3. 使用metadata标签配置主窗启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗最大化显示配置存在如下约束与限制：
    
    - 该配置项仅在PC/2in1设备上生效。
    - 若使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)的supportWindowModes属性，需要配置FULL_SCREEN选项，此时使用metadata标签配置主窗最大化启动生效，否则不生效。
    - 若使用[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)的supportWindowMode属性，需要配置fullscreen选项，此时使用metadata标签配置主窗最大化启动生效，否则不生效。
    - 主窗显示设置优先级排序为：全屏显示 > 使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)接口指定大小和位置 > 使用[setWindowRectAutoSave()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#setwindowrectautosave14)方法开启窗口尺寸记忆 > 使用metadata标签配置最大化 > 使用metadata标签配置大小和位置。全屏显示配置方法包括如下三种：
        1. 使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)的windowMode属性并将其配置为WINDOW_MODE_FULLSCREEN。
        2. 使用[startOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions)的supportWindowModes属性，且只配置FULL_SCREEN选项。
        3. 使用[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)的supportWindowMode属性，且只配置fullscreen选项。
4. 使用metadata配置[自由多窗](https://developer.huawei.com/consumer/cn/doc/design-guides/pad-0000001823654157#section1768267204717)下的可支持窗口模式。配置项为：name为ohos.ability.window.supportWindowModeInFreeMultiWindow，value取值为：fullscreen（表示全屏模式）、split（表示分屏模式）、floating（表示悬浮窗模式）。value取值为字符串，可以配置多种模式，每个模式之间用逗号分隔开，不区分顺序，不添加空格，例如：fullscreen,split。仅在支持并处于[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态的设备上生效；在支持但不处于[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态的设备及不支持[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态的设备上配置不生效也不报错。
    
    自由多窗下的可支持窗口模式可以采用多种方法进行配置，配置优先级为：通过[SetSupportedWindowModes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#setsupportedwindowmodes15)接口配置 > 通过StartAbility配置[StartOption](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions#startoptions)中的SupportWindowMode > 使用metadata配置 > 配置module.json5中[abilities](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)标签下的SupportWindowMode属性。
    
    非自由多窗模式下只能通过配置module.json5中abilities标签下的SupportWindowMode属性配置窗口支持模式，其他配置方式均不生效。
    

1. {
2.   "module": {
3.     "abilities": [{
4.       "metadata": [{
5.         "name": "ability_metadata",
6.         "value": "a test demo for ability",
7.         "resource": "$profile:config_file"
8.       },
9.       {
10.         "name": "ability_metadata_2",
11.         "value": "a string test",
12.         "resource": "$profile:config_file"
13.       },
14.       {
15.         "name": "ohos.ability.window.height",
16.         "value": "987"
17.       },
18.       {
19.         "name": "ohos.ability.window.width",
20.         "value": "1300"
21.       },
22.       {
23.         "name": "ohos.ability.window.left",
24.         "value": "right-50"
25.       },
26.       {
27.         "name": "ohos.ability.window.top",
28.         "value": "center+50"
29.       },
30.       {
31.         "name": "ohos.ability.window.isMaximize",
32.         "value": "true"
33.       },
34.       {
35.         "name": "enable.remove.starting.window",
36.         "value": "true"
37.       }
38.       {
39.         "name": "ohos.ability.window.supportWindowModeInFreeMultiWindow",
40.         "value": "fullscreen,split,floating",
41.       }],
42.     }],

43.     "extensionAbilities": [{
44.       "metadata": [{
45.         "name": "extensionAbility_metadata",
46.         "value": "a test for extensionAbility",
47.         "resource": "$profile:config_file"
48.       },
49.       {
50.         "name": "extensionAbility_metadata_2",
51.         "value": "a string test",
52.         "resource": "$profile:config_file"
53.       }],
54.     }]
55.   }
56. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-rotation "窗口旋转")
# 使用typeNode实现画中画功能开发（ArkTS）

更新时间: 2025-12-16 16:39

说明

- 从API version 12开始，支持使用typeNode实现画中画功能开发。
- 在API version 20之前，支持在Phone、Tablet设备使用typeNode实现画中画功能开发；从API version 20开始，支持在Phone、PC/2in1、Tablet设备使用typeNode实现画中画功能开发。

该方式适用于任意场景下应用接入画中画功能，以下根据实际开发场景提供四个示例，分别介绍对应场景下画中画功能的实现步骤：

- [应用使用typeNode自由节点（不添加到布局）实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section7627141117162)。
- [应用使用router导航时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section1236517470234)。
- [应用使用Navigation导航时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section173761626124613)。
- [应用使用单界面Ability时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section8907336134011)。

本文以视频播放为例，介绍通过typeNode实现画中画功能的基本开发步骤。

示例中的视频播放器简易实现参考：

1. // model/AVPlayer.ets
2. // 简易播放器实现
3. import { BusinessError } from '@kit.BasicServicesKit';
4. import { common } from '@kit.AbilityKit';
5. import { media } from '@kit.MediaKit';

6. export class AVPlayer {
7.   private avPlayer?: media.AVPlayer;
8.   surfaceID: string = '';

9.   setAVPlayerCallback() {
10.     this.avPlayer?.on('seekDone', (seekDoneTime: number) => {
11.       console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);
12.     })
13.     this.avPlayer?.on('stateChange', async (state, reason) => {
14.       if (!this.avPlayer) {
15.         return;
16.       }
17.       switch (state) {
18.         case 'idle':
19.           this.avPlayer.release();
20.           break;
21.         case 'initialized':
22.           this.avPlayer.surfaceId = this.surfaceID;
23.           this.avPlayer.prepare().then(() => {
24.             console.info('AVPlayer prepare succeeded.');
25.           }, (err: BusinessError) => {
26.             console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);
27.           });
28.           break;
29.         case 'prepared':
30.           this.avPlayer.play();
31.           break;
32.         case 'stopped':
33.           this.avPlayer.reset();
34.           break;
35.         default:
36.           break;
37.       }
38.     })
39.   }

40.   async avPlayerFdSrc() {

41.     try {
42.       this.avPlayer = await media.createAVPlayer();
43.     } catch(err) {
44.       console.error(`create AVPlayer failed`);
45.     };
46.     this.setAVPlayerCallback();
47.     let uiContext = AppStorage.get('UIContext') as UIContext;
48.     let context = uiContext.getHostContext() as common.UIAbilityContext;
49.     let fileDescriptor = await context.resourceManager.getRawFd('xxx.mp4');

50.     if (this.avPlayer) {
51.       this.avPlayer.fdSrc = fileDescriptor;
52.     }
53.   }
54. }

## 约束与限制

- 构造PiPConfiguration参数时，建议传入contentWidth和contentHeight参数用以计算画中画初始比例，否则系统将以16:9的比例呈现画中画窗口。
- contentNode支持XComponentType.SURFACE类型，且创建typeNode时必须指定为"XComponent"类型。

## 应用使用typeNode自由节点（不添加到布局）实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 通过主窗口UIContext创建typeNode节点。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';
4. import { PipManager } from '../model/PipManager';

5. export default class EntryAbility extends UIAbility {
6.   onWindowStageCreate(windowStage: window.WindowStage): void {
7.     windowStage.loadContent('pages/Index', (err) => {
8.       // ...
9.     });
10.     windowStage.getMainWindow().then((window) => {
11.       let ctx = window.getUIContext();
12.       AppStorage.setOrCreate('UIContext', ctx);
13.       // 通过主窗口UIContext创建typeNode节点
14.       PipManager.getInstance().makeTypeNode(ctx);
15.     })
16.   }
17. }

18. // Index.ets
19. // 该页面用于展示应用布局文件，创建的typeNode节点不会添加到该布局中
20. import { PipManager } from '../model/PipManager';

21. const TAG = 'Index'
22. @Entry
23. @Component
24. struct Index {
25.   build() {
26.     Column() {
27.       Text('This is MainPage')
28.         .fontSize(30)
29.         .fontWeight(FontWeight.Bold)
30.         .margin({ bottom: 20 })

31.       Text('This is not typeNode')
32.         .size({ width: '100%', height: '800px' })
33.         .fontSize(30)
34.         .textAlign(TextAlign.Center)
35.         .fontWeight(FontWeight.Bold)
36.         .backgroundColor('#4d5b5858')

37.       Row({ space: 20 }) {
38.         Button('startPip') // 启动画中画
39.           .onClick(() => {
40.             PipManager.getInstance().startPip();
41.           })

42.         Button('stopPip') // 停止画中画
43.           .onClick(() => {
44.             PipManager.getInstance().stopPip();
45.           })

46.         Button('updateSize') // 更新视频尺寸
47.           .onClick(() => {
48.             PipManager.getInstance().updateContentSize(900, 1600);
49.           })
50.       }
51.       .backgroundColor('#4da99797')
52.       .size({ width: '100%', height: 60 })
53.       .justifyContent(FlexAlign.SpaceAround)
54.     }
55.     .justifyContent(FlexAlign.Center)
56.     .width('100%')
57.     .height('100%')
58.   }

59.   aboutToDisappear(): void {
60.     PipManager.getInstance().unregisterPipStateChangeListener(); // 解注册画中画生命周期及状态回调
61.   }

62.   onPageShow(): void {
63.     console.info(TAG, 'onPageShow')
64.     PipManager.getInstance().init(this.getUIContext().getHostContext() as Context); // 创建画中画控制器
65.     PipManager.getInstance().setAutoStart(true); // 设置应用退后台时自动启动画中画
66.   }

67.   onPageHide(): void {
68.     console.info(TAG, 'onPageHide')
69.     PipManager.getInstance().setAutoStart(false);
70.   }
71. }

72. // model/PipManager.ets
73. // 画中画控制器单例
74. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
75. import { BusinessError } from '@kit.BasicServicesKit';
76. import { AVPlayer} from '../model/AVPlayer'

77. // 自定义XComponentController
78. class CustomXComponentController extends XComponentController {
79.   // 监听onSurfaceCreated，并将surfaceId设置给播放器
80.   onSurfaceCreated(surfaceId: string): void {
81.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
82.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
83.       return;
84.     }
85.     PipManager.getInstance().player.surfaceID = surfaceId;
86.     PipManager.getInstance().player.avPlayerFdSrc();
87.   }

88.   onSurfaceDestroyed(surfaceId: string): void {
89.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
90.   }
91. }

92. const TAG = 'PipManager';

93. export class PipManager {
94.   player: AVPlayer;
95.   private static instance: PipManager = new PipManager();
96.   private pipController?: PiPWindow.PiPController = undefined;
97.   private mXComponentController: XComponentController;
98.   private xComponent: typeNode.XComponent| null = null; // typeNode节点

99.   public static getInstance(): PipManager {
100.     return PipManager.instance;
101.   }

102.   constructor() {
103.     this.player = new AVPlayer();
104.     this.mXComponentController = new CustomXComponentController();
105.   }

106.   onActionEvent(control: PiPWindow.ControlEventParam) {
107.     switch (control.controlType) {
108.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
109.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
110.           //停止视频
111.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
112.           //播放视频
113.         }
114.         break;
115.       case PiPWindow.PiPControlType.VIDEO_NEXT:
116.         // 切换到下一个视频
117.         break;
118.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
119.         // 切换到上一个视频
120.         break;
121.       case PiPWindow.PiPControlType.FAST_FORWARD:
122.         // 视频进度快进
123.         break;
124.       case PiPWindow.PiPControlType.FAST_BACKWARD:
125.         // 视频进度后退
126.         break;
127.       default:
128.         break;
129.     }
130.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
131.   }

132.   // 监听画中画生命周期
133.   onStateChange(state: PiPWindow.PiPState, reason: string) {
134.     let curState: string = '';
135.     switch (state) {
136.       case PiPWindow.PiPState.ABOUT_TO_START:
137.         curState = "ABOUT_TO_START";
138.         break;
139.       case PiPWindow.PiPState.STARTED:
140.         curState = "STARTED";
141.         break;
142.       case PiPWindow.PiPState.ABOUT_TO_STOP:
143.         curState = "ABOUT_TO_STOP";
144.         break;
145.       case PiPWindow.PiPState.STOPPED:
146.         curState = "STOPPED";
147.         break;
148.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
149.         curState = "ABOUT_TO_RESTORE";
150.         break;
151.       case PiPWindow.PiPState.ERROR:
152.         curState = "ERROR";
153.         break;
154.       default:
155.         break;
156.     }
157.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
158.   }

159.   // 解注册监听
160.   unregisterPipStateChangeListener() {
161.     console.info(TAG, 'aboutToDisappear');
162.     this.pipController?.off('stateChange');
163.     this.pipController?.off('controlEvent');
164.   }

165.   getXComponentController(): CustomXComponentController {
166.     return this.mXComponentController;
167.   }

168.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
169.   init(ctx: Context) {
170.     if (this.pipController !== null && this.pipController != undefined) {
171.       return;
172.     }
173.     console.info(TAG, 'onPageShow');
174.     if (!PiPWindow.isPiPEnabled()) {
175.       console.error(TAG, `picture in picture disabled for current OS`);
176.       return;
177.     }

178.     let config: PiPWindow.PiPConfiguration = {
179.       context: ctx,
180.       componentController: this.getXComponentController(),
181.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
182.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则将设置为16:9默认比例
183.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则将设置为16:9默认比例
184.     };
185.     // 通过create接口创建画中画控制器实例

186.     PiPWindow.create(config, this.xComponent).then((controller: PiPWindow.PiPController) => {
187.       this.pipController = controller;
188.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
189.       this.pipController.setAutoStartEnabled(true);
190.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
191.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
192.         this.onStateChange(state, reason);
193.       });
194.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
195.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
196.         this.onActionEvent(control);
197.       });
198.     }).catch((err: BusinessError) => {
199.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
200.     });
201.   }

202.   // 步骤2：创建画中画控制器实例后，通过startPiP接口启动画中画
203.   startPip() {
204.     this.pipController?.startPiP().then(() => {
205.       console.info(TAG, `Succeeded in starting pip.`);
206.     }).catch((err: BusinessError) => {
207.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
208.     });
209.   }

210.   // 步骤3：更新媒体源尺寸信息
211.   updateContentSize(width: number, height: number) {
212.     if (this.pipController) {
213.       this.pipController.updateContentSize(width, height);
214.     }
215.   }

216.   // 步骤4：关闭画中画
217.   stopPip() {
218.     if (this.pipController === null || this.pipController === undefined) {
219.       return;
220.     }
221.     let promise: Promise<void> = this.pipController.stopPiP();
222.     promise.then(() => {
223.       console.info(TAG, `Succeeded in stopping pip.`);
224.     }).catch((err: BusinessError) => {
225.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
226.     });
227.   }

228.   setAutoStart(autoStart: boolean): void {
229.     this.pipController?.setAutoStartEnabled(autoStart);
230.   }

231.   // 创建typeNode节点
232.   makeTypeNode(ctx: UIContext) {
233.     if (this.xComponent === null || this.xComponent === undefined) {
234.       // 创建typeNode
235.       // let xc_options: XComponentOptions = {
236.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
237.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
238.       // }
239.       // this.xComponent = typeNode.createNode(ctx, "XComponent", xc_options);

240.       // 创建XComponent类型的typeNode
241.       this.xComponent = typeNode.createNode(ctx, "XComponent", {
242.         type: XComponentType.SURFACE, // 类型设置为SURFACE
243.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
244.       });
245.     }
246.   }
247. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.90557765226952201292377370988578:50001231000000:2800:CA399A5B260CE4512EC1508F4ED7A8922924014E1AF31834D14D86BEB03CD60C.gif "点击放大")

## 应用使用router导航时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新跳转到原界面。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.      // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { PiPWindow, router, Router } from '@kit.ArkUI'; // 引入PiPWindow模块

14. const TAG = 'Index'
15. @Entry
16. @Component
17. struct Index {
18.   private page1: string = 'pages/Page1';
19.   private pageRouter: Router | null = null;

20.   // 画中画生命周期事件监听，用于页面及节点操作
21.   private callback: Function = (state: PiPWindow.PiPState) => {
22.     console.info(TAG, `pipStateChange: state ${state}`);
23.     if (state === PiPWindow.PiPState.ABOUT_TO_START) {
24.       // 返回到上级页面（可选）
25.       this.pageRouter?.back();
26.     } else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
27.       // 重新将typeNode节点添加到布局中，例如还原场景
28.       PipManager.getInstance().addNode();
29.     } else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
30.       // 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
31.       this.jumpNext();
32.     }
33.   };

34.   aboutToAppear(): void {
35.     this.pageRouter = this.getUIContext().getRouter();
36.     PipManager.getInstance().registerLifecycleCallback(this.callback);
37.   }

38.   aboutToDisappear(): void {
39.     PipManager.getInstance().unregisterPipStateChangeListener();
40.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
41.   }

42.   jumpNext(): void {
43.     let topPage = this.pageRouter?.getState();
44.     if (topPage !== undefined && (this.page1.toString() === topPage.path + topPage.name)) {
45.       console.info(TAG, `page1 aready at top`)
46.       return;
47.     }
48.     this.pageRouter?.pushUrl({
49.       url: this.page1 // 目标url
50.     }, router.RouterMode.Standard, (err) => {
51.       if (err) {
52.         console.error(TAG, `Invoke pushUrl failed, code is ${err.code}: ${err.message}`);
53.         return;
54.       }
55.       console.info(TAG, 'Invoke pushUrl succeeded.');
56.     });
57.   }

58.   build() {
59.     Row() {
60.       Column() {
61.         Text('Main Page')
62.           .fontSize(50)
63.           .fontWeight(FontWeight.Bold)

64.         Button('Jump Next')
65.           .onClick(() => {
66.             this.jumpNext();
67.           })
68.           .margin({ top: 16, bottom: 16 })
69.       }
70.       .width('100%')
71.     }
72.     .height('100%')
73.   }
74. }

75. // pages/Page1.ets
76. import { PipManager } from '../model/PipManager';

77. const TAG = 'Page1';

78. @Entry
79. @Component
80. export struct Page1 {
81.   build() {
82.     Column() {
83.       Text('This is Page1')
84.         .fontSize(30)
85.         .fontWeight(FontWeight.Bold)
86.         .margin({bottom: 20})

87.       // 将typeNode添加到页面布局中
88.       NodeContainer(PipManager.getInstance().getNodeController())
89.         .size({ width: '100%', height: '800px' })

90.       Row({ space: 20 }) {
91.         Button('startPip')// 启动画中画
92.           .onClick(() => {
93.             PipManager.getInstance().startPip();
94.           })

95.         Button('stopPip')// 停止画中画
96.           .onClick(() => {
97.             PipManager.getInstance().stopPip();
98.           })

99.         Button('updateSize')// 更新视频尺寸
100.           .onClick(() => {
101.             // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
102.             // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
103.             PipManager.getInstance().updateContentSize(900, 1600);
104.           })
105.       }
106.       .backgroundColor('#4da99797')
107.       .size({ width: '100%', height: 60 })
108.       .justifyContent(FlexAlign.SpaceAround)
109.     }
110.     .justifyContent(FlexAlign.Center)
111.     .width('100%')
112.     .height('100%')
113.   }

114.   onPageShow(): void {
115.     console.info(TAG, 'onPageShow')
116.     PipManager.getInstance().initPipController(this.getUIContext().getHostContext() as Context);
117.     PipManager.getInstance().setAutoStart(true);
118.   }

119.   onPageHide(): void {
120.     console.info(TAG, 'onPageHide')
121.     PipManager.getInstance().setAutoStart(false);
122.     PipManager.getInstance().removeNode();
123.   }
124. }

125. // model/PipManager.ets
126. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
127. import { BusinessError } from '@kit.BasicServicesKit';
128. import { XCNodeController } from './XCNodeController';
129. import { AVPlayer } from './AVPlayer';

130. export class CustomXComponentController extends XComponentController {
131.   onSurfaceCreated(surfaceId: string): void {
132.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
133.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
134.       return;
135.     }
136.     // 将surfaceId设置给媒体源
137.     PipManager.getInstance().player.surfaceID = surfaceId;
138.     PipManager.getInstance().player.avPlayerFdSrc();
139.   }

140.   onSurfaceDestroyed(surfaceId: string): void {
141.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
142.   }
143. }

144. const TAG = 'PipManager';

145. export class PipManager {
146.   private static instance: PipManager = new PipManager();
147.   private pipController?: PiPWindow.PiPController = undefined;
148.   private xcNodeController: XCNodeController;
149.   private mXComponentController: XComponentController;
150.   private lifeCycleCallback: Set<Function> = new Set();
151.   player: AVPlayer;

152.   public static getInstance(): PipManager {
153.     return PipManager.instance;
154.   }

155.   constructor() {
156.     this.xcNodeController = new XCNodeController();
157.     this.player = new AVPlayer();
158.     this.mXComponentController = new CustomXComponentController();
159.   }

160.   public registerLifecycleCallback(callBack: Function) {
161.     this.lifeCycleCallback.add(callBack);
162.   }

163.   public unRegisterLifecycleCallback(callBack: Function): void {
164.     this.lifeCycleCallback.delete(callBack);
165.   }

166.   getNode(): typeNode.XComponent | null {
167.     return this.xcNodeController.getNode();
168.   }

169.   onActionEvent(control: PiPWindow.ControlEventParam) {
170.     switch (control.controlType) {
171.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
172.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
173.           //停止视频
174.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
175.           //播放视频
176.         }
177.         break;
178.       case PiPWindow.PiPControlType.VIDEO_NEXT:
179.         // 切换到下一个视频
180.         break;
181.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
182.         // 切换到上一个视频
183.         break;
184.       case PiPWindow.PiPControlType.FAST_FORWARD:
185.         // 视频进度快进
186.         break;
187.       case PiPWindow.PiPControlType.FAST_BACKWARD:
188.         // 视频进度后退
189.         break;
190.       default:
191.         break;
192.     }
193.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
194.   }

195.   onStateChange(state: PiPWindow.PiPState, reason: string) {
196.     let curState: string = '';
197.     this.xcNodeController.setCanAddNode(
198.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
199.     if (this.lifeCycleCallback !== null) {
200.       this.lifeCycleCallback.forEach((fun) => {
201.         fun(state)
202.       });
203.     }
204.     switch (state) {
205.       case PiPWindow.PiPState.ABOUT_TO_START:
206.         curState = "ABOUT_TO_START";
207.         // 将typeNode节点从布局移除
208.         this.xcNodeController.removeNode();
209.         break;
210.       case PiPWindow.PiPState.STARTED:
211.         curState = "STARTED";
212.         break;
213.       case PiPWindow.PiPState.ABOUT_TO_STOP:
214.         curState = "ABOUT_TO_STOP";
215.         break;
216.       case PiPWindow.PiPState.STOPPED:
217.         curState = "STOPPED";
218.         break;
219.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
220.         curState = "ABOUT_TO_RESTORE";
221.         break;
222.       case PiPWindow.PiPState.ERROR:
223.         curState = "ERROR";
224.         break;
225.       default:
226.         break;
227.     }
228.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
229.   }

230.   unregisterPipStateChangeListener() {
231.     console.info(`${TAG} aboutToDisappear`)
232.     this.pipController?.off('stateChange');
233.     this.pipController?.off('controlEvent');
234.   }

235.   getXComponentController(): CustomXComponentController {
236.     return this.mXComponentController;
237.   }

238.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
239.   initPipController(ctx: Context) {
240.     if (this.pipController !== null && this.pipController != undefined) {
241.       return;
242.     }
243.     console.info(`${TAG} onPageShow`)
244.     if (!PiPWindow.isPiPEnabled()) {
245.       console.error(TAG, `picture in picture disabled for current OS`);
246.       return;
247.     }
248.     let config: PiPWindow.PiPConfiguration = {
249.       context: ctx,
250.       componentController: this.getXComponentController(),
251.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
252.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
253.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
254.     };
255.     // 通过create接口创建画中画控制器实例

256.     PiPWindow.create(config, this.getNode()).then((controller: PiPWindow.PiPController) => {
257.       this.pipController = controller;
258.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
259.       this.pipController.setAutoStartEnabled(true)
260.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
261.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
262.         this.onStateChange(state, reason);
263.       });
264.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
265.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
266.         this.onActionEvent(control);
267.       });
268.     }).catch((err: BusinessError) => {
269.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
270.     });
271.   }

272.   // 步骤2：启动画中画
273.   startPip() {
274.     this.pipController?.startPiP().then(() => {
275.       console.info(TAG, `Succeeded in starting pip.`);
276.     }).catch((err: BusinessError) => {
277.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
278.     });
279.   }

280.   // 步骤3：更新媒体源尺寸信息
281.   updateContentSize(width: number, height: number) {
282.     if (this.pipController) {
283.       this.pipController.updateContentSize(width, height);
284.     }
285.   }

286.   // 步骤4：关闭画中画
287.   stopPip() {
288.     if (this.pipController) {
289.       let promise: Promise<void> = this.pipController.stopPiP();
290.       promise.then(() => {
291.         console.info(TAG, `Succeeded in stopping pip.`);
292.       }).catch((err: BusinessError) => {
293.         console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
294.       });
295.     }
296.   }

297.   getNodeController(): XCNodeController {
298.     console.info(TAG, `getNodeController.`);
299.     return this.xcNodeController;
300.   }

301.   setAutoStart(autoStart: boolean): void {
302.     this.pipController?.setAutoStartEnabled(autoStart);
303.   }

304.   removeNode(): void {
305.     this.xcNodeController.removeNode();
306.   }

307.   addNode(): void {
308.     this.xcNodeController.addNode();
309.   }
310. }

311. // model/XCNodeController.ets
312. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
313. import { PipManager } from './PipManager';

314. const TAG = 'XCNodeController';
315. // 创建自定义NodeController
316. export class XCNodeController extends NodeController {
317.   xComponent: typeNode.XComponent | null = null;
318.   private node: FrameNode | null = null;
319.   private canAddNode: boolean = true;

320.   // 设置是否可以添加节点
321.   setCanAddNode(canAddNode: boolean) {
322.     this.canAddNode = canAddNode;
323.   }

324.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
325.   makeNode(context: UIContext): FrameNode | null {
326.     this.node = new FrameNode(context);
327.     this.node.commonAttribute
328.     if (this.xComponent === null || this.xComponent === undefined) {
329.       // 创建typeNode
330.       // let xc_options: XComponentOptions = {
331.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
332.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
333.       // }
334.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

335.       // 创建XComponent类型的typeNode
336.       this.xComponent = typeNode.createNode(context, "XComponent", {
337.         type: XComponentType.SURFACE, // 类型设置为SURFACE
338.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
339.       });
340.     }
341.     if (this.canAddNode) {

342.       try {
343.         this.xComponent.getParent()?.removeChild(this.xComponent);
344.       } catch (error) {
345.         console.error(TAG, 'Failed to removeChild');
346.       }
347.       try {
348.         this.node.appendChild(this.xComponent);
349.       } catch (error) {
350.         console.error(TAG, 'Failed to appendChild');
351.       }
352.     }
353.     return this.node;
354.   }

355.   // 重新添加typeNode节点
356.   addNode() {
357.     if (this.node !== null && this.node !== undefined) {
358.       console.info(TAG, "addNode");

359.       try {
360.         this.node.appendChild(this.xComponent);
361.       } catch (error) {
362.         console.error(TAG, 'Failed to appendChild');
363.       }
364.     }
365.   }

366.   // 移除typeNode节点
367.   removeNode() {
368.     if (this.node !== null && this.node !== undefined) {
369.       console.info(TAG, "removeNode");

370.       try {
371.         this.node.removeChild(this.xComponent);
372.       } catch (error) {
373.         console.error(TAG, 'Failed to removeChild');
374.       }
375.     }
376.   }

377.   getNode(): typeNode.XComponent | null {
378.     console.info(TAG, "getNode is null:"+ (this.xComponent === null || this.xComponent === undefined))
379.     return this.xComponent;
380.   }
381. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.82469444221375517554757238487910:50001231000000:2800:D265F3EF899EAB29F484FC57231645CC4A2F93D0A92692BB6F191A779E80810D.gif "点击放大")

## 应用使用Navigation导航时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新跳转到原界面。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { Page1 } from "../pages/Page1"
14. import { PiPWindow } from '@kit.ArkUI';

15. const TAG = 'Index1';

16. @Entry
17. @Component
18. struct Index {
19.   @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack();
20.   // 画中画生命周期事件监听，用于页面及节点操作
21.   private callback: Function = (state: PiPWindow.PiPState) => {
22.     console.info(TAG, `pipStateChange: state ${state}`);
23.     if (state === PiPWindow.PiPState.ABOUT_TO_START) {
24.       // 返回到上级页面（可选）
25.       this.pageInfos.pop();
26.     } else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
27.       // 重新将typeNode节点添加到布局中，例如还原场景
28.       PipManager.getInstance().addNode();
29.     } else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
30.       // 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
31.       this.jumpNext();
32.     }
33.   };

34.   jumpNext() {
35.     if (this.pageInfos.getAllPathName()[0] === 'Page1') {
36.       console.log(TAG, 'Page1 already at top');
37.       return;
38.     }
39.     this.pageInfos.pushPath({ name: 'Page1' });
40.   }

41.   aboutToAppear(): void {
42.     PipManager.getInstance().registerLifecycleCallback(this.callback);
43.   }

44.   aboutToDisappear(): void {
45.     PipManager.getInstance().unregisterPipStateChangeListener();
46.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
47.   }

48.   @Builder
49.   PageMap(name: string) {
50.     if (name === 'Page1') {
51.       Page1();
52.     }
53.   }

54.   build() {
55.     Navigation(this.pageInfos) {
56.       Column() {
57.         Text("This is Main Page")
58.         Column()
59.           .height('200px')
60.         Row({ space: 12 }) {
61.           Button("Jump Page1")
62.             .width('80%')
63.             .height(40)
64.             .margin(20)
65.             .onClick(() => {
66.               this.jumpNext();
67.             })
68.         }
69.       }
70.       .height("100%")
71.       .width("100%")
72.       .justifyContent(FlexAlign.Center)
73.       .backgroundColor("#DCDCDC")
74.     }.title('MainTitle')
75.     .navDestination(this.PageMap)
76.   }
77. }

78. // pages/Page1.ets
79. import { PipManager } from '../model/PipManager';

80. const TAG = 'Page1';

81. @Entry
82. @Component
83. export struct Page1 {
84.   build() {
85.     NavDestination() {
86.       Column() {
87.         Text('This is Page1')
88.           .fontSize(30)
89.           .fontWeight(FontWeight.Bold)
90.           .margin({bottom: 20})

91.         // 将typeNode添加到页面布局中
92.         NodeContainer(PipManager.getInstance().getNodeController())
93.           .size({ width: '100%', height: '800px' })

94.         Row({ space: 20 }) {
95.           Button('startPip') // 启动画中画
96.             .onClick(() => {
97.               PipManager.getInstance().startPip();
98.             })
99.           Button('stopPip') // 停止画中画
100.             .onClick(() => {
101.               PipManager.getInstance().stopPip();
102.             })
103.           Button('updateSize') // 更新视频尺寸
104.             .onClick(() => {
105.               // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
106.               // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
107.               PipManager.getInstance().updateContentSize(900, 1600);
108.             })
109.         }
110.         .backgroundColor('#4da99797')
111.         .size({ width: '100%', height: 60 })
112.         .justifyContent(FlexAlign.SpaceAround)
113.       }
114.       .justifyContent(FlexAlign.Center)
115.       .width('100%')
116.       .height('100%')
117.     }
118.     .title('page1')
119.     .onShown(()=>{
120.       console.info(TAG, 'onShown')
121.       PipManager.getInstance().init(this.getUIContext().getHostContext() as Context);
122.       PipManager.getInstance().setAutoStart(true);
123.     })
124.     .onHidden(()=>{
125.       console.info(TAG, 'onHidden')
126.       PipManager.getInstance().setAutoStart(false);
127.       PipManager.getInstance().removeNode();
128.     })
129.   }
130. }

131. // model/XCNodeController.ets
132. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
133. import { PipManager } from './PipManager';

134. const TAG = 'XCNodeController';

135. // 创建自定义NodeController
136. export class XCNodeController extends NodeController {
137.   xComponent: typeNode.XComponent| null = null;
138.   private node: FrameNode | null = null;
139.   private canAddNode: boolean = true;

140.   // 设置是否可以添加节点
141.   setCanAddNode(canAddNode: boolean) {
142.     this.canAddNode = canAddNode;
143.   }

144.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
145.   makeNode(context: UIContext): FrameNode | null {
146.     console.info(TAG, "makeNode");
147.     this.node = new FrameNode(context);
148.     if (this.xComponent === null || this.xComponent === undefined) {
149.       // 创建typeNode
150.       // let xc_options: XComponentOptions = {
151.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
152.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
153.       // }
154.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

155.       // 创建XComponent类型的typeNode
156.       this.xComponent = typeNode.createNode(context, "XComponent", {
157.         type: XComponentType.SURFACE, // 类型设置为SURFACE
158.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
159.       });
160.     }
161.     if (this.canAddNode) {

162.       try {
163.         this.xComponent.getParent()?.removeChild(this.xComponent);
164.       } catch (error) {
165.         console.error(TAG, 'Failed to removeChild');
166.       }
167.       try {
168.         this.node.appendChild(this.xComponent);
169.       } catch (error) {
170.         console.error(TAG, 'Failed to appendChild');
171.       }
172.     }
173.     return this.node;
174.   }

175.   // 重新添加typeNode节点
176.   addNode() {
177.     if (this.node !== null && this.node !== undefined) {
178.       console.info(TAG, "addNode id:"+(this.node?.getUniqueId())+" "+this.xComponent?.getUniqueId());
179.       try {
180.         this.node.appendChild(this.xComponent);
181.       } catch (error) {
182.         console.error(TAG, 'Failed to appendChild');
183.       }
184.     }
185.   }

186.   // 移除typeNode节点
187.   removeNode() {
188.     if (this.node !== null && this.node !== undefined) {
189.       console.info(TAG, "removeNode");

190.       try {
191.         this.node.removeChild(this.xComponent);
192.       } catch (error) {
193.         console.error(TAG, 'Failed to removeChild');
194.       }
195.     }
196.   }

197.   getNode(): typeNode.XComponent | null {
198.     console.info(TAG, "getNode is null:"+ (this.xComponent === null || this.xComponent === undefined))
199.     return this.xComponent;
200.   }
201. }

202. // model/PipManager.ets
203. import { PiPWindow, typeNode } from '@kit.ArkUI';
204. import { BusinessError } from '@kit.BasicServicesKit';
205. import { XCNodeController } from './XCNodeController';
206. import { AVPlayer } from './AVPlayer'

207. export class CustomXComponentController extends XComponentController {
208.   onSurfaceCreated(surfaceId: string): void {
209.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
210.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
211.       return;
212.     }
213.     // 将surfaceId设置给媒体源
214.     PipManager.getInstance().player.surfaceID = surfaceId;
215.     PipManager.getInstance().player.avPlayerFdSrc();
216.   }

217.   onSurfaceDestroyed(surfaceId: string): void {
218.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
219.   }
220. }

221. const TAG = 'PipManager';

222. export class PipManager {
223.   private static instance: PipManager = new PipManager();
224.   private pipController?: PiPWindow.PiPController = undefined;
225.   private xcNodeController: XCNodeController;
226.   private mXComponentController: XComponentController;
227.   private lifeCycleCallback: Set<Function> = new Set();
228.   player: AVPlayer;

229.   public static getInstance(): PipManager {
230.     return PipManager.instance;
231.   }

232.   constructor() {
233.     this.xcNodeController = new XCNodeController();
234.     this.player = new AVPlayer();
235.     this.mXComponentController = new CustomXComponentController();
236.   }

237.   public registerLifecycleCallback(callBack: Function) {
238.     this.lifeCycleCallback.add(callBack);
239.   }

240.   public unRegisterLifecycleCallback(callBack: Function): void {
241.     this.lifeCycleCallback.delete(callBack);
242.   }

243.   getNode(): typeNode.XComponent | null {
244.     return this.xcNodeController.getNode();
245.   }

246.   onActionEvent(control: PiPWindow.ControlEventParam) {
247.     switch (control.controlType) {
248.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
249.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
250.           //停止视频
251.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
252.           //播放视频
253.         }
254.         break;
255.       case PiPWindow.PiPControlType.VIDEO_NEXT:
256.         // 切换到下一个视频
257.         break;
258.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
259.         // 切换到上一个视频
260.         break;
261.       case PiPWindow.PiPControlType.FAST_FORWARD:
262.         // 视频进度快进
263.         break;
264.       case PiPWindow.PiPControlType.FAST_BACKWARD:
265.         // 视频进度后退
266.         break;
267.       default:
268.         break;
269.     }
270.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
271.   }

272.   onStateChange(state: PiPWindow.PiPState, reason: string) {
273.     let curState: string = '';
274.     this.xcNodeController.setCanAddNode(
275.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
276.     if (this.lifeCycleCallback !== null) {
277.       this.lifeCycleCallback.forEach((fun) => {
278.         fun(state);
279.       });
280.     }
281.     switch (state) {
282.       case PiPWindow.PiPState.ABOUT_TO_START:
283.         curState = "ABOUT_TO_START";
284.         // 将typeNode节点从布局移除
285.         this.xcNodeController.removeNode();
286.         break;
287.       case PiPWindow.PiPState.STARTED:
288.         curState = "STARTED";
289.         break;
290.       case PiPWindow.PiPState.ABOUT_TO_STOP:
291.         curState = "ABOUT_TO_STOP";
292.         break;
293.       case PiPWindow.PiPState.STOPPED:
294.         curState = "STOPPED";
295.         break;
296.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
297.         curState = "ABOUT_TO_RESTORE";
298.         break;
299.       case PiPWindow.PiPState.ERROR:
300.         curState = "ERROR";
301.         break;
302.       default:
303.         break;
304.     }
305.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
306.   }

307.   unregisterPipStateChangeListener() {
308.     console.info(`${TAG} aboutToDisappear`);
309.     this.pipController?.off('stateChange');
310.     this.pipController?.off('controlEvent');
311.   }

312.   getXComponentController(): CustomXComponentController {
313.     return this.mXComponentController;
314.   }

315.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
316.   init(ctx: Context) {
317.     if (this.pipController !== null && this.pipController != undefined) {
318.       return;
319.     }
320.     console.info(`${TAG} onPageShow`)
321.     if (!PiPWindow.isPiPEnabled()) {
322.       console.error(TAG, `picture in picture disabled for current OS`);
323.       return;
324.     }

325.     let config: PiPWindow.PiPConfiguration = {
326.       context: ctx,
327.       componentController: this.getXComponentController(),
328.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
329.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
330.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
331.     };
332.     // 通过create接口创建画中画控制器实例

333.     PiPWindow.create(config, this.xcNodeController.getNode()).then((controller: PiPWindow.PiPController) => {
334.       this.pipController = controller;
335.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
336.       this.pipController?.setAutoStartEnabled(true);
337.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
338.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
339.         this.onStateChange(state, reason);
340.       });
341.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
342.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
343.         this.onActionEvent(control);
344.       });
345.     }).catch((err: BusinessError) => {
346.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
347.     });
348.   }

349.   // 步骤2：启动画中画
350.   startPip() {
351.     this.pipController?.startPiP().then(() => {
352.       console.info(TAG, `Succeeded in starting pip.`);
353.     }).catch((err: BusinessError) => {
354.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
355.     });
356.   }

357.   // 步骤3：更新媒体源尺寸信息
358.   updateContentSize(width: number, height: number) {
359.     if (this.pipController) {
360.       this.pipController.updateContentSize(width, height);
361.     }
362.   }

363.   // 步骤4：关闭画中画
364.   stopPip() {
365.     if (this.pipController === null || this.pipController === undefined) {
366.       return;
367.     }
368.     let promise: Promise<void> = this.pipController.stopPiP();
369.     promise.then(() => {
370.       console.info(TAG, `Succeeded in stopping pip.`);
371.     }).catch((err: BusinessError) => {
372.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
373.     });
374.   }

375.   getNodeController(): XCNodeController {
376.     console.info(TAG, `getNodeController.`);
377.     return this.xcNodeController;
378.   }

379.   setAutoStart(autoStart: boolean): void {
380.     this.pipController?.setAutoStartEnabled(autoStart);
381.   }

382.   removeNode() {
383.     this.xcNodeController.removeNode();
384.   }

385.   addNode(): void {
386.     this.xcNodeController.addNode();
387.   }
388. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.43251788662118222639209142237415:50001231000000:2800:ED88DA0D006FA169793382180F6B34B01E963A82202F4F13B8F4EC390D885240.gif "点击放大")

## 应用使用单界面Ability时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { PiPWindow } from '@kit.ArkUI'; // 引入PiPWindow模块

14. const TAG = 'Index'
15. @Entry
16. @Component
17. struct Index {
18.   private callback: Function = (state: PiPWindow.PiPState) => {
19.     if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
20.       // 画中画关闭或还原时触发ABOUT_TO_STOP生命周期，此时需要重新添加节点
21.       PipManager.getInstance().addNode();
22.     }
23.   };

24.   build() {
25.     Column() {
26.       Text('This is MainPage')
27.         .fontSize(30)
28.         .fontWeight(FontWeight.Bold)
29.         .margin({ bottom: 20 })

30.       // 将typeNode添加到页面布局中
31.       NodeContainer(PipManager.getInstance().getNodeController())
32.         .size({ width: '100%', height: '800px' })

33.       Row({ space: 20 }) {
34.         Button('startPip') // 启动画中画
35.           .onClick(() => {
36.             PipManager.getInstance().startPip();
37.           })

38.         Button('stopPip') // 停止画中画
39.           .onClick(() => {
40.             PipManager.getInstance().stopPip();
41.           })

42.         Button('updateSize') // 更新视频尺寸
43.           .onClick(() => {
44.             // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
45.             // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
46.             PipManager.getInstance().updateContentSize(900, 1600);
47.           })
48.       }
49.       .backgroundColor('#4da99797')
50.       .size({ width: '100%', height: 60 })
51.       .justifyContent(FlexAlign.SpaceAround)
52.     }
53.     .justifyContent(FlexAlign.Center)
54.     .width('100%')
55.     .height('100%')
56.   }

57.   aboutToAppear(): void {
58.     PipManager.getInstance().registerLifecycleCallback(this.callback);
59.   }

60.   aboutToDisappear(): void {
61.     PipManager.getInstance().unregisterPipStateChangeListener();
62.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
63.   }

64.   onPageShow(): void {
65.     console.info(TAG, 'onPageShow')
66.     PipManager.getInstance().init(this.getUIContext().getHostContext() as Context);
67.     PipManager.getInstance().setAutoStart(true);
68.   }

69.   onPageHide(): void {
70.     console.info(TAG, 'onPageHide')
71.     PipManager.getInstance().setAutoStart(false);
72.   }
73. }

74. // model/XCNodeController.ets
75. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
76. import { PipManager } from './PipManager';

77. const TAG = 'XCNodeController';

78. // 创建自定义NodeController
79. export class XCNodeController extends NodeController {
80.   xComponent: typeNode.XComponent | null = null;
81.   private node: FrameNode | null = null;
82.   private canAddNode: boolean = true;

83.   // 设置是否可以添加节点
84.   setCanAddNode(canAddNode: boolean) {
85.     this.canAddNode = canAddNode;
86.   }

87.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
88.   makeNode(context: UIContext): FrameNode | null {
89.     this.node = new FrameNode(context);
90.     this.node.commonAttribute
91.     if (this.xComponent === null || this.xComponent === undefined) {
92.       // 创建typeNode
93.       // let xc_options: XComponentOptions = {
94.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
95.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
96.       // }
97.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

98.       // 创建XComponent类型的typeNode
99.       this.xComponent = typeNode.createNode(context, "XComponent", {
100.         type: XComponentType.SURFACE, // 类型设置为SURFACE
101.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
102.       });
103.     }
104.     if (this.canAddNode) {

105.       try {
106.         this.xComponent.getParent()?.removeChild(this.xComponent);
107.       } catch (error) {
108.         console.error(TAG, 'Failed to removeChild');
109.       }
110.       try {
111.         this.node.appendChild(this.xComponent);
112.       } catch (error) {
113.         console.error(TAG, 'Failed to appendChild');
114.       }
115.     }
116.     return this.node;
117.   }

118.   // 重新添加typeNode节点
119.   addNode() {
120.     if (this.node !== null && this.node !== undefined) {
121.       console.info(TAG, "addNode");

122.       try {
123.         this.node.appendChild(this.xComponent);
124.       } catch (error) {
125.         console.error(TAG, 'Failed to appendChild');
126.       }
127.     }
128.   }

129.   // 移除typeNode节点
130.   removeNode() {
131.     if (this.node !== null && this.node !== undefined) {
132.       console.info(TAG, "removeNode");

133.       try {
134.         this.node.removeChild(this.xComponent);
135.       } catch (error) {
136.         console.error(TAG, 'Failed to removeChild');
137.       }
138.     }
139.   }

140.   getNode(): typeNode.XComponent | null {
141.     console.info(TAG, "getNode is null: "+ (this.xComponent === null || this.xComponent === undefined));
142.     return this.xComponent;
143.   }
144. }

145. // model/PipManager.ets
146. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
147. import { BusinessError } from '@kit.BasicServicesKit';
148. import { XCNodeController } from './XCNodeController';
149. import { AVPlayer} from '../model/AVPlayer'

150. // 自定义XComponentController
151. export class CustomXComponentController extends XComponentController {
152.   onSurfaceCreated(surfaceId: string): void {
153.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
154.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
155.       return;
156.     }
157.     PipManager.getInstance().player.surfaceID = surfaceId;
158.     PipManager.getInstance().player.avPlayerFdSrc();
159.   }

160.   onSurfaceDestroyed(surfaceId: string): void {
161.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
162.   }
163. }

164. const TAG = 'PipManager';

165. export class PipManager {
166.   private static instance: PipManager = new PipManager();
167.   private pipController?: PiPWindow.PiPController = undefined;
168.   private xcNodeController: XCNodeController;
169.   private mXComponentController: XComponentController;
170.   private lifeCycleCallback: Set<Function> = new Set();
171.   player: AVPlayer;

172.   public static getInstance(): PipManager {
173.     return PipManager.instance;
174.   }

175.   constructor() {
176.     this.xcNodeController = new XCNodeController();
177.     this.player = new AVPlayer();
178.     this.mXComponentController = new CustomXComponentController();
179.   }

180.   public registerLifecycleCallback(callBack: Function) {
181.     this.lifeCycleCallback.add(callBack);
182.   }

183.   public unRegisterLifecycleCallback(callBack: Function): void {
184.     this.lifeCycleCallback.delete(callBack);
185.   }

186.   getNode(): typeNode.XComponent | null {
187.     return this.xcNodeController.getNode();
188.   }

189.   onActionEvent(control: PiPWindow.ControlEventParam) {
190.     switch (control.controlType) {
191.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
192.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
193.           //停止视频
194.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
195.           //播放视频
196.         }
197.         break;
198.       case PiPWindow.PiPControlType.VIDEO_NEXT:
199.         // 切换到下一个视频
200.         break;
201.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
202.         // 切换到上一个视频
203.         break;
204.       case PiPWindow.PiPControlType.FAST_FORWARD:
205.         // 视频进度快进
206.         break;
207.       case PiPWindow.PiPControlType.FAST_BACKWARD:
208.         // 视频进度后退
209.         break;
210.       default:
211.         break;
212.     }
213.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
214.   }

215.   onStateChange(state: PiPWindow.PiPState, reason: string) {
216.     let curState: string = '';
217.     this.xcNodeController.setCanAddNode(
218.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED);
219.     if (this.lifeCycleCallback !== null) {
220.       this.lifeCycleCallback.forEach((fun) => {
221.         fun(state);
222.       });
223.     }
224.     switch (state) {
225.       case PiPWindow.PiPState.ABOUT_TO_START:
226.         curState = "ABOUT_TO_START";
227.         // 将typeNode节点从布局移除
228.         this.xcNodeController.removeNode();
229.         break;
230.       case PiPWindow.PiPState.STARTED:
231.         curState = "STARTED";
232.         break;
233.       case PiPWindow.PiPState.ABOUT_TO_STOP:
234.         curState = "ABOUT_TO_STOP";
235.         break;
236.       case PiPWindow.PiPState.STOPPED:
237.         curState = "STOPPED";
238.         break;
239.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
240.         curState = "ABOUT_TO_RESTORE";
241.         break;
242.       case PiPWindow.PiPState.ERROR:
243.         curState = "ERROR";
244.         break;
245.       default:
246.         break;
247.     }
248.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
249.   }

250.   unregisterPipStateChangeListener() {
251.     console.info(`${TAG} aboutToDisappear`);
252.     this.pipController?.off('stateChange');
253.     this.pipController?.off('controlEvent');
254.   }

255.   getXComponentController(): CustomXComponentController {
256.     return this.mXComponentController;
257.   }

258.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
259.   init(ctx: Context) {
260.     if (this.pipController !== null && this.pipController != undefined) {
261.       return;
262.     }
263.     console.info(`${TAG} onPageShow`)
264.     if (!PiPWindow.isPiPEnabled()) {
265.       console.error(TAG, `picture in picture disabled for current OS`);
266.       return;
267.     }
268.     let config: PiPWindow.PiPConfiguration = {
269.       context: ctx,
270.       componentController: this.getXComponentController(),
271.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
272.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
273.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
274.     };
275.     // 通过create接口创建画中画控制器实例

276.     PiPWindow.create(config, this.xcNodeController.getNode()).then((controller: PiPWindow.PiPController) => {
277.       this.pipController = controller;
278.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
279.       this.pipController?.setAutoStartEnabled(true);
280.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
281.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
282.         this.onStateChange(state, reason);
283.       });
284.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
285.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
286.         this.onActionEvent(control);
287.       });
288.     }).catch((err: BusinessError) => {
289.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
290.     });
291.   }

292.   // 步骤2：启动画中画
293.   startPip() {
294.     this.pipController?.startPiP().then(() => {
295.       console.info(TAG, `Succeeded in starting pip.`);
296.     }).catch((err: BusinessError) => {
297.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
298.     });
299.   }

300.   // 步骤3：更新媒体源尺寸信息
301.   updateContentSize(width: number, height: number) {
302.     if (this.pipController) {
303.       this.pipController.updateContentSize(width, height);
304.     }
305.   }

306.   // 步骤4：关闭画中画
307.   stopPip() {
308.     if (this.pipController === null || this.pipController === undefined) {
309.       return;
310.     }
311.     let promise: Promise<void> = this.pipController.stopPiP();
312.     promise.then(() => {
313.       console.info(TAG, `Succeeded in stopping pip.`);
314.     }).catch((err: BusinessError) => {
315.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
316.     });
317.   }

318.   getNodeController(): XCNodeController {
319.     console.info(TAG, `getNodeController.`);
320.     return this.xcNodeController;
321.   }

322.   setAutoStart(autoStart: boolean): void {
323.     this.pipController?.setAutoStartEnabled(autoStart);
324.   }

325.   // 将typeNode节点添加到原父节点
326.   addNode(): void {
327.     this.xcNodeController.addNode();
328.   }
329. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.60220636021835432999711118812128:50001231000000:2800:32D9F84E2562A17EC624DDF45EF40A320736F847ED3D941BBBF08B9B5899757F.gif "点击放大")

## 示例代码

- [实现画中画效果](https://gitee.com/harmonyos_samples/guide-snippets/tree/master/ArkUIWindowPipSamples/WindowPip)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-xcomponent "使用XComponent实现画中画功能开发（ArkTS）")
# 使用typeNode实现画中画功能开发（ArkTS）

更新时间: 2025-12-16 16:39

说明

- 从API version 12开始，支持使用typeNode实现画中画功能开发。
- 在API version 20之前，支持在Phone、Tablet设备使用typeNode实现画中画功能开发；从API version 20开始，支持在Phone、PC/2in1、Tablet设备使用typeNode实现画中画功能开发。

该方式适用于任意场景下应用接入画中画功能，以下根据实际开发场景提供四个示例，分别介绍对应场景下画中画功能的实现步骤：

- [应用使用typeNode自由节点（不添加到布局）实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section7627141117162)。
- [应用使用router导航时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section1236517470234)。
- [应用使用Navigation导航时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section173761626124613)。
- [应用使用单界面Ability时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section8907336134011)。

本文以视频播放为例，介绍通过typeNode实现画中画功能的基本开发步骤。

示例中的视频播放器简易实现参考：

1. // model/AVPlayer.ets
2. // 简易播放器实现
3. import { BusinessError } from '@kit.BasicServicesKit';
4. import { common } from '@kit.AbilityKit';
5. import { media } from '@kit.MediaKit';

6. export class AVPlayer {
7.   private avPlayer?: media.AVPlayer;
8.   surfaceID: string = '';

9.   setAVPlayerCallback() {
10.     this.avPlayer?.on('seekDone', (seekDoneTime: number) => {
11.       console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);
12.     })
13.     this.avPlayer?.on('stateChange', async (state, reason) => {
14.       if (!this.avPlayer) {
15.         return;
16.       }
17.       switch (state) {
18.         case 'idle':
19.           this.avPlayer.release();
20.           break;
21.         case 'initialized':
22.           this.avPlayer.surfaceId = this.surfaceID;
23.           this.avPlayer.prepare().then(() => {
24.             console.info('AVPlayer prepare succeeded.');
25.           }, (err: BusinessError) => {
26.             console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);
27.           });
28.           break;
29.         case 'prepared':
30.           this.avPlayer.play();
31.           break;
32.         case 'stopped':
33.           this.avPlayer.reset();
34.           break;
35.         default:
36.           break;
37.       }
38.     })
39.   }

40.   async avPlayerFdSrc() {

41.     try {
42.       this.avPlayer = await media.createAVPlayer();
43.     } catch(err) {
44.       console.error(`create AVPlayer failed`);
45.     };
46.     this.setAVPlayerCallback();
47.     let uiContext = AppStorage.get('UIContext') as UIContext;
48.     let context = uiContext.getHostContext() as common.UIAbilityContext;
49.     let fileDescriptor = await context.resourceManager.getRawFd('xxx.mp4');

50.     if (this.avPlayer) {
51.       this.avPlayer.fdSrc = fileDescriptor;
52.     }
53.   }
54. }

## 约束与限制

- 构造PiPConfiguration参数时，建议传入contentWidth和contentHeight参数用以计算画中画初始比例，否则系统将以16:9的比例呈现画中画窗口。
- contentNode支持XComponentType.SURFACE类型，且创建typeNode时必须指定为"XComponent"类型。

## 应用使用typeNode自由节点（不添加到布局）实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 通过主窗口UIContext创建typeNode节点。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';
4. import { PipManager } from '../model/PipManager';

5. export default class EntryAbility extends UIAbility {
6.   onWindowStageCreate(windowStage: window.WindowStage): void {
7.     windowStage.loadContent('pages/Index', (err) => {
8.       // ...
9.     });
10.     windowStage.getMainWindow().then((window) => {
11.       let ctx = window.getUIContext();
12.       AppStorage.setOrCreate('UIContext', ctx);
13.       // 通过主窗口UIContext创建typeNode节点
14.       PipManager.getInstance().makeTypeNode(ctx);
15.     })
16.   }
17. }

18. // Index.ets
19. // 该页面用于展示应用布局文件，创建的typeNode节点不会添加到该布局中
20. import { PipManager } from '../model/PipManager';

21. const TAG = 'Index'
22. @Entry
23. @Component
24. struct Index {
25.   build() {
26.     Column() {
27.       Text('This is MainPage')
28.         .fontSize(30)
29.         .fontWeight(FontWeight.Bold)
30.         .margin({ bottom: 20 })

31.       Text('This is not typeNode')
32.         .size({ width: '100%', height: '800px' })
33.         .fontSize(30)
34.         .textAlign(TextAlign.Center)
35.         .fontWeight(FontWeight.Bold)
36.         .backgroundColor('#4d5b5858')

37.       Row({ space: 20 }) {
38.         Button('startPip') // 启动画中画
39.           .onClick(() => {
40.             PipManager.getInstance().startPip();
41.           })

42.         Button('stopPip') // 停止画中画
43.           .onClick(() => {
44.             PipManager.getInstance().stopPip();
45.           })

46.         Button('updateSize') // 更新视频尺寸
47.           .onClick(() => {
48.             PipManager.getInstance().updateContentSize(900, 1600);
49.           })
50.       }
51.       .backgroundColor('#4da99797')
52.       .size({ width: '100%', height: 60 })
53.       .justifyContent(FlexAlign.SpaceAround)
54.     }
55.     .justifyContent(FlexAlign.Center)
56.     .width('100%')
57.     .height('100%')
58.   }

59.   aboutToDisappear(): void {
60.     PipManager.getInstance().unregisterPipStateChangeListener(); // 解注册画中画生命周期及状态回调
61.   }

62.   onPageShow(): void {
63.     console.info(TAG, 'onPageShow')
64.     PipManager.getInstance().init(this.getUIContext().getHostContext() as Context); // 创建画中画控制器
65.     PipManager.getInstance().setAutoStart(true); // 设置应用退后台时自动启动画中画
66.   }

67.   onPageHide(): void {
68.     console.info(TAG, 'onPageHide')
69.     PipManager.getInstance().setAutoStart(false);
70.   }
71. }

72. // model/PipManager.ets
73. // 画中画控制器单例
74. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
75. import { BusinessError } from '@kit.BasicServicesKit';
76. import { AVPlayer} from '../model/AVPlayer'

77. // 自定义XComponentController
78. class CustomXComponentController extends XComponentController {
79.   // 监听onSurfaceCreated，并将surfaceId设置给播放器
80.   onSurfaceCreated(surfaceId: string): void {
81.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
82.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
83.       return;
84.     }
85.     PipManager.getInstance().player.surfaceID = surfaceId;
86.     PipManager.getInstance().player.avPlayerFdSrc();
87.   }

88.   onSurfaceDestroyed(surfaceId: string): void {
89.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
90.   }
91. }

92. const TAG = 'PipManager';

93. export class PipManager {
94.   player: AVPlayer;
95.   private static instance: PipManager = new PipManager();
96.   private pipController?: PiPWindow.PiPController = undefined;
97.   private mXComponentController: XComponentController;
98.   private xComponent: typeNode.XComponent| null = null; // typeNode节点

99.   public static getInstance(): PipManager {
100.     return PipManager.instance;
101.   }

102.   constructor() {
103.     this.player = new AVPlayer();
104.     this.mXComponentController = new CustomXComponentController();
105.   }

106.   onActionEvent(control: PiPWindow.ControlEventParam) {
107.     switch (control.controlType) {
108.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
109.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
110.           //停止视频
111.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
112.           //播放视频
113.         }
114.         break;
115.       case PiPWindow.PiPControlType.VIDEO_NEXT:
116.         // 切换到下一个视频
117.         break;
118.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
119.         // 切换到上一个视频
120.         break;
121.       case PiPWindow.PiPControlType.FAST_FORWARD:
122.         // 视频进度快进
123.         break;
124.       case PiPWindow.PiPControlType.FAST_BACKWARD:
125.         // 视频进度后退
126.         break;
127.       default:
128.         break;
129.     }
130.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
131.   }

132.   // 监听画中画生命周期
133.   onStateChange(state: PiPWindow.PiPState, reason: string) {
134.     let curState: string = '';
135.     switch (state) {
136.       case PiPWindow.PiPState.ABOUT_TO_START:
137.         curState = "ABOUT_TO_START";
138.         break;
139.       case PiPWindow.PiPState.STARTED:
140.         curState = "STARTED";
141.         break;
142.       case PiPWindow.PiPState.ABOUT_TO_STOP:
143.         curState = "ABOUT_TO_STOP";
144.         break;
145.       case PiPWindow.PiPState.STOPPED:
146.         curState = "STOPPED";
147.         break;
148.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
149.         curState = "ABOUT_TO_RESTORE";
150.         break;
151.       case PiPWindow.PiPState.ERROR:
152.         curState = "ERROR";
153.         break;
154.       default:
155.         break;
156.     }
157.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
158.   }

159.   // 解注册监听
160.   unregisterPipStateChangeListener() {
161.     console.info(TAG, 'aboutToDisappear');
162.     this.pipController?.off('stateChange');
163.     this.pipController?.off('controlEvent');
164.   }

165.   getXComponentController(): CustomXComponentController {
166.     return this.mXComponentController;
167.   }

168.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
169.   init(ctx: Context) {
170.     if (this.pipController !== null && this.pipController != undefined) {
171.       return;
172.     }
173.     console.info(TAG, 'onPageShow');
174.     if (!PiPWindow.isPiPEnabled()) {
175.       console.error(TAG, `picture in picture disabled for current OS`);
176.       return;
177.     }

178.     let config: PiPWindow.PiPConfiguration = {
179.       context: ctx,
180.       componentController: this.getXComponentController(),
181.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
182.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则将设置为16:9默认比例
183.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则将设置为16:9默认比例
184.     };
185.     // 通过create接口创建画中画控制器实例

186.     PiPWindow.create(config, this.xComponent).then((controller: PiPWindow.PiPController) => {
187.       this.pipController = controller;
188.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
189.       this.pipController.setAutoStartEnabled(true);
190.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
191.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
192.         this.onStateChange(state, reason);
193.       });
194.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
195.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
196.         this.onActionEvent(control);
197.       });
198.     }).catch((err: BusinessError) => {
199.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
200.     });
201.   }

202.   // 步骤2：创建画中画控制器实例后，通过startPiP接口启动画中画
203.   startPip() {
204.     this.pipController?.startPiP().then(() => {
205.       console.info(TAG, `Succeeded in starting pip.`);
206.     }).catch((err: BusinessError) => {
207.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
208.     });
209.   }

210.   // 步骤3：更新媒体源尺寸信息
211.   updateContentSize(width: number, height: number) {
212.     if (this.pipController) {
213.       this.pipController.updateContentSize(width, height);
214.     }
215.   }

216.   // 步骤4：关闭画中画
217.   stopPip() {
218.     if (this.pipController === null || this.pipController === undefined) {
219.       return;
220.     }
221.     let promise: Promise<void> = this.pipController.stopPiP();
222.     promise.then(() => {
223.       console.info(TAG, `Succeeded in stopping pip.`);
224.     }).catch((err: BusinessError) => {
225.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
226.     });
227.   }

228.   setAutoStart(autoStart: boolean): void {
229.     this.pipController?.setAutoStartEnabled(autoStart);
230.   }

231.   // 创建typeNode节点
232.   makeTypeNode(ctx: UIContext) {
233.     if (this.xComponent === null || this.xComponent === undefined) {
234.       // 创建typeNode
235.       // let xc_options: XComponentOptions = {
236.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
237.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
238.       // }
239.       // this.xComponent = typeNode.createNode(ctx, "XComponent", xc_options);

240.       // 创建XComponent类型的typeNode
241.       this.xComponent = typeNode.createNode(ctx, "XComponent", {
242.         type: XComponentType.SURFACE, // 类型设置为SURFACE
243.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
244.       });
245.     }
246.   }
247. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.90557765226952201292377370988578:50001231000000:2800:CA399A5B260CE4512EC1508F4ED7A8922924014E1AF31834D14D86BEB03CD60C.gif "点击放大")

## 应用使用router导航时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新跳转到原界面。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.      // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { PiPWindow, router, Router } from '@kit.ArkUI'; // 引入PiPWindow模块

14. const TAG = 'Index'
15. @Entry
16. @Component
17. struct Index {
18.   private page1: string = 'pages/Page1';
19.   private pageRouter: Router | null = null;

20.   // 画中画生命周期事件监听，用于页面及节点操作
21.   private callback: Function = (state: PiPWindow.PiPState) => {
22.     console.info(TAG, `pipStateChange: state ${state}`);
23.     if (state === PiPWindow.PiPState.ABOUT_TO_START) {
24.       // 返回到上级页面（可选）
25.       this.pageRouter?.back();
26.     } else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
27.       // 重新将typeNode节点添加到布局中，例如还原场景
28.       PipManager.getInstance().addNode();
29.     } else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
30.       // 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
31.       this.jumpNext();
32.     }
33.   };

34.   aboutToAppear(): void {
35.     this.pageRouter = this.getUIContext().getRouter();
36.     PipManager.getInstance().registerLifecycleCallback(this.callback);
37.   }

38.   aboutToDisappear(): void {
39.     PipManager.getInstance().unregisterPipStateChangeListener();
40.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
41.   }

42.   jumpNext(): void {
43.     let topPage = this.pageRouter?.getState();
44.     if (topPage !== undefined && (this.page1.toString() === topPage.path + topPage.name)) {
45.       console.info(TAG, `page1 aready at top`)
46.       return;
47.     }
48.     this.pageRouter?.pushUrl({
49.       url: this.page1 // 目标url
50.     }, router.RouterMode.Standard, (err) => {
51.       if (err) {
52.         console.error(TAG, `Invoke pushUrl failed, code is ${err.code}: ${err.message}`);
53.         return;
54.       }
55.       console.info(TAG, 'Invoke pushUrl succeeded.');
56.     });
57.   }

58.   build() {
59.     Row() {
60.       Column() {
61.         Text('Main Page')
62.           .fontSize(50)
63.           .fontWeight(FontWeight.Bold)

64.         Button('Jump Next')
65.           .onClick(() => {
66.             this.jumpNext();
67.           })
68.           .margin({ top: 16, bottom: 16 })
69.       }
70.       .width('100%')
71.     }
72.     .height('100%')
73.   }
74. }

75. // pages/Page1.ets
76. import { PipManager } from '../model/PipManager';

77. const TAG = 'Page1';

78. @Entry
79. @Component
80. export struct Page1 {
81.   build() {
82.     Column() {
83.       Text('This is Page1')
84.         .fontSize(30)
85.         .fontWeight(FontWeight.Bold)
86.         .margin({bottom: 20})

87.       // 将typeNode添加到页面布局中
88.       NodeContainer(PipManager.getInstance().getNodeController())
89.         .size({ width: '100%', height: '800px' })

90.       Row({ space: 20 }) {
91.         Button('startPip')// 启动画中画
92.           .onClick(() => {
93.             PipManager.getInstance().startPip();
94.           })

95.         Button('stopPip')// 停止画中画
96.           .onClick(() => {
97.             PipManager.getInstance().stopPip();
98.           })

99.         Button('updateSize')// 更新视频尺寸
100.           .onClick(() => {
101.             // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
102.             // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
103.             PipManager.getInstance().updateContentSize(900, 1600);
104.           })
105.       }
106.       .backgroundColor('#4da99797')
107.       .size({ width: '100%', height: 60 })
108.       .justifyContent(FlexAlign.SpaceAround)
109.     }
110.     .justifyContent(FlexAlign.Center)
111.     .width('100%')
112.     .height('100%')
113.   }

114.   onPageShow(): void {
115.     console.info(TAG, 'onPageShow')
116.     PipManager.getInstance().initPipController(this.getUIContext().getHostContext() as Context);
117.     PipManager.getInstance().setAutoStart(true);
118.   }

119.   onPageHide(): void {
120.     console.info(TAG, 'onPageHide')
121.     PipManager.getInstance().setAutoStart(false);
122.     PipManager.getInstance().removeNode();
123.   }
124. }

125. // model/PipManager.ets
126. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
127. import { BusinessError } from '@kit.BasicServicesKit';
128. import { XCNodeController } from './XCNodeController';
129. import { AVPlayer } from './AVPlayer';

130. export class CustomXComponentController extends XComponentController {
131.   onSurfaceCreated(surfaceId: string): void {
132.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
133.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
134.       return;
135.     }
136.     // 将surfaceId设置给媒体源
137.     PipManager.getInstance().player.surfaceID = surfaceId;
138.     PipManager.getInstance().player.avPlayerFdSrc();
139.   }

140.   onSurfaceDestroyed(surfaceId: string): void {
141.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
142.   }
143. }

144. const TAG = 'PipManager';

145. export class PipManager {
146.   private static instance: PipManager = new PipManager();
147.   private pipController?: PiPWindow.PiPController = undefined;
148.   private xcNodeController: XCNodeController;
149.   private mXComponentController: XComponentController;
150.   private lifeCycleCallback: Set<Function> = new Set();
151.   player: AVPlayer;

152.   public static getInstance(): PipManager {
153.     return PipManager.instance;
154.   }

155.   constructor() {
156.     this.xcNodeController = new XCNodeController();
157.     this.player = new AVPlayer();
158.     this.mXComponentController = new CustomXComponentController();
159.   }

160.   public registerLifecycleCallback(callBack: Function) {
161.     this.lifeCycleCallback.add(callBack);
162.   }

163.   public unRegisterLifecycleCallback(callBack: Function): void {
164.     this.lifeCycleCallback.delete(callBack);
165.   }

166.   getNode(): typeNode.XComponent | null {
167.     return this.xcNodeController.getNode();
168.   }

169.   onActionEvent(control: PiPWindow.ControlEventParam) {
170.     switch (control.controlType) {
171.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
172.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
173.           //停止视频
174.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
175.           //播放视频
176.         }
177.         break;
178.       case PiPWindow.PiPControlType.VIDEO_NEXT:
179.         // 切换到下一个视频
180.         break;
181.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
182.         // 切换到上一个视频
183.         break;
184.       case PiPWindow.PiPControlType.FAST_FORWARD:
185.         // 视频进度快进
186.         break;
187.       case PiPWindow.PiPControlType.FAST_BACKWARD:
188.         // 视频进度后退
189.         break;
190.       default:
191.         break;
192.     }
193.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
194.   }

195.   onStateChange(state: PiPWindow.PiPState, reason: string) {
196.     let curState: string = '';
197.     this.xcNodeController.setCanAddNode(
198.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
199.     if (this.lifeCycleCallback !== null) {
200.       this.lifeCycleCallback.forEach((fun) => {
201.         fun(state)
202.       });
203.     }
204.     switch (state) {
205.       case PiPWindow.PiPState.ABOUT_TO_START:
206.         curState = "ABOUT_TO_START";
207.         // 将typeNode节点从布局移除
208.         this.xcNodeController.removeNode();
209.         break;
210.       case PiPWindow.PiPState.STARTED:
211.         curState = "STARTED";
212.         break;
213.       case PiPWindow.PiPState.ABOUT_TO_STOP:
214.         curState = "ABOUT_TO_STOP";
215.         break;
216.       case PiPWindow.PiPState.STOPPED:
217.         curState = "STOPPED";
218.         break;
219.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
220.         curState = "ABOUT_TO_RESTORE";
221.         break;
222.       case PiPWindow.PiPState.ERROR:
223.         curState = "ERROR";
224.         break;
225.       default:
226.         break;
227.     }
228.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
229.   }

230.   unregisterPipStateChangeListener() {
231.     console.info(`${TAG} aboutToDisappear`)
232.     this.pipController?.off('stateChange');
233.     this.pipController?.off('controlEvent');
234.   }

235.   getXComponentController(): CustomXComponentController {
236.     return this.mXComponentController;
237.   }

238.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
239.   initPipController(ctx: Context) {
240.     if (this.pipController !== null && this.pipController != undefined) {
241.       return;
242.     }
243.     console.info(`${TAG} onPageShow`)
244.     if (!PiPWindow.isPiPEnabled()) {
245.       console.error(TAG, `picture in picture disabled for current OS`);
246.       return;
247.     }
248.     let config: PiPWindow.PiPConfiguration = {
249.       context: ctx,
250.       componentController: this.getXComponentController(),
251.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
252.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
253.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
254.     };
255.     // 通过create接口创建画中画控制器实例

256.     PiPWindow.create(config, this.getNode()).then((controller: PiPWindow.PiPController) => {
257.       this.pipController = controller;
258.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
259.       this.pipController.setAutoStartEnabled(true)
260.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
261.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
262.         this.onStateChange(state, reason);
263.       });
264.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
265.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
266.         this.onActionEvent(control);
267.       });
268.     }).catch((err: BusinessError) => {
269.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
270.     });
271.   }

272.   // 步骤2：启动画中画
273.   startPip() {
274.     this.pipController?.startPiP().then(() => {
275.       console.info(TAG, `Succeeded in starting pip.`);
276.     }).catch((err: BusinessError) => {
277.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
278.     });
279.   }

280.   // 步骤3：更新媒体源尺寸信息
281.   updateContentSize(width: number, height: number) {
282.     if (this.pipController) {
283.       this.pipController.updateContentSize(width, height);
284.     }
285.   }

286.   // 步骤4：关闭画中画
287.   stopPip() {
288.     if (this.pipController) {
289.       let promise: Promise<void> = this.pipController.stopPiP();
290.       promise.then(() => {
291.         console.info(TAG, `Succeeded in stopping pip.`);
292.       }).catch((err: BusinessError) => {
293.         console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
294.       });
295.     }
296.   }

297.   getNodeController(): XCNodeController {
298.     console.info(TAG, `getNodeController.`);
299.     return this.xcNodeController;
300.   }

301.   setAutoStart(autoStart: boolean): void {
302.     this.pipController?.setAutoStartEnabled(autoStart);
303.   }

304.   removeNode(): void {
305.     this.xcNodeController.removeNode();
306.   }

307.   addNode(): void {
308.     this.xcNodeController.addNode();
309.   }
310. }

311. // model/XCNodeController.ets
312. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
313. import { PipManager } from './PipManager';

314. const TAG = 'XCNodeController';
315. // 创建自定义NodeController
316. export class XCNodeController extends NodeController {
317.   xComponent: typeNode.XComponent | null = null;
318.   private node: FrameNode | null = null;
319.   private canAddNode: boolean = true;

320.   // 设置是否可以添加节点
321.   setCanAddNode(canAddNode: boolean) {
322.     this.canAddNode = canAddNode;
323.   }

324.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
325.   makeNode(context: UIContext): FrameNode | null {
326.     this.node = new FrameNode(context);
327.     this.node.commonAttribute
328.     if (this.xComponent === null || this.xComponent === undefined) {
329.       // 创建typeNode
330.       // let xc_options: XComponentOptions = {
331.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
332.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
333.       // }
334.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

335.       // 创建XComponent类型的typeNode
336.       this.xComponent = typeNode.createNode(context, "XComponent", {
337.         type: XComponentType.SURFACE, // 类型设置为SURFACE
338.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
339.       });
340.     }
341.     if (this.canAddNode) {

342.       try {
343.         this.xComponent.getParent()?.removeChild(this.xComponent);
344.       } catch (error) {
345.         console.error(TAG, 'Failed to removeChild');
346.       }
347.       try {
348.         this.node.appendChild(this.xComponent);
349.       } catch (error) {
350.         console.error(TAG, 'Failed to appendChild');
351.       }
352.     }
353.     return this.node;
354.   }

355.   // 重新添加typeNode节点
356.   addNode() {
357.     if (this.node !== null && this.node !== undefined) {
358.       console.info(TAG, "addNode");

359.       try {
360.         this.node.appendChild(this.xComponent);
361.       } catch (error) {
362.         console.error(TAG, 'Failed to appendChild');
363.       }
364.     }
365.   }

366.   // 移除typeNode节点
367.   removeNode() {
368.     if (this.node !== null && this.node !== undefined) {
369.       console.info(TAG, "removeNode");

370.       try {
371.         this.node.removeChild(this.xComponent);
372.       } catch (error) {
373.         console.error(TAG, 'Failed to removeChild');
374.       }
375.     }
376.   }

377.   getNode(): typeNode.XComponent | null {
378.     console.info(TAG, "getNode is null:"+ (this.xComponent === null || this.xComponent === undefined))
379.     return this.xComponent;
380.   }
381. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.82469444221375517554757238487910:50001231000000:2800:D265F3EF899EAB29F484FC57231645CC4A2F93D0A92692BB6F191A779E80810D.gif "点击放大")

## 应用使用Navigation导航时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新跳转到原界面。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { Page1 } from "../pages/Page1"
14. import { PiPWindow } from '@kit.ArkUI';

15. const TAG = 'Index1';

16. @Entry
17. @Component
18. struct Index {
19.   @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack();
20.   // 画中画生命周期事件监听，用于页面及节点操作
21.   private callback: Function = (state: PiPWindow.PiPState) => {
22.     console.info(TAG, `pipStateChange: state ${state}`);
23.     if (state === PiPWindow.PiPState.ABOUT_TO_START) {
24.       // 返回到上级页面（可选）
25.       this.pageInfos.pop();
26.     } else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
27.       // 重新将typeNode节点添加到布局中，例如还原场景
28.       PipManager.getInstance().addNode();
29.     } else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
30.       // 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
31.       this.jumpNext();
32.     }
33.   };

34.   jumpNext() {
35.     if (this.pageInfos.getAllPathName()[0] === 'Page1') {
36.       console.log(TAG, 'Page1 already at top');
37.       return;
38.     }
39.     this.pageInfos.pushPath({ name: 'Page1' });
40.   }

41.   aboutToAppear(): void {
42.     PipManager.getInstance().registerLifecycleCallback(this.callback);
43.   }

44.   aboutToDisappear(): void {
45.     PipManager.getInstance().unregisterPipStateChangeListener();
46.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
47.   }

48.   @Builder
49.   PageMap(name: string) {
50.     if (name === 'Page1') {
51.       Page1();
52.     }
53.   }

54.   build() {
55.     Navigation(this.pageInfos) {
56.       Column() {
57.         Text("This is Main Page")
58.         Column()
59.           .height('200px')
60.         Row({ space: 12 }) {
61.           Button("Jump Page1")
62.             .width('80%')
63.             .height(40)
64.             .margin(20)
65.             .onClick(() => {
66.               this.jumpNext();
67.             })
68.         }
69.       }
70.       .height("100%")
71.       .width("100%")
72.       .justifyContent(FlexAlign.Center)
73.       .backgroundColor("#DCDCDC")
74.     }.title('MainTitle')
75.     .navDestination(this.PageMap)
76.   }
77. }

78. // pages/Page1.ets
79. import { PipManager } from '../model/PipManager';

80. const TAG = 'Page1';

81. @Entry
82. @Component
83. export struct Page1 {
84.   build() {
85.     NavDestination() {
86.       Column() {
87.         Text('This is Page1')
88.           .fontSize(30)
89.           .fontWeight(FontWeight.Bold)
90.           .margin({bottom: 20})

91.         // 将typeNode添加到页面布局中
92.         NodeContainer(PipManager.getInstance().getNodeController())
93.           .size({ width: '100%', height: '800px' })

94.         Row({ space: 20 }) {
95.           Button('startPip') // 启动画中画
96.             .onClick(() => {
97.               PipManager.getInstance().startPip();
98.             })
99.           Button('stopPip') // 停止画中画
100.             .onClick(() => {
101.               PipManager.getInstance().stopPip();
102.             })
103.           Button('updateSize') // 更新视频尺寸
104.             .onClick(() => {
105.               // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
106.               // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
107.               PipManager.getInstance().updateContentSize(900, 1600);
108.             })
109.         }
110.         .backgroundColor('#4da99797')
111.         .size({ width: '100%', height: 60 })
112.         .justifyContent(FlexAlign.SpaceAround)
113.       }
114.       .justifyContent(FlexAlign.Center)
115.       .width('100%')
116.       .height('100%')
117.     }
118.     .title('page1')
119.     .onShown(()=>{
120.       console.info(TAG, 'onShown')
121.       PipManager.getInstance().init(this.getUIContext().getHostContext() as Context);
122.       PipManager.getInstance().setAutoStart(true);
123.     })
124.     .onHidden(()=>{
125.       console.info(TAG, 'onHidden')
126.       PipManager.getInstance().setAutoStart(false);
127.       PipManager.getInstance().removeNode();
128.     })
129.   }
130. }

131. // model/XCNodeController.ets
132. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
133. import { PipManager } from './PipManager';

134. const TAG = 'XCNodeController';

135. // 创建自定义NodeController
136. export class XCNodeController extends NodeController {
137.   xComponent: typeNode.XComponent| null = null;
138.   private node: FrameNode | null = null;
139.   private canAddNode: boolean = true;

140.   // 设置是否可以添加节点
141.   setCanAddNode(canAddNode: boolean) {
142.     this.canAddNode = canAddNode;
143.   }

144.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
145.   makeNode(context: UIContext): FrameNode | null {
146.     console.info(TAG, "makeNode");
147.     this.node = new FrameNode(context);
148.     if (this.xComponent === null || this.xComponent === undefined) {
149.       // 创建typeNode
150.       // let xc_options: XComponentOptions = {
151.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
152.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
153.       // }
154.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

155.       // 创建XComponent类型的typeNode
156.       this.xComponent = typeNode.createNode(context, "XComponent", {
157.         type: XComponentType.SURFACE, // 类型设置为SURFACE
158.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
159.       });
160.     }
161.     if (this.canAddNode) {

162.       try {
163.         this.xComponent.getParent()?.removeChild(this.xComponent);
164.       } catch (error) {
165.         console.error(TAG, 'Failed to removeChild');
166.       }
167.       try {
168.         this.node.appendChild(this.xComponent);
169.       } catch (error) {
170.         console.error(TAG, 'Failed to appendChild');
171.       }
172.     }
173.     return this.node;
174.   }

175.   // 重新添加typeNode节点
176.   addNode() {
177.     if (this.node !== null && this.node !== undefined) {
178.       console.info(TAG, "addNode id:"+(this.node?.getUniqueId())+" "+this.xComponent?.getUniqueId());
179.       try {
180.         this.node.appendChild(this.xComponent);
181.       } catch (error) {
182.         console.error(TAG, 'Failed to appendChild');
183.       }
184.     }
185.   }

186.   // 移除typeNode节点
187.   removeNode() {
188.     if (this.node !== null && this.node !== undefined) {
189.       console.info(TAG, "removeNode");

190.       try {
191.         this.node.removeChild(this.xComponent);
192.       } catch (error) {
193.         console.error(TAG, 'Failed to removeChild');
194.       }
195.     }
196.   }

197.   getNode(): typeNode.XComponent | null {
198.     console.info(TAG, "getNode is null:"+ (this.xComponent === null || this.xComponent === undefined))
199.     return this.xComponent;
200.   }
201. }

202. // model/PipManager.ets
203. import { PiPWindow, typeNode } from '@kit.ArkUI';
204. import { BusinessError } from '@kit.BasicServicesKit';
205. import { XCNodeController } from './XCNodeController';
206. import { AVPlayer } from './AVPlayer'

207. export class CustomXComponentController extends XComponentController {
208.   onSurfaceCreated(surfaceId: string): void {
209.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
210.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
211.       return;
212.     }
213.     // 将surfaceId设置给媒体源
214.     PipManager.getInstance().player.surfaceID = surfaceId;
215.     PipManager.getInstance().player.avPlayerFdSrc();
216.   }

217.   onSurfaceDestroyed(surfaceId: string): void {
218.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
219.   }
220. }

221. const TAG = 'PipManager';

222. export class PipManager {
223.   private static instance: PipManager = new PipManager();
224.   private pipController?: PiPWindow.PiPController = undefined;
225.   private xcNodeController: XCNodeController;
226.   private mXComponentController: XComponentController;
227.   private lifeCycleCallback: Set<Function> = new Set();
228.   player: AVPlayer;

229.   public static getInstance(): PipManager {
230.     return PipManager.instance;
231.   }

232.   constructor() {
233.     this.xcNodeController = new XCNodeController();
234.     this.player = new AVPlayer();
235.     this.mXComponentController = new CustomXComponentController();
236.   }

237.   public registerLifecycleCallback(callBack: Function) {
238.     this.lifeCycleCallback.add(callBack);
239.   }

240.   public unRegisterLifecycleCallback(callBack: Function): void {
241.     this.lifeCycleCallback.delete(callBack);
242.   }

243.   getNode(): typeNode.XComponent | null {
244.     return this.xcNodeController.getNode();
245.   }

246.   onActionEvent(control: PiPWindow.ControlEventParam) {
247.     switch (control.controlType) {
248.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
249.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
250.           //停止视频
251.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
252.           //播放视频
253.         }
254.         break;
255.       case PiPWindow.PiPControlType.VIDEO_NEXT:
256.         // 切换到下一个视频
257.         break;
258.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
259.         // 切换到上一个视频
260.         break;
261.       case PiPWindow.PiPControlType.FAST_FORWARD:
262.         // 视频进度快进
263.         break;
264.       case PiPWindow.PiPControlType.FAST_BACKWARD:
265.         // 视频进度后退
266.         break;
267.       default:
268.         break;
269.     }
270.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
271.   }

272.   onStateChange(state: PiPWindow.PiPState, reason: string) {
273.     let curState: string = '';
274.     this.xcNodeController.setCanAddNode(
275.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
276.     if (this.lifeCycleCallback !== null) {
277.       this.lifeCycleCallback.forEach((fun) => {
278.         fun(state);
279.       });
280.     }
281.     switch (state) {
282.       case PiPWindow.PiPState.ABOUT_TO_START:
283.         curState = "ABOUT_TO_START";
284.         // 将typeNode节点从布局移除
285.         this.xcNodeController.removeNode();
286.         break;
287.       case PiPWindow.PiPState.STARTED:
288.         curState = "STARTED";
289.         break;
290.       case PiPWindow.PiPState.ABOUT_TO_STOP:
291.         curState = "ABOUT_TO_STOP";
292.         break;
293.       case PiPWindow.PiPState.STOPPED:
294.         curState = "STOPPED";
295.         break;
296.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
297.         curState = "ABOUT_TO_RESTORE";
298.         break;
299.       case PiPWindow.PiPState.ERROR:
300.         curState = "ERROR";
301.         break;
302.       default:
303.         break;
304.     }
305.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
306.   }

307.   unregisterPipStateChangeListener() {
308.     console.info(`${TAG} aboutToDisappear`);
309.     this.pipController?.off('stateChange');
310.     this.pipController?.off('controlEvent');
311.   }

312.   getXComponentController(): CustomXComponentController {
313.     return this.mXComponentController;
314.   }

315.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
316.   init(ctx: Context) {
317.     if (this.pipController !== null && this.pipController != undefined) {
318.       return;
319.     }
320.     console.info(`${TAG} onPageShow`)
321.     if (!PiPWindow.isPiPEnabled()) {
322.       console.error(TAG, `picture in picture disabled for current OS`);
323.       return;
324.     }

325.     let config: PiPWindow.PiPConfiguration = {
326.       context: ctx,
327.       componentController: this.getXComponentController(),
328.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
329.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
330.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
331.     };
332.     // 通过create接口创建画中画控制器实例

333.     PiPWindow.create(config, this.xcNodeController.getNode()).then((controller: PiPWindow.PiPController) => {
334.       this.pipController = controller;
335.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
336.       this.pipController?.setAutoStartEnabled(true);
337.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
338.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
339.         this.onStateChange(state, reason);
340.       });
341.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
342.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
343.         this.onActionEvent(control);
344.       });
345.     }).catch((err: BusinessError) => {
346.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
347.     });
348.   }

349.   // 步骤2：启动画中画
350.   startPip() {
351.     this.pipController?.startPiP().then(() => {
352.       console.info(TAG, `Succeeded in starting pip.`);
353.     }).catch((err: BusinessError) => {
354.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
355.     });
356.   }

357.   // 步骤3：更新媒体源尺寸信息
358.   updateContentSize(width: number, height: number) {
359.     if (this.pipController) {
360.       this.pipController.updateContentSize(width, height);
361.     }
362.   }

363.   // 步骤4：关闭画中画
364.   stopPip() {
365.     if (this.pipController === null || this.pipController === undefined) {
366.       return;
367.     }
368.     let promise: Promise<void> = this.pipController.stopPiP();
369.     promise.then(() => {
370.       console.info(TAG, `Succeeded in stopping pip.`);
371.     }).catch((err: BusinessError) => {
372.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
373.     });
374.   }

375.   getNodeController(): XCNodeController {
376.     console.info(TAG, `getNodeController.`);
377.     return this.xcNodeController;
378.   }

379.   setAutoStart(autoStart: boolean): void {
380.     this.pipController?.setAutoStartEnabled(autoStart);
381.   }

382.   removeNode() {
383.     this.xcNodeController.removeNode();
384.   }

385.   addNode(): void {
386.     this.xcNodeController.addNode();
387.   }
388. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.43251788662118222639209142237415:50001231000000:2800:ED88DA0D006FA169793382180F6B34B01E963A82202F4F13B8F4EC390D885240.gif "点击放大")

## 应用使用单界面Ability时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { PiPWindow } from '@kit.ArkUI'; // 引入PiPWindow模块

14. const TAG = 'Index'
15. @Entry
16. @Component
17. struct Index {
18.   private callback: Function = (state: PiPWindow.PiPState) => {
19.     if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
20.       // 画中画关闭或还原时触发ABOUT_TO_STOP生命周期，此时需要重新添加节点
21.       PipManager.getInstance().addNode();
22.     }
23.   };

24.   build() {
25.     Column() {
26.       Text('This is MainPage')
27.         .fontSize(30)
28.         .fontWeight(FontWeight.Bold)
29.         .margin({ bottom: 20 })

30.       // 将typeNode添加到页面布局中
31.       NodeContainer(PipManager.getInstance().getNodeController())
32.         .size({ width: '100%', height: '800px' })

33.       Row({ space: 20 }) {
34.         Button('startPip') // 启动画中画
35.           .onClick(() => {
36.             PipManager.getInstance().startPip();
37.           })

38.         Button('stopPip') // 停止画中画
39.           .onClick(() => {
40.             PipManager.getInstance().stopPip();
41.           })

42.         Button('updateSize') // 更新视频尺寸
43.           .onClick(() => {
44.             // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
45.             // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
46.             PipManager.getInstance().updateContentSize(900, 1600);
47.           })
48.       }
49.       .backgroundColor('#4da99797')
50.       .size({ width: '100%', height: 60 })
51.       .justifyContent(FlexAlign.SpaceAround)
52.     }
53.     .justifyContent(FlexAlign.Center)
54.     .width('100%')
55.     .height('100%')
56.   }

57.   aboutToAppear(): void {
58.     PipManager.getInstance().registerLifecycleCallback(this.callback);
59.   }

60.   aboutToDisappear(): void {
61.     PipManager.getInstance().unregisterPipStateChangeListener();
62.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
63.   }

64.   onPageShow(): void {
65.     console.info(TAG, 'onPageShow')
66.     PipManager.getInstance().init(this.getUIContext().getHostContext() as Context);
67.     PipManager.getInstance().setAutoStart(true);
68.   }

69.   onPageHide(): void {
70.     console.info(TAG, 'onPageHide')
71.     PipManager.getInstance().setAutoStart(false);
72.   }
73. }

74. // model/XCNodeController.ets
75. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
76. import { PipManager } from './PipManager';

77. const TAG = 'XCNodeController';

78. // 创建自定义NodeController
79. export class XCNodeController extends NodeController {
80.   xComponent: typeNode.XComponent | null = null;
81.   private node: FrameNode | null = null;
82.   private canAddNode: boolean = true;

83.   // 设置是否可以添加节点
84.   setCanAddNode(canAddNode: boolean) {
85.     this.canAddNode = canAddNode;
86.   }

87.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
88.   makeNode(context: UIContext): FrameNode | null {
89.     this.node = new FrameNode(context);
90.     this.node.commonAttribute
91.     if (this.xComponent === null || this.xComponent === undefined) {
92.       // 创建typeNode
93.       // let xc_options: XComponentOptions = {
94.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
95.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
96.       // }
97.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

98.       // 创建XComponent类型的typeNode
99.       this.xComponent = typeNode.createNode(context, "XComponent", {
100.         type: XComponentType.SURFACE, // 类型设置为SURFACE
101.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
102.       });
103.     }
104.     if (this.canAddNode) {

105.       try {
106.         this.xComponent.getParent()?.removeChild(this.xComponent);
107.       } catch (error) {
108.         console.error(TAG, 'Failed to removeChild');
109.       }
110.       try {
111.         this.node.appendChild(this.xComponent);
112.       } catch (error) {
113.         console.error(TAG, 'Failed to appendChild');
114.       }
115.     }
116.     return this.node;
117.   }

118.   // 重新添加typeNode节点
119.   addNode() {
120.     if (this.node !== null && this.node !== undefined) {
121.       console.info(TAG, "addNode");

122.       try {
123.         this.node.appendChild(this.xComponent);
124.       } catch (error) {
125.         console.error(TAG, 'Failed to appendChild');
126.       }
127.     }
128.   }

129.   // 移除typeNode节点
130.   removeNode() {
131.     if (this.node !== null && this.node !== undefined) {
132.       console.info(TAG, "removeNode");

133.       try {
134.         this.node.removeChild(this.xComponent);
135.       } catch (error) {
136.         console.error(TAG, 'Failed to removeChild');
137.       }
138.     }
139.   }

140.   getNode(): typeNode.XComponent | null {
141.     console.info(TAG, "getNode is null: "+ (this.xComponent === null || this.xComponent === undefined));
142.     return this.xComponent;
143.   }
144. }

145. // model/PipManager.ets
146. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
147. import { BusinessError } from '@kit.BasicServicesKit';
148. import { XCNodeController } from './XCNodeController';
149. import { AVPlayer} from '../model/AVPlayer'

150. // 自定义XComponentController
151. export class CustomXComponentController extends XComponentController {
152.   onSurfaceCreated(surfaceId: string): void {
153.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
154.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
155.       return;
156.     }
157.     PipManager.getInstance().player.surfaceID = surfaceId;
158.     PipManager.getInstance().player.avPlayerFdSrc();
159.   }

160.   onSurfaceDestroyed(surfaceId: string): void {
161.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
162.   }
163. }

164. const TAG = 'PipManager';

165. export class PipManager {
166.   private static instance: PipManager = new PipManager();
167.   private pipController?: PiPWindow.PiPController = undefined;
168.   private xcNodeController: XCNodeController;
169.   private mXComponentController: XComponentController;
170.   private lifeCycleCallback: Set<Function> = new Set();
171.   player: AVPlayer;

172.   public static getInstance(): PipManager {
173.     return PipManager.instance;
174.   }

175.   constructor() {
176.     this.xcNodeController = new XCNodeController();
177.     this.player = new AVPlayer();
178.     this.mXComponentController = new CustomXComponentController();
179.   }

180.   public registerLifecycleCallback(callBack: Function) {
181.     this.lifeCycleCallback.add(callBack);
182.   }

183.   public unRegisterLifecycleCallback(callBack: Function): void {
184.     this.lifeCycleCallback.delete(callBack);
185.   }

186.   getNode(): typeNode.XComponent | null {
187.     return this.xcNodeController.getNode();
188.   }

189.   onActionEvent(control: PiPWindow.ControlEventParam) {
190.     switch (control.controlType) {
191.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
192.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
193.           //停止视频
194.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
195.           //播放视频
196.         }
197.         break;
198.       case PiPWindow.PiPControlType.VIDEO_NEXT:
199.         // 切换到下一个视频
200.         break;
201.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
202.         // 切换到上一个视频
203.         break;
204.       case PiPWindow.PiPControlType.FAST_FORWARD:
205.         // 视频进度快进
206.         break;
207.       case PiPWindow.PiPControlType.FAST_BACKWARD:
208.         // 视频进度后退
209.         break;
210.       default:
211.         break;
212.     }
213.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
214.   }

215.   onStateChange(state: PiPWindow.PiPState, reason: string) {
216.     let curState: string = '';
217.     this.xcNodeController.setCanAddNode(
218.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED);
219.     if (this.lifeCycleCallback !== null) {
220.       this.lifeCycleCallback.forEach((fun) => {
221.         fun(state);
222.       });
223.     }
224.     switch (state) {
225.       case PiPWindow.PiPState.ABOUT_TO_START:
226.         curState = "ABOUT_TO_START";
227.         // 将typeNode节点从布局移除
228.         this.xcNodeController.removeNode();
229.         break;
230.       case PiPWindow.PiPState.STARTED:
231.         curState = "STARTED";
232.         break;
233.       case PiPWindow.PiPState.ABOUT_TO_STOP:
234.         curState = "ABOUT_TO_STOP";
235.         break;
236.       case PiPWindow.PiPState.STOPPED:
237.         curState = "STOPPED";
238.         break;
239.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
240.         curState = "ABOUT_TO_RESTORE";
241.         break;
242.       case PiPWindow.PiPState.ERROR:
243.         curState = "ERROR";
244.         break;
245.       default:
246.         break;
247.     }
248.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
249.   }

250.   unregisterPipStateChangeListener() {
251.     console.info(`${TAG} aboutToDisappear`);
252.     this.pipController?.off('stateChange');
253.     this.pipController?.off('controlEvent');
254.   }

255.   getXComponentController(): CustomXComponentController {
256.     return this.mXComponentController;
257.   }

258.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
259.   init(ctx: Context) {
260.     if (this.pipController !== null && this.pipController != undefined) {
261.       return;
262.     }
263.     console.info(`${TAG} onPageShow`)
264.     if (!PiPWindow.isPiPEnabled()) {
265.       console.error(TAG, `picture in picture disabled for current OS`);
266.       return;
267.     }
268.     let config: PiPWindow.PiPConfiguration = {
269.       context: ctx,
270.       componentController: this.getXComponentController(),
271.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
272.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
273.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
274.     };
275.     // 通过create接口创建画中画控制器实例

276.     PiPWindow.create(config, this.xcNodeController.getNode()).then((controller: PiPWindow.PiPController) => {
277.       this.pipController = controller;
278.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
279.       this.pipController?.setAutoStartEnabled(true);
280.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
281.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
282.         this.onStateChange(state, reason);
283.       });
284.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
285.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
286.         this.onActionEvent(control);
287.       });
288.     }).catch((err: BusinessError) => {
289.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
290.     });
291.   }

292.   // 步骤2：启动画中画
293.   startPip() {
294.     this.pipController?.startPiP().then(() => {
295.       console.info(TAG, `Succeeded in starting pip.`);
296.     }).catch((err: BusinessError) => {
297.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
298.     });
299.   }

300.   // 步骤3：更新媒体源尺寸信息
301.   updateContentSize(width: number, height: number) {
302.     if (this.pipController) {
303.       this.pipController.updateContentSize(width, height);
304.     }
305.   }

306.   // 步骤4：关闭画中画
307.   stopPip() {
308.     if (this.pipController === null || this.pipController === undefined) {
309.       return;
310.     }
311.     let promise: Promise<void> = this.pipController.stopPiP();
312.     promise.then(() => {
313.       console.info(TAG, `Succeeded in stopping pip.`);
314.     }).catch((err: BusinessError) => {
315.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
316.     });
317.   }

318.   getNodeController(): XCNodeController {
319.     console.info(TAG, `getNodeController.`);
320.     return this.xcNodeController;
321.   }

322.   setAutoStart(autoStart: boolean): void {
323.     this.pipController?.setAutoStartEnabled(autoStart);
324.   }

325.   // 将typeNode节点添加到原父节点
326.   addNode(): void {
327.     this.xcNodeController.addNode();
328.   }
329. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.60220636021835432999711118812128:50001231000000:2800:32D9F84E2562A17EC624DDF45EF40A320736F847ED3D941BBBF08B9B5899757F.gif "点击放大")

## 示例代码

- [实现画中画效果](https://gitee.com/harmonyos_samples/guide-snippets/tree/master/ArkUIWindowPipSamples/WindowPip)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-xcomponent "使用XComponent实现画中画功能开发（ArkTS）")
# 使用typeNode实现画中画功能开发（ArkTS）

更新时间: 2025-12-16 16:39

说明

- 从API version 12开始，支持使用typeNode实现画中画功能开发。
- 在API version 20之前，支持在Phone、Tablet设备使用typeNode实现画中画功能开发；从API version 20开始，支持在Phone、PC/2in1、Tablet设备使用typeNode实现画中画功能开发。

该方式适用于任意场景下应用接入画中画功能，以下根据实际开发场景提供四个示例，分别介绍对应场景下画中画功能的实现步骤：

- [应用使用typeNode自由节点（不添加到布局）实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section7627141117162)。
- [应用使用router导航时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section1236517470234)。
- [应用使用Navigation导航时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section173761626124613)。
- [应用使用单界面Ability时通过typeNode实现画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-typenode#section8907336134011)。

本文以视频播放为例，介绍通过typeNode实现画中画功能的基本开发步骤。

示例中的视频播放器简易实现参考：

1. // model/AVPlayer.ets
2. // 简易播放器实现
3. import { BusinessError } from '@kit.BasicServicesKit';
4. import { common } from '@kit.AbilityKit';
5. import { media } from '@kit.MediaKit';

6. export class AVPlayer {
7.   private avPlayer?: media.AVPlayer;
8.   surfaceID: string = '';

9.   setAVPlayerCallback() {
10.     this.avPlayer?.on('seekDone', (seekDoneTime: number) => {
11.       console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);
12.     })
13.     this.avPlayer?.on('stateChange', async (state, reason) => {
14.       if (!this.avPlayer) {
15.         return;
16.       }
17.       switch (state) {
18.         case 'idle':
19.           this.avPlayer.release();
20.           break;
21.         case 'initialized':
22.           this.avPlayer.surfaceId = this.surfaceID;
23.           this.avPlayer.prepare().then(() => {
24.             console.info('AVPlayer prepare succeeded.');
25.           }, (err: BusinessError) => {
26.             console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);
27.           });
28.           break;
29.         case 'prepared':
30.           this.avPlayer.play();
31.           break;
32.         case 'stopped':
33.           this.avPlayer.reset();
34.           break;
35.         default:
36.           break;
37.       }
38.     })
39.   }

40.   async avPlayerFdSrc() {

41.     try {
42.       this.avPlayer = await media.createAVPlayer();
43.     } catch(err) {
44.       console.error(`create AVPlayer failed`);
45.     };
46.     this.setAVPlayerCallback();
47.     let uiContext = AppStorage.get('UIContext') as UIContext;
48.     let context = uiContext.getHostContext() as common.UIAbilityContext;
49.     let fileDescriptor = await context.resourceManager.getRawFd('xxx.mp4');

50.     if (this.avPlayer) {
51.       this.avPlayer.fdSrc = fileDescriptor;
52.     }
53.   }
54. }

## 约束与限制

- 构造PiPConfiguration参数时，建议传入contentWidth和contentHeight参数用以计算画中画初始比例，否则系统将以16:9的比例呈现画中画窗口。
- contentNode支持XComponentType.SURFACE类型，且创建typeNode时必须指定为"XComponent"类型。

## 应用使用typeNode自由节点（不添加到布局）实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 通过主窗口UIContext创建typeNode节点。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';
4. import { PipManager } from '../model/PipManager';

5. export default class EntryAbility extends UIAbility {
6.   onWindowStageCreate(windowStage: window.WindowStage): void {
7.     windowStage.loadContent('pages/Index', (err) => {
8.       // ...
9.     });
10.     windowStage.getMainWindow().then((window) => {
11.       let ctx = window.getUIContext();
12.       AppStorage.setOrCreate('UIContext', ctx);
13.       // 通过主窗口UIContext创建typeNode节点
14.       PipManager.getInstance().makeTypeNode(ctx);
15.     })
16.   }
17. }

18. // Index.ets
19. // 该页面用于展示应用布局文件，创建的typeNode节点不会添加到该布局中
20. import { PipManager } from '../model/PipManager';

21. const TAG = 'Index'
22. @Entry
23. @Component
24. struct Index {
25.   build() {
26.     Column() {
27.       Text('This is MainPage')
28.         .fontSize(30)
29.         .fontWeight(FontWeight.Bold)
30.         .margin({ bottom: 20 })

31.       Text('This is not typeNode')
32.         .size({ width: '100%', height: '800px' })
33.         .fontSize(30)
34.         .textAlign(TextAlign.Center)
35.         .fontWeight(FontWeight.Bold)
36.         .backgroundColor('#4d5b5858')

37.       Row({ space: 20 }) {
38.         Button('startPip') // 启动画中画
39.           .onClick(() => {
40.             PipManager.getInstance().startPip();
41.           })

42.         Button('stopPip') // 停止画中画
43.           .onClick(() => {
44.             PipManager.getInstance().stopPip();
45.           })

46.         Button('updateSize') // 更新视频尺寸
47.           .onClick(() => {
48.             PipManager.getInstance().updateContentSize(900, 1600);
49.           })
50.       }
51.       .backgroundColor('#4da99797')
52.       .size({ width: '100%', height: 60 })
53.       .justifyContent(FlexAlign.SpaceAround)
54.     }
55.     .justifyContent(FlexAlign.Center)
56.     .width('100%')
57.     .height('100%')
58.   }

59.   aboutToDisappear(): void {
60.     PipManager.getInstance().unregisterPipStateChangeListener(); // 解注册画中画生命周期及状态回调
61.   }

62.   onPageShow(): void {
63.     console.info(TAG, 'onPageShow')
64.     PipManager.getInstance().init(this.getUIContext().getHostContext() as Context); // 创建画中画控制器
65.     PipManager.getInstance().setAutoStart(true); // 设置应用退后台时自动启动画中画
66.   }

67.   onPageHide(): void {
68.     console.info(TAG, 'onPageHide')
69.     PipManager.getInstance().setAutoStart(false);
70.   }
71. }

72. // model/PipManager.ets
73. // 画中画控制器单例
74. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
75. import { BusinessError } from '@kit.BasicServicesKit';
76. import { AVPlayer} from '../model/AVPlayer'

77. // 自定义XComponentController
78. class CustomXComponentController extends XComponentController {
79.   // 监听onSurfaceCreated，并将surfaceId设置给播放器
80.   onSurfaceCreated(surfaceId: string): void {
81.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
82.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
83.       return;
84.     }
85.     PipManager.getInstance().player.surfaceID = surfaceId;
86.     PipManager.getInstance().player.avPlayerFdSrc();
87.   }

88.   onSurfaceDestroyed(surfaceId: string): void {
89.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
90.   }
91. }

92. const TAG = 'PipManager';

93. export class PipManager {
94.   player: AVPlayer;
95.   private static instance: PipManager = new PipManager();
96.   private pipController?: PiPWindow.PiPController = undefined;
97.   private mXComponentController: XComponentController;
98.   private xComponent: typeNode.XComponent| null = null; // typeNode节点

99.   public static getInstance(): PipManager {
100.     return PipManager.instance;
101.   }

102.   constructor() {
103.     this.player = new AVPlayer();
104.     this.mXComponentController = new CustomXComponentController();
105.   }

106.   onActionEvent(control: PiPWindow.ControlEventParam) {
107.     switch (control.controlType) {
108.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
109.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
110.           //停止视频
111.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
112.           //播放视频
113.         }
114.         break;
115.       case PiPWindow.PiPControlType.VIDEO_NEXT:
116.         // 切换到下一个视频
117.         break;
118.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
119.         // 切换到上一个视频
120.         break;
121.       case PiPWindow.PiPControlType.FAST_FORWARD:
122.         // 视频进度快进
123.         break;
124.       case PiPWindow.PiPControlType.FAST_BACKWARD:
125.         // 视频进度后退
126.         break;
127.       default:
128.         break;
129.     }
130.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
131.   }

132.   // 监听画中画生命周期
133.   onStateChange(state: PiPWindow.PiPState, reason: string) {
134.     let curState: string = '';
135.     switch (state) {
136.       case PiPWindow.PiPState.ABOUT_TO_START:
137.         curState = "ABOUT_TO_START";
138.         break;
139.       case PiPWindow.PiPState.STARTED:
140.         curState = "STARTED";
141.         break;
142.       case PiPWindow.PiPState.ABOUT_TO_STOP:
143.         curState = "ABOUT_TO_STOP";
144.         break;
145.       case PiPWindow.PiPState.STOPPED:
146.         curState = "STOPPED";
147.         break;
148.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
149.         curState = "ABOUT_TO_RESTORE";
150.         break;
151.       case PiPWindow.PiPState.ERROR:
152.         curState = "ERROR";
153.         break;
154.       default:
155.         break;
156.     }
157.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
158.   }

159.   // 解注册监听
160.   unregisterPipStateChangeListener() {
161.     console.info(TAG, 'aboutToDisappear');
162.     this.pipController?.off('stateChange');
163.     this.pipController?.off('controlEvent');
164.   }

165.   getXComponentController(): CustomXComponentController {
166.     return this.mXComponentController;
167.   }

168.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
169.   init(ctx: Context) {
170.     if (this.pipController !== null && this.pipController != undefined) {
171.       return;
172.     }
173.     console.info(TAG, 'onPageShow');
174.     if (!PiPWindow.isPiPEnabled()) {
175.       console.error(TAG, `picture in picture disabled for current OS`);
176.       return;
177.     }

178.     let config: PiPWindow.PiPConfiguration = {
179.       context: ctx,
180.       componentController: this.getXComponentController(),
181.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
182.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则将设置为16:9默认比例
183.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则将设置为16:9默认比例
184.     };
185.     // 通过create接口创建画中画控制器实例

186.     PiPWindow.create(config, this.xComponent).then((controller: PiPWindow.PiPController) => {
187.       this.pipController = controller;
188.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
189.       this.pipController.setAutoStartEnabled(true);
190.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
191.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
192.         this.onStateChange(state, reason);
193.       });
194.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
195.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
196.         this.onActionEvent(control);
197.       });
198.     }).catch((err: BusinessError) => {
199.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
200.     });
201.   }

202.   // 步骤2：创建画中画控制器实例后，通过startPiP接口启动画中画
203.   startPip() {
204.     this.pipController?.startPiP().then(() => {
205.       console.info(TAG, `Succeeded in starting pip.`);
206.     }).catch((err: BusinessError) => {
207.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
208.     });
209.   }

210.   // 步骤3：更新媒体源尺寸信息
211.   updateContentSize(width: number, height: number) {
212.     if (this.pipController) {
213.       this.pipController.updateContentSize(width, height);
214.     }
215.   }

216.   // 步骤4：关闭画中画
217.   stopPip() {
218.     if (this.pipController === null || this.pipController === undefined) {
219.       return;
220.     }
221.     let promise: Promise<void> = this.pipController.stopPiP();
222.     promise.then(() => {
223.       console.info(TAG, `Succeeded in stopping pip.`);
224.     }).catch((err: BusinessError) => {
225.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
226.     });
227.   }

228.   setAutoStart(autoStart: boolean): void {
229.     this.pipController?.setAutoStartEnabled(autoStart);
230.   }

231.   // 创建typeNode节点
232.   makeTypeNode(ctx: UIContext) {
233.     if (this.xComponent === null || this.xComponent === undefined) {
234.       // 创建typeNode
235.       // let xc_options: XComponentOptions = {
236.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
237.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
238.       // }
239.       // this.xComponent = typeNode.createNode(ctx, "XComponent", xc_options);

240.       // 创建XComponent类型的typeNode
241.       this.xComponent = typeNode.createNode(ctx, "XComponent", {
242.         type: XComponentType.SURFACE, // 类型设置为SURFACE
243.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
244.       });
245.     }
246.   }
247. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.90557765226952201292377370988578:50001231000000:2800:CA399A5B260CE4512EC1508F4ED7A8922924014E1AF31834D14D86BEB03CD60C.gif "点击放大")

## 应用使用router导航时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新跳转到原界面。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.      // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { PiPWindow, router, Router } from '@kit.ArkUI'; // 引入PiPWindow模块

14. const TAG = 'Index'
15. @Entry
16. @Component
17. struct Index {
18.   private page1: string = 'pages/Page1';
19.   private pageRouter: Router | null = null;

20.   // 画中画生命周期事件监听，用于页面及节点操作
21.   private callback: Function = (state: PiPWindow.PiPState) => {
22.     console.info(TAG, `pipStateChange: state ${state}`);
23.     if (state === PiPWindow.PiPState.ABOUT_TO_START) {
24.       // 返回到上级页面（可选）
25.       this.pageRouter?.back();
26.     } else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
27.       // 重新将typeNode节点添加到布局中，例如还原场景
28.       PipManager.getInstance().addNode();
29.     } else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
30.       // 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
31.       this.jumpNext();
32.     }
33.   };

34.   aboutToAppear(): void {
35.     this.pageRouter = this.getUIContext().getRouter();
36.     PipManager.getInstance().registerLifecycleCallback(this.callback);
37.   }

38.   aboutToDisappear(): void {
39.     PipManager.getInstance().unregisterPipStateChangeListener();
40.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
41.   }

42.   jumpNext(): void {
43.     let topPage = this.pageRouter?.getState();
44.     if (topPage !== undefined && (this.page1.toString() === topPage.path + topPage.name)) {
45.       console.info(TAG, `page1 aready at top`)
46.       return;
47.     }
48.     this.pageRouter?.pushUrl({
49.       url: this.page1 // 目标url
50.     }, router.RouterMode.Standard, (err) => {
51.       if (err) {
52.         console.error(TAG, `Invoke pushUrl failed, code is ${err.code}: ${err.message}`);
53.         return;
54.       }
55.       console.info(TAG, 'Invoke pushUrl succeeded.');
56.     });
57.   }

58.   build() {
59.     Row() {
60.       Column() {
61.         Text('Main Page')
62.           .fontSize(50)
63.           .fontWeight(FontWeight.Bold)

64.         Button('Jump Next')
65.           .onClick(() => {
66.             this.jumpNext();
67.           })
68.           .margin({ top: 16, bottom: 16 })
69.       }
70.       .width('100%')
71.     }
72.     .height('100%')
73.   }
74. }

75. // pages/Page1.ets
76. import { PipManager } from '../model/PipManager';

77. const TAG = 'Page1';

78. @Entry
79. @Component
80. export struct Page1 {
81.   build() {
82.     Column() {
83.       Text('This is Page1')
84.         .fontSize(30)
85.         .fontWeight(FontWeight.Bold)
86.         .margin({bottom: 20})

87.       // 将typeNode添加到页面布局中
88.       NodeContainer(PipManager.getInstance().getNodeController())
89.         .size({ width: '100%', height: '800px' })

90.       Row({ space: 20 }) {
91.         Button('startPip')// 启动画中画
92.           .onClick(() => {
93.             PipManager.getInstance().startPip();
94.           })

95.         Button('stopPip')// 停止画中画
96.           .onClick(() => {
97.             PipManager.getInstance().stopPip();
98.           })

99.         Button('updateSize')// 更新视频尺寸
100.           .onClick(() => {
101.             // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
102.             // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
103.             PipManager.getInstance().updateContentSize(900, 1600);
104.           })
105.       }
106.       .backgroundColor('#4da99797')
107.       .size({ width: '100%', height: 60 })
108.       .justifyContent(FlexAlign.SpaceAround)
109.     }
110.     .justifyContent(FlexAlign.Center)
111.     .width('100%')
112.     .height('100%')
113.   }

114.   onPageShow(): void {
115.     console.info(TAG, 'onPageShow')
116.     PipManager.getInstance().initPipController(this.getUIContext().getHostContext() as Context);
117.     PipManager.getInstance().setAutoStart(true);
118.   }

119.   onPageHide(): void {
120.     console.info(TAG, 'onPageHide')
121.     PipManager.getInstance().setAutoStart(false);
122.     PipManager.getInstance().removeNode();
123.   }
124. }

125. // model/PipManager.ets
126. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
127. import { BusinessError } from '@kit.BasicServicesKit';
128. import { XCNodeController } from './XCNodeController';
129. import { AVPlayer } from './AVPlayer';

130. export class CustomXComponentController extends XComponentController {
131.   onSurfaceCreated(surfaceId: string): void {
132.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
133.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
134.       return;
135.     }
136.     // 将surfaceId设置给媒体源
137.     PipManager.getInstance().player.surfaceID = surfaceId;
138.     PipManager.getInstance().player.avPlayerFdSrc();
139.   }

140.   onSurfaceDestroyed(surfaceId: string): void {
141.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
142.   }
143. }

144. const TAG = 'PipManager';

145. export class PipManager {
146.   private static instance: PipManager = new PipManager();
147.   private pipController?: PiPWindow.PiPController = undefined;
148.   private xcNodeController: XCNodeController;
149.   private mXComponentController: XComponentController;
150.   private lifeCycleCallback: Set<Function> = new Set();
151.   player: AVPlayer;

152.   public static getInstance(): PipManager {
153.     return PipManager.instance;
154.   }

155.   constructor() {
156.     this.xcNodeController = new XCNodeController();
157.     this.player = new AVPlayer();
158.     this.mXComponentController = new CustomXComponentController();
159.   }

160.   public registerLifecycleCallback(callBack: Function) {
161.     this.lifeCycleCallback.add(callBack);
162.   }

163.   public unRegisterLifecycleCallback(callBack: Function): void {
164.     this.lifeCycleCallback.delete(callBack);
165.   }

166.   getNode(): typeNode.XComponent | null {
167.     return this.xcNodeController.getNode();
168.   }

169.   onActionEvent(control: PiPWindow.ControlEventParam) {
170.     switch (control.controlType) {
171.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
172.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
173.           //停止视频
174.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
175.           //播放视频
176.         }
177.         break;
178.       case PiPWindow.PiPControlType.VIDEO_NEXT:
179.         // 切换到下一个视频
180.         break;
181.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
182.         // 切换到上一个视频
183.         break;
184.       case PiPWindow.PiPControlType.FAST_FORWARD:
185.         // 视频进度快进
186.         break;
187.       case PiPWindow.PiPControlType.FAST_BACKWARD:
188.         // 视频进度后退
189.         break;
190.       default:
191.         break;
192.     }
193.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
194.   }

195.   onStateChange(state: PiPWindow.PiPState, reason: string) {
196.     let curState: string = '';
197.     this.xcNodeController.setCanAddNode(
198.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
199.     if (this.lifeCycleCallback !== null) {
200.       this.lifeCycleCallback.forEach((fun) => {
201.         fun(state)
202.       });
203.     }
204.     switch (state) {
205.       case PiPWindow.PiPState.ABOUT_TO_START:
206.         curState = "ABOUT_TO_START";
207.         // 将typeNode节点从布局移除
208.         this.xcNodeController.removeNode();
209.         break;
210.       case PiPWindow.PiPState.STARTED:
211.         curState = "STARTED";
212.         break;
213.       case PiPWindow.PiPState.ABOUT_TO_STOP:
214.         curState = "ABOUT_TO_STOP";
215.         break;
216.       case PiPWindow.PiPState.STOPPED:
217.         curState = "STOPPED";
218.         break;
219.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
220.         curState = "ABOUT_TO_RESTORE";
221.         break;
222.       case PiPWindow.PiPState.ERROR:
223.         curState = "ERROR";
224.         break;
225.       default:
226.         break;
227.     }
228.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
229.   }

230.   unregisterPipStateChangeListener() {
231.     console.info(`${TAG} aboutToDisappear`)
232.     this.pipController?.off('stateChange');
233.     this.pipController?.off('controlEvent');
234.   }

235.   getXComponentController(): CustomXComponentController {
236.     return this.mXComponentController;
237.   }

238.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
239.   initPipController(ctx: Context) {
240.     if (this.pipController !== null && this.pipController != undefined) {
241.       return;
242.     }
243.     console.info(`${TAG} onPageShow`)
244.     if (!PiPWindow.isPiPEnabled()) {
245.       console.error(TAG, `picture in picture disabled for current OS`);
246.       return;
247.     }
248.     let config: PiPWindow.PiPConfiguration = {
249.       context: ctx,
250.       componentController: this.getXComponentController(),
251.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
252.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
253.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
254.     };
255.     // 通过create接口创建画中画控制器实例

256.     PiPWindow.create(config, this.getNode()).then((controller: PiPWindow.PiPController) => {
257.       this.pipController = controller;
258.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
259.       this.pipController.setAutoStartEnabled(true)
260.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
261.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
262.         this.onStateChange(state, reason);
263.       });
264.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
265.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
266.         this.onActionEvent(control);
267.       });
268.     }).catch((err: BusinessError) => {
269.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
270.     });
271.   }

272.   // 步骤2：启动画中画
273.   startPip() {
274.     this.pipController?.startPiP().then(() => {
275.       console.info(TAG, `Succeeded in starting pip.`);
276.     }).catch((err: BusinessError) => {
277.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
278.     });
279.   }

280.   // 步骤3：更新媒体源尺寸信息
281.   updateContentSize(width: number, height: number) {
282.     if (this.pipController) {
283.       this.pipController.updateContentSize(width, height);
284.     }
285.   }

286.   // 步骤4：关闭画中画
287.   stopPip() {
288.     if (this.pipController) {
289.       let promise: Promise<void> = this.pipController.stopPiP();
290.       promise.then(() => {
291.         console.info(TAG, `Succeeded in stopping pip.`);
292.       }).catch((err: BusinessError) => {
293.         console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
294.       });
295.     }
296.   }

297.   getNodeController(): XCNodeController {
298.     console.info(TAG, `getNodeController.`);
299.     return this.xcNodeController;
300.   }

301.   setAutoStart(autoStart: boolean): void {
302.     this.pipController?.setAutoStartEnabled(autoStart);
303.   }

304.   removeNode(): void {
305.     this.xcNodeController.removeNode();
306.   }

307.   addNode(): void {
308.     this.xcNodeController.addNode();
309.   }
310. }

311. // model/XCNodeController.ets
312. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
313. import { PipManager } from './PipManager';

314. const TAG = 'XCNodeController';
315. // 创建自定义NodeController
316. export class XCNodeController extends NodeController {
317.   xComponent: typeNode.XComponent | null = null;
318.   private node: FrameNode | null = null;
319.   private canAddNode: boolean = true;

320.   // 设置是否可以添加节点
321.   setCanAddNode(canAddNode: boolean) {
322.     this.canAddNode = canAddNode;
323.   }

324.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
325.   makeNode(context: UIContext): FrameNode | null {
326.     this.node = new FrameNode(context);
327.     this.node.commonAttribute
328.     if (this.xComponent === null || this.xComponent === undefined) {
329.       // 创建typeNode
330.       // let xc_options: XComponentOptions = {
331.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
332.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
333.       // }
334.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

335.       // 创建XComponent类型的typeNode
336.       this.xComponent = typeNode.createNode(context, "XComponent", {
337.         type: XComponentType.SURFACE, // 类型设置为SURFACE
338.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
339.       });
340.     }
341.     if (this.canAddNode) {

342.       try {
343.         this.xComponent.getParent()?.removeChild(this.xComponent);
344.       } catch (error) {
345.         console.error(TAG, 'Failed to removeChild');
346.       }
347.       try {
348.         this.node.appendChild(this.xComponent);
349.       } catch (error) {
350.         console.error(TAG, 'Failed to appendChild');
351.       }
352.     }
353.     return this.node;
354.   }

355.   // 重新添加typeNode节点
356.   addNode() {
357.     if (this.node !== null && this.node !== undefined) {
358.       console.info(TAG, "addNode");

359.       try {
360.         this.node.appendChild(this.xComponent);
361.       } catch (error) {
362.         console.error(TAG, 'Failed to appendChild');
363.       }
364.     }
365.   }

366.   // 移除typeNode节点
367.   removeNode() {
368.     if (this.node !== null && this.node !== undefined) {
369.       console.info(TAG, "removeNode");

370.       try {
371.         this.node.removeChild(this.xComponent);
372.       } catch (error) {
373.         console.error(TAG, 'Failed to removeChild');
374.       }
375.     }
376.   }

377.   getNode(): typeNode.XComponent | null {
378.     console.info(TAG, "getNode is null:"+ (this.xComponent === null || this.xComponent === undefined))
379.     return this.xComponent;
380.   }
381. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.82469444221375517554757238487910:50001231000000:2800:D265F3EF899EAB29F484FC57231645CC4A2F93D0A92692BB6F191A779E80810D.gif "点击放大")

## 应用使用Navigation导航时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新跳转到原界面。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { Page1 } from "../pages/Page1"
14. import { PiPWindow } from '@kit.ArkUI';

15. const TAG = 'Index1';

16. @Entry
17. @Component
18. struct Index {
19.   @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack();
20.   // 画中画生命周期事件监听，用于页面及节点操作
21.   private callback: Function = (state: PiPWindow.PiPState) => {
22.     console.info(TAG, `pipStateChange: state ${state}`);
23.     if (state === PiPWindow.PiPState.ABOUT_TO_START) {
24.       // 返回到上级页面（可选）
25.       this.pageInfos.pop();
26.     } else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
27.       // 重新将typeNode节点添加到布局中，例如还原场景
28.       PipManager.getInstance().addNode();
29.     } else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
30.       // 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
31.       this.jumpNext();
32.     }
33.   };

34.   jumpNext() {
35.     if (this.pageInfos.getAllPathName()[0] === 'Page1') {
36.       console.log(TAG, 'Page1 already at top');
37.       return;
38.     }
39.     this.pageInfos.pushPath({ name: 'Page1' });
40.   }

41.   aboutToAppear(): void {
42.     PipManager.getInstance().registerLifecycleCallback(this.callback);
43.   }

44.   aboutToDisappear(): void {
45.     PipManager.getInstance().unregisterPipStateChangeListener();
46.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
47.   }

48.   @Builder
49.   PageMap(name: string) {
50.     if (name === 'Page1') {
51.       Page1();
52.     }
53.   }

54.   build() {
55.     Navigation(this.pageInfos) {
56.       Column() {
57.         Text("This is Main Page")
58.         Column()
59.           .height('200px')
60.         Row({ space: 12 }) {
61.           Button("Jump Page1")
62.             .width('80%')
63.             .height(40)
64.             .margin(20)
65.             .onClick(() => {
66.               this.jumpNext();
67.             })
68.         }
69.       }
70.       .height("100%")
71.       .width("100%")
72.       .justifyContent(FlexAlign.Center)
73.       .backgroundColor("#DCDCDC")
74.     }.title('MainTitle')
75.     .navDestination(this.PageMap)
76.   }
77. }

78. // pages/Page1.ets
79. import { PipManager } from '../model/PipManager';

80. const TAG = 'Page1';

81. @Entry
82. @Component
83. export struct Page1 {
84.   build() {
85.     NavDestination() {
86.       Column() {
87.         Text('This is Page1')
88.           .fontSize(30)
89.           .fontWeight(FontWeight.Bold)
90.           .margin({bottom: 20})

91.         // 将typeNode添加到页面布局中
92.         NodeContainer(PipManager.getInstance().getNodeController())
93.           .size({ width: '100%', height: '800px' })

94.         Row({ space: 20 }) {
95.           Button('startPip') // 启动画中画
96.             .onClick(() => {
97.               PipManager.getInstance().startPip();
98.             })
99.           Button('stopPip') // 停止画中画
100.             .onClick(() => {
101.               PipManager.getInstance().stopPip();
102.             })
103.           Button('updateSize') // 更新视频尺寸
104.             .onClick(() => {
105.               // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
106.               // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
107.               PipManager.getInstance().updateContentSize(900, 1600);
108.             })
109.         }
110.         .backgroundColor('#4da99797')
111.         .size({ width: '100%', height: 60 })
112.         .justifyContent(FlexAlign.SpaceAround)
113.       }
114.       .justifyContent(FlexAlign.Center)
115.       .width('100%')
116.       .height('100%')
117.     }
118.     .title('page1')
119.     .onShown(()=>{
120.       console.info(TAG, 'onShown')
121.       PipManager.getInstance().init(this.getUIContext().getHostContext() as Context);
122.       PipManager.getInstance().setAutoStart(true);
123.     })
124.     .onHidden(()=>{
125.       console.info(TAG, 'onHidden')
126.       PipManager.getInstance().setAutoStart(false);
127.       PipManager.getInstance().removeNode();
128.     })
129.   }
130. }

131. // model/XCNodeController.ets
132. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
133. import { PipManager } from './PipManager';

134. const TAG = 'XCNodeController';

135. // 创建自定义NodeController
136. export class XCNodeController extends NodeController {
137.   xComponent: typeNode.XComponent| null = null;
138.   private node: FrameNode | null = null;
139.   private canAddNode: boolean = true;

140.   // 设置是否可以添加节点
141.   setCanAddNode(canAddNode: boolean) {
142.     this.canAddNode = canAddNode;
143.   }

144.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
145.   makeNode(context: UIContext): FrameNode | null {
146.     console.info(TAG, "makeNode");
147.     this.node = new FrameNode(context);
148.     if (this.xComponent === null || this.xComponent === undefined) {
149.       // 创建typeNode
150.       // let xc_options: XComponentOptions = {
151.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
152.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
153.       // }
154.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

155.       // 创建XComponent类型的typeNode
156.       this.xComponent = typeNode.createNode(context, "XComponent", {
157.         type: XComponentType.SURFACE, // 类型设置为SURFACE
158.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
159.       });
160.     }
161.     if (this.canAddNode) {

162.       try {
163.         this.xComponent.getParent()?.removeChild(this.xComponent);
164.       } catch (error) {
165.         console.error(TAG, 'Failed to removeChild');
166.       }
167.       try {
168.         this.node.appendChild(this.xComponent);
169.       } catch (error) {
170.         console.error(TAG, 'Failed to appendChild');
171.       }
172.     }
173.     return this.node;
174.   }

175.   // 重新添加typeNode节点
176.   addNode() {
177.     if (this.node !== null && this.node !== undefined) {
178.       console.info(TAG, "addNode id:"+(this.node?.getUniqueId())+" "+this.xComponent?.getUniqueId());
179.       try {
180.         this.node.appendChild(this.xComponent);
181.       } catch (error) {
182.         console.error(TAG, 'Failed to appendChild');
183.       }
184.     }
185.   }

186.   // 移除typeNode节点
187.   removeNode() {
188.     if (this.node !== null && this.node !== undefined) {
189.       console.info(TAG, "removeNode");

190.       try {
191.         this.node.removeChild(this.xComponent);
192.       } catch (error) {
193.         console.error(TAG, 'Failed to removeChild');
194.       }
195.     }
196.   }

197.   getNode(): typeNode.XComponent | null {
198.     console.info(TAG, "getNode is null:"+ (this.xComponent === null || this.xComponent === undefined))
199.     return this.xComponent;
200.   }
201. }

202. // model/PipManager.ets
203. import { PiPWindow, typeNode } from '@kit.ArkUI';
204. import { BusinessError } from '@kit.BasicServicesKit';
205. import { XCNodeController } from './XCNodeController';
206. import { AVPlayer } from './AVPlayer'

207. export class CustomXComponentController extends XComponentController {
208.   onSurfaceCreated(surfaceId: string): void {
209.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
210.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
211.       return;
212.     }
213.     // 将surfaceId设置给媒体源
214.     PipManager.getInstance().player.surfaceID = surfaceId;
215.     PipManager.getInstance().player.avPlayerFdSrc();
216.   }

217.   onSurfaceDestroyed(surfaceId: string): void {
218.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
219.   }
220. }

221. const TAG = 'PipManager';

222. export class PipManager {
223.   private static instance: PipManager = new PipManager();
224.   private pipController?: PiPWindow.PiPController = undefined;
225.   private xcNodeController: XCNodeController;
226.   private mXComponentController: XComponentController;
227.   private lifeCycleCallback: Set<Function> = new Set();
228.   player: AVPlayer;

229.   public static getInstance(): PipManager {
230.     return PipManager.instance;
231.   }

232.   constructor() {
233.     this.xcNodeController = new XCNodeController();
234.     this.player = new AVPlayer();
235.     this.mXComponentController = new CustomXComponentController();
236.   }

237.   public registerLifecycleCallback(callBack: Function) {
238.     this.lifeCycleCallback.add(callBack);
239.   }

240.   public unRegisterLifecycleCallback(callBack: Function): void {
241.     this.lifeCycleCallback.delete(callBack);
242.   }

243.   getNode(): typeNode.XComponent | null {
244.     return this.xcNodeController.getNode();
245.   }

246.   onActionEvent(control: PiPWindow.ControlEventParam) {
247.     switch (control.controlType) {
248.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
249.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
250.           //停止视频
251.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
252.           //播放视频
253.         }
254.         break;
255.       case PiPWindow.PiPControlType.VIDEO_NEXT:
256.         // 切换到下一个视频
257.         break;
258.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
259.         // 切换到上一个视频
260.         break;
261.       case PiPWindow.PiPControlType.FAST_FORWARD:
262.         // 视频进度快进
263.         break;
264.       case PiPWindow.PiPControlType.FAST_BACKWARD:
265.         // 视频进度后退
266.         break;
267.       default:
268.         break;
269.     }
270.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
271.   }

272.   onStateChange(state: PiPWindow.PiPState, reason: string) {
273.     let curState: string = '';
274.     this.xcNodeController.setCanAddNode(
275.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
276.     if (this.lifeCycleCallback !== null) {
277.       this.lifeCycleCallback.forEach((fun) => {
278.         fun(state);
279.       });
280.     }
281.     switch (state) {
282.       case PiPWindow.PiPState.ABOUT_TO_START:
283.         curState = "ABOUT_TO_START";
284.         // 将typeNode节点从布局移除
285.         this.xcNodeController.removeNode();
286.         break;
287.       case PiPWindow.PiPState.STARTED:
288.         curState = "STARTED";
289.         break;
290.       case PiPWindow.PiPState.ABOUT_TO_STOP:
291.         curState = "ABOUT_TO_STOP";
292.         break;
293.       case PiPWindow.PiPState.STOPPED:
294.         curState = "STOPPED";
295.         break;
296.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
297.         curState = "ABOUT_TO_RESTORE";
298.         break;
299.       case PiPWindow.PiPState.ERROR:
300.         curState = "ERROR";
301.         break;
302.       default:
303.         break;
304.     }
305.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
306.   }

307.   unregisterPipStateChangeListener() {
308.     console.info(`${TAG} aboutToDisappear`);
309.     this.pipController?.off('stateChange');
310.     this.pipController?.off('controlEvent');
311.   }

312.   getXComponentController(): CustomXComponentController {
313.     return this.mXComponentController;
314.   }

315.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
316.   init(ctx: Context) {
317.     if (this.pipController !== null && this.pipController != undefined) {
318.       return;
319.     }
320.     console.info(`${TAG} onPageShow`)
321.     if (!PiPWindow.isPiPEnabled()) {
322.       console.error(TAG, `picture in picture disabled for current OS`);
323.       return;
324.     }

325.     let config: PiPWindow.PiPConfiguration = {
326.       context: ctx,
327.       componentController: this.getXComponentController(),
328.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
329.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
330.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
331.     };
332.     // 通过create接口创建画中画控制器实例

333.     PiPWindow.create(config, this.xcNodeController.getNode()).then((controller: PiPWindow.PiPController) => {
334.       this.pipController = controller;
335.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
336.       this.pipController?.setAutoStartEnabled(true);
337.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
338.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
339.         this.onStateChange(state, reason);
340.       });
341.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
342.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
343.         this.onActionEvent(control);
344.       });
345.     }).catch((err: BusinessError) => {
346.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
347.     });
348.   }

349.   // 步骤2：启动画中画
350.   startPip() {
351.     this.pipController?.startPiP().then(() => {
352.       console.info(TAG, `Succeeded in starting pip.`);
353.     }).catch((err: BusinessError) => {
354.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
355.     });
356.   }

357.   // 步骤3：更新媒体源尺寸信息
358.   updateContentSize(width: number, height: number) {
359.     if (this.pipController) {
360.       this.pipController.updateContentSize(width, height);
361.     }
362.   }

363.   // 步骤4：关闭画中画
364.   stopPip() {
365.     if (this.pipController === null || this.pipController === undefined) {
366.       return;
367.     }
368.     let promise: Promise<void> = this.pipController.stopPiP();
369.     promise.then(() => {
370.       console.info(TAG, `Succeeded in stopping pip.`);
371.     }).catch((err: BusinessError) => {
372.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
373.     });
374.   }

375.   getNodeController(): XCNodeController {
376.     console.info(TAG, `getNodeController.`);
377.     return this.xcNodeController;
378.   }

379.   setAutoStart(autoStart: boolean): void {
380.     this.pipController?.setAutoStartEnabled(autoStart);
381.   }

382.   removeNode() {
383.     this.xcNodeController.removeNode();
384.   }

385.   addNode(): void {
386.     this.xcNodeController.addNode();
387.   }
388. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.43251788662118222639209142237415:50001231000000:2800:ED88DA0D006FA169793382180F6B34B01E963A82202F4F13B8F4EC390D885240.gif "点击放大")

## 应用使用单界面Ability时通过typeNode实现画中画功能

1. 创建画中画控制器，注册生命周期事件以及控制事件回调。
    
    - 创建自定义NodeController，实现makeNode方法，在该方法中创建typeNode。
    - 通过create(config: PiPConfiguration, contentNode: typeNode.XComponent)接口创建画中画控制器实例。
    - 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。
    - 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。
    - 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调。
    
2. 启动画中画。
    
    创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除。
    
3. 更新媒体源尺寸信息。
    
    画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
    
4. 关闭画中画。
    
    当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
    

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       // ...
8.     });
9.   }
10. }

11. // pages/Index.ets
12. import { PipManager } from '../model/PipManager';
13. import { PiPWindow } from '@kit.ArkUI'; // 引入PiPWindow模块

14. const TAG = 'Index'
15. @Entry
16. @Component
17. struct Index {
18.   private callback: Function = (state: PiPWindow.PiPState) => {
19.     if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
20.       // 画中画关闭或还原时触发ABOUT_TO_STOP生命周期，此时需要重新添加节点
21.       PipManager.getInstance().addNode();
22.     }
23.   };

24.   build() {
25.     Column() {
26.       Text('This is MainPage')
27.         .fontSize(30)
28.         .fontWeight(FontWeight.Bold)
29.         .margin({ bottom: 20 })

30.       // 将typeNode添加到页面布局中
31.       NodeContainer(PipManager.getInstance().getNodeController())
32.         .size({ width: '100%', height: '800px' })

33.       Row({ space: 20 }) {
34.         Button('startPip') // 启动画中画
35.           .onClick(() => {
36.             PipManager.getInstance().startPip();
37.           })

38.         Button('stopPip') // 停止画中画
39.           .onClick(() => {
40.             PipManager.getInstance().stopPip();
41.           })

42.         Button('updateSize') // 更新视频尺寸
43.           .onClick(() => {
44.             // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
45.             // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
46.             PipManager.getInstance().updateContentSize(900, 1600);
47.           })
48.       }
49.       .backgroundColor('#4da99797')
50.       .size({ width: '100%', height: 60 })
51.       .justifyContent(FlexAlign.SpaceAround)
52.     }
53.     .justifyContent(FlexAlign.Center)
54.     .width('100%')
55.     .height('100%')
56.   }

57.   aboutToAppear(): void {
58.     PipManager.getInstance().registerLifecycleCallback(this.callback);
59.   }

60.   aboutToDisappear(): void {
61.     PipManager.getInstance().unregisterPipStateChangeListener();
62.     PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
63.   }

64.   onPageShow(): void {
65.     console.info(TAG, 'onPageShow')
66.     PipManager.getInstance().init(this.getUIContext().getHostContext() as Context);
67.     PipManager.getInstance().setAutoStart(true);
68.   }

69.   onPageHide(): void {
70.     console.info(TAG, 'onPageHide')
71.     PipManager.getInstance().setAutoStart(false);
72.   }
73. }

74. // model/XCNodeController.ets
75. import { FrameNode, NodeController, typeNode } from '@kit.ArkUI';
76. import { PipManager } from './PipManager';

77. const TAG = 'XCNodeController';

78. // 创建自定义NodeController
79. export class XCNodeController extends NodeController {
80.   xComponent: typeNode.XComponent | null = null;
81.   private node: FrameNode | null = null;
82.   private canAddNode: boolean = true;

83.   // 设置是否可以添加节点
84.   setCanAddNode(canAddNode: boolean) {
85.     this.canAddNode = canAddNode;
86.   }

87.   // 实现makeNode方法，当自定义NodeController被添加到布局时，该方法会被调用
88.   makeNode(context: UIContext): FrameNode | null {
89.     this.node = new FrameNode(context);
90.     this.node.commonAttribute
91.     if (this.xComponent === null || this.xComponent === undefined) {
92.       // 创建typeNode
93.       // let xc_options: XComponentOptions = {
94.       //   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
95.       //   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
96.       // }
97.       // this.xComponent = typeNode.createNode(context, "XComponent", xc_options);

98.       // 创建XComponent类型的typeNode
99.       this.xComponent = typeNode.createNode(context, "XComponent", {
100.         type: XComponentType.SURFACE, // 类型设置为SURFACE
101.         controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
102.       });
103.     }
104.     if (this.canAddNode) {

105.       try {
106.         this.xComponent.getParent()?.removeChild(this.xComponent);
107.       } catch (error) {
108.         console.error(TAG, 'Failed to removeChild');
109.       }
110.       try {
111.         this.node.appendChild(this.xComponent);
112.       } catch (error) {
113.         console.error(TAG, 'Failed to appendChild');
114.       }
115.     }
116.     return this.node;
117.   }

118.   // 重新添加typeNode节点
119.   addNode() {
120.     if (this.node !== null && this.node !== undefined) {
121.       console.info(TAG, "addNode");

122.       try {
123.         this.node.appendChild(this.xComponent);
124.       } catch (error) {
125.         console.error(TAG, 'Failed to appendChild');
126.       }
127.     }
128.   }

129.   // 移除typeNode节点
130.   removeNode() {
131.     if (this.node !== null && this.node !== undefined) {
132.       console.info(TAG, "removeNode");

133.       try {
134.         this.node.removeChild(this.xComponent);
135.       } catch (error) {
136.         console.error(TAG, 'Failed to removeChild');
137.       }
138.     }
139.   }

140.   getNode(): typeNode.XComponent | null {
141.     console.info(TAG, "getNode is null: "+ (this.xComponent === null || this.xComponent === undefined));
142.     return this.xComponent;
143.   }
144. }

145. // model/PipManager.ets
146. import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
147. import { BusinessError } from '@kit.BasicServicesKit';
148. import { XCNodeController } from './XCNodeController';
149. import { AVPlayer} from '../model/AVPlayer'

150. // 自定义XComponentController
151. export class CustomXComponentController extends XComponentController {
152.   onSurfaceCreated(surfaceId: string): void {
153.     console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
154.     if (PipManager.getInstance().player.surfaceID === surfaceId) {
155.       return;
156.     }
157.     PipManager.getInstance().player.surfaceID = surfaceId;
158.     PipManager.getInstance().player.avPlayerFdSrc();
159.   }

160.   onSurfaceDestroyed(surfaceId: string): void {
161.     console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
162.   }
163. }

164. const TAG = 'PipManager';

165. export class PipManager {
166.   private static instance: PipManager = new PipManager();
167.   private pipController?: PiPWindow.PiPController = undefined;
168.   private xcNodeController: XCNodeController;
169.   private mXComponentController: XComponentController;
170.   private lifeCycleCallback: Set<Function> = new Set();
171.   player: AVPlayer;

172.   public static getInstance(): PipManager {
173.     return PipManager.instance;
174.   }

175.   constructor() {
176.     this.xcNodeController = new XCNodeController();
177.     this.player = new AVPlayer();
178.     this.mXComponentController = new CustomXComponentController();
179.   }

180.   public registerLifecycleCallback(callBack: Function) {
181.     this.lifeCycleCallback.add(callBack);
182.   }

183.   public unRegisterLifecycleCallback(callBack: Function): void {
184.     this.lifeCycleCallback.delete(callBack);
185.   }

186.   getNode(): typeNode.XComponent | null {
187.     return this.xcNodeController.getNode();
188.   }

189.   onActionEvent(control: PiPWindow.ControlEventParam) {
190.     switch (control.controlType) {
191.       case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
192.         if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
193.           //停止视频
194.         } else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
195.           //播放视频
196.         }
197.         break;
198.       case PiPWindow.PiPControlType.VIDEO_NEXT:
199.         // 切换到下一个视频
200.         break;
201.       case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
202.         // 切换到上一个视频
203.         break;
204.       case PiPWindow.PiPControlType.FAST_FORWARD:
205.         // 视频进度快进
206.         break;
207.       case PiPWindow.PiPControlType.FAST_BACKWARD:
208.         // 视频进度后退
209.         break;
210.       default:
211.         break;
212.     }
213.     console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
214.   }

215.   onStateChange(state: PiPWindow.PiPState, reason: string) {
216.     let curState: string = '';
217.     this.xcNodeController.setCanAddNode(
218.       state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED);
219.     if (this.lifeCycleCallback !== null) {
220.       this.lifeCycleCallback.forEach((fun) => {
221.         fun(state);
222.       });
223.     }
224.     switch (state) {
225.       case PiPWindow.PiPState.ABOUT_TO_START:
226.         curState = "ABOUT_TO_START";
227.         // 将typeNode节点从布局移除
228.         this.xcNodeController.removeNode();
229.         break;
230.       case PiPWindow.PiPState.STARTED:
231.         curState = "STARTED";
232.         break;
233.       case PiPWindow.PiPState.ABOUT_TO_STOP:
234.         curState = "ABOUT_TO_STOP";
235.         break;
236.       case PiPWindow.PiPState.STOPPED:
237.         curState = "STOPPED";
238.         break;
239.       case PiPWindow.PiPState.ABOUT_TO_RESTORE:
240.         curState = "ABOUT_TO_RESTORE";
241.         break;
242.       case PiPWindow.PiPState.ERROR:
243.         curState = "ERROR";
244.         break;
245.       default:
246.         break;
247.     }
248.     console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
249.   }

250.   unregisterPipStateChangeListener() {
251.     console.info(`${TAG} aboutToDisappear`);
252.     this.pipController?.off('stateChange');
253.     this.pipController?.off('controlEvent');
254.   }

255.   getXComponentController(): CustomXComponentController {
256.     return this.mXComponentController;
257.   }

258.   // 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
259.   init(ctx: Context) {
260.     if (this.pipController !== null && this.pipController != undefined) {
261.       return;
262.     }
263.     console.info(`${TAG} onPageShow`)
264.     if (!PiPWindow.isPiPEnabled()) {
265.       console.error(TAG, `picture in picture disabled for current OS`);
266.       return;
267.     }
268.     let config: PiPWindow.PiPConfiguration = {
269.       context: ctx,
270.       componentController: this.getXComponentController(),
271.       templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
272.       contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
273.       contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
274.     };
275.     // 通过create接口创建画中画控制器实例

276.     PiPWindow.create(config, this.xcNodeController.getNode()).then((controller: PiPWindow.PiPController) => {
277.       this.pipController = controller;
278.       // 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
279.       this.pipController?.setAutoStartEnabled(true);
280.       // 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
281.       this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
282.         this.onStateChange(state, reason);
283.       });
284.       // 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
285.       this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
286.         this.onActionEvent(control);
287.       });
288.     }).catch((err: BusinessError) => {
289.       console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
290.     });
291.   }

292.   // 步骤2：启动画中画
293.   startPip() {
294.     this.pipController?.startPiP().then(() => {
295.       console.info(TAG, `Succeeded in starting pip.`);
296.     }).catch((err: BusinessError) => {
297.       console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
298.     });
299.   }

300.   // 步骤3：更新媒体源尺寸信息
301.   updateContentSize(width: number, height: number) {
302.     if (this.pipController) {
303.       this.pipController.updateContentSize(width, height);
304.     }
305.   }

306.   // 步骤4：关闭画中画
307.   stopPip() {
308.     if (this.pipController === null || this.pipController === undefined) {
309.       return;
310.     }
311.     let promise: Promise<void> = this.pipController.stopPiP();
312.     promise.then(() => {
313.       console.info(TAG, `Succeeded in stopping pip.`);
314.     }).catch((err: BusinessError) => {
315.       console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
316.     });
317.   }

318.   getNodeController(): XCNodeController {
319.     console.info(TAG, `getNodeController.`);
320.     return this.xcNodeController;
321.   }

322.   setAutoStart(autoStart: boolean): void {
323.     this.pipController?.setAutoStartEnabled(autoStart);
324.   }

325.   // 将typeNode节点添加到原父节点
326.   addNode(): void {
327.     this.xcNodeController.addNode();
328.   }
329. }

以上示例代码对应的示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163944.60220636021835432999711118812128:50001231000000:2800:32D9F84E2562A17EC624DDF45EF40A320736F847ED3D941BBBF08B9B5899757F.gif "点击放大")

## 示例代码

- [实现画中画效果](https://gitee.com/harmonyos_samples/guide-snippets/tree/master/ArkUIWindowPipSamples/WindowPip)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-xcomponent "使用XComponent实现画中画功能开发（ArkTS）")
# 画中画常见问题

更新时间: 2025-12-16 16:39

## 画中画如何实现多个视频流播放

开发者需要实现多个视频流播放，可以通过自定义节点将视频流封装为NodeController，创建画中画时配置为自定义节点[customUIController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-pipwindow#pipconfiguration)，实现多个视频流播放 。

## 画中画如何实现节点切换

开发者可以使用画中画typeNode方案，typeNode方案支持通过[updateContentNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-pipwindow#updatecontentnode18)方法更新画中画节点。

## 画中画如何解决拖动删除或点击关闭按钮关闭后，后台声音仍然存在的问题

对于申请了长时任务的应用，画中画拖动删除或点击关闭后仅删除画中画窗口，并不会结束应用进程。开发者需要开启画中画生命周期监听，在STOPPED生命周期中主动关闭任务或进程。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-native "使用NDK接口实现画中画功能开发（C/C++）")
# 画中画常见问题

更新时间: 2025-12-16 16:39

## 画中画如何实现多个视频流播放

开发者需要实现多个视频流播放，可以通过自定义节点将视频流封装为NodeController，创建画中画时配置为自定义节点[customUIController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-pipwindow#pipconfiguration)，实现多个视频流播放 。

## 画中画如何实现节点切换

开发者可以使用画中画typeNode方案，typeNode方案支持通过[updateContentNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-pipwindow#updatecontentnode18)方法更新画中画节点。

## 画中画如何解决拖动删除或点击关闭按钮关闭后，后台声音仍然存在的问题

对于申请了长时任务的应用，画中画拖动删除或点击关闭后仅删除画中画窗口，并不会结束应用进程。开发者需要开启画中画生命周期监听，在STOPPED生命周期中主动关闭任务或进程。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pipwindow-native "使用NDK接口实现画中画功能开发（C/C++）")
# 顶部窗口控制条避让适配智慧多窗

更新时间: 2025-12-16 16:40

顶部窗口控制条是应用窗口处于智慧多窗模式下，应用顶部的操作横条 ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.27288733386198945636433798593090:50001231000000:2800:070247D085A5B235D8CB69791C5EFDB2D57D1AAFA439BDC346CC1FF0868E7993.png) 。

顶部窗口控制条示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.30396811749464753232861421275952:50001231000000:2800:79D8F0EDF9909801617EAC4CB1F3B268487F5A704A21E6F777BFFA1C44E5F5F7.png "点击放大")

顶部横条的避让可通过以下两种方式适配：

- 使用窗口的避让能力：通过[setWindowLayoutFullScreen](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)设置窗口布局是否为沉浸式布局。
    
    沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。非沉浸式布局是指布局避让状态栏、导航栏以及智慧多窗顶部横条，组件不会与其重叠。因此可设置isLayoutFullScreen值为false使窗口的布局为非沉浸式布局。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.71455758921508185243369415467470:50001231000000:2800:78F622FE8BE81DE36A6B5E7049DA3F9FF807CEF2DC30E767EA32F0C07DBD055E.png "点击放大")
    
    示例：
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { window } from '@kit.ArkUI';
    4. import { common } from '@kit.AbilityKit';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State message: string = '非沉浸式布局';
    9.   private windowClass: window.Window | undefined = undefined;
    
    10.   aboutToAppear(): void {
    11.     try {
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           this.windowClass = data;
    20.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    21.         });
    22.     } catch (exception) {
    23.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    24.     }
    25.   }
    
    26.   private setWindowLayoutFullScreen(isLayoutFullScreen: boolean) {
    27.     if (!this.windowClass) {
    28.       return;
    29.     }
    30.     this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    31.       console.info('Succeeded in setting the window layout to full-screen mode.');
    32.     }).catch((err: BusinessError) => {
    33.       const errCode: number = err.code;
    34.       if (errCode) {
    35.         console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
    36.         return;
    37.       }
    38.     });
    39.   }
    
    40.   build() {
    41.     Stack({ alignContent: Alignment.TopStart }) {
    42.       Column() {
    43.         Text(this.message)
    44.           .fontSize(25)
    45.           .fontWeight(FontWeight.Bold)
    46.           .margin({
    47.             top: '2%',
    48.             bottom: '40%'
    49.           })
    
    50.         Button() {
    51.           Text('设置窗口为沉浸式布局')
    52.             .fontSize(18)
    53.             .fontWeight(FontWeight.Normal)
    54.         }
    55.         .type(ButtonType.Normal)
    56.         .borderRadius(15)
    57.         .margin({ top: 20 })
    58.         .stateStyles({
    59.           normal: {
    60.             .backgroundColor('#ff6b89d4')
    61.           },
    62.           pressed: {
    63.             .backgroundColor('#ffc81f2a')
    64.           }
    65.         })
    66.         .width('60%')
    67.         .height('6%')
    68.         .onClick(() => {
    69.           this.setWindowLayoutFullScreen(true);
    70.           this.message = '沉浸式布局';
    71.         })
    
    72.         Button() {
    73.           Text('设置窗口为非沉浸式布局')
    74.             .fontSize(18)
    75.             .fontWeight(FontWeight.Normal)
    76.         }
    77.         .type(ButtonType.Normal)
    78.         .borderRadius(15)
    79.         .margin({ top: 20 })
    80.         .stateStyles({
    81.           normal: {
    82.             .backgroundColor('#ff6b89d4')
    83.           },
    84.           pressed: {
    85.             .backgroundColor('#ffc81f2a')
    86.           }
    87.         })
    88.         .width('60%')
    89.         .height('6%')
    90.         .onClick(() => {
    91.           this.setWindowLayoutFullScreen(false);
    92.           this.message = '非沉浸式布局';
    93.         })
    94.       }
    95.       .width('100%')
    96.     }
    97.     .backgroundColor('#fceaeaea')
    98.     .height('100%')
    99.   }
    100. }
    
- 应用主动避让：应用不使用窗口避让能力（即设置窗口为沉浸式布局）。首次通过[getWindowAvoidArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让，并且注册[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#onavoidareachange9)监听系统避让区域变化以进行布局的动态调整。
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { common } from '@kit.AbilityKit';
    4. import { window } from '@kit.ArkUI';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State topSafeHeight: number = 0;
    
    9.   aboutToAppear(): void {
    10.     try {
    11.       let windowClass: window.Window | undefined = undefined;
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           windowClass = data;
    20.           windowClass.setWindowLayoutFullScreen(true);
    21.           this.topSafeHeight = this.getUIContext()?.px2vp(
    22.             windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);
    23.           windowClass.on('avoidAreaChange', (data) => {
    24.             if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
    25.               this.topSafeHeight = this.getUIContext()?.px2vp(data.area.topRect.height)
    26.             }
    27.           })
    28.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    29.         });
    30.     } catch (exception) {
    31.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    32.     }
    33.   }
    
    34.   build() {
    35.     Stack({ alignContent: Alignment.TopStart }) {
    36.       // 顶部避让区域
    37.       Row() {
    38.       }
    39.       .height(this.topSafeHeight)
    40.       .width("100%")
    
    41.       // 根据topSafeHeight动态调整应用布局
    42.       // ...
    43.     }
    44.     .height('100%')
    45.   }
    46. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-layout-adapt "应用布局适配智慧多窗")
# 顶部窗口控制条避让适配智慧多窗

更新时间: 2025-12-16 16:40

顶部窗口控制条是应用窗口处于智慧多窗模式下，应用顶部的操作横条 ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.27288733386198945636433798593090:50001231000000:2800:070247D085A5B235D8CB69791C5EFDB2D57D1AAFA439BDC346CC1FF0868E7993.png) 。

顶部窗口控制条示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.30396811749464753232861421275952:50001231000000:2800:79D8F0EDF9909801617EAC4CB1F3B268487F5A704A21E6F777BFFA1C44E5F5F7.png "点击放大")

顶部横条的避让可通过以下两种方式适配：

- 使用窗口的避让能力：通过[setWindowLayoutFullScreen](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)设置窗口布局是否为沉浸式布局。
    
    沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。非沉浸式布局是指布局避让状态栏、导航栏以及智慧多窗顶部横条，组件不会与其重叠。因此可设置isLayoutFullScreen值为false使窗口的布局为非沉浸式布局。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.71455758921508185243369415467470:50001231000000:2800:78F622FE8BE81DE36A6B5E7049DA3F9FF807CEF2DC30E767EA32F0C07DBD055E.png "点击放大")
    
    示例：
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { window } from '@kit.ArkUI';
    4. import { common } from '@kit.AbilityKit';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State message: string = '非沉浸式布局';
    9.   private windowClass: window.Window | undefined = undefined;
    
    10.   aboutToAppear(): void {
    11.     try {
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           this.windowClass = data;
    20.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    21.         });
    22.     } catch (exception) {
    23.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    24.     }
    25.   }
    
    26.   private setWindowLayoutFullScreen(isLayoutFullScreen: boolean) {
    27.     if (!this.windowClass) {
    28.       return;
    29.     }
    30.     this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    31.       console.info('Succeeded in setting the window layout to full-screen mode.');
    32.     }).catch((err: BusinessError) => {
    33.       const errCode: number = err.code;
    34.       if (errCode) {
    35.         console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
    36.         return;
    37.       }
    38.     });
    39.   }
    
    40.   build() {
    41.     Stack({ alignContent: Alignment.TopStart }) {
    42.       Column() {
    43.         Text(this.message)
    44.           .fontSize(25)
    45.           .fontWeight(FontWeight.Bold)
    46.           .margin({
    47.             top: '2%',
    48.             bottom: '40%'
    49.           })
    
    50.         Button() {
    51.           Text('设置窗口为沉浸式布局')
    52.             .fontSize(18)
    53.             .fontWeight(FontWeight.Normal)
    54.         }
    55.         .type(ButtonType.Normal)
    56.         .borderRadius(15)
    57.         .margin({ top: 20 })
    58.         .stateStyles({
    59.           normal: {
    60.             .backgroundColor('#ff6b89d4')
    61.           },
    62.           pressed: {
    63.             .backgroundColor('#ffc81f2a')
    64.           }
    65.         })
    66.         .width('60%')
    67.         .height('6%')
    68.         .onClick(() => {
    69.           this.setWindowLayoutFullScreen(true);
    70.           this.message = '沉浸式布局';
    71.         })
    
    72.         Button() {
    73.           Text('设置窗口为非沉浸式布局')
    74.             .fontSize(18)
    75.             .fontWeight(FontWeight.Normal)
    76.         }
    77.         .type(ButtonType.Normal)
    78.         .borderRadius(15)
    79.         .margin({ top: 20 })
    80.         .stateStyles({
    81.           normal: {
    82.             .backgroundColor('#ff6b89d4')
    83.           },
    84.           pressed: {
    85.             .backgroundColor('#ffc81f2a')
    86.           }
    87.         })
    88.         .width('60%')
    89.         .height('6%')
    90.         .onClick(() => {
    91.           this.setWindowLayoutFullScreen(false);
    92.           this.message = '非沉浸式布局';
    93.         })
    94.       }
    95.       .width('100%')
    96.     }
    97.     .backgroundColor('#fceaeaea')
    98.     .height('100%')
    99.   }
    100. }
    
- 应用主动避让：应用不使用窗口避让能力（即设置窗口为沉浸式布局）。首次通过[getWindowAvoidArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让，并且注册[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#onavoidareachange9)监听系统避让区域变化以进行布局的动态调整。
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { common } from '@kit.AbilityKit';
    4. import { window } from '@kit.ArkUI';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State topSafeHeight: number = 0;
    
    9.   aboutToAppear(): void {
    10.     try {
    11.       let windowClass: window.Window | undefined = undefined;
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           windowClass = data;
    20.           windowClass.setWindowLayoutFullScreen(true);
    21.           this.topSafeHeight = this.getUIContext()?.px2vp(
    22.             windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);
    23.           windowClass.on('avoidAreaChange', (data) => {
    24.             if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
    25.               this.topSafeHeight = this.getUIContext()?.px2vp(data.area.topRect.height)
    26.             }
    27.           })
    28.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    29.         });
    30.     } catch (exception) {
    31.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    32.     }
    33.   }
    
    34.   build() {
    35.     Stack({ alignContent: Alignment.TopStart }) {
    36.       // 顶部避让区域
    37.       Row() {
    38.       }
    39.       .height(this.topSafeHeight)
    40.       .width("100%")
    
    41.       // 根据topSafeHeight动态调整应用布局
    42.       // ...
    43.     }
    44.     .height('100%')
    45.   }
    46. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-layout-adapt "应用布局适配智慧多窗")
# 顶部窗口控制条避让适配智慧多窗

更新时间: 2025-12-16 16:40

顶部窗口控制条是应用窗口处于智慧多窗模式下，应用顶部的操作横条 ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.27288733386198945636433798593090:50001231000000:2800:070247D085A5B235D8CB69791C5EFDB2D57D1AAFA439BDC346CC1FF0868E7993.png) 。

顶部窗口控制条示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.30396811749464753232861421275952:50001231000000:2800:79D8F0EDF9909801617EAC4CB1F3B268487F5A704A21E6F777BFFA1C44E5F5F7.png "点击放大")

顶部横条的避让可通过以下两种方式适配：

- 使用窗口的避让能力：通过[setWindowLayoutFullScreen](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)设置窗口布局是否为沉浸式布局。
    
    沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。非沉浸式布局是指布局避让状态栏、导航栏以及智慧多窗顶部横条，组件不会与其重叠。因此可设置isLayoutFullScreen值为false使窗口的布局为非沉浸式布局。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.71455758921508185243369415467470:50001231000000:2800:78F622FE8BE81DE36A6B5E7049DA3F9FF807CEF2DC30E767EA32F0C07DBD055E.png "点击放大")
    
    示例：
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { window } from '@kit.ArkUI';
    4. import { common } from '@kit.AbilityKit';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State message: string = '非沉浸式布局';
    9.   private windowClass: window.Window | undefined = undefined;
    
    10.   aboutToAppear(): void {
    11.     try {
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           this.windowClass = data;
    20.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    21.         });
    22.     } catch (exception) {
    23.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    24.     }
    25.   }
    
    26.   private setWindowLayoutFullScreen(isLayoutFullScreen: boolean) {
    27.     if (!this.windowClass) {
    28.       return;
    29.     }
    30.     this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    31.       console.info('Succeeded in setting the window layout to full-screen mode.');
    32.     }).catch((err: BusinessError) => {
    33.       const errCode: number = err.code;
    34.       if (errCode) {
    35.         console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
    36.         return;
    37.       }
    38.     });
    39.   }
    
    40.   build() {
    41.     Stack({ alignContent: Alignment.TopStart }) {
    42.       Column() {
    43.         Text(this.message)
    44.           .fontSize(25)
    45.           .fontWeight(FontWeight.Bold)
    46.           .margin({
    47.             top: '2%',
    48.             bottom: '40%'
    49.           })
    
    50.         Button() {
    51.           Text('设置窗口为沉浸式布局')
    52.             .fontSize(18)
    53.             .fontWeight(FontWeight.Normal)
    54.         }
    55.         .type(ButtonType.Normal)
    56.         .borderRadius(15)
    57.         .margin({ top: 20 })
    58.         .stateStyles({
    59.           normal: {
    60.             .backgroundColor('#ff6b89d4')
    61.           },
    62.           pressed: {
    63.             .backgroundColor('#ffc81f2a')
    64.           }
    65.         })
    66.         .width('60%')
    67.         .height('6%')
    68.         .onClick(() => {
    69.           this.setWindowLayoutFullScreen(true);
    70.           this.message = '沉浸式布局';
    71.         })
    
    72.         Button() {
    73.           Text('设置窗口为非沉浸式布局')
    74.             .fontSize(18)
    75.             .fontWeight(FontWeight.Normal)
    76.         }
    77.         .type(ButtonType.Normal)
    78.         .borderRadius(15)
    79.         .margin({ top: 20 })
    80.         .stateStyles({
    81.           normal: {
    82.             .backgroundColor('#ff6b89d4')
    83.           },
    84.           pressed: {
    85.             .backgroundColor('#ffc81f2a')
    86.           }
    87.         })
    88.         .width('60%')
    89.         .height('6%')
    90.         .onClick(() => {
    91.           this.setWindowLayoutFullScreen(false);
    92.           this.message = '非沉浸式布局';
    93.         })
    94.       }
    95.       .width('100%')
    96.     }
    97.     .backgroundColor('#fceaeaea')
    98.     .height('100%')
    99.   }
    100. }
    
- 应用主动避让：应用不使用窗口避让能力（即设置窗口为沉浸式布局）。首次通过[getWindowAvoidArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让，并且注册[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#onavoidareachange9)监听系统避让区域变化以进行布局的动态调整。
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { common } from '@kit.AbilityKit';
    4. import { window } from '@kit.ArkUI';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State topSafeHeight: number = 0;
    
    9.   aboutToAppear(): void {
    10.     try {
    11.       let windowClass: window.Window | undefined = undefined;
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           windowClass = data;
    20.           windowClass.setWindowLayoutFullScreen(true);
    21.           this.topSafeHeight = this.getUIContext()?.px2vp(
    22.             windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);
    23.           windowClass.on('avoidAreaChange', (data) => {
    24.             if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
    25.               this.topSafeHeight = this.getUIContext()?.px2vp(data.area.topRect.height)
    26.             }
    27.           })
    28.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    29.         });
    30.     } catch (exception) {
    31.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    32.     }
    33.   }
    
    34.   build() {
    35.     Stack({ alignContent: Alignment.TopStart }) {
    36.       // 顶部避让区域
    37.       Row() {
    38.       }
    39.       .height(this.topSafeHeight)
    40.       .width("100%")
    
    41.       // 根据topSafeHeight动态调整应用布局
    42.       // ...
    43.     }
    44.     .height('100%')
    45.   }
    46. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-layout-adapt "应用布局适配智慧多窗")
# 顶部窗口控制条避让适配智慧多窗

更新时间: 2025-12-16 16:40

顶部窗口控制条是应用窗口处于智慧多窗模式下，应用顶部的操作横条 ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.27288733386198945636433798593090:50001231000000:2800:070247D085A5B235D8CB69791C5EFDB2D57D1AAFA439BDC346CC1FF0868E7993.png) 。

顶部窗口控制条示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.30396811749464753232861421275952:50001231000000:2800:79D8F0EDF9909801617EAC4CB1F3B268487F5A704A21E6F777BFFA1C44E5F5F7.png "点击放大")

顶部横条的避让可通过以下两种方式适配：

- 使用窗口的避让能力：通过[setWindowLayoutFullScreen](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)设置窗口布局是否为沉浸式布局。
    
    沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。非沉浸式布局是指布局避让状态栏、导航栏以及智慧多窗顶部横条，组件不会与其重叠。因此可设置isLayoutFullScreen值为false使窗口的布局为非沉浸式布局。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.71455758921508185243369415467470:50001231000000:2800:78F622FE8BE81DE36A6B5E7049DA3F9FF807CEF2DC30E767EA32F0C07DBD055E.png "点击放大")
    
    示例：
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { window } from '@kit.ArkUI';
    4. import { common } from '@kit.AbilityKit';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State message: string = '非沉浸式布局';
    9.   private windowClass: window.Window | undefined = undefined;
    
    10.   aboutToAppear(): void {
    11.     try {
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           this.windowClass = data;
    20.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    21.         });
    22.     } catch (exception) {
    23.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    24.     }
    25.   }
    
    26.   private setWindowLayoutFullScreen(isLayoutFullScreen: boolean) {
    27.     if (!this.windowClass) {
    28.       return;
    29.     }
    30.     this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    31.       console.info('Succeeded in setting the window layout to full-screen mode.');
    32.     }).catch((err: BusinessError) => {
    33.       const errCode: number = err.code;
    34.       if (errCode) {
    35.         console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
    36.         return;
    37.       }
    38.     });
    39.   }
    
    40.   build() {
    41.     Stack({ alignContent: Alignment.TopStart }) {
    42.       Column() {
    43.         Text(this.message)
    44.           .fontSize(25)
    45.           .fontWeight(FontWeight.Bold)
    46.           .margin({
    47.             top: '2%',
    48.             bottom: '40%'
    49.           })
    
    50.         Button() {
    51.           Text('设置窗口为沉浸式布局')
    52.             .fontSize(18)
    53.             .fontWeight(FontWeight.Normal)
    54.         }
    55.         .type(ButtonType.Normal)
    56.         .borderRadius(15)
    57.         .margin({ top: 20 })
    58.         .stateStyles({
    59.           normal: {
    60.             .backgroundColor('#ff6b89d4')
    61.           },
    62.           pressed: {
    63.             .backgroundColor('#ffc81f2a')
    64.           }
    65.         })
    66.         .width('60%')
    67.         .height('6%')
    68.         .onClick(() => {
    69.           this.setWindowLayoutFullScreen(true);
    70.           this.message = '沉浸式布局';
    71.         })
    
    72.         Button() {
    73.           Text('设置窗口为非沉浸式布局')
    74.             .fontSize(18)
    75.             .fontWeight(FontWeight.Normal)
    76.         }
    77.         .type(ButtonType.Normal)
    78.         .borderRadius(15)
    79.         .margin({ top: 20 })
    80.         .stateStyles({
    81.           normal: {
    82.             .backgroundColor('#ff6b89d4')
    83.           },
    84.           pressed: {
    85.             .backgroundColor('#ffc81f2a')
    86.           }
    87.         })
    88.         .width('60%')
    89.         .height('6%')
    90.         .onClick(() => {
    91.           this.setWindowLayoutFullScreen(false);
    92.           this.message = '非沉浸式布局';
    93.         })
    94.       }
    95.       .width('100%')
    96.     }
    97.     .backgroundColor('#fceaeaea')
    98.     .height('100%')
    99.   }
    100. }
    
- 应用主动避让：应用不使用窗口避让能力（即设置窗口为沉浸式布局）。首次通过[getWindowAvoidArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让，并且注册[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#onavoidareachange9)监听系统避让区域变化以进行布局的动态调整。
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { common } from '@kit.AbilityKit';
    4. import { window } from '@kit.ArkUI';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State topSafeHeight: number = 0;
    
    9.   aboutToAppear(): void {
    10.     try {
    11.       let windowClass: window.Window | undefined = undefined;
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           windowClass = data;
    20.           windowClass.setWindowLayoutFullScreen(true);
    21.           this.topSafeHeight = this.getUIContext()?.px2vp(
    22.             windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);
    23.           windowClass.on('avoidAreaChange', (data) => {
    24.             if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
    25.               this.topSafeHeight = this.getUIContext()?.px2vp(data.area.topRect.height)
    26.             }
    27.           })
    28.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    29.         });
    30.     } catch (exception) {
    31.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    32.     }
    33.   }
    
    34.   build() {
    35.     Stack({ alignContent: Alignment.TopStart }) {
    36.       // 顶部避让区域
    37.       Row() {
    38.       }
    39.       .height(this.topSafeHeight)
    40.       .width("100%")
    
    41.       // 根据topSafeHeight动态调整应用布局
    42.       // ...
    43.     }
    44.     .height('100%')
    45.   }
    46. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-layout-adapt "应用布局适配智慧多窗")
# 顶部窗口控制条避让适配智慧多窗

更新时间: 2025-12-16 16:40

顶部窗口控制条是应用窗口处于智慧多窗模式下，应用顶部的操作横条 ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.27288733386198945636433798593090:50001231000000:2800:070247D085A5B235D8CB69791C5EFDB2D57D1AAFA439BDC346CC1FF0868E7993.png) 。

顶部窗口控制条示意图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.30396811749464753232861421275952:50001231000000:2800:79D8F0EDF9909801617EAC4CB1F3B268487F5A704A21E6F777BFFA1C44E5F5F7.png "点击放大")

顶部横条的避让可通过以下两种方式适配：

- 使用窗口的避让能力：通过[setWindowLayoutFullScreen](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)设置窗口布局是否为沉浸式布局。
    
    沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。非沉浸式布局是指布局避让状态栏、导航栏以及智慧多窗顶部横条，组件不会与其重叠。因此可设置isLayoutFullScreen值为false使窗口的布局为非沉浸式布局。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164042.71455758921508185243369415467470:50001231000000:2800:78F622FE8BE81DE36A6B5E7049DA3F9FF807CEF2DC30E767EA32F0C07DBD055E.png "点击放大")
    
    示例：
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { window } from '@kit.ArkUI';
    4. import { common } from '@kit.AbilityKit';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State message: string = '非沉浸式布局';
    9.   private windowClass: window.Window | undefined = undefined;
    
    10.   aboutToAppear(): void {
    11.     try {
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           this.windowClass = data;
    20.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    21.         });
    22.     } catch (exception) {
    23.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    24.     }
    25.   }
    
    26.   private setWindowLayoutFullScreen(isLayoutFullScreen: boolean) {
    27.     if (!this.windowClass) {
    28.       return;
    29.     }
    30.     this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    31.       console.info('Succeeded in setting the window layout to full-screen mode.');
    32.     }).catch((err: BusinessError) => {
    33.       const errCode: number = err.code;
    34.       if (errCode) {
    35.         console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
    36.         return;
    37.       }
    38.     });
    39.   }
    
    40.   build() {
    41.     Stack({ alignContent: Alignment.TopStart }) {
    42.       Column() {
    43.         Text(this.message)
    44.           .fontSize(25)
    45.           .fontWeight(FontWeight.Bold)
    46.           .margin({
    47.             top: '2%',
    48.             bottom: '40%'
    49.           })
    
    50.         Button() {
    51.           Text('设置窗口为沉浸式布局')
    52.             .fontSize(18)
    53.             .fontWeight(FontWeight.Normal)
    54.         }
    55.         .type(ButtonType.Normal)
    56.         .borderRadius(15)
    57.         .margin({ top: 20 })
    58.         .stateStyles({
    59.           normal: {
    60.             .backgroundColor('#ff6b89d4')
    61.           },
    62.           pressed: {
    63.             .backgroundColor('#ffc81f2a')
    64.           }
    65.         })
    66.         .width('60%')
    67.         .height('6%')
    68.         .onClick(() => {
    69.           this.setWindowLayoutFullScreen(true);
    70.           this.message = '沉浸式布局';
    71.         })
    
    72.         Button() {
    73.           Text('设置窗口为非沉浸式布局')
    74.             .fontSize(18)
    75.             .fontWeight(FontWeight.Normal)
    76.         }
    77.         .type(ButtonType.Normal)
    78.         .borderRadius(15)
    79.         .margin({ top: 20 })
    80.         .stateStyles({
    81.           normal: {
    82.             .backgroundColor('#ff6b89d4')
    83.           },
    84.           pressed: {
    85.             .backgroundColor('#ffc81f2a')
    86.           }
    87.         })
    88.         .width('60%')
    89.         .height('6%')
    90.         .onClick(() => {
    91.           this.setWindowLayoutFullScreen(false);
    92.           this.message = '非沉浸式布局';
    93.         })
    94.       }
    95.       .width('100%')
    96.     }
    97.     .backgroundColor('#fceaeaea')
    98.     .height('100%')
    99.   }
    100. }
    
- 应用主动避让：应用不使用窗口避让能力（即设置窗口为沉浸式布局）。首次通过[getWindowAvoidArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让，并且注册[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#onavoidareachange9)监听系统避让区域变化以进行布局的动态调整。
    
    1. // Index.ets
    2. import { BusinessError } from '@kit.BasicServicesKit';
    3. import { common } from '@kit.AbilityKit';
    4. import { window } from '@kit.ArkUI';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State topSafeHeight: number = 0;
    
    9.   aboutToAppear(): void {
    10.     try {
    11.       let windowClass: window.Window | undefined = undefined;
    12.       window.getLastWindow(this.getUIContext()?.getHostContext() as common.UIAbilityContext,
    13.         (err: BusinessError, data) => {
    14.           const errCode: number = err.code;
    15.           if (errCode) {
    16.             console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
    17.             return;
    18.           }
    19.           windowClass = data;
    20.           windowClass.setWindowLayoutFullScreen(true);
    21.           this.topSafeHeight = this.getUIContext()?.px2vp(
    22.             windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);
    23.           windowClass.on('avoidAreaChange', (data) => {
    24.             if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
    25.               this.topSafeHeight = this.getUIContext()?.px2vp(data.area.topRect.height)
    26.             }
    27.           })
    28.           console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
    29.         });
    30.     } catch (exception) {
    31.       console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
    32.     }
    33.   }
    
    34.   build() {
    35.     Stack({ alignContent: Alignment.TopStart }) {
    36.       // 顶部避让区域
    37.       Row() {
    38.       }
    39.       .height(this.topSafeHeight)
    40.       .width("100%")
    
    41.       // 根据topSafeHeight动态调整应用布局
    42.       // ...
    43.     }
    44.     .height('100%')
    45.   }
    46. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-layout-adapt "应用布局适配智慧多窗")
