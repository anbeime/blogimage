# 自定义节点常见问题

更新时间: 2025-12-16 16:39

本文档介绍自定义节点的常见问题并提供参考。

## 自定义组件的aboutToDisappear回调异常

**问题现象**

从API version 12开始，自定义节点的子节点在页面退出后未立即回调自定义组件的[aboutToDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttodisappear)方法。自定义组件的aboutToDisappear通常在其销毁的时候触发，页面销毁后未立即回调则说明该自定义组件在页面销毁后未立即销毁。

**可能原因**

- 自定义组件存在父节点且父节点未销毁。
- 自定义组件由[BuilderNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-arktsnode-buildernode)创建，该前端对象既未被回收，也未解除对后端自定义组件的引用。BuilderNode创建时，默认持有后端节点的强引用。
- 通过调用[OH_ArkUI_GetNodeHandleFromNapiValue](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-node-napi-h#oh_arkui_getnodehandlefromnapivalue)方法，可以获取BuilderNode或ComponentContent对象中的root节点，此操作会使后端节点的引用计数加一。
- 在[NodeContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontent)中，通过[addFrameNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontent#addframenode12)方法增加了对被添加的FrameNode对象节点的引用关系。然而，该NodeContent对象未被回收，且未通过[removeFrameNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontent#removeframenode12)接口删除所增加的引用关系。

**解决措施**

- 将需要释放的自定义组件从父节点上移除，排除父节点对自定义组件生命周期的影响。
- 自定义组件由[BuilderNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-arktsnode-buildernode)创建时，调用[dispose](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-buildernode#dispose12)接口，立即释放前端BuilderNode对象对于后端节点的强引用。
- 对于使用OH_ArkUI_GetNodeHandleFromNapiValue获取BuilderNode或ComponentContent对象的root节点，
    
    调用[disposenode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-arkui-nativemodule-arkui-nativenodeapi-1#disposenode)减少OH_ArkUI_GetNodeHandleFromNapiValue增加的引用计数。
    
- 未调用dispose时，当前端的BuilderNode对象在[GC](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/gc-introduction)中被回收会释放对后端根节点的引用。调试阶段可使用[hidumper](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hidumper)指令触发GC或[查询堆内存](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hidumper#%E6%9F%A5%E8%AF%A2%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86%E5%86%85%E5%AD%98)来分析引用关系。

**示例代码**

下文中，根节点表示BuilderNode的根节点，aboutToDisappear表示BuilderNode中构建的自定义组件（即BuilderNodePage）中的回调。

- 跳转至pageOneTmp页面后返回，通过指令触发GC，继续操作设备后可以看到aboutToDisappear回调。根节点相关的引用关系和解决方案：
    
    - NodeContent对根节点的引用关系：需要触发NodeContent对象的回收，或主动调用removeFrameNode接口。
    - 全局对象对BuilderNode的引用关系：通过[ArrayList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist)的[clear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist#clear)方法清除对BuilderNode的引用。
    - BuilderNode对象对根节点的引用关系：确保BuilderNode对象无其他引用关系，触发该对象的回收可以解除其对根节点的引用。
- 跳转至pageTwoTmp页面后返回，可以直接看到aboutToDisappear回调。根节点相关的引用关系以及解决方案：
    
    - NodeContent对根节点的引用关系：通过NodeContent的removeFrameNode接口解除引用关系。
    - BuilderNode对象对根节点的引用关系：通过BuilderNode的dispose接口直接解除引用关系。
- 跳转至pageThreeTmp页面后返回，可以直接看到aboutToDisappear回调。根节点相关的引用关系以及解决方案：
    
    - 根节点的父节点对其的引用关系：由于父节点为FrameNode对象对应的节点，可以直接通过FrameNode的removeChild方法解除引用关系。
    - BuilderNode对象对根节点的引用关系：通过BuilderNode的dispose接口直接解除引用关系。

1. import { BuilderNode, FrameNode, NodeContent } from '@kit.ArkUI';
2. import { ArrayList } from '@kit.ArkTS';

3. const CUSTOM_COMPONENT_CONT: string = "CustomComponentCont"
4. AppStorage.setOrCreate<number>(CUSTOM_COMPONENT_CONT, 0);
5. let globalBuilderNodeList: ArrayList<BuilderNode<[]>> = new ArrayList<BuilderNode<[]>>();

6. @Component
7. struct BuilderNodePage {
8.   aboutToAppear(): void {
9.     const count: number | undefined = AppStorage.get<number>(CUSTOM_COMPONENT_CONT);
10.     const current: number = count ? count + 1 : 1;
11.     AppStorage.setOrCreate<number>(CUSTOM_COMPONENT_CONT, current);
12.     console.info("BuilderNodePage", "aboutToAppear " + AppStorage.get<number>(CUSTOM_COMPONENT_CONT))
13.   }

14.   aboutToDisappear(): void {
15.     setTimeout(() => {
16.       const count: number | undefined = AppStorage.get<number>(CUSTOM_COMPONENT_CONT);
17.       console.info("BuilderNodePage", "aboutToDisappear " + count)
18.       const current: number = count ? count - 1 : -1;
19.       AppStorage.set<number>(CUSTOM_COMPONENT_CONT, current)
20.       console.info("BuilderNodePage", "aboutToDisappear " + AppStorage.get<number>(CUSTOM_COMPONENT_CONT))
21.     }, 1)
22.   }

23.   build() {
24.     Text("This is a BuilderNode")
25.   }
26. }

27. @Builder
28. function BuilderNodeBuilder() {
29.   BuilderNodePage();
30. }

31. @Entry
32. @Component
33. struct NavigationExample {
34.   @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack()
35.   private arr: number[] = [1, 2, 3];
36.   @StorageProp(CUSTOM_COMPONENT_CONT) customComponentCount: number | undefined =
37.     AppStorage.get<number>(CUSTOM_COMPONENT_CONT);

38.   @Builder
39.   pageMap(name: string) {
40.     if (name === "NavDestinationTitle1") {
41.       pageOneTmp();
42.     } else if (name === "NavDestinationTitle2") {
43.       pageTwoTmp();
44.     } else if (name === "NavDestinationTitle3") {
45.       pageThreeTmp();
46.     }
47.   }

48.   onPageShow(): void {
49.     console.info("NavigationExample " + this.customComponentCount);
50.   }

51.   build() {
52.     Column() {
53.       Navigation(this.pageInfos) {
54.         Text("BuilderNode中自定义组件的遗留数量 " + this.customComponentCount)
55.           .width("90%")
56.           .height(40)
57.           .backgroundColor('#FFFFFF')
58.         Button("移除全局引用")
59.           .onClick(() => {
60.             // 清除所有全局引用。
61.             // 可以使用hidumper指令触发GC验证引用关系是否清零。
62.             globalBuilderNodeList.clear();
63.           })
64.         List({ space: 12 }) {
65.           ForEach(this.arr, (item: number) => {
66.             ListItem() {
67.               Text("Page" + item)
68.                 .width("100%")
69.                 .height(72)
70.                 .backgroundColor('#FFFFFF')
71.                 .borderRadius(24)
72.                 .fontSize(16)
73.                 .fontWeight(500)
74.                 .textAlign(TextAlign.Center)
75.                 .onClick(() => {
76.                   this.pageInfos.pushPath({ name: "NavDestinationTitle" + item });
77.                 })
78.             }
79.           }, (item: number) => item.toString())
80.         }
81.         .width("100%")
82.         .margin({ top: 12 })
83.       }
84.       .title("主标题")
85.       .mode(NavigationMode.Stack)
86.       .navDestination(this.pageMap)
87.     }
88.     .height('100%')
89.     .width('100%')
90.     .backgroundColor('#F1F3F5')
91.   }
92. }

93. @Component
94. export struct pageOneTmp {
95.   @Consume('pageInfos') pageInfos: NavPathStack;
96.   private builderNode: BuilderNode<[]> = new BuilderNode(this.getUIContext());
97.   private content: NodeContent = new NodeContent();

98.   aboutToAppear(): void {
99.     console.info("pageOneTmp", "aboutToAppear")
100.     this.builderNode.build(wrapBuilder(BuilderNodeBuilder));
101.     if (this.builderNode.getFrameNode()) {
102.       this.content.addFrameNode(this.builderNode.getFrameNode());
103.     }
104.     // 添加全局引用，该对象在全局引用移除前无法被GC。
105.     globalBuilderNodeList.add(this.builderNode);
106.   }

107.   aboutToDisappear(): void {
108.     console.info("pageOneTmp", "aboutToDisappear")
109.   }

110.   build() {
111.     NavDestination() {
112.       Column() {
113.         Text("pageOneTmp")
114.         ContentSlot(this.content)
115.       }.width('100%').height('100%')
116.     }.title("NavDestinationTitle1")
117.     .onBackPressed(() => {
118.       const popDestinationInfo = this.pageInfos.pop(); // 弹出路由栈栈顶元素。
119.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
120.       return true;
121.     })
122.   }
123. }

124. @Component
125. export struct pageTwoTmp {
126.   @Consume('pageInfos') pageInfos: NavPathStack;
127.   private builderNode: BuilderNode<[]> = new BuilderNode(this.getUIContext());
128.   private content: NodeContent = new NodeContent();

129.   aboutToAppear(): void {
130.     console.info("pageTwoTmp", "aboutToAppear")
131.     this.builderNode!.build(wrapBuilder(BuilderNodeBuilder));
132.     if (this.builderNode!.getFrameNode()) {
133.       // 将BuilderNode的根节点挂载至NodeContent对象中。
134.       // 如果要触发builderNode的根节点的析构，需要主动从NodeContent对象中移除该节点，或者等待NodeContent对象被GC。
135.       // 否则，BuilderNode的根节点无法触发析构。
136.       this.content.addFrameNode(this.builderNode!.getFrameNode());
137.     }
138.   }

139.   aboutToDisappear(): void {
140.     console.info("pageTwoTmp", "aboutToDisappear")
141.     if (this.builderNode?.getFrameNode()) {
142.       // 将BuilderNode的根节点从NodeContent对象中移除。
143.       // 需要在BuilderNode的dispose操作之前执行，否则无法获得该BuilderNode的根节点。
144.       this.content.removeFrameNode(this.builderNode?.getFrameNode());
145.     }
146.     this.builderNode?.dispose();
147.   }

148.   build() {
149.     NavDestination() {
150.       Column() {
151.         Text("pageTwoTmp")
152.         ContentSlot(this.content)
153.       }.width('100%').height('100%')
154.     }.title("NavDestinationTitle2")
155.     .onBackPressed(() => {
156.       const popDestinationInfo = this.pageInfos.pop(); // 弹出路由栈栈顶元素。
157.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
158.       return true;
159.     })
160.   }
161. }

162. @Component
163. export struct pageThreeTmp {
164.   @Consume('pageInfos') pageInfos: NavPathStack;
165.   private builderNode: BuilderNode<[]> = new BuilderNode(this.getUIContext());
166.   private content: NodeContent = new NodeContent();
167.   private rootNode: FrameNode = new FrameNode(this.getUIContext());

168.   aboutToAppear(): void {
169.     console.info("pageThreeTmp", "aboutToAppear")
170.     this.builderNode!.build(wrapBuilder(BuilderNodeBuilder));
171.     if (this.builderNode!.getFrameNode()) {
172.       this.content.addFrameNode(this.rootNode);
173.       // BuilderNode的根节点被挂载至FrameNode对象对应的节点中。
174.       // BuilderNode的根节点如果要触发析构需要从主动从FrameNode对象对应的节点中移除，或者等待FrameNode对象对应的节点析构。
175.       // 否则，BuilderNode的根节点无法触发析构。
176.       this.rootNode.appendChild(this.builderNode.getFrameNode());
177.     }
178.   }

179.   aboutToDisappear(): void {
180.     console.info("pageThreeTmp", "aboutToDisappear")
181.     if (this.builderNode?.getFrameNode()) {
182.       // 将BuilderNode的根节点从FrameNode对象对应的节点中移除。
183.       // 需要在BuilderNode的dispose操作以及FrameNode对象dispose之前执行，否则无法获得他们对应的节点。
184.       this.rootNode.removeChild(this.builderNode?.getFrameNode());
185.     }
186.     this.builderNode?.dispose();
187.   }

188.   build() {
189.     NavDestination() {
190.       Column() {
191.         Text("pageThreeTmp")
192.         ContentSlot(this.content)
193.       }.width('100%').height('100%')
194.     }.title("NavDestinationTitle3")
195.     .onBackPressed(() => {
196.       const popDestinationInfo = this.pageInfos.pop(); // 弹出路由栈栈顶元素。
197.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
198.       return true;
199.     })
200.   }
201. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ui-development-faq "UI开发常见问题")
# 按钮与选择组件常见问题

更新时间: 2025-12-16 16:39

本文档介绍按钮与选择组件的常见问题并提供参考。

## Slider组件滑块与滑轨是如何对齐的

Slider的滑块与滑轨显示样式[SliderStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-slider#sliderstyle%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)有三种，其中SliderStyle.OutSet与SliderStyle.InSet存在滑块。Slider的滑动条进度为最小值时，滑块对齐方式如下：

SliderStyle.OutSet模式下，滑块的中心与滑轨的端点对齐，示例图如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163930.67130364015982334852552128768056:50001231000000:2800:8B0E9BC6DAAF682A6BC18CED16C54E42AD1DD7FE92F2E35EB998B92ABE6D938E.jpg)

SliderStyle.InSet模式下，滑块与滑轨的中心对齐，即距离端点滑轨高度的一半的位置，示例图如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163931.21377980005103997644290799434929:50001231000000:2800:288B3D10176F0105C3B18AD1FEB5EDDE80BE4847BB7D38C5F7A838E41846E578.jpg)

**示例**

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Column() {
6.       Slider({
7.         style: SliderStyle.OutSet
8.       })
9.         .blockSize({
10.           width: 20,
11.           height: 20
12.         })
13.         .trackThickness(50)
14.       Slider({
15.         style: SliderStyle.InSet
16.       })
17.         .blockSize({
18.           width: 20,
19.           height: 20
20.         })
21.         .trackThickness(50)
22.     }
23.     .height('100%')
24.     .width('100%')
25.   }
26. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-node-faq "自定义节点常见问题")
# 使用文本常见问题

更新时间: 2025-12-16 16:39

本文档介绍使用文本的常见问题并提供参考。

## 文本显示（Text/Span）常见问题

以下内容介绍了使用[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text)和[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)组件进行文本显示时可能遇到的常见问题，包括文本截断、添加标签、显示表情等场景的处理方法。

### Text组件尾部省略号后为什么还有一段空白，没有占满组件宽度

**问题现象**

在Text组件上未设置宽度，当内容过长时，省略号与组件边缘之间会留有较大空白，且内容更新时省略号的位置会发生变化。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.68332835266137195621200814003632:50001231000000:2800:998CDDA95B7C05BA70C5127C0758C78EEF80B296EDE1DF5B254689872F8010C6.gif)

**原因分析**

当Text组件未设置宽度且内容超长时，组件宽度将采用父组件传递的布局约束的最大宽度。不同内容、不同的断词模式导致排版塑型结果不同，因此省略开始位置也会不同。

**解决措施**

设置[wordBreak](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#wordbreak11)属性为WordBreak.BREAK_ALL，任意2个字符间断行使文本内容尽量占满组件区域。

示例代码如下：

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '混合Hello World! honorificabilitudinitatibus!';

5.   build() {
6.     Column() {
7.       Text(this.message)
8.         .id('HelloWorld')
9.         .fontSize('25fp')
10.         .maxLines(1)
11.         .textOverflow({ overflow: TextOverflow.Ellipsis})
12.         .onClick(() => {
13.           this.message = 'Welcome try try try 1235628327434348';
14.         })
15.         .border({ width: 1})
16.         .wordBreak(WordBreak.BREAK_ALL) // 修改断词模式
17.     }
18.     .width(300)
19.     .border({ width: 1, color: Color.Blue})
20.     .margin({left: 30, top: 50})
21.   }
22. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.09852442039365489862229270892499:50001231000000:2800:F330F3AEB6874DDE6516313B4D585596AC36988E9096D89D1A473596F93DF917.gif)

### Text组件如何实现行末展开样式

**解决措施**

自行测算截断字符，并在行末添加...展开或者...图标作为组件内容。实现方式请参考[属性字符串转Paragraph数组](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-measureutils#getparagraphs20)、[文本展开折叠](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-text-expand-collapse)。

### Text组件如何实现内容超长时自动显示省略样式吗？

**问题现象**

在固定尺寸的组件区域内，不同字号的内容显示的最大行数会有所不同。期望实现内容超长时自动显示省略样式，则无需设置固定的maxLines值。

**解决措施**

设置[heightAdaptivePolicy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#heightadaptivepolicy10)为TextHeightAdaptivePolicy.LAYOUT_CONSTRAINT_FIRST，该模式会删除超过布局约束的行，从而实现类似设置maxLines的效果。

示例代码如下：

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '混合Hello World! 多行文本 中英文数字混合 1282378283 ~';
5.   @State fontSize: number = 25;

6.   build() {
7.     Column({ space: 10 }) {
8.       Text(this.message)
9.         .id('HelloWorld')
10.         .fontSize(this.fontSize)
11.         .textOverflow({ overflow: TextOverflow.Ellipsis})
12.         .border({ width: 1})
13.         .heightAdaptivePolicy(TextHeightAdaptivePolicy.LAYOUT_CONSTRAINT_FIRST) // 调整自适应布局策略
14.         .width(300)
15.         .height(200)
16.       Row(){
17.         Button('fontSize+5')
18.           .onClick(()=>{
19.             this.fontSize += 5;
20.           })
21.         Button('fontSize-5')
22.           .onClick(()=>{
23.             this.fontSize -= 5;
24.           })
25.       }
26.     }
27.     .margin({left: 30, top: 50})
28.   }
29. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.28209714506333730659040082026520:50001231000000:2800:D57838D4C44539B4CFEF4D13AEB147D43818A72B372F21C5BCF13A21ACC7095D.gif)

### 在文本前后添加自定义标签

**问题现象**

如何在文本的前后各添加一个标签，例如“专题”或“Top1”，且这些标签的[背景样式](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-background)、[尺寸设置](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-size)需要能够自定义。

**解决措施一**

如果标签和中间的长文本需在同一行显示，开发者可能会考虑使用[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)实现，但是Span不支持设置尺寸。此时，可以在[弹性布局 (Flex)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-flex-layout)或者[Row](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-row)中放置标签和长文本，并为长文本设置[textOverflow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textoverflow)属性，以确保文本超长时能够自适应截断，显示在一行之内。

实现步骤：

1.将标签和长文本放在同一个沿水平方向布局的容器Row中。

2.中间长文本设置textOverflow属性为TextOverflow.Ellipsis，空间不足时截断文本，显示省略号。

实现案例请参考[实现热搜榜](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display#%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%90%9C%E6%A6%9C)，该示例中，文字“1”、“爆”就是“我是热搜词条”的两个标签。这种实现方式写法简便，适合单行文本添加标签的场景。

**解决措施二**

如果需在多行文本前后添加标签并且不截断文本，上述方案会导致三个Text中的文本不能对齐，因为多行文本会在Row的宽度内折行。此时，可以在[层叠布局 (Stack)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-stack-layout)中放置标签和长文本，给中间多行文本设置首行文本缩进距离[textIndent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textindent10)。多行文本后面的标签则需要通过[offset](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-location#offset)属性调整位置。这种实现方式，可以让三个Text组件中的文字水平对齐。实现步骤如下：

实现步骤：

1.将标签和长文本放在Stack中。

2.在组件显示之前的回调[aboutToAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear)中，使用[measureTextSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-measureutils#measuretextsize12)计算前标签的宽度，作为中间多行文本的首行缩进距离。

3.在组件显示之前的回调aboutToAppear中，通过[getparagraphs](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-measureutils#getparagraphs20)计算中间多行文本最后一行的宽度、除最后一行文本之外的高度，作为后标签的偏移量offset。

4.设置后标签相对于Stack左上角的偏移量。

示例：

1. import { LengthMetrics } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct Index {
5.   @State message: string = '这是一段长文本，超长部分折行，前后添加标签';
6.   @State frontTag: string = '前标签';
7.   @State backTag: string = '后标签';
8.   @State frontPaddingVp: number = 20;
9.   @State backPaddingVp: number = 10;
10.   @State fontTagWidthVp: Length = 0;
11.   @State backTagWidthVp: Length = 0;
12.   @State backOffsetVpX: Length = 0;
13.   @State backOffsetVpY: Length = 0;
14.   @State messageLines: number = 0;
15.   @State stackWidthVp: number = 300;

16.   // 显示之前，测算前后标签的位置，中间文本的缩进距离
17.   aboutToAppear(): void {
18.     // 计算前标签的宽度fontTagWidthVp，作为message的首行缩进距离
19.     let frontTagSize: SizeOptions = this.getUIContext().getMeasureUtils().measureTextSize({
20.       textContent: this.frontTag,
21.     });
22.     this.fontTagWidthVp = this.getUIContext().px2vp(Number(frontTagSize.width)) + this.frontPaddingVp * 2

23.     // 计算frontTag+message占据的行数
24.     let linesFrontTagPlusMessage = 0;
25.     let mutableStr = new MutableStyledString(this.message,
26.       [{
27.         start: 0,
28.         length: 1,
29.         styledKey: StyledStringKey.PARAGRAPH_STYLE,
30.         styledValue: new ParagraphStyle({ textIndent: LengthMetrics.vp(this.fontTagWidthVp) })
31.       }]
32.     )
33.     let paragraphArr = this.getUIContext()
34.       .getMeasureUtils()
35.       .getParagraphs(mutableStr, { constraintWidth: LengthMetrics.vp(this.stackWidthVp) });
36.     for (let i = 0; i < paragraphArr.length; ++i) {
37.       linesFrontTagPlusMessage += paragraphArr[i].getLineCount();
38.     }

39.     // 后标签offsetX的偏移量backOffsetVpX=frontTag+message最后一行的宽度
40.     this.backOffsetVpX =
41.       this.getUIContext().px2vp((paragraphArr[paragraphArr.length-1].getLineWidth(linesFrontTagPlusMessage - 1)))
42.     // 后标签offsetY的偏移量backOffsetVpY=frontTag+message总高度-最后一行的高度。
43.     let heightFrontTagPlusMessageVp = 0;
44.     for (let i = 0; i < paragraphArr.length; ++i) {
45.       heightFrontTagPlusMessageVp += this.getUIContext().px2vp(paragraphArr[i].getHeight());
46.     }
47.     let lastLineHeight =
48.       this.getUIContext().px2vp(paragraphArr[paragraphArr.length-1].getLineHeight(linesFrontTagPlusMessage - 1))
49.     this.backOffsetVpY = heightFrontTagPlusMessageVp - lastLineHeight
50.   }

51.   build() {
52.     Column({ space: 20 }) {
53.       Blank()
54.         .height(200)
55.       Stack() {
56.         Text(this.frontTag)
57.           .padding({ left: this.frontPaddingVp, right: this.frontPaddingVp })
58.           .backgroundColor('rgb(39, 135, 217)')
59.         Text(this.message)
60.           .textIndent(this.fontTagWidthVp)
61.           .padding(0)
62.         Text(this.backTag)
63.           .padding({ left: this.backPaddingVp, right: this.backPaddingVp })
64.           .backgroundColor('rgb(0, 74, 175)')
65.           .offset({
66.             x: this.backOffsetVpX,
67.             y: this.backOffsetVpY
68.           })
69.       }
70.       .alignContent(Alignment.TopStart) // 顶部起始端对齐
71.       .width(this.stackWidthVp)
72.     }
73.     .height('100%')
74.     .width('90%')
75.     .padding('5%')
76.   }
77. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.47863062994645489737157093983000:50001231000000:2800:2217D9185C2F749E22B0AE9CFE3A82747352432B18B7385187DA820FE3C77110.png)

### Text组件如何实现表情与文字一起显示

**问题现象**

emoji表情有时以表情符号的形式表示，如何将表情符号转换为emoji表情，并在Text组件中与文字一同显示？

**解决措施**

使用正则表达式解析表情符号，再将表情符号与图片资源建立映射，通过[Span](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-span)和[ImageSpan](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-imagespan)同时展示表情和文字。

1. @Entry
2. @Component
3. struct TextExample {
4.   @State fulltext: string =
5.     '你好我是Text[grin]，你好我[rolling_on_the_floor_laughing]是Text，[slightly_smiling_face]你好我是Text[grin]';

6.   static classifyTextAndEmojis(input: string): Map<string, string[]> {
7.     const emojiRegex = /\[([a-zA-Z_]+)\]/g; // 根据实际情况编写正则表达式
8.     const resultMap = new Map<string, string[]>(); // 用map记录普通文本和表情
9.     resultMap.set('text', []);
10.     resultMap.set('emojis', []);

11.     let lastIndex = 0;
12.     let match: RegExpExecArray | null = null;

13.     while ((match = emojiRegex.exec(input)) !== null) {
14.       // 添加普通文本
15.       if (match.index > lastIndex) {
16.         resultMap.get('text')?.push(input.substring(lastIndex, match.index));
17.       }
18.       // 添加匹配到的表情
19.       resultMap.get('emojis')?.push(match[1]);
20.       lastIndex = match.index + match[0].length;
21.     }
22.     // 添加最后一段文本
23.     if (lastIndex < input.length) {
24.       resultMap.get('text')?.push(input.substring(lastIndex));
25.     }
26.     return resultMap;
27.   }

28.   static getEmojiImg(emojis: string[]): Resource[] { // 根据正则匹配结果返回自定义表情资源
29.     let emojisImg: Resource[] = []
30.     for (let i = 0; i < emojis.length; i++) {
31.       switch (emojis[i]) { // $r("...")需要替换为开发者所需的图像资源
32.         case 'rolling_on_the_floor_laughing':
33.           emojisImg.push($r("app.media.rolling_on_the_floor_laughing"))
34.         case 'slightly_smiling_face':
35.           emojisImg.push($r("app.media.slightly_smiling_face"))
36.         case 'grin':
37.           emojisImg.push($r("app.media.grin"))
38.         default:
39.       }
40.     }
41.     return emojisImg
42.   }

43.   build() {
44.     Column() {
45.       TextInput({
46.         placeholder: "用户输入带表情的文本，例如：你好[grin]"
47.       })
48.         .width('80%')
49.         .padding(10)
50.         .border({ width: 1, color: '#EEEEEE' })
51.         .onChange((value: string) => {
52.           // 输入变化时，更新 fulltext
53.           this.fulltext = value;
54.         });

55.       Text() {
56.         ForEach(TextExample.classifyTextAndEmojis(this.fulltext).get('text'),
57.           (item: string, index: number) => { // 展示文本和自定义表情资源
58.             Span(item)
59.               .fontSize(18)
60.               .fontColor('#666666')
61.               .fontWeight(FontWeight.Regular)

62.             ImageSpan(TextExample.getEmojiImg(
63.               TextExample.classifyTextAndEmojis(this.fulltext).get('emojis'))[index])
64.               .verticalAlign(ImageSpanAlignment.BOTTOM)
65.               .height(24)
66.           })
67.       }
68.       .width('80%')
69.       .padding(15)
70.     }
71.     .width('100%')
72.     .height('100%')
73.     .justifyContent(FlexAlign.Center)
74.     .alignItems(HorizontalAlign.Center)
75.     .padding(20)
76.   }
77. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.35257321205162451123819479723433:50001231000000:2800:09F61BFD43DAEEB226E77C2491A9C686211AB49EC69A49A856389BD2956C9277.png)

### 文本超长时如何展示

**问题现象**

Text组件中内容过多，超出父组件容器[Column](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-column)的高度，会导致文本溢出容器边界，如何让文本显示在父组件容器的区域内？

**解决措施一**

Text文本是自动折行的，当没有限制Text高度[height](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-size#height)时，Text高度在文本的行数增加时自动调整。可以通过设置[maxLines](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#maxlines)属性限制文本的最大行数，如果有多余的文本默认会被截断。也可以通过[textOverflow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#textoverflow)属性来指定截断方式。

以下示例展示了限制Text组件不超过三行的场景。

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '这是一段超长文本'.repeat(50);

5.   build() {
6.     Column() {
7.       Text(this.message)
8.         .height('auto')
9.         .maxLines(3)
10.     }
11.     .height(200)
12.     .width('80%')
13.     .margin('10%')
14.     .borderWidth(1)
15.     .justifyContent(FlexAlign.Center)
16.   }
17. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.65131496798446420700597249384428:50001231000000:2800:2D3663BD9B34A5B76C686F11D47C694AFBF2135E43E7EA81FF733968AFDFE732.png)

**解决措施二**

上述方法会导致部分文本被裁剪掉，如果需要保留全部文本，可以把Text组件放在滚动容器[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)内，再通过手势滑动来浏览全部文本，具体示例如下：

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = '这是一段超长文本'.repeat(50);

5.   build() {
6.     Column() {
7.       Scroll() {
8.         Text(this.message)
9.       }
10.       .scrollBar(BarState.Off)
11.     }
12.     .height(200)
13.     .width('80%')
14.     .margin('10%')
15.     .borderWidth(1)
16.     .justifyContent(FlexAlign.Center)
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.23087733798533254187563806915238:50001231000000:2800:786F665882148F88E477710783A12B0B40792CCD92C21B0E34F6D5C07D3C4A76.gif)

### selection如何触发弹出自定义菜单并设置菜单字体大小

**问题现象**

在[bindSelectionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#bindselectionmenu11)自定义选择菜单中，可通过TextResponseType设置文本选择菜单的响应类型。通过[selection](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#selection11)如何触发弹出自定义菜单并设置菜单字体大小。

**解决措施**

若希望由selection触发自定义菜单，可将TextResponseType设置为DEFAULT。同时，在[Menu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menu)组件上通过配置font属性，即可自定义菜单的字体大小，灵活适配界面设计需求。

1. // xxx.ets
2. @Entry
3. @Component
4. struct TextExample8 {
5.   controller: TextController = new TextController();
6.   options: TextOptions = { controller: this.controller };
7.   @State selectStart: number = 0;
8.   @State selectEnd: number = 0;

9.   build() {
10.     Column() {
11.       Column() {
12.         Text("TextTextTextText")
13.           .fontSize(14)
14.           .selection(this.selectStart, this.selectEnd)
15.           .copyOption(CopyOptions.InApp)
16.           .bindSelectionMenu(TextSpanType.TEXT, this.CustomMenu, TextResponseType.DEFAULT, {
17.             onDisappear: () => {
18.               this.selectStart = -1;
19.               this.selectEnd = -1;
20.             },
21.           })
22.           .textAlign(TextAlign.Center)
23.           .borderWidth(1)
24.           .borderColor(Color.Red)
25.         Button("Set selection")
26.           .onClick(() => {
27.             this.selectStart = 0;
28.             this.selectEnd = 10;
29.           })
30.           .fontSize(14)
31.           .margin({ top: 20 })
32.       }
33.       .width('100%')
34.       .padding({ top: 300 })
35.     }
36.     .height('100%')
37.   }

38.   @Builder
39.   CustomMenu() {
40.     Column() {
41.       Menu() {
42.         MenuItem({ content: "Item Content" })
43.         MenuItem({ content: "Item Content" })
44.         MenuItem({ content: "Item Content" })
45.       }
46.       .font({ size: 14 })
47.       .radius($r('sys.float.ohos_id_corner_radius_card'))
48.       .clip(true)
49.       .backgroundColor('#F0F0F0')
50.     }
51.   }
52. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163943.51972532304878820521458111019323:50001231000000:2800:96043393CB963272B1FC20592298BD4A4BE9685B166D0D2C53900AB47C9E9C99.gif)

### 如何屏蔽文本的长按手势

**问题现象**

配置[CopyOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#copyoptions9)将文本设置为可选择，此时长按文本会选择文字内容并弹出系统菜单，如何使长按手势不生效。

**解决措施**

想要使长按手势对文本不生效，可以设置触发时间小于系统菜单触发时间（500ms）的自定义长按手势。

1. // xxx.ets
2. @Entry
3. @Component
4. struct TextExample8 {
5.   build() {
6.     Column() {
7.       Text("TextTextTextText")
8.         .copyOption(CopyOptions.InApp)
9.         .gesture(LongPressGesture({ repeat: false, duration: 400 })
10.           .onAction(() => {
11.           }))
12.         .margin({
13.           top: 100,
14.           bottom: 100,
15.           left: 100,
16.           right: 100
17.         })
18.     }
19.     .height('100%')
20.   }
21. }

### 设置enableVariableFontWeight为true后字重不能跟随设置调节

**问题现象**

Text组件调用[fontWeight](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-text#fontweight12)接口，[FontSettingOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-text-common#fontsettingoptions12%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)类型的入参options设置enableVariableFontWeight值为true之后，在系统设置的“字体大小和界面缩放”页面中调节字体粗细，Text组件的字重不跟随变化。

**解决措施**

1. 如果需要Text组件字重跟随系统设置变化，需要在[configuration标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-configuration-file#configuration%E6%A0%87%E7%AD%BE)设置followSystem。
    
2. 字体配置项options控制是否启用可变字重调节。
    

- 当options的参数enableVariableFontWeight取值true时，启用可变字重调节。weight取值为[100, 900]范围内任意整数时，字重取值为weight。此时如果在设置中调节字体粗细，字重始终是开发者设置的数值weight，字体粗细不会变化。
    
- 当options的参数enableVariableFontWeight取值false时，禁用可变字重调节。weight取值为[100, 900]范围内的整百数值时，字重取值为weight。weight是非整百数值时，字重取默认值400。此时更改设置中的字体粗细，字重会随设置变化。此时如果在设置中调节字体粗细，字重会随设置变化。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-select-component-faq "按钮与选择组件常见问题")
# 窗口开发概述

更新时间: 2025-12-16 16:38

## 窗口模块的定义

窗口模块用于在同一块物理屏幕上，提供多个应用界面显示、交互的机制。

- 对应用开发者而言，窗口模块提供了界面显示和交互能力。
    
- 对终端用户而言，窗口模块提供了控制应用界面的方式。
    
- 对整个操作系统而言，窗口模块提供了不同应用界面的组织管理逻辑。
    

## 窗口模块的用途

在HarmonyOS中，窗口模块主要负责以下职责：

- **提供应用和系统界面的窗口对象。** 应用开发者通过窗口加载UI界面，实现界面显示功能。
    
- **组织不同窗口的显示关系，即维护不同窗口间的叠加层次和位置属性。** 应用和系统的窗口具有多种类型，不同类型的窗口具有不同的默认位置和叠加层次（Z轴高度）。同时，用户操作也可以在一定范围内对窗口的位置和叠加层次进行调整。
    
- **提供窗口装饰。窗口装饰指窗口标题栏和窗口边框。** 窗口标题栏通常包括窗口最大化、最小化及关闭按钮等界面元素，具有默认的点击行为，方便用户进行操作；窗口边框则方便用户对窗口进行拖拽缩放等行为。窗口装饰是系统的默认行为，开发者可选择启用/禁用，无需关注UI代码层面的实现。
    
- **提供窗口动效。** 在窗口显示、隐藏及窗口间切换时，窗口模块通常会添加动画效果，以使各个交互过程更加连贯流畅。在HarmonyOS中，应用窗口的动效为默认行为，不需要开发者进行设置或者修改。
    
- **指导输入事件分发。** 即根据当前窗口的状态或焦点，进行事件的分发。触摸和鼠标事件根据窗口的位置和尺寸进行分发，而键盘事件会被分发至焦点窗口。应用开发者可以通过窗口模块提供的接口设置窗口是否可以触摸和是否可以获焦。
    

## 基本概念

### 窗口类型

HarmonyOS的窗口模块将窗口界面分为系统窗口、应用窗口两种基本类型。

- **系统窗口**：系统窗口指完成系统特定功能的窗口。如音量条、壁纸、通知栏、状态栏、导航栏等。
- **应用窗口**：应用窗口区别于系统窗口，指与应用显示相关的窗口。根据显示内容的不同，应用窗口又分为应用主窗口、应用子窗口两种类型。
    - 应用主窗口：应用主窗口用于显示应用界面，会在“任务管理界面”显示。
    - 应用子窗口：应用子窗口用于显示应用的弹窗、悬浮窗等辅助窗口，不会在“任务管理界面”显示。应用子窗口的生命周期跟随应用主窗口。

### 应用窗口模式

应用窗口模式指应用主窗口启动时的显示方式。HarmonyOS目前支持全屏、分屏、自由窗口三种应用窗口模式。这种对多种应用窗口模式的支持能力，也称为操作系统的“多窗口能力”。

- **全屏**：应用主窗口启动时铺满整个屏幕。
- **分屏**：应用主窗口启动时占据屏幕的某个部分，当前支持二分屏。两个分屏窗口之间具有分界线，可通过拖拽分界线调整两个部分的窗口尺寸。
- **自由窗口**：自由窗口的大小和位置可自由改变。同一个屏幕上可同时显示多个自由窗口，这些自由窗口按照打开或者获取焦点的顺序在Z轴排布。当自由窗口被点击或触摸时，将导致其Z轴高度提升，并获取焦点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163826.10513793659738543538323512987448:50001231000000:2800:522E13584F8989E8ED8B604EBD15BE200C40282372F0B7F4A463C9CE30B9C3D3.png)

针对窗口模式的适配开发指导，具体可参考[窗口模式最佳实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-device-window-mode)。

## 实现原理

当前窗口的实现和开发与应用开发模型相关联，不同模型下的接口功能略有区别。当前应用开发模型分为FA模型和Stage模型。

两个模型的整体架构和设计思想，详见[应用模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-models)。

针对窗口开发，推荐使用Stage模型进行相关开发。

## 主窗口的生命周期

### 生命周期概述

在Stage模型下，一个UIAbility对应一个WindowStage，一个WindowStage对应一个应用主窗，UIAbility、WindowStage和应用主窗三者之间的关系如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.04132941078758715389357708364208:50001231000000:2800:295EBE5432140330896DD740BC8BEB22BBA3299398D1B72C887E7E55F846ECBC.png)

每个UIAbility实例都会与一个WindowStage类实例绑定，该类起到了应用进程内窗口管理器的作用。它包含一个主窗口，也就是说UIAbility实例通过WindowStage持有了一个主窗口，该主窗口为ArkUI提供了绘制区域，可以加载不同的ArkUI页面。

在Stage模型下，由UIAbility通过WindowStage管理主窗口并维护其生命周期，可以通过[onWindowStageCreate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-uiability#onwindowstagecreate)和[onWindowStageDestroy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-uiability#onwindowstagedestroy)接收主窗口创建和销毁的通知。详见：[UIAbility生命周期](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-lifecycle)。

### 生命周期状态

窗口在进入前台、前后台切换及退后台时，会触发窗口相应的生命周期状态变化。

Stage模型下主窗口的生命周期状态包括切到前台（SHOWN）、可交互状态（RESUMED）、不可交互状态（PAUSED）和切到后台（HIDDEN）。

- **SHOWN**：窗口进入到前台。当应用从后台切换至前台时，会触发SHOWN事件。
    
- **RESUMED**：窗口进入可交互状态。窗口到前台后会进入该状态，另外窗口恢复也会触发RESUMED事件。
    
- **PAUSED**：窗口进入不可交互状态。窗口在前台可见但是不可交互时，触发PAUSED事件。窗口会保持这种状态，直到重新恢复或退后台。如果窗口恢复，则会触发RESUMED事件，进入可交互状态。
    
- **HIDDEN**：窗口进入到后台。当应用从前台切换至后台时，会触发HIDDEN事件。
    

说明

RESUMED和PAUSED状态分别在窗口切换至前台和切换至后台时触发。但是在一些场景下，RESUMED和PAUSED状态触发会有差异。

- 在一些系统管控场景下会导致RESUMED和PAUSED事件差异，例如应用管控场景，应用窗口在切换至前台进入到认证界面时，触发PAUSED事件，认证通过后，触发RESUMED事件。

|**生命周期状态**|**触发场景举例**|
|:--|:--|
|SHOWN|例如：应用全屏启动、悬浮窗被拉起等。|
|RESUMED|例如：应用全屏启动、悬浮窗被拉起或应用上滑悬停后回到应用等。|
|PAUSED|例如：应用退后台回到桌面、应用全屏状态上滑跟手进入多任务或全屏状态下被系统管控等。|
|HIDDEN|例如：应用全屏状态上滑退后台回到桌面以及其他退后台或销毁等。|

应用主窗口生命周期事件流转关系如下图：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.99419053206282022216355800375231:50001231000000:2800:20ECDC1A6FF3B4B7707AAE396C8CE31C9C96E314193F330A545D6A49B99F0100.png)

**特殊场景**：存在应用被系统管控的场景，会导致应用在启动过程中或RESUMED状态下，进入PAUSED状态，并触发回调通知。

### 监听生命周期状态变化

如果需要感知应用主窗口生命周期变化，开发者可以使用下述注册监听接口来监听应用主窗口的生命周期变化。

- API version 20之前，通过调用[on('windowStageEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#onwindowstageevent9)注册WindowStage生命周期变化的监听，通过调用[off('windowStageEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#offwindowstageevent9)注销WindowStage生命周期变化的监听。本接口无法保证生命周期状态切换间的顺序，对于状态间的顺序有要求的情况下不建议使用。
- API version 20开始，通过调用[on('windowStageLifecycleEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#onwindowstagelifecycleevent20)注册WindowStage生命周期变化的监听，通过调用接口[off('windowStageLifecycleEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#offwindowstagelifecycleevent20)注销WindowStage生命周期变化的监听。本接口不提供WindowStage的获焦失焦状态监听，对于WindowStage获焦失焦状态有监听需求的情况下，推荐使用[on('windowEvent')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#onwindowevent10)， 对生命周期状态间的顺序有要求的情况下建议使用本接口。

### 不同设备生命周期的差异化行为

在Stage模型下，应用主窗口从前台进入后台状态也会驱动UIAbility的生命周期。在该模型下，需要额外关注这个机制在不同类型产品的差异化行为。

- **Phone类型设备上**：窗口从前台进入后台状态，会驱动UIAbility到后台状态。
    
- **Tablet类型设备上：**
    
    - 针对不支持在2in1设备上运行的应用，或可同时支持在phone和2in1上运行的应用，窗口从前台进入后台状态，会驱动UIAbility为后台状态。
        
    - 针对不支持在phone设备上运行且支持在2in1设备上运行的应用，窗口从前台进入后台状态，不会驱动UIAbility为后台状态。
        
- **2in1类型设备上：**
    
    - 针对支持在phone设备运行的应用，窗口从前台进入后台状态，会驱动UIAbility为后台状态。
        
    - 针对不支持在phone设备运行的应用，窗口从前台进入后台状态，不会驱动UIAbility为后台状态。
        

## 约束与限制

- 在FA模型下，不支持系统窗口的相关开发。
    
- 窗口存在大小限制[WindowLimits](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-i#windowlimits11)，该限制由产品配置决定。未调用[setWindowLimits](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlimits11)配置过WindowLimits时，使用[getWindowLimits](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowlimits11)可获取系统限制，单位为px。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-manager "窗口管理")
# 管理应用窗口（Stage模型）

更新时间: 2025-12-16 16:38

## 基本概念

- 窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用的辅助窗口（子窗、全局悬浮窗等）和处于自由窗口下的应用主窗口无法使用沉浸式能力。
    
- 全局悬浮窗：全局悬浮窗是一种特殊的应用辅助窗口，具备在应用主窗口和对应Ability退至后台后仍然可以在前台显示的能力。全局悬浮窗可以用于应用退至后台后，使用小窗继续显示UI，例如音乐应用用于显示桌面歌词等。应用在创建全局悬浮窗前，需要申请对应的权限。
    

## 场景介绍

在Stage模型下，管理应用窗口的典型场景有：

- 设置应用主窗口属性及目标页面
    
- 设置应用子窗口属性及目标页面
    
- 体验窗口沉浸式能力
    
- 设置全局悬浮窗
    
- 监听窗口不可交互与可交互事件
    

以下分别介绍具体开发方式。

## 接口说明

上述场景涉及的常用接口如下表所示。更多API说明请参见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window)。

|实例名|接口名|描述|
|:--|:--|:--|
|WindowStage|getMainWindow(callback: AsyncCallback<Window>): void|获取WindowStage实例下的主窗口。<br><br>此接口仅可在Stage模型下使用。|
|WindowStage|loadContent(path: string, callback: AsyncCallback<void>): void|为当前WindowStage的主窗口加载具体页面。<br><br>其中path为要加载到窗口中的页面内容的路径，该路径需添加到工程的main_pages.json文件中。<br><br>此接口仅可在Stage模型下使用。|
|WindowStage|createSubWindow(name: string, callback: AsyncCallback<Window>): void|创建子窗口。<br><br>此接口仅可在Stage模型下使用。|
|WindowStage|on(eventType: 'windowStageEvent', callback: Callback<WindowStageEventType>): void|开启WindowStage生命周期变化的监听。<br><br>此接口仅可在Stage模型下使用。|
|window静态方法|createWindow(config: Configuration, callback: AsyncCallback<Window>): void|创建子窗口或者系统窗口。<br><br>-config：创建窗口时的参数。|
|Window|setUIContent(path: string, callback: AsyncCallback<void>): void|根据当前工程中某个页面的路径为窗口加载具体的页面内容。<br><br>其中path为要加载到窗口中的页面内容的路径，在Stage模型下该路径需添加到工程的main_pages.json文件中。|
|Window|setWindowBrightness(brightness: number, callback: AsyncCallback<void>): void|设置屏幕亮度值。|
|Window|setWindowTouchable(isTouchable: boolean, callback: AsyncCallback<void>): void|设置窗口是否为可触状态。true表示可触；false表示不可触。|
|Window|moveWindowTo(x: number, y: number, callback: AsyncCallback<void>): void|移动当前窗口位置。|
|Window|resize(width: number, height: number, callback: AsyncCallback<void>): void|改变当前窗口大小。|
|Window|setWindowLayoutFullScreen(isLayoutFullScreen: boolean): Promise<void>|设置主窗口或子窗口的布局是否为沉浸式布局。true表示沉浸式布局；false表示非沉浸式布局。|
|Window|setWindowSystemBarEnable(names: Array<'status'\|'navigation'>): Promise<void>|设置主窗口状态栏、底部导航（根据用户设置，可表现为导航条或三键导航栏）的可见模式，状态栏和底部导航通过status控制、navigation参数无效果。<br><br>例如，该参数设置为['status', 'navigation']，则全部显示；设置为[]，则不显示。|
|Window|setWindowSystemBarProperties(systemBarProperties: SystemBarProperties): Promise<void>|设置窗口内导航栏、状态栏属性。<br><br>systemBarProperties：导航栏、状态栏的属性集合。|
|Window|showWindow(callback: AsyncCallback<void>): void|显示当前窗口。|
|Window|on(type: 'touchOutside', callback: Callback<void>): void|开启本窗口区域外的点击事件的监听。|
|Window|destroyWindow(callback: AsyncCallback<void>): void|销毁当前窗口。|

## 设置应用主窗口

在Stage模型下，应用主窗口由UIAbility创建并维护生命周期。在UIAbility的onWindowStageCreate回调中，通过WindowStage获取应用主窗口，即可对其进行属性设置等操作。还可以在应用配置文件中设置应用主窗口的属性，如最大窗口宽度maxWindowWidth等，详见[module.json5配置文件中的abilities标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)。

### 开发步骤

1. 获取应用主窗口。
    
    通过getMainWindow接口获取应用主窗口。
    
2. 设置主窗口属性。
    
    可设置主窗口的背景色、亮度值、是否可触等多个属性，开发者可根据需要选择对应的接口。本示例以设置“是否可触”属性为例。
    
3. 为主窗口加载对应的目标页面。
    
    通过loadContent接口加载主窗口的目标页面。
    

4. import { UIAbility } from '@kit.AbilityKit';
5. import { window } from '@kit.ArkUI';
6. import { BusinessError } from '@kit.BasicServicesKit';

7. export default class EntryAbility extends UIAbility {
8.   onWindowStageCreate(windowStage: window.WindowStage) {
9.     // 1.获取应用主窗口。
10.     let windowClass: window.Window | null = null;
11.     windowStage.getMainWindow((err: BusinessError, data) => {
12.       let errCode: number = err.code;
13.       if (errCode) {
14.         console.error(`Failed to obtain the main window. Code:${err.code}, message:${err.message}`);
15.         return;
16.       }
17.       windowClass = data;
18.       console.info(`Succeeded in obtaining the main window. Result:${data}`);
19.       // 2.设置主窗口属性。以设置"是否可触"属性为例。
20.       let isTouchable: boolean = true;
21.       windowClass.setWindowTouchable(isTouchable, (err: BusinessError) => {
22.         let errCode: number = err.code;
23.         if (errCode) {
24.           console.error('Failed to set the window to be touchable. Cause:' + JSON.stringify(err));
25.           return;
26.         }
27.         console.info('Succeeded in setting the window to be touchable.');
28.       })
29.     })
30.     // 3.为主窗口加载对应的目标页面。
31.     windowStage.loadContent("pages/page2", (err: BusinessError) => {
32.       let errCode: number = err.code;
33.       if (errCode) {
34.         console.error('Failed to load the content. Cause:' + JSON.stringify(err));
35.         return;
36.       }
37.       console.info('Succeeded in loading the content.');
38.     });
39.   }
40. };

## 设置应用子窗口

开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。

说明

以下几种场景不建议使用子窗口，建议优先考虑使用控件[overlay](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-overlay)能力实现。

- 移动设备（手机、在非自由模式下的平板设备）场景下子窗不能超出处于悬浮窗模式、分屏模式的应用主窗口范围，与控件一致。
- 分屏窗口与自由窗口模式下，主窗口位置大小发生改变时控件实时跟随变化能力优于子窗。
- 部分设备平台下根据实际的系统配置限制，子窗只有系统默认的动效和圆角阴影，应用无法设置，自由度低。

### 开发步骤

1. 创建应用子窗口。
    
    通过createSubWindow接口创建应用子窗口。
    
    子窗口创建后默认是[沉浸式布局](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E6%B2%89%E6%B5%B8%E5%BC%8F%E5%B8%83%E5%B1%80)。
    
2. 设置子窗口属性。
    
    子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。
    
    在调用showWindow之前，建议设置子窗口的大小和位置。
    
    如果没有设置子窗口的大小，调用showWindow后:
    
    - [自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)状态下，默认子窗口大小为当前物理屏幕的大小。其中，[MateBook Fold折叠电脑](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-mate-book-fold)半折叠态下，默认子窗口大小为竖向展开态的物理屏幕大小。
    - 非自由窗口状态下，默认子窗口大小为主窗口大小。
3. 加载显示子窗口的具体内容。
    
    通过setUIContent和showWindow接口加载显示子窗口的具体内容。
    
4. 销毁子窗口。
    
    当不再需要某些子窗口时，可根据具体实现逻辑，使用destroyWindow接口销毁子窗口。
    

直接在onWindowStageCreate里面创建子窗口的整体示例代码如下：

1. import { UIAbility } from '@kit.AbilityKit';
2. import { window } from '@kit.ArkUI';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. let windowStage_: window.WindowStage | null = null;
5. let sub_windowClass: window.Window | null = null;

6. export default class EntryAbility extends UIAbility {
7.   showSubWindow() {
8.     // 1.创建应用子窗口。
9.     if (windowStage_ == null) {
10.       console.error('Failed to create the subwindow. Cause: windowStage_ is null');
11.     }
12.     else {
13.       windowStage_.createSubWindow("mySubWindow", (err: BusinessError, data) => {
14.         let errCode: number = err.code;
15.         if (errCode) {
16.           console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));
17.           return;
18.         }
19.         sub_windowClass = data;
20.         if (!sub_windowClass) {
21.           console.error('sub_windowClass is null');
22.           return;
23.         }
24.         console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));
25.         // 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。
26.         sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
27.           let errCode: number = err.code;
28.           if (errCode) {
29.             console.error('Failed to move the window. Cause:' + JSON.stringify(err));
30.             return;
31.           }
32.           console.info('Succeeded in moving the window.');
33.         });
34.         sub_windowClass.resize(500, 500, (err: BusinessError) => {
35.           let errCode: number = err.code;
36.           if (errCode) {
37.             console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
38.             return;
39.           }
40.           console.info('Succeeded in changing the window size.');
41.         });
42.         // 3.为子窗口加载对应的目标页面。
43.         sub_windowClass.setUIContent("pages/page3", (err: BusinessError) => {
44.           let errCode: number = err.code;
45.           if (errCode) {
46.             console.error('Failed to load the content. Cause:' + JSON.stringify(err));
47.             return;
48.           }
49.           console.info('Succeeded in loading the content.');
50.           if (!sub_windowClass) {
51.             console.error('sub_windowClass is null');
52.             return;
53.           }
54.           // 3.显示子窗口。
55.           sub_windowClass.showWindow((err: BusinessError) => {
56.             let errCode: number = err.code;
57.             if (errCode) {
58.               console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
59.               return;
60.             }
61.             console.info('Succeeded in showing the window.');
62.           });
63.         });
64.       })
65.     }
66.   }

67.   destroySubWindow() {
68.     if (!sub_windowClass) {
69.       console.error('sub_windowClass is null');
70.       return;
71.     }
72.     // 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。
73.     sub_windowClass.destroyWindow((err: BusinessError) => {
74.       let errCode: number = err.code;
75.       if (errCode) {
76.         console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
77.         return;
78.       }
79.       console.info('Succeeded in destroying the window.');
80.     });
81.   }

82.   onWindowStageCreate(windowStage: window.WindowStage) {
83.     windowStage_ = windowStage;
84.     // 开发者可以在适当的时机，如主窗口上按钮点击事件等，创建子窗口。并不一定需要在onWindowStageCreate调用，这里仅作展示
85.     this.showSubWindow();
86.   }

87.   onWindowStageDestroy() {
88.     // 开发者可以在适当的时机，如子窗口上点击关闭按钮等，销毁子窗口。并不一定需要在onWindowStageDestroy调用，这里仅作展示
89.     this.destroySubWindow();
90.   }
91. };

另外，也可以在某个page页面通过点击按钮创建子窗口，整体示例代码如下：

1. // EntryAbility.ets
2. import { UIAbility } from '@kit.AbilityKit';
3. import { window } from '@kit.ArkUI';
4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage) {
6.     windowStage.loadContent('pages/Index', (err) => {
7.       if (err.code) {
8.         console.error('Failed to load the content. Cause:' + JSON.stringify(err));
9.         return;
10.       }
11.       console.info('Succeeded in loading the content.');
12.     })

13.     // 给Index页面传递windowStage
14.     AppStorage.setOrCreate('windowStage', windowStage);
15.   }
16. }

17. // Index.ets
18. import { window } from '@kit.ArkUI';
19. import { BusinessError } from '@kit.BasicServicesKit';

20. let windowStage_: window.WindowStage | undefined = undefined;
21. let sub_windowClass: window.Window | undefined = undefined;
22. @Entry
23. @Component
24. struct Index {
25.   @State message: string = 'Hello World';
26.   private createSubWindow(){
27.     // 获取windowStage
28.     windowStage_ = AppStorage.get('windowStage');
29.     // 1.创建应用子窗口。
30.     if (windowStage_ == null) {
31.       console.error('Failed to create the subwindow. Cause: windowStage_ is null');
32.     }
33.     else {
34.       windowStage_.createSubWindow("mySubWindow", (err: BusinessError, data) => {
35.         let errCode: number = err.code;
36.         if (errCode) {
37.           console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));
38.           return;
39.         }
40.         sub_windowClass = data;
41.         if (!sub_windowClass) {
42.           console.error('sub_windowClass is null');
43.           return;
44.         }
45.         console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));
46.         // 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。
47.         sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
48.           let errCode: number = err.code;
49.           if (errCode) {
50.             console.error('Failed to move the window. Cause:' + JSON.stringify(err));
51.             return;
52.           }
53.           console.info('Succeeded in moving the window.');
54.         });
55.         sub_windowClass.resize(500, 500, (err: BusinessError) => {
56.           let errCode: number = err.code;
57.           if (errCode) {
58.             console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
59.             return;
60.           }
61.           console.info('Succeeded in changing the window size.');
62.         });
63.         // 3.为子窗口加载对应的目标页面。
64.         sub_windowClass.setUIContent("pages/subWindow", (err: BusinessError) => {
65.           let errCode: number = err.code;
66.           if (errCode) {
67.             console.error('Failed to load the content. Cause:' + JSON.stringify(err));
68.             return;
69.           }
70.           console.info('Succeeded in loading the content.');
71.           if (!sub_windowClass) {
72.             console.error('sub_windowClass is null');
73.             return;
74.           }
75.           // 3.显示子窗口。
76.           sub_windowClass.showWindow((err: BusinessError) => {
77.             let errCode: number = err.code;
78.             if (errCode) {
79.               console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
80.               return;
81.             }
82.             console.info('Succeeded in showing the window.');
83.           });
84.         });
85.       })
86.     }
87.   }
88.   private destroySubWindow(){
89.     if (!sub_windowClass) {
90.       console.error('sub_windowClass is null');
91.       return;
92.     }
93.     // 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。
94.     sub_windowClass.destroyWindow((err: BusinessError) => {
95.       let errCode: number = err.code;
96.       if (errCode) {
97.         console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
98.         return;
99.       }
100.       console.info('Succeeded in destroying the window.');
101.     });
102.   }
103.   build() {
104.     Row() {
105.       Column() {
106.         Text(this.message)
107.           .fontSize(50)
108.           .fontWeight(FontWeight.Bold)
109.         Button(){
110.           Text('CreateSubWindow')
111.           .fontSize(24)
112.           .fontWeight(FontWeight.Normal)
113.         }.width(220).height(68)
114.         .margin({left:10, top:60})
115.         .onClick(() => {
116.           this.createSubWindow()
117.         })
118.         Button(){
119.           Text('destroySubWindow')
120.           .fontSize(24)
121.           .fontWeight(FontWeight.Normal)
122.         }.width(220).height(68)
123.         .margin({left:10, top:60})
124.         .onClick(() => {
125.           this.destroySubWindow()
126.         })
127.       }
128.       .width('100%')
129.     }
130.     .height('100%')
131.   }
132. }

133. // subWindow.ets
134. @Entry
135. @Component
136. struct SubWindow {
137.   @State message: string = 'Hello subWindow';
138.   build() {
139.     Row() {
140.       Column() {
141.         Text(this.message)
142.           .fontSize(20)
143.           .fontWeight(FontWeight.Bold)
144.       }
145.       .width('100%')
146.     }
147.     .height('100%')
148.     .backgroundColor('#0D9FFB')
149.   }
150. }

## 体验窗口沉浸式能力

在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。从API version 10开始，沉浸式窗口默认配置为全屏大小并由组件模块控制布局，状态栏、导航栏背景颜色为透明，文字颜色为黑色；应用窗口调用setWindowLayoutFullScreen接口，设置为true表示由组件模块控制忽略状态栏、导航栏的沉浸式全屏布局，设置为false表示由组件模块控制避让状态栏、导航栏的非沉浸式全屏布局。

说明

当前沉浸式界面开发仅支持窗口级别的配置，暂不支持Page级别的配置。若有Page级别切换的需要，可以在页面生命周期开始，例如onPageShow中设置沉浸模式，然后在页面退出，例如onPageHide中恢复默认设置来实现。

### 开发步骤

1. 获取应用主窗口。
    
    通过getMainWindow接口获取应用主窗口。
    
2. 实现沉浸式效果。有以下两种方式：
    
    - 方式一：应用主窗口为全屏窗口时，调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。
        
    - 方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。
        
3. 加载显示沉浸式窗口的具体内容。
    
    通过loadContent接口加载沉浸式窗口的具体内容。
    

4. import { UIAbility } from '@kit.AbilityKit';
5. import { window } from '@kit.ArkUI';
6. import { BusinessError } from '@kit.BasicServicesKit';

7. export default class EntryAbility extends UIAbility {
8.   onWindowStageCreate(windowStage: window.WindowStage) {
9.     // 1.获取应用主窗口。
10.     let windowClass: window.Window | null = null;
11.     windowStage.getMainWindow((err: BusinessError, data) => {
12.       let errCode: number = err.code;
13.       if (errCode) {
14.         console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
15.         return;
16.       }
17.       windowClass = data;
18.       console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));

19.       // 2.实现沉浸式效果。方式一：设置导航栏、状态栏不显示。
20.       let names: Array<'status' | 'navigation'> = [];
21.       windowClass.setWindowSystemBarEnable(names)
22.         .then(() => {
23.           console.info('Succeeded in setting the system bar to be visible.');
24.         })
25.         .catch((err: BusinessError) => {
26.           console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));
27.         });
28.       // 2.实现沉浸式效果。方式二：设置窗口为全屏布局，配合设置导航栏、状态栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。
29.       let isLayoutFullScreen = true;
30.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen)
31.         .then(() => {
32.           console.info('Succeeded in setting the window layout to full-screen mode.');
33.         })
34.         .catch((err: BusinessError) => {
35.           console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
36.         });
37.       let sysBarProps: window.SystemBarProperties = {
38.         statusBarColor: '#ff00ff',
39.         navigationBarColor: '#00ff00',
40.         // 以下两个属性从API Version 8开始支持
41.         statusBarContentColor: '#ffffff',
42.         navigationBarContentColor: '#ffffff'
43.       };
44.       windowClass.setWindowSystemBarProperties(sysBarProps)
45.         .then(() => {
46.           console.info('Succeeded in setting the system bar properties.');
47.         })
48.         .catch((err: BusinessError) => {
49.           console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));
50.         });
51.     })
52.     // 3.为沉浸式窗口加载对应的目标页面。
53.     windowStage.loadContent("pages/page2", (err: BusinessError) => {
54.       let errCode: number = err.code;
55.       if (errCode) {
56.         console.error('Failed to load the content. Cause:' + JSON.stringify(err));
57.         return;
58.       }
59.       console.info('Succeeded in loading the content.');
60.     });
61.   }
62. };

## 设置全局悬浮窗（受限开放）

全局悬浮窗可以在已有的任务基础上，创建一个始终在前台显示的窗口。即使创建全局悬浮窗的任务退至后台，全局悬浮窗仍然可以在前台显示。通常全局悬浮窗位于所有应用窗口之上，开发者可以创建全局悬浮窗，并对全局悬浮窗进行属性设置等操作。

### 开发步骤

**前提条件：** 创建WindowType.TYPE_FLOAT即全局悬浮窗类型的窗口，需要申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，该权限为受控开放权限，仅符合[指定场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/restricted-permissions#ohospermissionsystem_float_window)的在2in1设备上的应用可申请该权限。申请方式请参考：[申请使用受限权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions-in-acl)。

在其他设备或场景下，请使用画中画功能，使用方式参考：[画中画开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-pipwindow)。

注意

如果应用未在应用市场（AGC）申请相应的权限证书，却试图在配置文件中声明此类权限，将会导致应用安装失败。

1. 创建全局悬浮窗。
    
    通过window.createWindow接口创建全局悬浮窗类型的窗口。
    
2. 对全局悬浮窗进行属性设置等操作。
    
    全局悬浮窗窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置全局悬浮窗背景色、亮度等属性。
    
3. 加载显示全局悬浮窗的具体内容。
    
    通过setUIContent和showWindow接口加载显示全局悬浮窗的具体内容。
    
4. 销毁全局悬浮窗。
    
    当不再需要全局悬浮窗时，可根据具体实现逻辑，使用destroyWindow接口销毁全局悬浮窗。
    

1. import { UIAbility } from '@kit.AbilityKit';
2. import { window } from '@kit.ArkUI';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. export default class EntryAbility extends UIAbility {
5.   onWindowStageCreate(windowStage: window.WindowStage) {
6.     // 1.创建全局悬浮窗。
7.     let windowClass: window.Window | null = null;
8.     let config: window.Configuration = {
9.       name: "floatWindow", windowType: window.WindowType.TYPE_FLOAT, ctx: this.context
10.     };
11.     window.createWindow(config, (err: BusinessError, data) => {
12.       let errCode: number = err.code;
13.       if (errCode) {
14.         console.error('Failed to create the floatWindow. Cause: ' + JSON.stringify(err));
15.         return;
16.       }
17.       console.info('Succeeded in creating the floatWindow. Data: ' + JSON.stringify(data));
18.       windowClass = data;
19.       // 2.全局悬浮窗窗口创建成功后，设置全局悬浮窗的位置、大小及相关属性等。
20.       windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
21.         let errCode: number = err.code;
22.         if (errCode) {
23.           console.error('Failed to move the window. Cause:' + JSON.stringify(err));
24.           return;
25.         }
26.         console.info('Succeeded in moving the window.');
27.       });
28.       windowClass.resize(500, 500, (err: BusinessError) => {
29.         let errCode: number = err.code;
30.         if (errCode) {
31.           console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
32.           return;
33.         }
34.         console.info('Succeeded in changing the window size.');
35.       });
36.       // 3.为全局悬浮窗加载对应的目标页面。
37.       windowClass.setUIContent("pages/page4", (err: BusinessError) => {
38.         let errCode: number = err.code;
39.         if (errCode) {
40.           console.error('Failed to load the content. Cause:' + JSON.stringify(err));
41.           return;
42.         }
43.         console.info('Succeeded in loading the content.');
44.         // 3.显示全局悬浮窗。
45.         (windowClass as window.Window).showWindow((err: BusinessError) => {
46.           let errCode: number = err.code;
47.           if (errCode) {
48.             console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
49.             return;
50.           }
51.           console.info('Succeeded in showing the window.');
52.         });
53.       });
54.       // 4.销毁全局悬浮窗。当不再需要全局悬浮窗时，可根据具体实现逻辑，使用destroy对其进行销毁。
55.       windowClass.destroyWindow((err: BusinessError) => {
56.         let errCode: number = err.code;
57.         if (errCode) {
58.           console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
59.           return;
60.         }
61.         console.info('Succeeded in destroying the window.');
62.       });
63.     });
64.   }
65. };

## 监听窗口不可交互与可交互事件

应用在前台显示过程中可能会进入某些不可交互的场景，比较典型的是进入多任务界面。此时，对于一些应用可能需要选择暂停某个与用户正在交互的业务，如视频类应用暂停正在播放的视频或者相机暂停预览流等。而当该应用从多任务又切回前台时，又变成了可交互的状态，此时需要恢复被暂停中断的业务，如恢复视频播放或相机预览流等。

### 开发步骤

在创建WindowStage对象后可通过监听'windowStageEvent'事件类型，监听到窗口进入前台、后台、前台可交互、前台不可交互等事件，应用可根据这些上报的事件状态进行相应的业务处理。

1. import { UIAbility } from '@kit.AbilityKit';
2. import { window } from '@kit.ArkUI';

3. export default class EntryAbility extends UIAbility {
4.   onWindowStageCreate(windowStage: window.WindowStage) {
5.     try {
6.       windowStage.on('windowStageEvent', (data) => {
7.         console.info('Succeeded in enabling the listener for window stage event changes. Data: ' +
8.           JSON.stringify(data));

9.         // 根据事件状态类型选择进行相应的处理
10.         if (data === window.WindowStageEventType.SHOWN) {
11.           console.info('current window stage event is SHOWN');
12.           // 应用进入前台，默认为可交互状态
13.           // ...
14.         } else if (data === window.WindowStageEventType.HIDDEN) {
15.           console.info('current window stage event is HIDDEN');
16.           // 应用进入后台，默认为不可交互状态
17.           // ...
18.         } else if (data === window.WindowStageEventType.PAUSED) {
19.           console.info('current window stage event is PAUSED');
20.           // 前台应用进入多任务，转为不可交互状态
21.           // ...
22.         } else if (data === window.WindowStageEventType.RESUMED) {
23.           console.info('current window stage event is RESUMED');
24.           // 进入多任务后又继续返回前台时，恢复可交互状态
25.           // ...
26.         }

27.         // ...
28.       });
29.     } catch (exception) {
30.       console.error('Failed to enable the listener for window stage event changes. Cause:' +
31.         JSON.stringify(exception));
32.     }
33.   }
34. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-overview "窗口开发概述")
