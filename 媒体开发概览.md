# 媒体开发概览

更新时间: 2025-12-16 16:35

HarmonyOS提供丰富的一站式媒体业务开放能力，开发者能够在系统上快速开发主流的媒体业务，满足常规高频使用场景，并提供优秀的性能表现。

## 媒体系统架构

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163514.28035366939295256459463032973935:50001231000000:2800:1BBA414A91B1538D7BA4B3F0E88B71B6945614F91EDFDD8AB58B8650F4AF2D46.png "点击放大")

媒体系统架构提供用户视觉、听觉信息的处理能力，例如音视频信息的采集、编码存储、解码播放等。操作系统实现中，根据不同的媒体信息处理内容，将媒体划分为不同的模块，包括音频、视频、图片等。

媒体系统面向应用开发提供音视频应用、图库应用、相机应用的编程框架接口；面向设备开发提供对接不同硬件芯片的适配加速功能；中间以服务形式提供媒体核心功能和管理机制。

- 音频服务（Audio Kit）：提供场景化音频播放和录制接口，助力开发者快速构建音频高清采集及沉浸式播放能力。
- 音视频编解码服务（AVCodec Kit）：提供音视频编解码、媒体文件解析、封装及媒体数据输入等原子能力。
- 音视频播控服务（AVSession Kit）：提供系统级音视频管控服务，统一管理系统中所有音视频行为。
- 相机服务（Camera Kit）：提供场景化相机控制管理接口，实现预览图像显示、拍照图片保存及视频录制功能。
- 数字版权保护服务（DRM Kit）：提供DRM加密音视频解密，支持设备DRM证书管理、许可证管理及内容解密功能。
- 图片处理服务（Image Kit）：提供全面图片处理能力，帮助开发者实现图片的解码、编码、编辑、元数据处理和图片接收等功能。
- 媒体服务（Media Kit）：提供端到端播放原始媒体资源，音视频录制与屏幕录制，获取媒体资源元数据、缩略图，视频转码等功能。
- 媒体文件管理服务（Media Library Kit）：提供管理相册和媒体文件的能力，包括照片和视频。
- 铃声服务（Ringtone Kit）：提供铃声设置功能，为用户提供简单一致、安全高品质的铃声设置体验。
- 统一扫码服务（Scan Kit）：提供系统级的扫码服务。

## 媒体应用开发综述

### 相机预览

相机预览是启动相机后实时的图像显示，通常在拍照和录像前执行。

**指南**

- [预览(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-preview)
- [双路预览(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-dual-channel-preview)
- [动态调整预览帧率(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-framerate)
- [适配相机旋转角度(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-rotation-angle-adaptation)
- [预览(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-camera-preview)
- [预览流二次处理(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-camera-preview-imagereceiver)
- [动态调整预览帧率(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-setframerate-native)

**API参考**

- ArkTS API：[camera](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera)
- C API：[OH_Camera](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-oh-camera)

**最佳实践**

- [相机预览花屏解决方案](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-deal-stride-solution)

### 相机拍照

拍照是相机的最重要功能之一，Camera Kit提供多种拍照方式，开发者可以直接拉起系统相机拍照、采用系统预配置简化应用开发流程，或是根据开放接口开发一个专业的相机应用。

**指南**

- [通过系统相机拍照和录像(CameraPicker)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-picker)
- [拍照(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-shooting)
- [分段式拍照(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-deferred-capture)
- [动态照片拍摄(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-moving-photo)
- [使用相机预配置(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-preconfig)
- [HDR Vivid相机拍照(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-hdr-shooting)
- [适配相机旋转角度(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-rotation-angle-adaptation)
- [拍照(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-camera-shooting)
- [分段式拍照(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-camera-deferred-capture)
- [使用相机预配置(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-preconfig-native)

**API参考**

- ArkTS API：[camera](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera)
- ArkTS组件：[cameraPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camerapicker)
- C API：[OH_Camera](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-oh-camera)

**最佳实践**

- [生态应用相机实现系统级相机体验](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-third-party-camera)
- [相机分段式拍照性能优化实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-camera-shot2see)

**示例代码**

- [基于相机开放能力实现系统级相机](https://gitcode.com/HarmonyOS_Samples/third-party-camera)
- [基于系统相机实现拍照功能](https://gitcode.com/HarmonyOS_Samples/camera-picker)
- [实现相机数据采集保存功能](https://gitcode.com/HarmonyOS_Samples/camera)
- [实现相机数据采集保存功能（C++）](https://gitcode.com/HarmonyOS_Samples/camera-data-collection)

### 视频播放

AVPlayer提供功能齐全的一体化播放能力，支持多种音视频格式和流媒体协议。应用使用AVPlayer不仅可以实现基础的播放控制，还可以通过外挂字幕、画中画、自定义UI控件、内容版权保护等功能，为用户提供优良的影音体验。

**指南**

- [AVPlayer简介（含支持的格式与协议）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/media-kit-intro#avplayer)
- [使用AVPlayer播放视频(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-playback)
- [使用AVPlayer设置播放URL(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/playback-url-setting-method)
- [使用AVPlayer播放流媒体(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/streaming-media-playback-development-guide)
- [使用AVPlayer添加视频外挂字幕(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-subtitle)
- [使用AVPlayer播放视频(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ndk-avplayer-for-video-playback)
- [HDR Vivid视频播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-vivid-video-player)
- [接入Background Tasks Kit长时任务实现后台播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/continuous-task)
- [应用接入AVSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avsession-access-scene)
- [应用接入播控自检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/playback-control-access-selfcheck)
- [基于AVPlayer播放DRM节目(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/drm-avplayer-arkts-integration)
- [视频转码(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/media-transcoder-arkts)
- [在应用程序中使用画中画功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-pipwindow)

**API参考**

- ArkTS API：[AVPlayer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avplayer)
- C API：[AVPlayer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avplayer)

**最佳实践**

- [视频播放开发实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-playback-development-practice)
- [在线视频播放卡顿优化实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-online-video-playback-lags-practice)
- [音画同步最佳实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-video-synchronization)
- [基于系统能力获取视频缩略图](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-thumbnail)

**示例代码**

- [实现视频播放功能](https://gitcode.com/HarmonyOS_Samples/video-play)
- [实现视频边缓存边播放功能](https://gitcode.com/HarmonyOS_Samples/video-cache)
- [实现视频流畅播放且支持后台与焦点打断功能](https://gitcode.com/HarmonyOS_Samples/video-player)
- [基于系统能力获取视频缩略图](https://gitcode.com/HarmonyOS_Samples/VideoThumbnail)
- [实现流畅切换短视频](https://gitcode.com/HarmonyOS_Samples/SmoothSwitchShortVideos)
- [实现音画同步播放效果](https://gitcode.com/HarmonyOS_Samples/AudioToVideoSync)

**设计体验**

- [播控中心](https://developer.huawei.com/consumer/cn/doc/design-guides/broadcasting-control-0000001957017133)
- [画中画](https://developer.huawei.com/consumer/cn/doc/design-guides/pip-0000001927422624)

### 视频录制

AVRecorder提供音视频录制的能力，AVScreenCapture提供屏幕录制的能力，支持多源输入，可灵活配置录制参数，帮助开发者轻松实现音视频录制功能。

**指南**

- [AVRecorder简介（含支持的格式）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/media-kit-intro#avrecorder)
- [使用AVRecorder录制视频(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-recording)
- [AVScreenCapture简介（含支持的格式）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/media-kit-intro#avscreencapture)
- [使用AVScreenCaptureRecorder录屏写文件(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avscreencapture-arkts)
- [使用AVScreenCapture录屏取码流(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avscreencapture-for-buffer)
- [使用AVScreenCapture录屏写文件(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avscreencapture-for-file)
- [HDR Vivid相机录像](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-hdr-recording)
- [HDR Vivid视频录制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-vivid-video-recorder)
- [使用Camera Kit录像(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-recording)

**API参考**

- ArkTS API：[AVRecorder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avrecorder)
- C API：[AVRecorder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avrecorder)
- ArkTS API：[AVScreenCaptureRecorder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avscreencapturerecorder)
- C API：[AVScreenCapture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avscreencapture)

**示例代码**

- [基于CameraKit通过AVRecorder录像](https://gitcode.com/HarmonyOS_Samples/camera-kit-avrecorder)

### 视频投播

使用媒体播控，可以简单高效地将音视频投放到其他HarmonyOS设备上播放，如在手机上播放的音视频，可以投到2in1设备上继续播放。

**指南**

- [使用通话设备切换组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-switch-call-devices)
- [投播组件开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/distributed-playback-guide)
- [扩展屏投播开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avsession-extended-screen)

**API参考**

- ArkTS API：[avsession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-avsession)
- ArkTS组件：[AVCastPicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-multimedia-avcastpicker)

**示例代码**

- [实现视频投播功能](https://gitcode.com/HarmonyOS_Samples/VideoCast)

### 音频播放

开发者可以使用AVPlayer播放媒体资源，如mp4/mp3/mkv/mpeg-ts等，也可以使用AudioRenderer播放PCM音频数据。

**AVPlayer指南**

- [使用AVPlayer播放音频(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avplayer-for-playback)

- [使用AVPlayer设置播放URL(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/playback-url-setting-method)
- [使用AVPlayer播放流媒体(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/streaming-media-playback-development-guide)

- [使用SoundPool播放短音频(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-soundpool-for-playback)

- [使用AVPlayer播放音频(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ndk-avplayer-for-playback)

**AVPlayer API参考**

- ArkTS API：[AVPlayer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avplayer)
- C API：[AVPlayer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avplayer)

**AudioRenderer****指南**

- [使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)
- [响应音频流输出设备变更](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-output-device-change)
- [使用OHAudio开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)
- [使用AudioHaptic开发音振协同播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiohaptic-for-playback)

**AudioRenderer API参考**

- ArkTS API：[AudioRenderer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer)
- ArkTS API：[audioHaptic](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-audiohaptic)
- C API：[OHAudio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio)

**通用指南**

- [接入Background Tasks Kit长时任务实现后台播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/continuous-task)
- [应用接入AVSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avsession-access-scene)
- [应用接入播控自检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/playback-control-access-selfcheck)
- [使用合适的音频流类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype)
- [音频焦点和音频会话介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency)
- [使用AudioSession管理应用音频焦点(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-session-management)
- [使用AudioSession管理应用音频焦点(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-session)

**最佳实践**

- [音频焦点管理解决方案](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-focus-management)
- [音频播放类应用交互场景实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-interaction-practice)
- [音乐服务卡片](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-music-card)

**示例代码**

- [实现音频应用作为媒体会话提供方接入媒体会话](https://gitcode.com/HarmonyOS_Samples/media-provider)
- [实现音频低时延录制与播放](https://gitcode.com/HarmonyOS_Samples/audio-native)
- [基于AudioRenderer的音频播控和多场景交互](https://gitcode.com/HarmonyOS_Samples/audio-interaction)

**设计体验**

- [播控中心](https://developer.huawei.com/consumer/cn/doc/design-guides/broadcasting-control-0000001957017133)

### 音频采集

AudioCapture提供了音频采集能力，为开发者提供PCM原始数据。

**指南**

- [使用AudioCapturer开发音频录制功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiocapturer-for-recording)
- [使用OHAudio开发音频录制功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-recording)

**API参考**

- ArkTS API：[AudioCapturer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiocapturer)
- C API：[OHAudio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio)

**示例代码**

- [实现音频低时延录制与播放](https://gitcode.com/HarmonyOS_Samples/audio-native)
- [基于AudioRenderer的音频播控和多场景交互](https://gitcode.com/HarmonyOS_Samples/audio-interaction)

### 音频录制

AVRecorder提供音频录制的能力，帮助开发者录制纯音频文件。

**指南**

- [使用AVRecorder录制音频(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avrecorder-for-recording)

**API参考**

- ArkTS API：[AVRecorder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avrecorder)
- C API：[AVRecorder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avrecorder)

### 媒体资源的选择和保存

**指南**

- [使用Picker选择媒体库资源](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/photoaccesshelper-photoviewpicker)
- [使用PhotoPicker组件访问图片/视频](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/component-guidelines-photoviewpicker)
- [保存媒体库资源](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/photoaccesshelper-savebutton)

**API参考**

- ArkTS API：[photoAccessHelper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-photoaccesshelper)
- ArkTS组件：[AlbumPickerComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-file-albumpickercomponent)
- ArkTS组件：[PhotoPickerComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-file-photopickercomponent)
- ArkTS组件：[RecentPhotoComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-file-recentphotocomponent)

**最佳实践**

- [图片获取与保存实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-image_get_and_save)

**示例代码**

- [实现图片获取与保存功能](https://gitcode.com/HarmonyOS_Samples/ImageGetAndSave)
- [基于PhotoPicker实现图片推荐功能](https://gitcode.com/HarmonyOS_Samples/SmartPhotoPicker)

### 隐私安全

在进行媒体应用开发过程中，应用需要访问个人数据（如用户照片、视频、音频文件等）和设备数据（如相机、麦克风等）。这些资源受系统保护，使用时需通过Picker或申请相关权限。

**访问个人数据**

- [使用Picker选择媒体库资源](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/photoaccesshelper-photoviewpicker)
- [保存资源到媒体库](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/photoaccesshelper-savebutton)
- [选择音频类文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/select-user-file#%E9%80%89%E6%8B%A9%E9%9F%B3%E9%A2%91%E7%B1%BB%E6%96%87%E4%BB%B6)
- [保存音频类文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/save-user-file#%E4%BF%9D%E5%AD%98%E9%9F%B3%E9%A2%91%E7%B1%BB%E6%96%87%E4%BB%B6)

应用需要克隆、备份或同步图片/视频类文件时，可[申请受限权限读写媒体库](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/photoaccesshelper-preparation#%E7%94%B3%E8%AF%B7%E7%9B%B8%E5%86%8C%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%85%B3%E6%9D%83%E9%99%90)。

**访问设备数据**

麦克风权限ohos.permission.MICROPHONE、相机权限ohos.permission.CAMERA、媒体地理位置信息权限ohos.permission.MEDIA_LOCATION，均为用户授权权限，申请方式见[向用户申请授权](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/request-user-authorization)。

## 更多资源

|   |   |   |
|---|---|---|
|Audio Kit|音频焦点|- 开发指南：[使用合适的音频流类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype)<br>- 开发指南：[音频焦点和音频会话](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency)<br>- ArkTS API参考：[AudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager)<br>- ArkTS API参考：[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)|
|音频通话|- 开发指南：[使用AudioRenderer播放对端的通话声音](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-call-development#%E4%BD%BF%E7%94%A8audiorenderer%E6%92%AD%E6%94%BE%E5%AF%B9%E7%AB%AF%E7%9A%84%E9%80%9A%E8%AF%9D%E5%A3%B0%E9%9F%B3)<br>- 开发指南：[使用AudioCapturer录制本端的通话声音](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-call-development#%E4%BD%BF%E7%94%A8audiocapturer%E5%BD%95%E5%88%B6%E6%9C%AC%E7%AB%AF%E7%9A%84%E9%80%9A%E8%AF%9D%E5%A3%B0%E9%9F%B3)|
|更多|[Audio Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-kit)<br><br>[Audio Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/audio-api)|
|AVCodec Kit|音频编解码|- 开发指南：[音频编码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-encoding)<br>- 开发指南：[音频解码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-decoding)<br>- 示例代码：[AudioEncoder（音频编码）](https://gitcode.com/HarmonyOS_Samples/AVCodecVideo/blob/master/entry/src/main/cpp/capbilities/AudioEncoder.cpp)<br>- 示例代码：[AudioDecoder（音频解码）](https://gitcode.com/HarmonyOS_Samples/AVCodecVideo/blob/master/entry/src/main/cpp/capbilities/AudioDecoder.cpp)<br>- C API参考：[AudioCodec（音频编解码）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-avcodec-audiocodec-h)|
|视频编解码|- 开发指南：[视频编码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-encoding)<br>- 示例代码：[VideoEncoder（视频编码）](https://gitcode.com/openharmony/applications_app_samples/blob/master/code/BasicFeature/Media/AVCodec/entry/src/main/cpp/capbilities/video_encoder.cpp)<br>- C API参考：[VideoEncoder（视频编码）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-avcodec-videoencoder-h)<br>- 开发指南：[视频解码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-decoding)<br>- 示例代码：[VideoDecoder（视频解码）](https://gitcode.com/openharmony/applications_app_samples/blob/master/code/BasicFeature/Media/AVCodec/entry/src/main/cpp/capbilities/video_decoder.cpp)<br>- C API参考：[VideoDecoder（视频解码）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-avcodec-videodecoder-h)|
|更多|[AVCodec Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avcodec-kit)<br><br>[AVCodec Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/avcodec-api)|
|AVSession Kit|本地媒体会话|- ArkTS API参考：[媒体会话管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-avsession)<br>- 开发指南：[应用接入AVSession场景介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avsession-access-scene)<br>- 示例代码：[基于AVPlayer实现播放接入](https://gitcode.com/HarmonyOS_Samples/media-provider)<br>- 示例代码：[基于AudioRenderer实现播放接入](https://gitcode.com/HarmonyOS_Samples/audio-interaction)|
|更多|[AVSession Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avsession-kit)<br><br>[AVSession Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/avsession-api)|
|Camera Kit|视频录制|- ArkTS API参考：[Camera API(相机管理)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera)<br><br>- 开发指南：[录像(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-recording)<br>- 开发指南：[录像(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-camera-recording)<br>- 示例实现：[录像实践(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-recording-case)|
|安全相机|- ArkTS API参考：[SecureSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-camera-securesession)<br><br>- 开发指南：[安全相机(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-secure-photo)|
|更多|[Camera Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-kit)<br><br>[Camera Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/camera-api)|
|DRM Kit|AVPlayer播放DRM节目|- ArkTS API参考：[DRM](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-drm)<br>- 开发指南：[数字版权保护(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/drm-arkts-dev-guide)<br>- 示例实现：[基于AVPlayer播放DRM节目(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/drm-avplayer-arkts-integration)|
|AVCodec播放DRM节目|- C API参考：[数字版权保护API(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-drm)<br>- 开发指南：[数字版权保护(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/drm-c-dev-guide)<br>- 示例实现：[基于AVCodec播放DRM节目(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/drm-avcodec-integration)|
|更多|[DRM Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/drm-kit)<br><br>[DRM Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/drm-api)|
|Image Kit|图片解码|支持HEIF、JPEG、PNG、WebP、GIF、BMP、SVG、ICO、DNG格式图片的解码。<br><br>- ArkTS指南：[使用ImageSource完成图片解码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-decoding)<br>- C/C++指南：[使用Image_NativeModule完成图片解码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-source-c)<br><br>支持自定义申请内存类型，优化解码效率。<br><br>- ArkTS指南：[申请图片解码内存(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-allocator-type)<br>- C/C++指南：[申请图片解码内存(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-allocator-type-c)|
|图片编码|支持编码为HEIF、JPEG、PNG、WebP、GIF格式图片。<br><br>- ArkTS指南：[使用ImagePacker完成图片编码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-encoding)<br>- C/C++指南：[使用Image_NativeModule完成图片编码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-packer-c)|
|图片接收|支持作为消费者接收和处理图片。<br><br>- ArkTS指南：[使用ImageReceiver完成图片接收](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-receiver)<br>- C/C++指南：[使用Image_NativeModule完成图片接收](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-receiver-c)<br>- C/C++指南：[使用Image_NativeModule处理图像信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-info-c)|
|图片编辑和处理|支持裁剪、缩放、偏移、旋转、翻转、设置透明度等图像变换，以及对图片部分区域做像素数据写入的位图操作。<br><br>- ArkTS指南：[使用PixelMap完成图像变换](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-transformation)<br>- ArkTS指南：[使用PixelMap完成位图操作](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-pixelmap-operation)<br>- C/C++指南：[使用Image_NativeModule完成位图操作](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/pixelmap-c)|
|支持读取和编辑图片的EXIF信息。<br><br>- ArkTS指南：[编辑图片EXIF信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-tool)<br>- C/C++指南：[使用Image_NativeModule编辑图片EXIF信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-tool-c)|
|支持为图片添加个性化的滤镜效果。<br><br>- C/C++指南：[使用ImageEffect编辑图片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-effect-guidelines)|
|支持对图片做清晰度增强、色彩空间转换、HDR效果转换。<br><br>- C/C++指南：[图片缩放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-scaling)<br>- C/C++指南：[图片色彩空间转换](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-csc)<br>- C/C++指南：[图片动态元数据生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-dynamic-metadata-generation)<br>- C/C++指南：[单层HDR图片转换双层](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-single-to-dual)<br>- C/C++指南：[双层HDR图片转换单层](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-dual-to-single)|
|更多|[Image Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-kit)<br><br>[Image Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/image-api)|
|**Media Kit**|视频转码|- ArkTS API参考：[AVTranscoder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avtranscoder)<br>- 开发指南：[使用AVTranscoder实现视频转码(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avtranscoder-for-transcodering)<br>- 开发指南：[创建异步线程执行AVTranscoder视频转码(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avtranscoder-practice)|
|元数据|- ArkTS API参考：[AVMetadataExtractor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avmetadataextractor)<br>- C API参考：[AVMetadataExtractor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avmetadataextractor)<br>- 开发指南：[使用AVMetadataExtractor提取音视频元数据信息(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avmetadataextractor)<br>- 开发指南：[使用AVMetadataExtractor获取元数据(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ndk-avmetadataextractor-for-media)|
|缩略图|- ArkTS API参考：[AVImageGenerator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avimagegenerator)<br>- C API参考：[AVImageGenerator](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avimagegenerator)<br><br>- 开发指南：[使用AVImageGenerator提取视频指定时间图像(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avimagegenerator)<br>- 开发指南：[使用AVImageGenerator获取视频帧(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ndk-avimagegenerator-for-video)<br>- 最佳实践：[基于系统能力获取视频缩略图](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-thumbnail)|
|更多|[Media Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/media-kit)<br><br>[Media Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/media-api)|
|**Media Library Kit**|管理动态照片|- 指南：[访问和管理动态照片资源](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/photoaccesshelper-movingphoto)<br>- 指南：[使用MovingPhotoView播放动态照片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/movingphotoview-guidelines)|
|更多|[Media Library Kit开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/medialibrary-kit)<br><br>[Media Library Kit API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/media-library-api)|
|Ringtone Kit|铃声设置服务|- ArkTS API参考：[铃声服务](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ringtone-ringtone)<br>- 指南：[设置铃声](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ringtone-preparations)|
|Scan Kit|默认界面扫码|- ArkTS API参考：[默认界面扫码](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/scan-scanbarcode-api)<br>- 指南：[默认界面扫码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scan-scanbarcode)|
|自定义界面扫码|- ArkTS API参考：[自定义界面扫码](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/scan-customscan-api)<br>- 指南：[自定义界面扫码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scan-customscan)|
|图像识码|- ArkTS API参考：[图像识码](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/scan-imagedecode)<br>- 指南：[识别本地图片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scan-detectbarcode)<br>- 指南：[识别图像数据](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scan-decodeimage)|
|码图生成|- ArkTS API参考：[码图生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/scan-generatebarcode)<br>- 指南：[通过文本生成码图](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scan-barcodegenerate)<br>- 指南：[通过字节数组生成码图](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scan-generatearray)|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multimedia-hdr-vivid "使用HDR Vivid特性开发媒体应用")
# 使用HDR Vivid特性开发媒体应用

更新时间: 2025-12-16 16:35

[HDR Vivid](https://www.theuwa.com/standard?cate=3)是UWA认证的动态HDR视频标准，在HarmonyOS平台上，开发者能够利用HDR Vivid的特性，开发媒体类应用，为用户呈现高动态范围和广色域的视觉体验。作为新一代高动态范围图像标准，HDR Vivid贯穿内容创作、平台支持和设备显示，为用户带来更宽广的色彩范围、更细腻的层次表现、更显著的明暗对比，以及更智能的动态元数据处理，助力用户领略世界的真实色彩。

## HDR Vivid视频

应用只需调用媒体领域提供的API，即可接入HarmonyOS的HDR Vivid视频采集、转码和解码显示功能，基于HDR Vivid标准，制作出高质量的视频。

|类别|开发指导|提供能力的Kit|
|:--|:--|:--|
|采集|[HDR Vivid相机录像](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-hdr-recording)|Camera Kit|
|编码|[HDR Vivid视频录制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-vivid-video-recorder)|AVCodec Kit|
|解码|[HDR Vivid视频播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-vivid-video-player)|AVCodec Kit|
|转换|[视频解码支持HDRVivid2SDR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdrvivid2sdr)|AVCodec Kit|
|[HDR Vivid视频动态元数据生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/generate-video-dynamic-metadata)|Media Kit|
|[HDR视频色彩空间转换](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-csc)|Media Kit|

## HDR Vivid图片

应用只需调用媒体领域提供的API，即可接入HarmonyOS的HDR Vivid图片采集、转码和解码显示功能，基于HDR Vivid标准，制作出高质量的图片。

|类别|开发指导|提供能力的Kit|
|:--|:--|:--|
|采集|[HDR Vivid相机拍照](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-hdr-shooting)|Camera Kit|
|编码|[HDR Vivid图片编码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-packer-c)|Image Kit|
|解码|[HDR Vivid图片解码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-source-c)|Image Kit|
|转换|[HDR图片动态元数据生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-dynamic-metadata-generation)|Image Kit|
|[HDR图片色彩空间转换](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/image-csc)|Image Kit|
|[单层HDR图片转换双层](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-single-to-dual)|Image Kit|
|[双层HDR图片转换单层](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdr-dual-to-single)|Image Kit|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multimedia-development-overview "媒体开发概览")
# Audio Kit简介

更新时间: 2025-12-16 16:35

Audio Kit（音频服务）旨在提供场景化的音频播放和录制接口，助力开发者迅速构建音频高清采集及沉浸式播放能力。

## 亮点/特征

- 低时延播放
    
    提供统一音频低时延/非低时延播放能力接口，通过垂直打通硬件，达成最低的音频输出时延。在游戏、提示/告警音、K歌等场景下，可以通过低时延接口，实现音频快速流畅播放。
    
- 音效模式
    
    提供系统音效模式设置，应用可以按需开/关系统音效，确保最佳音效输出体验。
    
    系统默认为音乐、听书、影院等不同场景进行相应音效处理，但应用内部自身也存在一些定制化音效，为确保最终音效不产生冲突，系统提供音效模式配置开关，允许应用按需开/关系统音效。
    
- 音振协同
    
    提供音振协同能力接口，实现音频及振动流的低时延同步控制。达成在输入法中开启音频和振动效果，打字输入时音振协同、节奏一致，来电铃声和振动同时响起，铃音和振动节奏同步一致的体验。
    

## 音频架构

开发者可以利用Audio Kit的接口，使用音频系统提供的播放、录音及音频策略管理能力，进而访问相应的音频硬件。音频架构定义了系统如何封装和管理音频硬件能力。音频架构图如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163515.78636135171413383709972338840648:50001231000000:2800:3632A1A610197ABDF678F1B31A3DE0E5402754A5AE96D9CD1DFCDA47AF4DE5CE.png)

**Application**

应用开发者通过Audio Kit提供的公开API接口，利用音频系统提供的软硬件能力，实现应用所需的播放和录音功能。

**Napi**

通过NAPI，一种Node.js推出的用于开发C++模块的接口，封装了操作系统底层能力并对外提供ArkTS接口。通过NAPI可实现ArkTS与C/C++代码互相访问。

**Native framework**

在Native框架层，音频系统实现了播放、录音、音量控制、设备路由和音效处理等接口的框架实现，通过跨进程接口连接音频服务。

**Native SystemAbility**

音频服务进程audio_server承载了软件实现的音频系统功能组件，提供了丰富的音频策略管理和数据处理能力。组件通过HDI接口与HAL层连接，从而使用音频硬件能力。

**HAL**

HAL通过统一的HDI接口对外提供服务，不同的音频硬件开发人员实现HDI接口，使得音频服务可以通过不同类型的音频设备进行播放和录音。

**Kernel**

内核驱动程序负责与音频硬件交互，针对不同规模的操作系统，可以选择多种内核，如Linux、LiteOS、HarmonyOS内核等。

## 开发说明

在每个功能中，会介绍多种实现方式以应对不同的使用场景，以及该场景相关的子功能点。比如在音频播放功能内，会同时介绍音频的并发策略、音量管理和输出设备等在操作系统中的处理方式，帮助开发者能够开发出功能覆盖更全面的应用。

本开发指导仅针对音频播放或录制本身，Audio Kit提供相关能力，不涉及UI界面、图形处理、媒体存储或其他相关领域功能。

在开发音频功能之前，尤其是要实现处理音频数据的功能前，建议开发者先了解声学相关的知识，帮助理解操作系统提供的API是如何控制音频系统，从而开发出更易用、体验更好的音视频类应用。建议了解的相关概念包括但不限于：

- 音频量化的过程：采样 > 量化 > 编码。
    
- 音频量化过程的相关概念：模拟信号和数字信号、采样率、声道、采样格式、位宽、码率、常见编码格式（如AAC、MP3、PCM、WMA等）、常见封装格式（如WAV、MPA、FLAC、AAC、OGG等）。
    

## 音频流介绍

在开发音频应用之前，还需要了解什么是音频流，它是HarmonyOS音频系统中的关键概念，在之后的章节中会多次提及。

音频流，是指音频系统中一个具备音频格式和音频使用场景信息的独立音频数据处理单元。可以表示播放，也可以表示录制，并且具备独立音量调节和音频设备路由切换能力。

音频流基础信息通过[AudioStreamInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiostreaminfo8)表示，包含采样、声道、位宽、编码信息，是创建音频播放或录制流的必要参数，描述了音频数据的基本属性。在配置时开发者需要保证基础信息与传输的音频数据相匹配，音频系统才能正确处理数据。

### 音频流使用场景信息

除了基本属性，音频流还需要具备使用场景信息。基础信息只能对音频数据进行描述，但在实际的使用过程中，不同的音频流，在音量大小、设备路由、并发策略上是有区别的。系统就是通过音频流所附带的使用场景信息，为不同的音频流制定合适的处理策略，以达到更好的音频用户体验。

- 播放场景
    
    音频播放场景的信息，通过[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)进行描述。
    
    StreamUsage指音频流本身的用途类型，包括媒体、语音通信、语音播报、通知、铃声等。
    
- 录制场景
    
    音频流录制场景的信息，通过[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#sourcetype8)进行描述。
    
    SourceType指音频流中录音源的类型，包括麦克风音频源、语音识别音频源、语音通话音频源等。
    

可参考[使用合适的音频流类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype)进行设置。

## 支持的音频格式

audio模块下的接口支持PCM编码，包括AudioRenderer、AudioCapturer、TonePlayer、OpenSL ES等。

音频格式说明：

- 支持的音频采样率（Hz）：8000、11025、12000、16000、22050、24000、32000、44100、48000、64000、8820012+、96000，17640012+、19200012+具体参考枚举[AudioSamplingRate](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiosamplingrate8)。
    
    不同设备支持的采样率规格会存在差异。
    
- 支持单声道、双声道，具体参考[AudioChannel](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiochannel8)。
    
- 支持的采样格式：U8（无符号8位整数）、S16LE（带符号的16位整数，小尾数）、S24LE（带符号的24位整数，小尾数）、S32LE（带符号的32位整数，小尾数）、F32LE（带符号的32位浮点数，小尾数），具体参考[AudioSampleFormat](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiosampleformat8)。
    
    由于系统限制，S24LE、S32LE、F32LE仅部分设备支持，请根据实际情况使用。
    
    小尾数指的是小端模式，即数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。这种存储模式将地址的高低和数据的位权有效结合起来，高地址部分权值高，低地址部分权值低。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-kit "Audio Kit（音频服务）")
# 使用合适的音频流类型

更新时间: 2025-12-16 16:35

[音频流](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-kit-intro#%E9%9F%B3%E9%A2%91%E6%B5%81%E4%BB%8B%E7%BB%8D)类型是定义音频数据播放和录制方式的关键属性。对于播放流，其类型由[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)确定；对于录制流，则由[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#sourcetype8)决定。音频流类型对音量控制、音频焦点管理以及输入/输出设备的选择具有决定性影响。

为了确保音频行为符合预期并提供优质的用户体验，应用开发者应根据具体业务场景和实际需求，为音频选择恰当的流类型。

接下来，文档将介绍[常用的音频流类型及其适用场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9F%B3%E9%A2%91%E6%B5%81%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)，同时说明[不同流类型对音频业务的影响](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype#%E6%B5%81%E7%B1%BB%E5%9E%8B%E5%AF%B9%E9%9F%B3%E9%A2%91%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D)。最后，指导开发者在采用不同方法实现音频播放和音频录制时，应当如何[设置音频流类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype#%E8%AE%BE%E7%BD%AE%E9%9F%B3%E9%A2%91%E6%B5%81%E7%B1%BB%E5%9E%8B)。

## 常用的音频流类型及其适用场景

### 播放音频流类型

下表中列举常用的播放音频流类型，由[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)定义。

|音频流使用类型（StreamUsage）|适用场景|
|:--|:--|
|STREAM_USAGE_MUSIC|适用于播放音乐，同样适用于其他媒体场景，如[使用SoundPool](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-soundpool-for-playback)播放简短音效等。|
|STREAM_USAGE_MOVIE|适用于播放短视频、电影、电视剧等各类视频内容。|
|STREAM_USAGE_AUDIOBOOK|适用于播放有声读物、新闻、播客等。|
|STREAM_USAGE_GAME|适用于游戏内配乐、配音，后台音乐不会被打断；游戏内语音，建议使用STREAM_USAGE_VOICE_COMMUNICATION。|
|STREAM_USAGE_NAVIGATION|适用于导航场景的语音播报功能。|
|STREAM_USAGE_VOICE_MESSAGE|适用于播放语音短消息。|
|STREAM_USAGE_VOICE_COMMUNICATION|适用于VoIP语音通话。|
|STREAM_USAGE_ALARM|适用于播放闹铃。|
|STREAM_USAGE_RINGTONE|适用于VoIP来电响铃等。|
|STREAM_USAGE_NOTIFICATION|适用于播放通知音、提示音。|

### 录制音频流类型

下表中列举常用的录制音频流类型，由[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#sourcetype8)定义。

|音频流使用类型（SourceType）|适用场景|
|:--|:--|
|SOURCE_TYPE_MIC|适用于普通录音。|
|SOURCE_TYPE_VOICE_RECOGNITION9+|适用于语音识别。|
|SOURCE_TYPE_PLAYBACK_CAPTURE|（API12已废弃）适用于录制其他应用送到系统中播放的原始音频数据。<br><br>AudioKit不再提供内录接口，请通过[录屏接口AVScreenCapture](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avscreencapture)进行内录。|
|SOURCE_TYPE_VOICE_COMMUNICATION|适用于VoIP语音通话。|
|SOURCE_TYPE_VOICE_MESSAGE|适用于录制语音短消息。|
|SOURCE_TYPE_CAMCORDER13+|适用于相机录像。|
|SOURCE_TYPE_UNPROCESSED14+|适用于获取麦克风采集到的纯净音频数据（系统不做任何算法处理）。|
|SOURCE_TYPE_LIVE20+|适用于直播，在支持的设备上会提供系统回声消除能力。|

## 流类型对音频业务的影响

不同的流类型会影响用户在控制音量时的体验，以及系统在调整音频焦点和选择输入/输出设备时的表现。此外，系统还会根据录制流类型对采集到的音频数据配置对应的优化处理策略，因此录制流类型的选择会影响到录制的音频效果。例如：如果在VoIP通话场景下使用了SOURCE_TYPE_MIC而不是SOURCE_TYPE_VOICE_COMMUNICATION类型，可能会使降噪、环境音消除等优化策略不生效，造成VoIP通话体验不佳。建议开发者根据业务场景选择合适的音频流类型。

### 音量控制

播放流类型（[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)）决定了音频流所属的音量类型（[AudioVolumeType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiovolumetype)），各类音量类型（如媒体、铃声、闹钟、通话等）拥有独立的音量值，在用户界面上可独立调节，相互之间不会影响。

常见的播放流类型与音量类型的对应关系为：

|音频流使用类型（StreamUsage）|音量类型（AudioVolumeType）|
|:--|:--|
|MUSIC、MOVIE、AUDIOBOOK、GAME|媒体音量（MEDIA）|
|RINGTONE、NOTIFICATION|铃声音量（RINGTONE）|
|VOICE_COMMUNICATION|通话音量（VOICE_CALL）|
|ALARM|闹钟音量（ALARM）|

### 音频焦点调整

音频流类型在音频焦点管理中扮演着关键角色，不同类型的音频流具有不同的默认优先级和处理方式。

当应用启动音频播放或录制时，系统会根据音频流类型自动申请焦点，这可能会中断其他音频或降低其音量。音频焦点的具体介绍可参考[音频焦点和音频会话介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency)。

此处仅说明常见的音频流类型影响音频焦点的表现，其他类型可参考[系统默认焦点策略表](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-focus-management#section123975612118)。

- 启动导航（Navigation）时，正在播放的音乐（Music）音量会自动调低，待导航（Navigation）结束后，音乐（Music）音量将自动恢复。
    
- 开始播放视频（Movie）时，将会停止正在播放的音乐（Music）；当视频（Movie）播放结束后，音乐（Music）播放不会自动恢复，对应的应用也不会收到任何恢复通知。
    
- 开始语音通话（VoiceCommunication）时，将会暂停正在播放的音乐（Music）；当语音通话（VoiceCommunication）结束后，播放音乐（Music）的应用将收到恢复播放的通知。
    
- 音乐（Music）和游戏音频（Game）可以混音播放，两者互不影响。
    
- 开始录制语音短消息（VoiceMessage）时，会自动暂停正在播放的音乐（Music）；当语音短消息（VoiceMessage）录制结束后，播放音乐（Music）的应用将收到恢复播放的通知。
    

### 输入/输出设备选择

对于不同类型的音频流，系统会为其选定相应的输入/输出设备。

此处仅说明常见的音频流类型对应的输入/输出设备。

- 音乐（Music）类型音频流的默认输出设备为扬声器。
    
- 语音通话（VoiceCommunication）类型音频流的默认输入设备为麦克风，默认输出设备为听筒。
    
- 闹铃（Alarm）类型音频流的默认输出设备为扬声器‌。若先连接蓝牙耳机，再开始播放Alarm音频，则扬声器和蓝牙耳机会同时播放。
    

若默认的输入/输出设备不符合使用诉求，应用也可以调用相关接口主动修改。应用[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)时，可以调用[setDefaultOutputDevice](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#setdefaultoutputdevice12)接口，设置默认发声设备。

## 设置音频流类型

应用可采用多种方法实现音频播放或录音功能，因此，设置音频流类型的方式也各不相同。

常见的设置播放音频流类型的方法有：

- **[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)**：
    
    可以在调用[createAudioRenderer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-f#audiocreateaudiorenderer8)以获取音频渲染器时，传入对应的[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)。
    
    createAudioRenderer的参数options类型为AudioRendererOptions，包含AudioRendererInfo渲染器信息，使用AudioRendererInfo.usage可指定StreamUsage音频流类型。
    
- **[使用OHAudio开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)**：
    
    可以在调用[OH_AudioStreamBuilder_SetRendererInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setrendererinfo)接口时，传入对应的[OH_AudioStream_Usage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_usage)指定音频流类型。
    
- **[使用AVPlayer开发音频播放功能(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avplayer-for-playback)**：
    
    可以通过设置AVPlayer的[属性](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avplayer#%E5%B1%9E%E6%80%A7)audioRendererInfo来实现。AVPlayer.audioRendererInfo的类型为audio.AudioRendererInfo。使用AudioRendererInfo.usage可指定[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)音频流类型。
    
    说明
    
    在设置AVPlayer的audioRendererInfo属性时，只允许在initialized状态下设置。
    
    如果应用未主动设置该属性，AVPlayer将进行默认处理。当媒体源包含视频时，usage的默认值为STREAM_USAGE_MOVIE；否则，usage的默认值为STREAM_USAGE_MUSIC。
    
- **[使用AVPlayer开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ndk-avplayer-for-playback)**：
    
    可以在调用[OH_AVPlayer_SetAudioRendererInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avplayer-h#oh_avplayer_setaudiorendererinfo)接口时，传入对应的[OH_AudioStream_Usage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_usage)指定音频流类型。
    
- **[使用SoundPool开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-soundpool-for-playback)**：
    
    可以在调用[createSoundPool](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-f#mediacreatesoundpool10)接口时，传入对应的[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)指定音频流类型。
    

常见的设置录制音频流类型的方法有：

- **[使用AudioCapturer开发音频录制功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiocapturer-for-recording)**：
    
    可以在调用[createAudioCapturer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-f#audiocreateaudiocapturer8)接口时，传入对应的[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#sourcetype8)。
    
    createAudioCapturer的参数options类型为AudioCapturerOptions，包含AudioCapturerInfo采集器信息，使用AudioCapturerInfo.source可指定SourceType音源类型。
    
- **[使用OHAudio开发音频录制功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-recording)**：
    
    可以在调用[OH_AudioStreamBuilder_SetCapturerInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setcapturerinfo)接口时，传入对应的[OH_AudioStream_SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_sourcetype)指定音源类型。
    
- **[使用AVRecorder开发音频录制功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avrecorder-for-recording)**：
    
    可以在调用[AVRecorder.prepare](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avrecorder#prepare9-1)接口时，传入对应的[AudioSourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-e#audiosourcetype9)。
    
    AVRecorder.prepare的参数config类型为AVRecorderConfig，使用AVRecorderConfig.audioSourceType可指定音源类型。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-kit-intro "Audio Kit简介")
# 音频焦点和音频会话介绍

更新时间: 2025-12-16 16:35

在应用播放或录制声音时，常出现与其他音频流的并发或中断情况，这对用户体验构成显著影响。例如，当应用启动视频播放时，若后台正在播放音乐，用户会期望音乐能自动暂停，以确保视频音频优先播放，这正是音频焦点功能的体现。对于涉及音频服务的应用而言，妥善地管理音频焦点非常重要，它可以显著提升用户的音频体验。

本文档将介绍系统的音频焦点策略，以及应对焦点变化的方法。同时，系统提供了音频会话（AudioSession）机制，允许应用自定义其音频流的焦点策略。

## 音频焦点

系统预设了默认的[音频焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E7%AD%96%E7%95%A5)，根据音频流的类型及启动的先后顺序，对所有播放和录制音频流进行统一管理。

在启动播放或录制功能前，应用需要先[申请音频焦点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E7%94%B3%E8%AF%B7%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9)；而在播放或录制结束后，应适时[释放音频焦点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%87%8A%E6%94%BE%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9)。在播放或录制的过程中，可能会因其他音频流的介入而失去焦点，此时，应用需依据焦点变化采取[相应措施](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E5%8F%98%E5%8C%96)。

对于应用而言，为了确保为用户提供优质的音频焦点体验，应当注意以下几点：

- 在启动播放或录制操作前，应根据音频的具体用途，选择并[使用合适的音频流类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype)，即准确设置[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)或[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#sourcetype8)。
    
- 在播放或录制的过程中，需[监听音频焦点事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E5%8F%98%E5%8C%96)，并在接收到音频焦点中断事件（[InterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)）时，采取相应的处理措施。
    
- 如果应用程序有意主动管理音频焦点，可使用[音频会话（AudioSession）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9Daudiosession)相关的接口进行操作。
    

### 申请音频焦点

**当应用开始播放或录制音频时，系统将自动为相应的音频流申请音频焦点。**

例如，应用[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)，当调用AudioRenderer的[start](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#start8)时，系统会自动为应用请求音频焦点。

若音频焦点请求成功，音频流将正常启动；反之，若音频焦点请求被拒绝，音频流将无法开始播放或录制。

建议应用主动[监听音频焦点事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E5%8F%98%E5%8C%96)，一旦音频焦点请求被拒绝，应用将接收到[音频焦点事件（InterruptEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)。

如果应用希望只申请一次焦点，连续播放多条音频流不被中断，可使用[音频会话（AudioSession）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9Daudiosession)的焦点申请接口。

**特殊场景：**

1. **短音播放**：若应用[使用SoundPool开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-soundpool-for-playback)，且[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)指定为Music、Movie、AudioBook等类型，播放短音，则其申请焦点时默认为并发模式，不会影响其他音频。
    
2. **静音播放**：若应用以静音状态开始播放音频（或视频），并且希望静音阶段不影响其他音频，当后续解除静音的时候，再以正常策略申请音频焦点，则可以调用静音并发播放模式的相关接口。具体可参考：
    
    - [使用AVPlayer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avplayer-for-playback)，可以调用[setMediaMuted](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avplayer#setmediamuted12)函数。
        
    - [使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)，可调用[setSilentModeAndMixWithOthers](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#setsilentmodeandmixwithothers12)函数。
        
    - [使用OHAudio开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)，可调用[OH_AudioRenderer_SetSilentModeAndMixWithOthers](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_setsilentmodeandmixwithothers)函数。
        

### 释放音频焦点

**当应用结束播放或录制音频时，系统会自动为相应的音频流释放音频焦点。**

例如，应用[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)，当调用AudioRenderer的[pause](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#pause8)、[stop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#stop8)、[release](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#release8)等时，系统会为其释放音频焦点。

当音频流释放音频焦点时，若存在受其影响的其他音频流（如音量被调低或被暂停的流），将触发恢复操作。

如果应用不希望在音频流停止时立即释放音频焦点，可使用[音频会话（AudioSession）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9Daudiosession)的相关接口，实现音频焦点释放的延迟效果。

如果应用通过激活[音频会话（AudioSession）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9Daudiosession)申请过焦点，需要结束AudioSession以释放焦点。

### 音频焦点策略

当音频流申请或释放音频焦点时，系统依据音频焦点策略，对所有音频流（包括播放和录制）实施焦点管理，决定哪些音频流可正常运行，哪些需被打断或执行其他操作。

系统预设的默认音频焦点策略，主要依据音频流类型（即播放流的[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)和录制流的[SourceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#sourcetype8)）及音频流启动的顺序进行决策。

为防止焦点变化不符合预期，应用在启动播放或录制前，应根据音频流的用途，准确设置StreamUsage或SourceType。关于各类型的详细说明，请参考[使用合适的音频流类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype)。

常见的音频焦点场景示例如下：

- 开始播放Movie音频流时，将导致正在播放的Music音频流暂停，但Movie播放停止后，Music不会收到恢复播放的通知。
- 开始Navigation音频流时，会自动降低正在播放的Music音频流音量，Navigation停止后，Music音量将恢复至原样。
- Music音频流与Game音频流可并发混音播放，相互之间不会影响音量或播放状态。
- VoiceCommunication开始播放时，将暂停正在播放的Music音频流，VoiceCommunication停止后，Music将收到恢复播放的通知。
- 开始录制VoiceMessage时，Music音频流会被暂停，VoiceMessage录制停止后，Music将收到恢复播放的通知。

若默认的音频焦点策略无法满足特定场景的需求，应用程序可利用[音频会话（AudioSession）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9Daudiosession)，调整本应用音频流所采用的音频焦点策略。

### 焦点模式

针对同一应用创建的多个音频流，应用可通过设置[焦点模式（InterruptMode）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#interruptmode9)，选择由应用自主管控，或由系统统一管理。

系统预设了两种焦点模式：

- 共享焦点模式（SHARE_MODE）：同一应用创建的多个音频流共享一个音频焦点。这些音频流之间的并发规则由应用自行决定，音频焦点策略不会介入。仅当其他应用创建的音频流与该应用的音频流同时播放时，才会触发音频焦点策略的管理。
    
- 独立焦点模式（INDEPENDENT_MODE）：应用创建的每个音频流均独立拥有一个音频焦点，多个音频流同时播放时，将触发音频焦点策略的管理。
    

应用可根据需求选择合适的焦点模式。在创建音频流时，系统默认采用共享焦点模式（SHARE_MODE），应用可主动设置所需模式。

设置焦点模式的方法：

- 若[使用AVPlayer开发音频播放功能(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avplayer-for-playback)，则可以通过修改AVPlayer的[audioInterruptMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avplayer)属性进行设置。
    
- 若[使用AVPlayer开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ndk-avplayer-for-playback)，则可以调用[OH_AVPlayer_SetAudioInterruptMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avplayer-h#oh_avplayer_setaudiointerruptmode)函数进行设置。
    
- 若[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)，则可以调用[setInterruptMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#setinterruptmode9)函数进行设置。
    
- 若[使用OHAudio开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)，则可以调用[OH_AudioStreamBuilder_SetRendererInterruptMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setrendererinterruptmode)函数进行设置。
    

### 处理音频焦点变化

在应用播放或录制音频的过程中，若有其他音频流申请焦点，系统会根据[焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E7%AD%96%E7%95%A5)进行焦点处理。若判定本音频流的焦点有变化，需要执行暂停、继续、降低音量、恢复音量等操作，则系统会自动执行一些必要的操作，并通过[音频焦点事件（InterruptEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)通知应用。

因此，为了维持应用和系统的状态一致性，保证良好的用户体验，推荐应用监听音频焦点事件，并在焦点发生变化时，根据[InterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)做出必要的响应。

**使用不同方式开发时，如何监听音频焦点事件：**

- 若[使用AVPlayer开发音频播放功能(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avplayer-for-playback)，可以调用[on('audioInterrupt')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-avplayer#onaudiointerrupt9)接口，监听音频焦点事件[InterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)。
    
- 若[使用AVPlayer开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ndk-avplayer-for-playback)，可以调用[OH_AVPlayer_SetOnInfoCallback()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avplayer-h#oh_avplayer_setoninfocallback)接口，监听音频焦点事件[OH_AVPlayerOnInfoCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-avplayer-base-h#oh_avplayeroninfocallback)。
    
- 若[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)，可以调用[on('audioInterrupt')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#onaudiointerrupt9)接口，监听音频焦点事件[InterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)。
    
- 若[使用OHAudio开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)，可以调用[OH_AudioStreamBuilder_SetRendererCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setrenderercallback)接口，监听音频焦点事件[OH_AudioRenderer_OnInterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiorenderer-callbacks-struct#oh_audiorenderer_oninterruptevent)。
    
- 若[使用AudioCapturer开发音频录制功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiocapturer-for-recording)，可以调用[on('audioInterrupt')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiocapturer#onaudiointerrupt10)接口，监听音频焦点事件[InterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)。
    
- 若[使用OHAudio开发音频录制功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-recording)，可以调用[OH_AudioStreamBuilder_SetCapturerCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setcapturercallback)接口，监听音频焦点事件[OH_AudioCapturer_OnInterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiocapturer-callbacks-struct#oh_audiocapturer_oninterruptevent)。
    

应用在收到音频焦点事件（[InterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)）时，需要根据其中信息，做出相应的处理，以保持应用与系统状态一致，带给用户良好的音频体验。

在音频焦点事件中，应用应重点关注两个信息：打断类型（InterruptForceType）和打断提示（InterruptHint）。

- 打断类型（[InterruptForceType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#interruptforcetype9)）：
    
    InterruptForceType参数提示应用该焦点变化是否已由系统强制操作：
    
    - 强制打断类型（INTERRUPT_FORCE）：由系统进行操作，强制执行。应用收到打断提示后无需再调用系统相关接口，只需做一些必要的处理，例如更新状态、更新界面显示等。
        
    - 共享打断类型（INTERRUPT_SHARE）：由应用进行操作，应用可以选择响应或忽略，系统不会干涉。
        
    
    系统默认优先采用强制打断类型（INTERRUPT_FORCE），应用无法更改。
    
    注意
    
    对于一些系统无法强制执行的操作（例如INTERRUPT_HINT_RESUME），会采用共享打断类型（INTERRUPT_SHARE）。
    
- 打断提示（[InterruptHint](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#interrupthint)）：
    
    InterruptHint参数用于提示应用音频流的状态：
    
    - 继续（INTERRUPT_HINT_RESUME）：音频流可恢复播放或录制，仅会接收到PAUSE（暂停提示）之后收到。
        
        此操作无法由系统强制执行，其对应的InterruptForceType一定为INTERRUPT_SHARE类型。
        
    - 暂停（INTERRUPT_HINT_PAUSE）：音频暂停，暂时失去音频焦点。后续待焦点可用时，会再收到INTERRUPT_HINT_RESUME。
        
    - 停止（INTERRUPT_HINT_STOP）：音频停止，彻底失去音频焦点。
        
    - 降低音量（INTERRUPT_HINT_DUCK）：音频降低音量播放，而不会停止。默认降低至正常音量的20%。
        
    - 恢复音量（INTERRUPT_HINT_UNDUCK）：音频恢复正常音量。
        

### 典型场景

典型焦点的适配场景如下表所示。

|先播放的音频类型|推荐流类型|后播放的音频类型|推荐流类型|推荐体验|适配方案|
|:--|:--|:--|:--|:--|:--|
|音乐|STREAM_USAGE_MUSIC|音乐|STREAM_USAGE_MUSIC|后播音乐正常播放，先播音乐停止播放，UI变成停止播放状态。|先播音乐应用注册焦点事件监听，接收到INTERRUPT_HINT_STOP事件时，停止音乐播放，并更新UI界面。|
|音乐|STREAM_USAGE_MUSIC|导航|STREAM_USAGE_NAVIGATION|导航正常播放，音乐降低音量播放。<br><br>导航结束后，音乐恢复正常音量。|音乐应用注册焦点事件监听，接收到INTERRUPT_HINT_DUCK和INTERRUPT_HINT_UNDUCK事件时，可以选择更新UI界面。|
|视频|STREAM_USAGE_MOVIE|闹铃|STREAM_USAGE_ALARM|闹铃响起后，视频暂停播放。<br><br>闹钟结束后，视频继续播放。|视频应用注册焦点事件监听。接收到INTERRUPT_HINT_PAUSE事件时，直接暂停视频播放，并更新UI界面。<br><br>当闹铃结束后，视频应用接收到INTERRUPT_HINT_RESUME事件，重新启动播放。|
|音乐|STREAM_USAGE_MUSIC|来电铃声|STREAM_USAGE_RINGTONE|开始响铃，音乐暂停播放。<br><br>不接通或者接通再挂断后，音乐恢复播放。|音乐应用注册焦点事件监听。接收到INTERRUPT_HINT_PAUSE事件时，直接暂停音乐播放，并更新UI界面。<br><br>当电话结束后，音频应用接收到INTERRUPT_HINT_RESUME事件，重新启动播放。|
|音乐|STREAM_USAGE_MUSIC|VoIP通话|STREAM_USAGE_VOICE_COMMUNICATION|通话接通时，音乐暂停播放。<br><br>通话挂断后，音乐恢复播放。|音乐应用注册焦点事件监听。<br><br>接收到INTERRUPT_HINT_PAUSE事件时，直接暂停音乐播放，并更新UI界面。<br><br>当通话结束后，音乐应用接收到INTERRUPT_HINT_RESUME事件，重新启动播放。|

**处理音频焦点示例:**

为了带给用户更好的音频体验，针对不同的音频焦点事件内容，应用需要做出相应的处理操作。此处以[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)为例，展示推荐应用采取的处理方法，提供伪代码供开发者参考。

在监听音频播放焦点变化事件之前，需要先获取[AudioRenderer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-f#audiocreateaudiorenderer8)实例。若使用其他接口开发音频播放或音频录制功能，处理方法类似，具体的代码实现，开发者可结合实际情况编写，处理方法也可自行调整。

1. import { audio } from '@kit.AudioKit';  // 导入audio模块。
2. import { BusinessError } from '@kit.BasicServicesKit'; // 导入BusinessError。

3. let isPlay: boolean; // 是否正在播放，实际开发中，对应与音频播放状态相关的模块。
4. let isDucked: boolean; //是否降低音量，实际开发中，对应与音频音量相关的模块。
5. let started: boolean; // 标识符，记录“开始播放（start）”操作是否成功。

6. async function onAudioInterrupt(): Promise<void> {
7.   // 此处以使用AudioRenderer开发音频播放功能举例，变量audioRenderer即为播放时创建的AudioRenderer实例。
8.   audioRenderer.on('audioInterrupt', async(interruptEvent: audio.InterruptEvent) => {
9.     // 在发生音频焦点变化时，audioRenderer收到interruptEvent回调，此处根据其内容做相应处理。
10.     // 1. 可选：读取interruptEvent.forceType的类型，判断系统是否已强制执行相应操作。
11.     // 注：默认焦点策略下，INTERRUPT_HINT_RESUME为INTERRUPT_SHARE类型，其余hintType均为INTERRUPT_FORCE类型。因此对forceType可不做判断。
12.     // 2. 必选：读取interruptEvent.hintType的类型，做出相应的处理。
13.     if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_FORCE) {
14.       // 强制打断类型（INTERRUPT_FORCE）：音频相关处理已由系统执行，应用需更新自身状态，做相应调整。
15.        switch (interruptEvent.hintType) {
16.         case audio.InterruptHint.INTERRUPT_HINT_PAUSE:
17.           // 此分支表示系统已将音频流暂停（临时失去焦点），为保持状态一致，应用需切换至音频暂停状态。
18.           // 临时失去焦点：待其他音频流释放音频焦点后，本音频流会收到resume对应的音频焦点事件，到时可自行继续播放。
19.           isPlay = false; // 此句为简化处理，代表应用切换至音频暂停状态的若干操作。
20.           break;
21.         case audio.InterruptHint.INTERRUPT_HINT_STOP:
22.           // 此分支表示系统已将音频流停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态。
23.           // 永久失去焦点：后续不会再收到任何音频焦点事件，若想恢复播放，需要用户主动触发。
24.           isPlay = false; // 此句为简化处理，代表应用切换至音频暂停状态的若干操作。
25.           break;
26.         case audio.InterruptHint.INTERRUPT_HINT_DUCK:
27.           // 此分支表示系统已将音频音量降低（默认降到正常音量的20%）。
28.           isDucked = true; // 此句为简化处理，代表应用切换至降低音量播放状态的若干操作。
29.           break;
30.         case audio.InterruptHint.INTERRUPT_HINT_UNDUCK:
31.           // 此分支表示系统已将音频音量恢复正常。
32.           isDucked = false; // 此句为简化处理，代表应用切换至正常音量播放状态的若干操作。
33.           break;
34.         default:
35.           break;
36.       }
37.     } else if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_SHARE) {
38.       // 共享打断类型（INTERRUPT_SHARE）：应用可自主选择执行相关操作或忽略音频焦点事件。
39.       switch (interruptEvent.hintType) {
40.         case audio.InterruptHint.INTERRUPT_HINT_RESUME:
41.           // 此分支表示临时失去焦点后被暂停的音频流此时可以继续播放，建议应用继续播放，切换至音频播放状态。
42.           // 若应用此时不想继续播放，可以忽略此音频焦点事件，不进行处理即可。
43.           // 继续播放，此处主动执行start()，以标识符变量started记录start()的执行结果。
44.           await audioRenderer.start().then(() => {
45.             started = true; // start()执行成功。
46.           }).catch((err: BusinessError) => {
47.             started = false; // start()执行失败。
48.           });
49.           // 若start()执行成功，则切换至音频播放状态。
50.           if (started) {
51.             isPlay = true; // 此句为简化处理，代表应用切换至音频播放状态的若干操作。
52.           } else {
53.             // 音频继续播放的操作执行失败。
54.           }
55.           break;
56.         default:
57.           break;
58.       }
59.    }
60.   });
61. }

## 音频会话（AudioSession）

应用可以使用音频会话（AudioSession）的相关接口，自定义本应用音频流的焦点策略。在系统进行焦点管理时，只要条件允许，本应用的所有音频流将优先遵循通过AudioSession指定的策略。

使用音频会话（AudioSession）相关接口，主要可以实现以下功能：

- 应用激活音频会话（AudioSession）并指定[音频会话策略（AudioSessionStrategy）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D%E7%AD%96%E7%95%A5audiosessionstrategy)后，本应用的所有音频流在参与焦点管理时，会优先使用该策略。
    
    典型场景：应用播放短视频时，会打断后台音乐，应用希望自身的音频流停止后，后台的音乐可以自动恢复（该场景需要应用在音频流启动前激活AudioSession，音频流停止后停用AudioSession）。
    
- 音频会话（AudioSession）处于激活状态下，本应用的音频流全部停止时，不会立刻释放音频焦点，系统会保持音频焦点，直到音频会话停用时再释放音频焦点，或是直到该应用有新的音频流申请焦点。
    
    典型场景：应用连续播放多个音频时，在多个音频衔接的间隙，不希望后台被影响的其他音频自动恢复，希望整个播放过程保持音频焦点的连贯性（该场景需要应用在整个播放过程开始前激活AudioSession，整个播放过程结束后停用AudioSession）。
    

### 音频会话（AudioSession）使用流程

音频会话（AudioSession）使用流程示意图：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163517.74259711220148029903639703971148:50001231000000:2800:623AB5F2288F85AC4BB9818D5099FEAA8AA23BF8E324808B31F2E28DC41C5D90.png)

1. 音频业务开始之前，需要先获取AudioSessionManager实例。
    
    具体方法可参考[获取音频会话管理器(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-session-management#%E8%8E%B7%E5%8F%96%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%99%A8)或[获取音频会话管理器(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-session#%E8%8E%B7%E5%8F%96%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%99%A8)。
    
2. 在音频业务开始前，还需要激活当前应用的AudioSession，并根据实际需要指定[AudioSessionStrategy](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D%E7%AD%96%E7%95%A5audiosessionstrategy)。
    
    具体方法可参考[激活音频会话(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-session-management#%E6%BF%80%E6%B4%BB%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D)或[激活音频会话(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-session#%E6%BF%80%E6%B4%BB%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D)。
    
    说明
    
    - 激活AudioSession时传入的策略会被保存，在此之后，本应用的音频流参与焦点管理时（比如申请焦点、释放焦点等），会优先使用本策略。
    - 允许重复激活AudioSession，重复激活时系统保存的策略会被更新，焦点管理时会使用最新的策略。
    
    AudioSession处于激活状态时，有以下特性：
    
    - 若应用一直没有音频流处于运行状态，则系统会在1分钟后自动停用AudioSession。
    - 应用的音频流停止时，若该应用无其他音频流运行，则不会立刻释放焦点，而是会保持焦点（进入静默等待状态），直到AudioSession停用或该应用有新的音频流申请焦点。
3. 应用正常开始播放、录制等音频业务。系统会在音频流开始时，申请音频焦点。本应用的所有音频流在参与焦点处理时，会优先使用AudioSession指定的策略。
    
    注意
    
    应用在申请音频焦点（开始音频播放或录制）之前需要确保AudioSession已经处于激活状态，否则AudioSession的自定义焦点策略不会影响此次焦点申请。若应用使用了异步接口，则需要格外注意异步操作执行的时序。
    
4. 音频业务结束之后，停用AudioSession。系统会在音频流停止且AudioSession停用时，释放音频焦点。
    
    应用需要在音频业务结束之后，主动停用AudioSession。
    
    应用在停用AudioSession时，如果该应用的所有音频流已全部停止（即处于保持焦点的静默等待状态），则会立刻释放音频焦点；如果该应用仍有音频流在运行，则它的音频流仍然会持有焦点，直到音频流停止时才释放。
    
    具体方法可参考[停用音频会话(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-session-management#%E5%81%9C%E7%94%A8%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D)或[停用音频会话(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-session#%E5%81%9C%E7%94%A8%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D)。
    

在使用AudioSession的过程中，推荐应用[监听AudioSession停用事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E7%9B%91%E5%90%ACaudiosession%E5%81%9C%E7%94%A8%E4%BA%8B%E4%BB%B6)，当AudioSession被停用时，应用可以及时收到[AudioSession停用事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiosessiondeactivatedevent12)。

### 音频会话策略（AudioSessionStrategy）

应用在激活AudioSession时，需先指定音频会话策略（AudioSessionStrategy）。可通过设置[音频并发模式（AudioConcurrencyMode）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audioconcurrencymode12)来指定不同的音频会话策略。

注意

音频并发策略优先级为：STOP > PAUSE > DUCK > PLAYBOTH。当指定的音频会话策略优先级高于默认并发策略时，指定的音频会话策略不会生效。

系统预设了以下四种音频并发模式：

- 默认模式（CONCURRENCY_DEFAULT）：即系统默认的[音频焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E7%AD%96%E7%95%A5)。
    
- 并发模式（CONCURRENCY_MIX_WITH_OTHERS）：和其他音频流并发。
    
    **典型场景：**
    
    - 应用播放音乐时，会被后起的音乐或视频打断，应用希望自身的音频流和后起的音乐或视频并发（该场景需要应用在音频流启动前激活AudioSession）。
        
    - 应用录音时，会打断后台正在播放的音乐或视频，应用希望自身的音频流和后台正在播放的音乐或视频并发（该场景需要应用在音频流启动前激活AudioSession）。
        
- 降低音量模式（CONCURRENCY_DUCK_OTHERS）：和其他音频流并发，并且降低其他音频流的音量。
    
    **典型场景：** 应用播放游戏音效时，会和后台正在播放的音乐并发，应用希望自身的音频流和后台正在播放的音乐并发时压低后台音乐音量（该场景需要应用在音频流启动前激活AudioSession）。
    
- 暂停模式（CONCURRENCY_PAUSE_OTHERS）：暂停其他音频流，待释放焦点后通知其他音频流恢复。
    
    **典型场景：** 应用播放短视频时，会打断后台正在播放的音乐，应用希望自身的音频流停止后，后台的音乐可以自动恢复（该场景需要应用在音频流启动前激活AudioSession，音频流停止后停用AudioSession）。
    

注意

1. 当应用通过AudioSession使用上述各种模式时，系统将尽量满足其焦点策略，但可能无法保证在所有场景下完全满足。
    
    例如：若使用CONCURRENCY_PAUSE_OTHERS模式，本应用发起Movie流，申请音频焦点时，如果其他应用的Music流正在播放，则Music流会被暂停。如果其他应用的VoiceCommunication流正在播放，则VoiceCommunication流不会被暂停。
    
2. 并发模式（CONCURRENCY_MIX_WITH_OTHERS）在本应用申请焦点和后续其他应用申请焦点时均会生效；降低音量模式（CONCURRENCY_DUCK_OTHERS）和暂停模式（CONCURRENCY_PAUSE_OTHERS）仅在本应用申请焦点时生效，后续其他应用申请焦点时，优先遵循其他应用的并发模式。
    
    例如：若使用CONCURRENCY_MIX_WITH_OTHERS模式，本应用会和其他同类型的音频流并发播放，与申请焦点的先后顺序无关。若使用CONCURRENCY_PAUSE_OTHERS模式，本应用申请焦点时，会暂停其他正在播放的音频流，但后续其他应用申请焦点时，会遵循其他应用的并发模式，不受本应用使用CONCURRENCY_MIX_WITH_OTHERS模式的影响。
    

### 监听AudioSession停用事件

应用在使用AudioSession的过程中，推荐应用监听音频会话停用事件（AudioSessionDeactivatedEvent）。当AudioSession被停用（非主动停用）时，应用会收到此事件通知。应用可根据自身业务需求，做相应的处理，例如释放相应资源、重新激活AudioSession等。

具体方法可参考[音频会话管理(ArkTS)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-session-management)或[音频会话管理(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-session)。

音频会话停用事件（AudioSessionDeactivatedEvent）包含参数音频会话停用原因（AudioSessionDeactivatedReason），该参数表示AudioSession被停用的原因，主要有两种：

- 应用焦点被抢占（DEACTIVATED_LOWER_PRIORITY）：该应用所有的音频流全部被其他音频流打断，丢失焦点，AudioSession被同时停用。
    
- 超时（DEACTIVATED_TIMEOUT）：若AudioSession处于激活状态，但该应用没有音频流在运行状态，则AudioSession会在1分钟之后被超时停用。
    
    注意
    
    当AudioSession因超时而停用时，被其压低音量（Duck）的音频会触发恢复音量（Unduck）操作，被其暂停（Pause）的音频流会触发停止（Stop）操作。
    

### 通过设置AudioSession场景参数申请焦点

**从API version 20开始支持该功能。**

在保持现有特性的基础上，应用可通过AudioSession申请焦点，提升多音频流播放的连续性。

典型使用场景如下：

- 在多个小视频滑动播放时，多个音频流频繁申请和释放焦点可能导致漏音。使用AudioSession申请一次焦点，可以避免中间多个音频流播放时频繁申请和释放焦点，从而防止漏音。
- 在VoIP通话场景下，可能需要启动铃声流、录音流和播放流，这些音频流的焦点优先级不同，部分音频流可能被其他应用的音频流中断。为了保持业务体验的连续性，可以使用AudioSession申请焦点，避免音频流被中断。
- 应用使用播放器的SDK播放音频流，不持有AudioRenderer对象，但希望监听焦点变化。

通过AudioSession申请焦点，首先要调用[setAudioSessionScene](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#setaudiosessionscene20)设置场景参数。然后调用[activateAudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#activateaudiosession12)激活AudioSession。

当前支持的AudioSessionScene如下，应用可以根据具体的业务场景，选择不同的场景参数配置。

|名称|值|说明|
|:--|:--|:--|
|AUDIO_SESSION_SCENE_MEDIA|0|媒体音频会话场景。|
|AUDIO_SESSION_SCENE_GAME|1|游戏音频会话场景。|
|AUDIO_SESSION_SCENE_VOICE_COMMUNICATION|2|VoIP语音通话音频会话场景。|

**AudioSession焦点生效规则：**

- 通过AudioSession申请焦点，仅对播放流有效，对录音流及部分播放音频流（如STREAM_USAGE_ALARM、STREAM_USAGE_NOTIFICATION、STREAM_USAGE_ACCESSIBILITY等）无效。
- 如果AudioSession主动结束或被超时释放，需要重新设置AudioSessionScene并调用activateAudioSession以再次申请焦点。
- 在AudioSession激活过程中，如果动态修改AudioSessionScene，需要重新调用activateAudioSession才能生效。
- 如果AudioSession的焦点被暂停，所有受其管理的音频流也会被暂停。
- AudioSession申请的焦点是应用级别的，如果应用内部包含不同的模块，各个模块间要做好协调处理，避免其中一个模块使用AudioSession申请了焦点，另一个模块的音频流被AudioSession的焦点管控而产生非预期的效果。

### 监听AudioSession焦点状态变化事件

**从API version 20开始支持该功能。**

AudioSession申请的焦点，跟通过AudioRenderer申请的焦点是同等地位，若有其他应用音频流申请焦点，系统会根据[焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E7%AD%96%E7%95%A5)进行焦点处理。若判定当前AudioSession的焦点有变化，需要执行暂停、继续、降低音量、恢复音量等操作，则系统会自动执行一些必要的操作，并通过[AudioSession焦点状态事件（AudioSessionStateChangedEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiosessionstatechangedevent20)通知应用。

为了维持应用和系统的状态一致性，确保良好的用户体验，应用应监听AudioSession焦点状态事件，并在焦点变化时做出必要响应。

注意

如果应用同时注册了AudioRenderer的焦点事件监听，需要注意以下两点：

1. 应用会收到AudioSession焦点状态变化和AudioRenderer焦点变化的回调（[InterruptEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#interruptevent9)），根据需要处理这些回调即可。
2. 如果AudioSession的焦点被暂停，恢复暂停状态时，只会给AudioSession发送焦点恢复事件，不会再给AudioRenderer发送焦点恢复事件。

### 通过AudioSession查询和监听音频输出设备

**从API version 20开始支持该功能。**

应用使用播放器的SDK播放音频流，不持有AudioRenderer对象，无法灵活控制播放设备的选择和设备状态的监听。因此，AudioSession不仅增加了焦点管理能力，还提供了音频输出设备管理功能，包括设置默认输出设备和监听设备变化。具体说明请参考文档[AudioSessionManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager)。

API接口使用指导请参考[通过AudioSession查询和监听音频输出设备](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-output-device-management#%E9%80%9A%E8%BF%87audiosession%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%9B%91%E5%90%AC%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-right-streamusage-and-sourcetype "使用合适的音频流类型")
# 使用AudioSession管理应用音频焦点(ArkTS)

更新时间: 2025-12-16 16:35

对于涉及多个音频流并发播放的场景，系统已预设了默认的[音频焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E7%AD%96%E7%95%A5)，该策略将对所有音频流（包括播放和录制）实施统一的焦点管理。

应用可利用音频会话管理（AudioSessionManager）提供的接口，通过AudioSession主动管理应用内音频流的焦点，自定义本应用音频流的焦点策略，调整本应用音频流释放音频焦点的时机，从而贴合应用特定的使用需求。

本文档主要介绍AudioSession相关ArkTS API的使用方法和注意事项，更多音频焦点及音频会话的信息，可参考：[音频焦点和音频会话介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency)。

## 获取音频会话管理器

创建AudioSessionManager实例。在使用AudioSessionManager的API前，需要先通过[getSessionManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getsessionmanager12)创建实例。

1. import { audio } from '@kit.AudioKit';

2. let audioManager = audio.getAudioManager();
3. let audioSessionManager: audio.AudioSessionManager = audioManager.getSessionManager();

## 激活音频会话

应用可以通过[AudioSessionManager.activateAudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#activateaudiosession12)接口激活当前应用的音频会话。

应用在激活AudioSession时，需指定[音频会话策略（AudioSessionStrategy）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D%E7%AD%96%E7%95%A5audiosessionstrategy)。策略中包含参数concurrencyMode，其类型为[AudioConcurrencyMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audioconcurrencymode12)，用于声明音频并发策略。

1. import { audio } from '@kit.AudioKit';
2. import { BusinessError } from '@kit.BasicServicesKit';

3. let strategy: audio.AudioSessionStrategy = {
4.   concurrencyMode: audio.AudioConcurrencyMode.CONCURRENCY_MIX_WITH_OTHERS
5. };

6. audioSessionManager.activateAudioSession(strategy).then(() => {
7.   console.info('Succeeded in doing activateAudioSession.');
8. }).catch((err: BusinessError) => {
9.   console.error(`Failed to activateAudioSession. Code: ${err.code}, message: ${err.message}`);
10. });

## 查询音频会话是否已激活

应用可以通过[isAudioSessionActivated](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#isaudiosessionactivated12)接口检查当前应用的音频会话是否已激活。

1. let isActivated = audioSessionManager.isAudioSessionActivated();

## 停用音频会话

应用可以通过[deactivateAudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#deactivateaudiosession12)接口停用当前应用的音频会话。

1. import { BusinessError } from '@kit.BasicServicesKit';

2. audioSessionManager.deactivateAudioSession().then(() => {
3.   console.info('Succeeded in doing deactivateAudioSession.');
4. }).catch((err: BusinessError) => {
5.   console.error(`Failed to deactivateAudioSession. Code: ${err.code}, message: ${err.message}`);
6. });

## 监听音频会话停用事件

应用可以通过[on('audioSessionDeactivated')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#onaudiosessiondeactivated12)接口监听[音频会话停用事件（AudioSessionDeactivatedEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiosessiondeactivatedevent12)。

当AudioSession被停用（非主动停用）时，应用会收到[音频会话停用事件（AudioSessionDeactivatedEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiosessiondeactivatedevent12)，其中包含[音频会话停用原因（AudioSessionDeactivatedReason）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiosessiondeactivatedreason12)。

在收到AudioSessionDeactivatedEvent时，应用可根据自身业务需求，做相应的处理，例如释放相应资源、重新激活AudioSession等。

1. import { audio } from '@kit.AudioKit';

2. audioSessionManager.on('audioSessionDeactivated', (audioSessionDeactivatedEvent: audio.AudioSessionDeactivatedEvent) => {
3.   console.info(`reason of audioSessionDeactivated: ${audioSessionDeactivatedEvent.reason} `);
4. });

## 取消监听音频会话停用事件

应用可以通过[off('audioSessionDeactivated')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#offaudiosessiondeactivated12)接口取消监听音频会话停用事件。

1. audioSessionManager.off('audioSessionDeactivated');

**音频会话从创建到激活并监听的完整示例：**

1. import { audio } from '@kit.AudioKit';
2. import { BusinessError } from '@kit.BasicServicesKit';

3. let audioManager = audio.getAudioManager();
4. // 创建音频会话管理器。
5. let audioSessionManager: audio.AudioSessionManager = audioManager.getSessionManager();
6. // 设置音频并发模式。
7. let strategy: audio.AudioSessionStrategy = {
8.   concurrencyMode: audio.AudioConcurrencyMode.CONCURRENCY_MIX_WITH_OTHERS
9. };

10. // 激活音频会话。
11. audioSessionManager.activateAudioSession(strategy).then(() => {
12.   console.info('Succeeded in doing activateAudioSession.');
13. }).catch((err: BusinessError) => {
14.   console.error(`Failed to activateAudioSession. Code: ${err.code}, message: ${err.message}`);
15. });

16. // 查询音频会话是否已激活。
17. let isActivated = audioSessionManager.isAudioSessionActivated();

18. // 监听音频会话停用事件。
19. audioSessionManager.on('audioSessionDeactivated', (audioSessionDeactivatedEvent: audio.AudioSessionDeactivatedEvent) => {
20.   console.info(`reason of audioSessionDeactivated: ${audioSessionDeactivatedEvent.reason} `);
21. });

22. // 音频会话激活后，应用在此处正常执行音频播放、暂停、停止、释放等操作即可。

23. // 停用音频会话。
24. audioSessionManager.deactivateAudioSession().then(() => {
25.   console.info('Succeeded in doing deactivateAudioSession.');
26. }).catch((err: BusinessError) => {
27.   console.error(`Failed to deactivateAudioSession. Code: ${err.code}, message: ${err.message}`);
28. });

29. // 取消监听音频会话停用事件。
30. audioSessionManager.off('audioSessionDeactivated');

## 通过设置AudioSession场景参数申请焦点

应用通过AudioSession申请焦点。首先要调用接口[setAudioSessionScene](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#setaudiosessionscene20)设置场景参数，然后调用[activateAudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiosessionmanager#activateaudiosession12)接口激活AudioSession。

1. import { audio } from '@kit.AudioKit';
2. import { BusinessError } from '@kit.BasicServicesKit';

3. audioSessionManager.setAudioSessionScene(audio.AudioSessionScene.AUDIO_SESSION_SCENE_MEDIA);

4. let strategy: audio.AudioSessionStrategy = {
5.   concurrencyMode: audio.AudioConcurrencyMode.CONCURRENCY_MIX_WITH_OTHERS
6. };

7. audioSessionManager.activateAudioSession(strategy).then(() => {
8.   console.info('activateAudioSession SUCCESS');
9. }).catch((err: BusinessError) => {
10.   console.error(`ERROR: ${err}`);
11. });

## 监听AudioSession焦点状态变化事件

通过[AudioSession焦点状态事件（AudioSessionStateChangedEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiosessionstatechangedevent20)监听音频会话焦点状态的变化。

**AudioSession申请焦点以及监听焦点变化事件的完整示例：**

1. import { audio } from '@kit.AudioKit';  // 导入audio模块。
2. import { BusinessError } from '@kit.BasicServicesKit'; // 导入BusinessError。

3. let audioSessionStateChangedCallback = (audioSessionStateChangedEvent: audio.AudioSessionStateChangedEvent) => {
4.   console.info(`hint of audioSessionStateChanged: ${audioSessionStateChangedEvent.stateChangeHint} `);

5.   switch (audioSessionStateChangedEvent.stateChangeHint) {
6.   case audio.AudioSessionStateChangeHint.AUDIO_SESSION_STATE_CHANGE_HINT_PAUSE:
7.     // 此分支表示系统已将音频流暂停，应用需切换至音频暂停状态。
8.     // 临时失去焦点：其他音频流释放音频焦点后，本音频流会收到resume事件，可继续播放。
9.     break;
10.   case audio.AudioSessionStateChangeHint.AUDIO_SESSION_STATE_CHANGE_HINT_RESUME:
11.     // 此分支表示系统解除AudioSession焦点的暂停操作。
12.     break;
13.   case audio.AudioSessionStateChangeHint.AUDIO_SESSION_STATE_CHANGE_HINT_STOP:
14.     // 此分支表示系统已将音频流停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态。
15.     // 永久失去焦点：后续不会再收到音频焦点事件，恢复播放需用户主动触发。
16.     break;
17.   case audio.AudioSessionStateChangeHint.AUDIO_SESSION_STATE_CHANGE_HINT_TIME_OUT_STOP:
18.     // 此分支表示由于长时间无音频流播放，系统已将AudioSession停止（永久失去焦点），应用需切换至音频暂停状态。
19.     // 永久失去焦点：后续不会再收到音频焦点事件，恢复播放需用户主动触发。
20.     break;
21.   case audio.AudioSessionStateChangeHint.AUDIO_SESSION_STATE_CHANGE_HINT_DUCK:
22.     // 此分支表示系统已将音频音量降低（默认降到正常音量的20%）。
23.     break;
24.   case audio.AudioSessionStateChangeHint.AUDIO_SESSION_STATE_CHANGE_HINT_UNDUCK:
25.     // 此分支表示系统已将音频音量恢复正常。
26.     break;
27.   default:
28.     break;
29.   }
30. };

31. let audioManager = audio.getAudioManager();
32. let audioSessionManager = audioManager.getSessionManager();

33. audioSessionManager.on('audioSessionStateChanged', audioSessionStateChangedCallback);

34. // 示例中选择了AUDIO_SESSION_SCENE_MEDIA会话场景，实际情况请根据具体场景修改该参数。
35. audioSessionManager.setAudioSessionScene(audio.AudioSessionScene.AUDIO_SESSION_SCENE_MEDIA);

36. // 示例中选择了CONCURRENCY_MIX_WITH_OTHERS策略，请根据具体场景修改该参数。
37. let strategy: audio.AudioSessionStrategy = {
38.   concurrencyMode: audio.AudioConcurrencyMode.CONCURRENCY_MIX_WITH_OTHERS
39. };

40. // 激活AudioSession，即抢占焦点
41. audioSessionManager.activateAudioSession(strategy).then(() => {
42.   console.info('activateAudioSession SUCCESS');
43. }).catch((err: BusinessError) => {
44.   console.error(`ERROR: ${err}`);
45. });

46. // 根据实际业务，可以启动多个AudioRenderer等音频播放。

47. // 结束AudioSession，即释放焦点
48. audioSessionManager.deactivateAudioSession().then(() => {
49.   console.info('deactivateAudioSession SUCCESS');
50. }).catch((err: BusinessError) => {
51.   console.error(`ERROR: ${err}`);
52. });

53. audioSessionManager.off('audioSessionStateChanged', audioSessionStateChangedCallback);

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-session "音频焦点管理")
# 使用AudioSession管理应用音频焦点(C/C++)

更新时间: 2025-12-16 16:35

对于涉及多个音频流并发播放的场景，系统已预设了默认的[音频焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency#%E9%9F%B3%E9%A2%91%E7%84%A6%E7%82%B9%E7%AD%96%E7%95%A5)，该策略将对所有音频流（包括播放和录制）实施统一的焦点管理。

应用可利用音频会话管理（AudioSessionManager）提供的接口，通过AudioSession主动管理应用内音频流的焦点，自定义本应用音频流的焦点策略，调整本应用音频流释放音频焦点的时机，从而贴合应用特定的使用需求。

本文档主要介绍AudioSession相关C API的使用方法和注意事项，更多音频焦点及音频会话的信息，可参考：[音频焦点和音频会话介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency)。

## 使用入门

应用要使用OHAudio提供的音频会话管理（AudioSessionManager）能力，需要添加对应的头文件。

### 在 CMake 脚本中链接动态库

1. target_link_libraries(sample PUBLIC libohaudio.so)

### 添加头文件

应用通过引入[native_audio_session_manager.h](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h)头文件，使用音频播放相关API。

1. #include <ohaudio/native_audio_session_manager.h>

## 获取音频会话管理器

创建[OH_AudioSessionManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiosessionmanager)实例。在使用音频会话管理功能前，需要先通过[OH_AudioManager_GetAudioSessionManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiomanager_getaudiosessionmanager)创建音频会话管理实例。

1. OH_AudioSessionManager *audioSessionManager;
2. OH_AudioManager_GetAudioSessionManager(&audioSessionManager);

## 激活音频会话

应用可以通过[OH_AudioSessionManager_ActivateAudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosessionmanager_activateaudiosession)接口激活当前应用的音频会话。

应用在[激活音频会话](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-session#%E6%BF%80%E6%B4%BB%E9%9F%B3%E9%A2%91%E4%BC%9A%E8%AF%9D)时，需指定[音频会话策略（OH_AudioSession_Strategy）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiosession-strategy)，其中包含[音频并发模式（OH_AudioSession_ConcurrencyMode）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosession_concurrencymode)参数，用于声明不同的音频并发策略。

1. OH_AudioSession_Strategy strategy = {CONCURRENCY_MIX_WITH_OTHERS};

2. OH_AudioSessionManager_ActivateAudioSession(audioSessionManager, &strategy);

## 查询音频会话是否已激活

应用可以通过[OH_AudioSessionManager_IsAudioSessionActivated](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosessionmanager_isaudiosessionactivated)接口检查当前应用的音频会话是否已激活。

1. bool isActivated = OH_AudioSessionManager_IsAudioSessionActivated(audioSessionManager);

## 停用音频会话

应用可以通过[OH_AudioSessionManager_DeactivateAudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosessionmanager_deactivateaudiosession)接口停用当前应用的音频会话。

1. OH_AudioSessionManager_DeactivateAudioSession(audioSessionManager);

## 监听音频会话停用事件

在使用AudioSession功能的过程中，推荐应用监听[音频会话停用事件（OH_AudioSession_DeactivatedEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiosession-deactivatedevent)。

当AudioSession被停用（非主动停用）时，应用会收到[音频会话停用事件（OH_AudioSession_DeactivatedEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiosession-deactivatedevent)，其中包含[音频会话停用原因（OH_AudioSession_DeactivatedReason）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosession_deactivatedreason)。

在收到AudioSessionDeactivatedEvent时，应用可根据自身业务需求，做相应的处理，例如释放相应资源、重新激活AudioSession等。

### 定义回调函数

1. int32_t MyAudioSessionDeactivatedCallback(OH_AudioSession_DeactivatedEvent event)
2. {
3.   switch(event.reason) {
4.     case DEACTIVATED_LOWER_PRIORITY:
5.       // 应用焦点被抢占。
6.       return 0;
7.     case DEACTIVATED_TIMEOUT:
8.       // 超时。
9.       return 0;
10.   }
11. }

### 注册音频会话停用事件回调

应用可以通过[OH_AudioSessionManager_RegisterSessionDeactivatedCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosessionmanager_registersessiondeactivatedcallback)接口监听音频会话停用事件。

1. OH_AudioSessionManager_RegisterSessionDeactivatedCallback(audioSessionManager, MyAudioSessionDeactivatedCallback);

### 取消注册音频会话停用事件回调

应用可以通过[OH_AudioSessionManager_UnregisterSessionDeactivatedCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosessionmanager_unregistersessiondeactivatedcallback)接口取消监听音频会话停用事件。

1. OH_AudioSessionManager_UnregisterSessionDeactivatedCallback(audioSessionManager, MyAudioSessionDeactivatedCallback);

**音频会话从创建到激活并监听的完整示例：**

参考以下示例，完成音频会话从创建到激活并监听的过程。

1. #include <cstdint>
2. #include "ohaudio/native_audio_session_manager.h"

3. int32_t MyAudioSessionDeactivatedCallback(OH_AudioSession_DeactivatedEvent event)
4. {
5.   switch(event.reason) {
6.     case DEACTIVATED_LOWER_PRIORITY:
7.       // 应用焦点被抢占。
8.       return 0;
9.     case DEACTIVATED_TIMEOUT:
10.       // 超时。
11.       return 0;
12.   }
13. }

14. OH_AudioSessionManager *audioSessionManager;

15. // 创建音频会话管理器。
16. OH_AudioCommon_Result resultManager = OH_AudioManager_GetAudioSessionManager(&audioSessionManager);

17. OH_AudioSession_Strategy strategy = {CONCURRENCY_MIX_WITH_OTHERS};

18. // 设置音频并发模式并激活音频会话。
19. OH_AudioCommon_Result resultActivate = OH_AudioSessionManager_ActivateAudioSession(audioSessionManager, &strategy);

20. // 查询音频会话是否已激活。
21. bool isActivated = OH_AudioSessionManager_IsAudioSessionActivated(audioSessionManager);

22. // 监听音频会话停用事件。
23. OH_AudioCommon_Result resultRegister = OH_AudioSessionManager_RegisterSessionDeactivatedCallback(audioSessionManager, MyAudioSessionDeactivatedCallback);

24. // 音频会话激活后应用在此处正常执行音频播放、暂停、停止、释放等操作即可。

25. // 取消监听音频会话停用事件。
26. OH_AudioCommon_Result resultUnregister = OH_AudioSessionManager_UnregisterSessionDeactivatedCallback(audioSessionManager, MyAudioSessionDeactivatedCallback);

27. // 停用音频会话。
28. OH_AudioCommon_Result resultDeactivate = OH_AudioSessionManager_DeactivateAudioSession(audioSessionManager);

## 通过设置AudioSession场景参数申请焦点

应用通过AudioSession申请焦点。首先要调用接口[OH_AudioSessionManager_SetScene](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosessionmanager_setscene)设置场景参数，然后调用[OH_AudioSessionManager_ActivateAudioSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-session-manager-h#oh_audiosessionmanager_activateaudiosession)接口激活AudioSession。

1. OH_AudioSessionManager_SetScene(audioSessionManager, AUDIO_SESSION_SCENE_MEDIA);

2. OH_AudioSession_Strategy strategy = {CONCURRENCY_MIX_WITH_OTHERS};

3. OH_AudioSessionManager_ActivateAudioSession(audioSessionManager, &strategy);

## 监听AudioSession焦点状态变化事件

通过[AudioSession焦点状态事件（OH_AudioSession_StateChangedEvent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiosession-statechangedevent)监听音频会话焦点状态的变化。

**AudioSession申请焦点以及监听焦点变化事件的完整示例：**

1. OH_AudioSessionManager *audioSessionManager;

2. // 创建音频会话管理器。
3. OH_AudioCommon_Result resultManager = OH_AudioManager_GetAudioSessionManager(&audioSessionManager);

4. void AudioSessionStateChangedCallback(OH_AudioSession_StateChangedEvent event)
5. {
6.   switch(event.stateChangeHint) {
7.     case AUDIO_SESSION_STATE_CHANGE_HINT_PAUSE:
8.       // 此分支表示系统已将音频流暂停（临时失去焦点），为保持状态一致，应用需切换至音频暂停状态。
9.       // 临时失去焦点：其他音频流释放音频焦点后，本音频流会收到resume事件，可继续播放。
10.       break;
11.     case AUDIO_SESSION_STATE_CHANGE_HINT_RESUME:
12.       // 此分支表示系统解除对AudioSession焦点的暂停操作。
13.       break;
14.     case AUDIO_SESSION_STATE_CHANGE_HINT_STOP:
15.       // 此分支表示系统已将音频流停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态。
16.       // 永久失去焦点：后续不会再收到任何音频焦点事件，若想恢复播放，需要用户主动触发。
17.       break;
18.     case AUDIO_SESSION_STATE_CHANGE_HINT_TIME_OUT_STOP:
19.       // 此分支表示由于长时间没有音频流播放，为防止系统资源被长时间无效占用，系统已将AudioSession停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态。
20.       // 永久失去焦点：后续不会再收到任何音频焦点事件，若想恢复播放，需要用户主动触发。
21.       break;
22.     case AUDIO_SESSION_STATE_CHANGE_HINT_DUCK:
23.       // 此分支表示系统已将音频音量降低（默认降到正常音量的20%）。
24.       break;
25.     case AUDIO_SESSION_STATE_CHANGE_HINT_UNDUCK:
26.       // 此分支表示系统已将音频音量恢复正常。
27.       break;
28.     default:
29.       break;
30.   }
31. }

32. OH_AudioCommon_Result result = OH_AudioSessionManager_RegisterStateChangeCallback(audioSessionManager, AudioSessionStateChangedCallback);

33. // AUDIO_SESSION_SCENE_MEDIA 仅为示例，实际使用时请根据具体情况进行修改。
34. OH_AudioSessionManager_SetScene(audioSessionManager, AUDIO_SESSION_SCENE_MEDIA);

35. // CONCURRENCY_MIX_WITH_OTHERS 是示例，实际使用时请根据情况修改
36. OH_AudioSession_Strategy strategy = {CONCURRENCY_MIX_WITH_OTHERS};

37. result = OH_AudioSessionManager_ActivateAudioSession(audioSessionManager, &strategy);

38. // 根据实际业务，可以启动多个AudioRenderer等音频播放

39. result = OH_AudioSessionManager_DeactivateAudioSession(audioSessionManager);

40. result = OH_AudioSessionManager_UnregisterStateChangeCallback(audioSessionManager, AudioSessionStateChangedCallback);

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-session-management "使用AudioSession管理应用音频焦点(ArkTS)")
# 音频播放开发概述

更新时间: 2025-12-16 16:35

## 如何选择音频播放开发方式

系统提供了多样化的API，来帮助开发者完成音频播放的开发，不同的API适用于不同音频数据格式、音频资源来源、音频使用场景，甚至是不同开发语言。因此，选择合适的音频播放API，有助于降低开发工作量，实现更佳的音频播放效果。

- [AudioRenderer](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)：用于音频输出的ArkTS/JS API，仅支持PCM格式，需要应用持续写入音频数据进行工作。应用可以在输入前添加数据预处理，如设定音频文件的采样率、位宽等，要求开发者具备音频处理的基础知识，适用于更专业、更多样化的媒体播放应用开发。
    
- [AudioHaptic](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiohaptic-for-playback)：用于音振协同播放的ArkTS/JS API，适用于需要在播放音频时同步发起振动的场景，如来电铃声随振、键盘按键反馈、消息通知反馈等。
    
- [OHAudio](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)：用于音频输出的Native API，此API在设计上实现归一，同时支持普通音频通路和低时延通路。仅支持PCM格式，适用于依赖Native层实现音频输出功能的场景。
    

除上述方式外，也可以通过Media Kit中的AVPlayer和SoundPool实现音频播放。

- [AVPlayer](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avplayer-for-playback)：用于音频播放的ArkTS/JS API，集成了流媒体和本地资源解析、媒体资源解封装、音频解码和音频输出功能。可用于直接播放mp3、m4a等格式的音频文件，不支持直接播放PCM格式文件。
    
- [SoundPool](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-soundpool-for-playback)：低时延的短音播放ArkTS/JS API，适用于播放急促简短的音效，如相机快门音效、按键音效、游戏射击音效等。
    

## 后台播放开发须知

应用如果需要实现在后台播放音频（包含熄屏播放音频），除了开发音频播放功能之外，还需要根据自身业务场景，选择[接入AVSession](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avsession-access-scene)或[申请长时任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/continuous-task)，具体规则为：

- 当应用需要在后台播放媒体类型（流类型为STREAM_USAGE_MUSIC、STREAM_USAGE_MOVIE和STREAM_USAGE_AUDIOBOOK）和游戏类型（流类型为STREAM_USAGE_GAME）时，必须接入AVSession和申请长时任务。
    
- 除了上述播放类型，针对用户可感知的其他播放任务，如果应用需要在后台长时间运行该任务，必须申请[AUDIO_PLAYBACK](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resourceschedule-backgroundtaskmanager#backgroundmode)类型长时任务。
    

如果应用不满足上述接入规范，退至后台播放时会被系统静音并冻结，无法在后台正常播放。直到应用重新切回前台时，才会被解除静音并恢复播放。

详细的适配指南可参考[后台播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avsession-background-scene)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback "音频播放")
# 使用AudioRenderer开发音频播放功能

更新时间: 2025-12-16 16:35

AudioRenderer是音频渲染器，用于播放PCM（Pulse Code Modulation）音频数据，相比[AVPlayer](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-avplayer-for-playback)而言，可以在输入前添加数据预处理，更适合有音频开发经验的开发者，以实现更灵活的播放功能。

## 开发指导

使用AudioRenderer播放音频涉及到AudioRenderer实例的创建、音频渲染参数的配置、渲染的开始与停止、资源的释放等。本开发指导将以一次渲染音频数据的过程为例，向开发者讲解如何使用AudioRenderer进行音频渲染，建议搭配[AudioRenderer的API说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer)阅读。

下图展示了AudioRenderer的状态变化，在创建实例后，调用对应的方法可以进入指定的状态实现对应的行为。需要注意的是在确定的状态执行不合适的方法可能导致AudioRenderer发生错误，建议开发者在调用状态转换的方法前进行状态检查，避免程序运行产生预期以外的结果。

为保证UI线程不被阻塞，大部分AudioRenderer调用都是异步的。对于每个API均提供了callback函数和Promise函数，以下示例均采用callback函数。

**图1** AudioRenderer状态变化示意图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163523.17193283247121785423374812877964:50001231000000:2800:B8B706105FAC545FA92AEC6534D7826724AF62347E69E45550D963D100402215.png)

在进行应用开发的过程中，建议开发者通过[on('stateChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#onstatechange8)方法订阅AudioRenderer的状态变更。因为针对AudioRenderer的某些操作，仅在音频播放器在固定状态时才能执行。如果应用在音频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。

- prepared状态： 通过调用[createAudioRenderer()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-f#audiocreateaudiorenderer8)方法进入到该状态。
    
- running状态： 正在进行音频数据播放，可以在prepared状态通过调用[start()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#start8)方法进入此状态，也可以在paused状态和stopped状态通过调用[start()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#start8)方法进入此状态。
    
- paused状态： 在running状态可以通过调用[pause()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#pause8)方法暂停音频数据的播放并进入paused状态，暂停播放之后可以通过调用[start()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#start8)方法继续音频数据播放。
    
- stopped状态： 在paused/running状态可以通过[stop()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#stop8)方法停止音频数据的播放。
    
- released状态： 在prepared、paused、stopped等状态，用户均可通过[release()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#release8)方法释放掉所有占用的硬件和软件资源，并且不会再进入到其他的任何一种状态了。
    

### 开发步骤及注意事项

1. 配置音频渲染参数并创建AudioRenderer实例，音频渲染参数的详细信息可以查看[AudioRendererOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiorendereroptions8)。
    
    1. import { audio } from '@kit.AudioKit';
    
    2. let audioStreamInfo: audio.AudioStreamInfo = {
    3.   samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率。
    4.   channels: audio.AudioChannel.CHANNEL_2, // 通道。
    5.   sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式。
    6.   encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式。
    7. };
    
    8. let audioRendererInfo: audio.AudioRendererInfo = {
    9.   usage: audio.StreamUsage.STREAM_USAGE_MUSIC, // 音频流使用类型：音乐。根据业务场景配置，参考StreamUsage。
    10.   rendererFlags: 0 // 音频渲染器标志。
    11. };
    
    12. let audioRendererOptions: audio.AudioRendererOptions = {
    13.   streamInfo: audioStreamInfo,
    14.   rendererInfo: audioRendererInfo
    15. };
    
    16. audio.createAudioRenderer(audioRendererOptions, (err, data) => {
    17.   if (err) {
    18.     console.error(`Invoke createAudioRenderer failed, code is ${err.code}, message is ${err.message}`);
    19.     return;
    20.   } else {
    21.     console.info('Invoke createAudioRenderer succeeded.');
    22.     let audioRenderer = data;
    23.   }
    24. });
    
2. 调用on('writeData')方法，订阅监听音频数据写入回调，推荐使用API version 12支持返回回调结果的方式。
    
    - API version 12开始该方法支持返回回调结果，系统可以根据开发者返回的值来决定此次回调中的数据是否播放。
        
        注意
        
        - 能填满回调所需长度数据的情况下，返回audio.AudioDataCallbackResult.VALID，系统会取用完整长度的数据缓冲进行播放。请不要在未填满数据的情况下返回audio.AudioDataCallbackResult.VALID，否则会导致杂音、卡顿等现象。
            
        - 在无法填满回调所需长度数据的情况下，建议开发者返回audio.AudioDataCallbackResult.INVALID，系统不会处理该段音频数据，然后会再次向应用请求数据，确认数据填满后返回audio.AudioDataCallbackResult.VALID。
            
        - 回调函数结束后，音频服务会把缓冲中数据放入队列里等待播放，因此请勿在回调外再次更改缓冲中的数据。对于最后一帧，如果数据不够填满缓冲长度，开发者需要使用剩余数据拼接空数据的方式，将缓冲填满，避免缓冲内的历史脏数据对播放效果产生不良的影响。
            
        
        1. import { audio } from '@kit.AudioKit';
        2. import { BusinessError } from '@kit.BasicServicesKit';
        3. import { fileIo as fs } from '@kit.CoreFileKit';
        4. import { common } from '@kit.AbilityKit';
        
        5. class Options {
        6.   offset?: number;
        7.   length?: number;
        8. }
        
        9. let bufferSize: number = 0;
        10. // 请在组件内获取context，确保this.getUIContext().getHostContext()返回结果为UIAbilityContext。
        11. let context = this.getUIContext().getHostContext() as common.UIAbilityContext;
        12. let path = context.cacheDir;
        13. // 此处仅作示例，实际使用时需要将文件替换为应用要播放的PCM文件。
        14. let filePath = path + '/StarWars10s-2C-48000-4SW.pcm';
        15. let file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_ONLY);
        
        16. let writeDataCallback = (buffer: ArrayBuffer) => {
        17.   let options: Options = {
        18.     offset: bufferSize,
        19.     length: buffer.byteLength
        20.   };
        
        21.   try {
        22.     fs.readSync(file.fd, buffer, options);
        23.     bufferSize += buffer.byteLength;
        24.     // 系统会判定buffer有效，正常播放。
        25.     return audio.AudioDataCallbackResult.VALID;
        26.   } catch (error) {
        27.     console.error('Error reading file:', error);
        28.     // 系统会判定buffer无效，不播放。
        29.     return audio.AudioDataCallbackResult.INVALID;
        30.   }
        31. };
        
        32. audioRenderer.on('writeData', writeDataCallback);
        
    - API version 11该方法不支持返回回调结果，系统默认回调中的数据均为有效数据。
        
        注意
        
        - 请确保填满回调所需长度数据，否则会导致杂音、卡顿等现象。
            
        - 在无法填满回调所需长度数据的情况下，建议开发者选择暂时停止写入数据（不暂停音频流），阻塞回调函数，等待数据充足时，再继续写入数据，确保数据填满。在阻塞回调函数后，如需调用AudioRenderer相关接口，需先解阻塞。
            
        - 开发者如果不希望播放本次回调中的音频数据，可以主动将回调中的数据块置空（置空后，也会被系统统计到已写入的数据，播放静音帧）。
            
        - 回调函数结束后，音频服务会把缓冲中数据放入队列里等待播放，因此请勿在回调外再次更改缓冲中的数据。对于最后一帧，如果数据不够填满缓冲长度，开发者需要使用剩余数据拼接空数据的方式，将缓冲填满，避免缓冲内的历史脏数据对播放效果产生不良的影响。
            
        
        1. import { BusinessError } from '@kit.BasicServicesKit';
        2. import { fileIo as fs } from '@kit.CoreFileKit';
        3. import { common } from '@kit.AbilityKit';
        
        4. class Options {
        5.   offset?: number;
        6.   length?: number;
        7. }
        
        8. let bufferSize: number = 0;
        9. // 请在组件内获取context，确保this.getUIContext().getHostContext()返回结果为UIAbilityContext。
        10. let context = this.getUIContext().getHostContext() as common.UIAbilityContext;
        11. let path = context.cacheDir;
        12. // 此处仅作示例，实际使用时需要将文件替换为应用要播放的PCM文件。
        13. let filePath = path + '/StarWars10s-2C-48000-4SW.pcm';
        14. let file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_ONLY);
        15. let writeDataCallback = (buffer: ArrayBuffer) => {
        16.   // 如果开发者不希望播放某段buffer，可在此处添加判断并对buffer进行置空处理。
        17.   let options: Options = {
        18.     offset: bufferSize,
        19.     length: buffer.byteLength
        20.   };
        21.   fs.readSync(file.fd, buffer, options);
        22.   bufferSize += buffer.byteLength;
        23. };
        
        24. audioRenderer.on('writeData', writeDataCallback);
        
3. 调用start()方法进入running状态，开始渲染音频。
    
    1. import { BusinessError } from '@kit.BasicServicesKit';
    
    2. audioRenderer.start((err: BusinessError) => {
    3.   if (err) {
    4.     console.error(`Renderer start failed, code is ${err.code}, message is ${err.message}`);
    5.   } else {
    6.     console.info('Renderer start success.');
    7.   }
    8. });
    
4. 调用stop()方法停止渲染。
    
    1. import { BusinessError } from '@kit.BasicServicesKit';
    
    2. audioRenderer.stop((err: BusinessError) => {
    3.   if (err) {
    4.     console.error(`Renderer stop failed, code is ${err.code}, message is ${err.message}`);
    5.   } else {
    6.     console.info('Renderer stopped.');
    7.   }
    8. });
    
5. 调用release()方法销毁实例，释放资源。
    
    应用需根据实际业务需求合理使用AudioRenderer实例，按需创建并及时释放，避免占用过多音频资源导致异常。
    
    1. import { BusinessError } from '@kit.BasicServicesKit';
    
    2. audioRenderer.release((err: BusinessError) => {
    3.   if (err) {
    4.     console.error(`Renderer release failed, code is ${err.code}, message is ${err.message}`);
    5.   } else {
    6.     console.info('Renderer released.');
    7.   }
    8. });
    

### 选择正确的StreamUsage

创建播放器时候，开发者需要根据应用场景指定播放器的StreamUsage，选择正确的StreamUsage可以避免用户遇到不符合预期的行为。

在音频API文档[StreamUsage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)介绍中，列举了每一种类型推荐的应用场景。例如音乐场景推荐使用STREAM_USAGE_MUSIC，电影或者视频场景推荐使用STREAM_USAGE_MOVIE，游戏场景推荐使用STREAM_USAGE_GAME，等等。

如果开发者配置了不正确的StreamUsage，可能带来一些不符合预期的行为。例如以下场景。

- 游戏场景错误使用STREAM_USAGE_MUSIC类型，游戏应用将无法和其他音乐应用并发播放，而游戏场景通常可以与其他音乐应用并发播放。
- 导航场景错误使用STREAM_USAGE_MUSIC类型，导航应用播报时候会导致正在播放的音乐停止播放，而导航场景我们通常期望正在播放的音乐仅仅降低音量播放。

### 配置合适的音频采样率

采样率：指音频每秒单个声道样点数，单位为Hz。

重采样：根据输入输出音频采样率的差异，进行上采样（通过插值增加样点数）或下采样（通过抽取减少样点数）。

AudioRenderer支持枚举类型AudioSamplingRate中定义的所有采样率。

若通过AudioRenderer设置的输入音频采样率与设备输出采样率不一致，系统会将输入音频重采样为设备输出采样率。

若为减少重采样功耗，可使用采样率与输出设备采样率一致的输入音频。推荐使用48k采样率。

### 完整示例

下面展示了使用AudioRenderer渲染音频文件的示例代码。

1. import { audio } from '@kit.AudioKit';
2. import { BusinessError } from '@kit.BasicServicesKit';
3. import { fileIo as fs } from '@kit.CoreFileKit';
4. import { common } from '@kit.AbilityKit';

5. const TAG = 'AudioRendererDemo';

6. class Options {
7.   offset?: number;
8.   length?: number;
9. }

10. let audioRenderer: audio.AudioRenderer | undefined = undefined;
11. let audioStreamInfo: audio.AudioStreamInfo = {
12.   samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率。
13.   channels: audio.AudioChannel.CHANNEL_2, // 通道。
14.   sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式。
15.   encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式。
16. };
17. let audioRendererInfo: audio.AudioRendererInfo = {
18.   usage: audio.StreamUsage.STREAM_USAGE_MUSIC, // 音频流使用类型：音乐。根据业务场景配置，参考StreamUsage。
19.   rendererFlags: 0 // 音频渲染器标志。
20. };
21. let audioRendererOptions: audio.AudioRendererOptions = {
22.   streamInfo: audioStreamInfo,
23.   rendererInfo: audioRendererInfo
24. };
25. let file: fs.File;
26. let writeDataCallback: audio.AudioRendererWriteDataCallback;

27. async function initArguments(context: common.UIAbilityContext) {
28.   let bufferSize: number = 0;
29.   let path = context.cacheDir;
30.   // 此处仅作示例，实际使用时需要将文件替换为应用要播放的PCM文件。
31.   let filePath = path + '/StarWars10s-2C-48000-4SW.pcm';
32.   file = fs.openSync(filePath, fs.OpenMode.READ_ONLY);
33.   writeDataCallback = (buffer: ArrayBuffer) => {
34.     let options: Options = {
35.       offset: bufferSize,
36.       length: buffer.byteLength
37.     };

38.     try {
39.       let bufferLength = fs.readSync(file.fd, buffer, options);
40.       bufferSize += buffer.byteLength;
41.       // 如果当前回调传入的数据不足一帧，空白区域需要使用静音数据填充，否则会导致播放出现杂音。
42.       if (bufferLength < buffer.byteLength) {
43.         let view = new DataView(buffer);
44.         for (let i = bufferLength; i < buffer.byteLength; i++) {
45.           // 空白区域填充静音数据。当使用音频采样格式为SAMPLE_FORMAT_U8时0x7F为静音数据，使用其他采样格式时0为静音数据。
46.           view.setUint8(i, 0);
47.         }
48.       }
49.       // API version 11不支持返回回调结果，从API version 12开始支持返回回调结果。
50.       // 如果开发者不希望播放某段buffer，返回audio.AudioDataCallbackResult.INVALID即可。
51.       return audio.AudioDataCallbackResult.VALID;
52.     } catch (error) {
53.       console.error('Error reading file:', error);
54.       // API version 11不支持返回回调结果，从API version 12开始支持返回回调结果。
55.       return audio.AudioDataCallbackResult.INVALID;
56.     }
57.   };
58. }

59. // 初始化，创建实例，设置监听事件。
60. async function init() {
61.   audio.createAudioRenderer(audioRendererOptions, (err, renderer) => { // 创建AudioRenderer实例。
62.     if (!err) {
63.       console.info(`${TAG}: creating AudioRenderer success`);
64.       audioRenderer = renderer;
65.       if (audioRenderer !== undefined) {
66.         audioRenderer.on('writeData', writeDataCallback);
67.       }
68.     } else {
69.       console.info(`${TAG}: creating AudioRenderer failed, error: ${err.message}`);
70.     }
71.   });
72. }

73. // 开始一次音频渲染。
74. async function start() {
75.   if (audioRenderer !== undefined) {
76.     let stateGroup = [audio.AudioState.STATE_PREPARED, audio.AudioState.STATE_PAUSED, audio.AudioState.STATE_STOPPED];
77.     if (stateGroup.indexOf(audioRenderer.state.valueOf()) === -1) { // 当且仅当状态为prepared、paused和stopped之一时才能启动渲染。
78.       console.error(TAG + 'start failed');
79.       return;
80.     }
81.     // 启动渲染。
82.     audioRenderer.start((err: BusinessError) => {
83.       if (err) {
84.         console.error('Renderer start failed.');
85.       } else {
86.         console.info('Renderer start success.');
87.       }
88.     });
89.   }
90. }

91. // 暂停渲染。
92. async function pause() {
93.   if (audioRenderer !== undefined) {
94.     // 只有渲染器状态为running的时候才能暂停。
95.     if (audioRenderer.state.valueOf() !== audio.AudioState.STATE_RUNNING) {
96.       console.info('Renderer is not running');
97.       return;
98.     }
99.     // 暂停渲染。
100.     audioRenderer.pause((err: BusinessError) => {
101.       if (err) {
102.         console.error('Renderer pause failed.');
103.       } else {
104.         console.info('Renderer pause success.');
105.       }
106.     });
107.   }
108. }

109. // 停止渲染。
110. async function stop() {
111.   if (audioRenderer !== undefined) {
112.     // 只有渲染器状态为running或paused的时候才可以停止。
113.     if (audioRenderer.state.valueOf() !== audio.AudioState.STATE_RUNNING && audioRenderer.state.valueOf() !== audio.AudioState.STATE_PAUSED) {
114.       console.info('Renderer is not running or paused.');
115.       return;
116.     }
117.     // 停止渲染。
118.     audioRenderer.stop((err: BusinessError) => {
119.       if (err) {
120.         console.error('Renderer stop failed.');
121.       } else {
122.         console.info('Renderer stop success.');
123.       }
124.     });
125.   }
126. }

127. // 销毁实例，释放资源。
128. async function release() {
129.   if (audioRenderer !== undefined) {
130.     // 渲染器状态不是released状态，才能release。
131.     if (audioRenderer.state.valueOf() === audio.AudioState.STATE_RELEASED) {
132.       console.info('Renderer already released');
133.       return;
134.     }
135.     // 释放资源。
136.     audioRenderer.release((err: BusinessError) => {
137.       if (err) {
138.         console.error('Renderer release failed.');
139.       } else {
140.         fs.closeSync(file);
141.         console.info('Renderer release success.');
142.       }
143.     });
144.   }
145. }

146. @Entry
147. @Component
148. struct Index {
149.   build() {
150.     Scroll() {
151.       Column() {
152.         Row() {
153.           Column() {
154.             Text('初始化').fontColor(Color.Black).fontSize(16).margin({ top: 12 });
155.           }
156.           .backgroundColor(Color.White)
157.           .borderRadius(30)
158.           .width('45%')
159.           .height('25%')
160.           .margin({ right: 12, bottom: 12 })
161.           .onClick(async () => {
162.             let context = this.getUIContext().getHostContext() as common.UIAbilityContext;
163.             initArguments(context);
164.             init();
165.           });

166.           Column() {
167.             Text('开始播放').fontColor(Color.Black).fontSize(16).margin({ top: 12 });
168.           }
169.           .backgroundColor(Color.White)
170.           .borderRadius(30)
171.           .width('45%')
172.           .height('25%')
173.           .margin({ bottom: 12 })
174.           .onClick(async () => {
175.             start();
176.           });
177.         }

178.         Row() {
179.           Column() {
180.             Text('暂停播放').fontSize(16).margin({ top: 12 });
181.           }
182.           .id('audio_effect_manager_card')
183.           .backgroundColor(Color.White)
184.           .borderRadius(30)
185.           .width('45%')
186.           .height('25%')
187.           .margin({ right: 12, bottom: 12 })
188.           .onClick(async () => {
189.             pause();
190.           });

191.           Column() {
192.             Text('停止播放').fontColor(Color.Black).fontSize(16).margin({ top: 12 });
193.           }
194.           .backgroundColor(Color.White)
195.           .borderRadius(30)
196.           .width('45%')
197.           .height('25%')
198.           .margin({ bottom: 12 })
199.           .onClick(async () => {
200.             stop();
201.           });
202.         }

203.         Row() {
204.           Column() {
205.             Text('释放资源').fontColor(Color.Black).fontSize(16).margin({ top: 12 });
206.           }
207.           .id('audio_volume_card')
208.           .backgroundColor(Color.White)
209.           .borderRadius(30)
210.           .width('45%')
211.           .height('25%')
212.           .margin({ right: 12, bottom: 12 })
213.           .onClick(async () => {
214.             release();
215.           });
216.         }
217.         .padding(12)
218.       }
219.       .height('100%')
220.       .width('100%')
221.       .backgroundColor('#F1F3F5');
222.     }
223.   }
224. }

当同优先级或高优先级音频流要使用输出设备时，当前音频流会被中断，应用可以自行响应中断事件并做出处理。具体的音频并发处理方式可参考[处理音频焦点事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-overview "音频播放开发概述")
# 使用OHAudio开发音频播放功能(C/C++)

更新时间: 2025-12-16 16:35

OHAudio是系统在API version 10中引入的一套C API，此API在设计上实现归一，同时支持普通音频通路和低时延通路。仅支持PCM格式，适用于依赖Native层实现音频输出功能的场景。

OHAudio音频播放状态变化示意图：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163526.79349009398856001480348337728410:50001231000000:2800:413DDBD555FCDA7C21790935CBA746662121523F3508943D8353491FDF0042C2.png)

## 使用入门

开发者要使用OHAudio提供的播放能力，需要添加对应的头文件。

### 在 CMake 脚本中链接动态库

1. target_link_libraries(sample PUBLIC libohaudio.so)

### 添加头文件

开发者通过引入<[native_audiostreambuilder.h](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h)>和<[native_audiorenderer.h](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h)>头文件，使用音频播放相关API。

1. #include <ohaudio/native_audiorenderer.h>
2. #include <ohaudio/native_audiostreambuilder.h>

## 开发步骤

详细的API说明请参考[OHAudio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio)。

### 音频流构造器

OHAudio提供OH_AudioStreamBuilder接口，遵循构造器设计模式，用于构建音频流。开发者需要根据业务场景，指定对应的[OH_AudioStream_Type](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_type)。

OH_AudioStream_Type包含两种类型：

- AUDIOSTREAM_TYPE_RENDERER
- AUDIOSTREAM_TYPE_CAPTURER

使用[OH_AudioStreamBuilder_Create](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_create)创建构造器示例：

1. OH_AudioStreamBuilder* builder;
2. OH_AudioStreamBuilder_Create(&builder, streamType);

在音频业务结束之后，开发者应该执行[OH_AudioStreamBuilder_Destroy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_destroy)接口来销毁构造器。

1. OH_AudioStreamBuilder_Destroy(builder);

开发者可以通过以下几个步骤来实现一个简单的播放功能。

### 实现音频播放

1. 创建构造器。
    
    1. OH_AudioStreamBuilder* builder;
    2. OH_AudioStreamBuilder_Create(&builder, AUDIOSTREAM_TYPE_RENDERER);
    
2. 配置音频流参数。
    
    关于音频采样率可参考[配置合适的音频采样率](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback#%E9%85%8D%E7%BD%AE%E5%90%88%E9%80%82%E7%9A%84%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7%E7%8E%87)。
    
    创建音频播放构造器后，可以设置音频流所需要的参数，可以参考下面的案例。
    
    1. // 设置音频采样率。
    2. OH_AudioStreamBuilder_SetSamplingRate(builder, 48000);
    3. // 设置音频声道。
    4. OH_AudioStreamBuilder_SetChannelCount(builder, 2);
    5. // 设置音频采样格式。
    6. OH_AudioStreamBuilder_SetSampleFormat(builder, AUDIOSTREAM_SAMPLE_S16LE);
    7. // 设置音频流的编码类型。
    8. OH_AudioStreamBuilder_SetEncodingType(builder, AUDIOSTREAM_ENCODING_TYPE_RAW);
    9. // 设置输出音频流的工作场景。
    10. OH_AudioStreamBuilder_SetRendererInfo(builder, AUDIOSTREAM_USAGE_MUSIC);
    
    注意，播放的音频数据要通过回调接口写入，开发者要实现回调接口，从API version 12开始支持使用[OH_AudioStreamBuilder_SetRendererWriteDataCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setrendererwritedatacallback)设置数据回调函数。数据回调函数的声明请查看[OH_AudioRenderer_OnWriteDataCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiorenderer_onwritedatacallback)。
    
3. 设置音频回调函数。
    
    多音频并发处理可参考文档[处理音频焦点事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-concurrency)，仅接口语言差异。
    
    - 从API version 12开始**推荐**使用[OH_AudioRenderer_OnWriteDataCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiorenderer_onwritedatacallback)用于写入音频数据。
        
        注意
        
        - 能填满回调所需长度数据的情况下，返回AUDIO_DATA_CALLBACK_RESULT_VALID，系统会取用完整长度的数据缓冲进行播放。请不要在未填满数据的情况下返回AUDIO_DATA_CALLBACK_RESULT_VALID，否则会导致杂音、卡顿等现象。
            
        - 在无法填满回调所需长度数据的情况下，建议开发者返回AUDIO_DATA_CALLBACK_RESULT_INVALID，系统不会处理该段音频数据，然后会再次向应用请求数据，确认数据填满后返回AUDIO_DATA_CALLBACK_RESULT_VALID。
            
        - 回调函数结束后，音频服务会把缓冲中数据放入队列里等待播放，因此请勿在回调外再次更改缓冲中的数据。对于最后一帧，如果数据不够填满缓冲长度，开发者需要使用剩余数据拼接空数据的方式，将缓冲填满，避免缓冲内的历史脏数据对播放效果产生不良的影响。
            
        
    - 从API version 12开始可通过[OH_AudioStreamBuilder_SetFrameSizeInCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setframesizeincallback)设置audioDataSize的大小。
        
    
    1. // 自定义写入数据函数。
    2. OH_AudioData_Callback_Result MyOnWriteData(
    3.     OH_AudioRenderer* renderer,
    4.     void* userData,
    5.     void* audioData,
    6.     int32_t audioDataSize)
    7. {
    8.     // 将待播放的数据，按audioDataSize长度写入audioData。
    9.     // 如果开发者不希望播放某段audioData，返回AUDIO_DATA_CALLBACK_RESULT_INVALID即可。
    10.     return AUDIO_DATA_CALLBACK_RESULT_VALID;
    11. }
    12. // 自定义音频中断事件函数。
    13. void MyOnInterruptEvent(
    14.     OH_AudioRenderer* renderer,
    15.     void* userData,
    16.     OH_AudioInterrupt_ForceType type,
    17.     OH_AudioInterrupt_Hint hint)
    18. {
    19.     // 根据type和hint表示的音频中断信息，更新播放器状态和界面。
    20. }
    21. // 自定义异常回调函数。
    22. void MyOnError(
    23.     OH_AudioRenderer* renderer,
    24.     void* userData,
    25.     OH_AudioStream_Result error)
    26. {
    27.     // 根据error表示的音频异常信息，做出相应的处理。
    28. }
    
    29. // 配置音频中断事件回调函数。
    30. OH_AudioRenderer_OnInterruptCallback OnIntereruptCb = MyOnInterruptEvent;
    31. OH_AudioStreamBuilder_SetRendererInterruptCallback(builder, OnIntereruptCb, nullptr);
    
    32. // 配置音频异常回调函数。
    33. OH_AudioRenderer_OnErrorCallback OnErrorCb = MyOnError;
    34. OH_AudioStreamBuilder_SetRendererErrorCallback(builder, OnErrorCb, nullptr);
    
    35. // 配置写入音频数据回调函数。
    36. OH_AudioRenderer_OnWriteDataCallback writeDataCb = MyOnWriteData;
    37. OH_AudioStreamBuilder_SetRendererWriteDataCallback(builder, writeDataCb, nullptr);
    
4. 构造播放音频流。
    
    1. OH_AudioRenderer* audioRenderer;
    2. OH_AudioStreamBuilder_GenerateRenderer(builder, &audioRenderer);
    
5. 使用音频流。
    
    音频流中包含以下接口，用来实现对音频流的控制。
    
    |接口|说明|
    |:--|:--|
    |OH_AudioStream_Result OH_AudioRenderer_Start(OH_AudioRenderer* renderer)|开始播放。|
    |OH_AudioStream_Result OH_AudioRenderer_Pause(OH_AudioRenderer* renderer)|暂停播放。|
    |OH_AudioStream_Result OH_AudioRenderer_Stop(OH_AudioRenderer* renderer)|停止播放。|
    |OH_AudioStream_Result OH_AudioRenderer_Flush(OH_AudioRenderer* renderer)|释放缓存数据。|
    |OH_AudioStream_Result OH_AudioRenderer_Release(OH_AudioRenderer* renderer)|释放播放实例。|
    
6. 释放构造器。
    
    构造器不再使用时，需要释放相关资源。
    
    应用需根据实际业务需求合理使用构造器，按需创建并及时释放，避免占用过多音频资源导致异常。
    
    1. OH_AudioStreamBuilder_Destroy(builder);
    

### 设置音频流音量

开发者可使用[OH_AudioRenderer_SetVolume](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_setvolume)接口设置当前音频流音量值。

1. // 要设置的音量值，音量值的范围是[0.0, 1.0]。
2. float volume = 0.5f;

3. // 设置当前音频流音量值。
4. OH_AudioStream_Result OH_AudioRenderer_SetVolume(audioRenderer, volume);

### 设置低时延模式

当设备支持低时延通路且采样率设置为48000Hz时，开发者可以使用低时延模式创建播放器，获得更高质量的音频体验。

开发流程与普通播放（[实现音频播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback#%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE)）场景一致，仅需要在步骤1创建音频流构造器时，调用[OH_AudioStreamBuilder_SetLatencyMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setlatencymode)设置低时延模式。

注意

- 当音频录制场景[OH_AudioStream_Usage](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_usage)为AUDIOSTREAM_USAGE_VOICE_COMMUNICATION和AUDIOSTREAM_USAGE_VIDEO_COMMUNICATION时，不支持主动设置低时延模式，系统会根据设备的能力，决策输出的音频通路。
- 低时延通路对于数据处理性能要求较高，应用数据生成缓慢时容易导致卡顿。普通音乐、视频播放场景下不建议设置该模式，仅推荐游戏、K歌等对时延敏感的应用设置低时延模式。

1. OH_AudioStreamBuilder_SetLatencyMode(builder, AUDIOSTREAM_LATENCY_MODE_FAST);

### 设置音频声道布局

播放音频文件时，可以通过设置音频的声道布局信息，指定渲染或播放时的扬声器摆位，使得渲染和播放效果更佳，获得更高质量的音频体验。

开发流程与普通播放（[实现音频播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback#%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE)）场景一致，仅需要在步骤1创建音频流构造器时，调用[OH_AudioStreamBuilder_SetChannelLayout()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setchannellayout)设置声道布局信息。

当声道布局与声道数不匹配时，创建音频流会失败。建议在设置声道布局时，确认下发的声道布局信息是否正确。

如果不知道准确的声道布局信息，或者开发者需要使用默认声道布局，可以不调用设置声道布局接口，或者下发CH_LAYOUT_UNKNOWN，以使用基于声道数的默认声道布局。

对于HOA（高阶立体环绕声）格式的音频，想要获得正确的渲染和播放效果，必须指定声道布局信息。

1. OH_AudioStreamBuilder_SetChannelLayout(builder, CH_LAYOUT_STEREO);

### 播放Audio Vivid格式音源

播放Audio Vivid（菁彩三维声）格式音频文件时，需要使用与普通播放不同的数据写入回调函数，该回调可以同时写入PCM（脉冲编码调制）数据与元数据。

开发流程与普通播放（[实现音频播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback#%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE)）场景一致，仅需要在步骤1创建音频流构造器时，调用[OH_AudioStreamBuilder_SetWriteDataWithMetadataCallback()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setwritedatawithmetadatacallback)设置PCM数据与元数据同时写入的回调函数，同时调用[OH_AudioStreamBuilder_SetEncodingType()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setencodingtype)设置编码类型为AUDIOSTREAM_ENCODING_TYPE_AUDIOVIVID。

在播放Audio Vivid时，帧长是固定的，不可通过[OH_AudioStreamBuilder_SetFrameSizeInCallback()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setframesizeincallback)设置回调帧长。同时，在设置播放声道数和声道布局时，需要将写入音源的声床数和对象数相加后进行设置。

1. // 自定义同时写入PCM数据和元数据函数。
2. int32_t MyOnWriteDataWithMetadata(
3.     OH_AudioRenderer* renderer,
4.     void* userData,
5.     void* audioData,
6.     int32_t audioDataSize,
7.     void* metadata,
8.     int32_t metadataSize)
9. {
10.     // 将待播放的PCM数据和元数据，分别按audioDataSize和metadataSize写入buffer。
11.     return 0;
12. }

13. // 设置编码类型。
14. OH_AudioStreamBuilder_SetEncodingType(builder, AUDIOSTREAM_ENCODING_TYPE_AUDIOVIVID);
15. // 配置回调函数。
16. OH_AudioRenderer_WriteDataWithMetadataCallback metadataCallback = MyOnWriteDataWithMetadata;
17. // 设置同时写入PCM数据和元数据的回调。
18. OH_AudioStreamBuilder_SetWriteDataWithMetadataCallback(builder, metadataCallback, nullptr);

## 注意事项

从API version 12开始**不再推荐**使用[OH_AudioRenderer_Callbacks](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiorenderer-callbacks-struct)的方式设置音频回调函数。若必须使用，需要注意在设置音频回调函数时，通过下面两种方式中的任意一种来设置音频回调函数，避免不可预期的行为。

- 方式1：请确保[OH_AudioRenderer_Callbacks](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-ohaudio-oh-audiorenderer-callbacks-struct)的每一个回调都被**自定义的回调方法**或**空指针**初始化。
    
    1. // 自定义写入数据函数。
    2. int32_t MyOnWriteData(
    3.     OH_AudioRenderer* renderer,
    4.     void* userData,
    5.     void* buffer,
    6.     int32_t length)
    7. {
    8.     // 将待播放的数据，按length长度写入buffer。
    9.     return 0;
    10. }
    11. // 自定义音频中断事件函数。
    12. int32_t MyOnInterruptEvent(
    13.     OH_AudioRenderer* renderer,
    14.     void* userData,
    15.     OH_AudioInterrupt_ForceType type,
    16.     OH_AudioInterrupt_Hint hint)
    17. {
    18.     // 根据type和hint表示的音频中断信息，更新播放器状态和界面。
    19.     return 0;
    20. }
    
    21. OH_AudioRenderer_Callbacks callbacks;
    
    22. // 配置回调函数，如果需要监听，则赋值。
    23. callbacks.OH_AudioRenderer_OnWriteData = MyOnWriteData;
    24. callbacks.OH_AudioRenderer_OnInterruptEvent = MyOnInterruptEvent;
    
    25. // （必选）无触发回调场景，使用空指针初始化。从API version 11开始，开发者如果需要监听设备变化，可直接使用OH_AudioRenderer_OutputDeviceChangeCallback替代。
    26. callbacks.OH_AudioRenderer_OnStreamEvent = nullptr;
    27. // （必选）如果不需要监听，使用空指针初始化。
    28. callbacks.OH_AudioRenderer_OnError = nullptr;
    
- 方式2：使用前，初始化并清零结构体。
    
    1. // 自定义写入数据函数。
    2. int32_t MyOnWriteData(
    3.     OH_AudioRenderer* renderer,
    4.     void* userData,
    5.     void* buffer,
    6.     int32_t length)
    7. {
    8.     // 将待播放的数据，按length长度写入buffer。
    9.     return 0;
    10. }
    11. // 自定义音频中断事件函数。
    12. int32_t MyOnInterruptEvent(
    13.     OH_AudioRenderer* renderer,
    14.     void* userData,
    15.     OH_AudioInterrupt_ForceType type,
    16.     OH_AudioInterrupt_Hint hint)
    17. {
    18.     // 根据type和hint表示的音频中断信息，更新播放器状态和界面。
    19.     return 0;
    20. }
    21. OH_AudioRenderer_Callbacks callbacks;
    
    22. // 使用前，初始化并清零结构体。
    23. memset(&callbacks, 0, sizeof(OH_AudioRenderer_Callbacks));
    
    24. // 配置需要的回调函数。
    25. callbacks.OH_AudioRenderer_OnWriteData = MyOnWriteData;
    26. callbacks.OH_AudioRenderer_OnInterruptEvent = MyOnInterruptEvent;
    

## 示例代码

- [音频低时延录制与播放](https://gitee.com/harmonyos_samples/audio-native)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback "使用AudioRenderer开发音频播放功能")

# 低时延音频播放(C/C++)

更新时间: 2025-12-16 16:35

从API version 10开始支持低时延音频播放。

低时延音频播放是一种通过软硬芯协同设计实现的音频渲染方案。其核心机制是通过减少buffer大小、优化读写数据架构，使该模式下音频播放具有更低的时延。

## 使用前提

- 支持低时延模式的音频输出设备。
- 可通过[OH_AudioRenderer_GetFastStatus()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_getfaststatus)验证当前设备是否支持低时延模式。

## 开发指导

### 简介

为使用低时延模式，开发者需要参考[使用OHAudio开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)进行音频开发。

当前OHAudio支持两种模式：普通模式（AUDIOSTREAM_LATENCY_MODE_NORMAL）和低时延模式（AUDIOSTREAM_LATENCY_MODE_FAST）。

### 设置低时延模式

开发者通过调用[OH_AudioStreamBuilder_SetLatencyMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setlatencymode)，设置[OH_AudioStream_LatencyMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_latencymode)来决定音频流使用的模式。

设置低时延模式开发示例：

1. OH_AudioStream_LatencyMode latencyMode = AUDIOSTREAM_LATENCY_MODE_FAST;
2. OH_AudioStreamBuilder_SetLatencyMode(builder, latencyMode);

针对OHAudio开发音频播放，有以下相关实例可供参考：

- [OHAudio录制和播放](https://gitcode.com/openharmony/applications_app_samples/tree/master/code/DocsSample/Media/Audio/OHAudio)。

## 注意事项

### 低时延模式限制

在以下场景中，即使设置了低时延模式，系统仍会使用普通模式。

- 当前设备不支持低时延模式。
- 当前流格式不支持低时延模式。
- 系统低时延资源已被全部占用。
- 当前系统中存在更高优先级流（如：蜂窝通话）。

从API version 20开始，支持低时延相关查询接口。

- 开发者通过调用[OH_AudioRenderer_GetFastStatus()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_getfaststatus)来获取音频播放流是否正在低时延状态下工作。
- 在部分特殊场景（如：存在更高优先级流、当前连接设备不支持等）下，开发者可以通过调用[OH_AudioRenderer_OnFastStatusChange()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_onfaststatuschange)来获取低时延状态改变事件。

### 使用低时延流的场景

- 游戏、k歌、直播等对时延要求较高的场景，建议使用低时延模式。
- 视频播放、音乐播放等没有实时要求的场景，不建议使用低时延模式。

### 确保数据及时提供

低时延模式下，应用提供数据的频次比普通播放模式高，如果传送数据不及时可能导致杂音等问题。开发者应避免在数据回调线程中做耗时操作，确保数据回调线程可以及时返回。

### 数据回调线程

播放的音频数据需要通过回调接口写入。开发者要实现回调接口，使用[OH_AudioStreamBuilder_SetRendererWriteDataCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setrendererwritedatacallback)设置写入音频数据的回调函数，在设置音频回调函数时，回调函数[OH_AudioRenderer_OnWriteDataCallback](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiorenderer_onwritedatacallback)（从API version 12开始支持）用于写入音频数据。

开发音频播放功能的示例代码请参考：[使用OHAudio开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)。

设置数据回调函数示例：

1. // 自定义写入数据函数。
2. static OH_AudioData_Callback_Result MyOnWriteData(
3.     OH_AudioRenderer* renderer,
4.     void* userData,
5.     void* audioData,
6.     int32_t audioDataSize)
7. {
8.     // 将待播放的数据，按audioDataSize长度写入audioData。
9.     // 如果开发者不希望播放某段audioData，返回AUDIO_DATA_CALLBACK_RESULT_INVALID即可。
10.     return AUDIO_DATA_CALLBACK_RESULT_VALID;
11. }
12. // 配置写入音频数据回调函数。
13. OH_AudioRenderer_OnWriteDataCallback writeDataCb = MyOnWriteData;
14. OH_AudioStreamBuilder_SetRendererWriteDataCallback(builder, writeDataCb, nullptr);

- 为避免音频卡顿，禁止在回调方法OH_AudioRenderer_OnWriteData中执行耗时操作。
    
- 为保证OH_AudioRenderer_OnWriteData与流状态控制逻辑独立正常运行，禁止在OH_AudioRenderer_OnWriteData回调方法中调用音频流控制接口。
    
    |音频流控制接口|说明|
    |:--|:--|
    |OH_AudioStream_Result OH_AudioRenderer_Start(OH_AudioRenderer* renderer)|开始播放。|
    |OH_AudioStream_Result OH_AudioRenderer_Pause(OH_AudioRenderer* renderer)|暂停播放。|
    |OH_AudioStream_Result OH_AudioRenderer_Stop(OH_AudioRenderer* renderer)|停止播放。|
    |OH_AudioStream_Result OH_AudioRenderer_Flush(OH_AudioRenderer* renderer)|释放缓存数据。|
    |OH_AudioStream_Result OH_AudioRenderer_Release(OH_AudioRenderer* renderer)|释放播放实例。|
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback "使用OHAudio开发音频播放功能(C/C++)")
# 低功耗音频播放

更新时间: 2025-12-16 16:35

从API version 11开始支持低功耗音频播放。

低功耗音频播放是一种通过软硬芯协同设计实现的音频渲染方案。其核心机制是增大音频渲染器的内部缓存，使系统能够一次性填充大量音频数据，从而允许主处理器长时间休眠，减少频繁处理音频数据的功耗，显著降低系统级功耗负载。

## 使用前提

当前支持外放、有线耳机和部分蓝牙耳机实现低功耗功能。

## 开发指导

低功耗音频渲染器与普通音频渲染器接口无差异，但需关注应用数据周期与播放进度。音频渲染器使用请参考[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)和[使用OHAudio开发音频播放功能(C/C++)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)。

**数据周期示意图**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163530.29475121902154012672563028192795:50001231000000:2800:980CBF9CB4E456C15CAFF552BBC70F6D3CE931C048C40CB2088C316458B142A6.png)

在数据周期内，快速请求数据写满缓存时，进入休眠状态。当缓存数据消费完后，会触发下一个周期。

**播放进度示意图**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163530.15517054482225797455470703494796:50001231000000:2800:6298A973638DEB90264435E990C91AD05A2F7F1972A13A5BFE5B376D80F32E29.png)

在数据周期内，快速请求数据写满缓存时，播放进度按实际播放量计算。当缓存数据消费完（即播放进度到达写入数据量）后，会触发下一个周期。

### 注意事项

1. 流类型使用[STREAM_USAGE_MUSIC](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)、[STREAM_USAGE_AUDIOBOOK](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#streamusage)、[AUDIOSTREAM_USAGE_MUSIC](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_usage)或[AUDIOSTREAM_USAGE_AUDIOBOOK](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_usage)，系统默认为低功耗渲染器。
    
2. 低功耗渲染器缓存：亮屏场景下，最大1000ms；熄屏场景下，最大10000ms。缓存数据消费完时会唤醒主处理器，触发应用传送数据，传送数据的周期与缓存大小保持一致。
    
    - 应用在感知周期内未请求数据属于正常现象，无需停流。系统会自行判断长时间未收到数据的情况并停流；当应用重新发送数据时，系统将恢复流状态。
    - 熄屏场景下，数据写满缓存后主处理器进入休眠，应用会进入挂起状态。若应用需要后台播放或熄屏播放，请参考[后台播放开发须知](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback-overview#%E5%90%8E%E5%8F%B0%E6%92%AD%E6%94%BE%E5%BC%80%E5%8F%91%E9%A1%BB%E7%9F%A5)。
    - 低功耗渲染器每次请求数据长度与普通渲染器相同，通过高请求频率来填满缓存。预计每1ms请求1次，实际时长受应用和硬件影响。若应用无法快速提供数据，会降级到普通渲染器周期。如果普通渲染器周期无法保证数据及时性，需应用优化数据处理。
    - 当应用数据不足一次回调长度时，不允许填空数据以避免播放卡顿（到达EOS时除外）。建议等待数据充足或返回错误码。具体参考[AudioRenderer音频数据回调](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback#%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)和[OHAudio音频数据回调](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback#%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4)。
3. 低功耗渲染器和低时延渲染器不支持并发，采用先到先得原则，即先启动的生效，后启动的降级为普通渲染器。具体示例如下：
    
    - 先启低功耗渲染器A，再启低功耗渲染器B，则B降级普通渲染器。
    - 先启低功耗渲染器，再启低时延渲染器，则低时延降级普通渲染器。
    - 先启低时延渲染器，再启低功耗渲染器，则低功耗降级普通渲染器。
4. 应用数据写完不代表已经播完，需调用获取音频时间戳接口[getAudioTimestampInfo()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#getaudiotimestampinfo19)或[OH_AudioRenderer_GetAudioTimestampInfo()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_getaudiotimestampinfo)，判断实际播放进度。
    
    - 获取时间戳接口调用频率建议大于200ms一次，以免影响系统性能。
    - 应用程序调用接口[flush()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#flush11)或[OH_AudioRenderer_Flush()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_flush)后，播放的数据量会重置为0。
    - 播放数据量均会小于写入数据量。由于系统帧长与时延机制，播完的播放数据量不等于写入数据量。
    - 写完数据后获取时间戳，如果2个周期内时间戳不变，即为播完；或者根据设置的倍速推算剩余播放时长，超过相应时长，即为播完。（如：记总写入数据量p1，写完后获取时间戳p2，设置倍速α且α>0，音频采样率fs且fs>0，剩余可播时长t。公式：![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163530.56922027983014342273229393605134:50001231000000:2800:1411E4C925DE6CDE8C43FBFD552173B3A9258B1A0EEBCF0CDA303779EFDA6A09.png)）

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-fast-playback "低时延音频播放(C/C++)")
# 播放音量管理

更新时间: 2025-12-16 16:35

本模块提供播放音量管理能力，包括对**系统音量**、**应用音量**和**音频流音量**的管理。

**系统音量**是由HarmonyOS系统全局管理的音量设置，适用于所有应用程序和设备。HarmonyOS系统将音频分为不同的流类型，每种流类型有独立的系统音量控制。

说明

系统音量可以通过物理音量按键或系统设置界面调节。在设置界面中，用户可以单独调整上述每种系统音量的大小。

常见的流类型以及对应的系统音量如下所示。

- 媒体音量：用于音乐、视频、游戏等媒体播放。
- 通话音量：用于语音通话。
- 铃声音量：用于来电铃声。
- 闹钟音量：用于闹钟提醒。

**应用音量**是HarmonyOS提供给三方应用用来控制该应用下所有音频流音量的一种音量类型。三方应用设置应用音量之后，该应用中起的所有音频流默认使用该音量大小。另外具有系统应用权限的应用可以通过UID单独调整指定应用的音量。

**音频流音量**是由应用独立控制的音量设置，仅影响该应用中指定的音频流输出音量大小。例如：媒体播放器可以独立控制其播放音量，而不影响系统音量以及该应用中的其他类型流音量。

系统音量、应用音量和音频流音量的关系如下所示。

- 层级关系：系统音量是全局的，应用音量和音频流音量是局部的。
    
    应用音量和音频流音量的调整范围受系统音量的限制。例如：系统媒体音量设置为50%，应用音量设置为100%，应用程序的最终输出音量只能达到50%。
    
    音频流音量是对应用音量的更精细化控制。设置了应用音量的三方应用，还可以继续通过音频流音量对指定的音频流进行更加精细化的控制。
    
- 协同关系：应用最终的输出音量是由系统音量、应用音量和音频流音量共同决定的。例如：系统媒体音量设置为50%，应用音量设置为50%，应用程序中对媒体音频流设置音频流音量为100%，则该音频流最终输出的音量为25%。
    

HarmonyOS通过系统音量，应用音量和音频流音量协同的方式实现应用对音量的精确控制。

## 系统音量

管理系统音量的接口由AudioVolumeManager提供，在使用之前，需要使用[getVolumeManager()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getvolumemanager9)获取AudioVolumeManager实例。

通过AudioVolumeManager只能获取音量信息及监听音量变化，不能主动调节系统音量。如果应用需要调节系统音量，可以[使用音量面板调节系统音量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/volume-management#%E4%BD%BF%E7%94%A8%E9%9F%B3%E9%87%8F%E9%9D%A2%E6%9D%BF%E8%B0%83%E8%8A%82%E7%B3%BB%E7%BB%9F%E9%9F%B3%E9%87%8F)。

1. import { audio } from '@kit.AudioKit';

2. let audioManager = audio.getAudioManager();
3. let audioVolumeManager = audioManager.getVolumeManager();

### 获取音量信息

管理系统音量的接口由AudioVolumeManager提供，在使用之前，需要使用[getVolumeManager()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getvolumemanager9)获取AudioVolumeManager实例。

1. import { audio } from '@kit.AudioKit';

2. let audioManager = audio.getAudioManager();
3. let audioVolumeManager = audioManager.getVolumeManager();

使用[AudioVolumeManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiovolumemanager)获取指定流类型的音量信息。

示例代码如下所示：

1. import { audio } from '@kit.AudioKit';
2. import { BusinessError } from '@kit.BasicServicesKit';

3. // 获取指定流的音量。
4. audioVolumeManager.getVolumeByStream(audio.StreamUsage.STREAM_USAGE_MUSIC);

5. // 获取指定流的最小音量。
6. audioVolumeManager.getMinVolumeByStream(audio.StreamUsage.STREAM_USAGE_MUSIC);

7. // 获取指定流的最大音量。
8. audioVolumeManager.getMaxVolumeByStream(audio.StreamUsage.STREAM_USAGE_MUSIC);

### 监听系统音量变化

通过设置监听事件，可以监听系统音量的变化：

1. import { audio } from '@kit.AudioKit';

2. audioVolumeManager.on('streamVolumeChange', audio.StreamUsage.STREAM_USAGE_MUSIC, (streamVolumeEvent: audio.StreamVolumeEvent) => {
3.   console.info(`StreamUsagem: ${streamVolumeEvent.streamUsage} `);
4.   console.info(`Volume level: ${streamVolumeEvent.volume} `);
5.   console.info(`Whether to updateUI: ${streamVolumeEvent.updateUi} `);
6. });

### 使用音量面板调节系统音量

应用无法直接调节系统音量，可以通过系统音量面板，让用户通过界面操作来调节音量。当用户通过应用内音量面板调节音量时，系统会展示音量提示界面，显性地提示用户系统音量发生改变。

系统提供了ArkTS组件AVVolumePanel（音量面板），应用可以创建该组件，具体样例和介绍请查看[AVVolumePanel参考文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-multimedia-avvolumepanel)。

## 应用音量

管理应用音量的接口由AudioVolumeManager提供，在使用之前，需要使用[getVolumeManager()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getvolumemanager9)获取AudioVolumeManager实例。

当[音量模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiovolumemode19)设置为APP_INDIVIDUAL时，可通过下面示例接口设置、查询应用音量。

### 调节应用音量

1. import { audio } from '@kit.AudioKit';

2. let audioManager = audio.getAudioManager();
3. let audioVolumeManager = audioManager.getVolumeManager();

4. // 设置应用的音量（范围为0到100）。
5. audioVolumeManager.setAppVolumePercentage(20).then(() => {
6.   console.info(`set app volume success.`);
7. });

8. // 查询应用音量。
9. audioVolumeManager.getAppVolumePercentage().then((value: number) => {
10.   console.info(`app volume is ${value}.`);
11. });

12. // 监听应用音量变化，on方法和off方法传入callback参数一致，off方法取消对应on方法订阅的监听。
13. let appVolumeChangeCallback = (volumeEvent: audio.VolumeEvent) => {
14.   console.info(`VolumeType of stream: ${volumeEvent.volumeType} `);
15.   console.info(`Volume level: ${volumeEvent.volume} `);
16.   console.info(`Whether to updateUI: ${volumeEvent.updateUi} `);
17. };
18. audioVolumeManager.on('appVolumeChange', appVolumeChangeCallback);
19. audioVolumeManager.off('appVolumeChange', appVolumeChangeCallback);

## 音频流音量

管理音频流音量的接口是AVPlayer或AudioRenderer的setVolume()方法，使用[AVPlayer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-media-f#mediacreateavplayer9)设置音频流音量的示例代码如下：

1. let volume = 1.0;  // 指定的音量大小，取值范围为[0.00-1.00]，1表示最大音量。
2. avPlayer.setVolume(volume);

使用[AudioRenderer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-f#audiocreateaudiorenderer8)的[setVolume](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#setvolume9)和[getVolume](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#getvolume12)接口分别完成音频流音量的设置和获取。

示例代码如下所示：

1. import { BusinessError } from '@kit.BasicServicesKit';

2. // 设置音频流音量。
3. audioRenderer.setVolume(0.5).then(() => {  // 音量范围为[0.0-1.0]。
4.   console.info('Invoke setVolume succeeded.');
5. }).catch((err: BusinessError) => {
6.   console.error(`Invoke setVolume failed, code is ${err.code}, message is ${err.message}`);
7. });

8. // 获取音频流音量。
9. try {
10.   let value: number = audioRenderer.getVolume();
11.   console.info(`Indicate that the volume is obtained ${value}.`);
12. } catch (err) {
13.   let error = err as BusinessError;
14.   console.error(`Failed to obtain the volume, error ${error}.`);
15. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiohaptic-for-playback "使用AudioHaptic开发音振协同播放功能")
# 音频时延管理

更新时间: 2025-12-16 16:35

音频时延指从用户触发点击到声音从设备播放所经过的时间。

从音频数据传输的角度，指从触发回调写入开始，到最终播放出声的耗时，包括数据写入、算法处理、硬件传输延迟，以及在蓝牙场景下的蓝牙传输延迟。

当前OHAudio支持两种模式：普通模式（AUDIOSTREAM_LATENCY_MODE_NORMAL）和低时延模式（AUDIOSTREAM_LATENCY_MODE_FAST）。

开发者通过调用[OH_AudioStreamBuilder_SetLatencyMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostreambuilder-h#oh_audiostreambuilder_setlatencymode)，设置[OH_AudioStream_LatencyMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiostream-base-h#oh_audiostream_latencymode)，来决定音频流使用哪种模式。

低时延模式通过读写数据架构优化，使得该模式下音频播放和录制具有更低的时延。

为使用低时延模式，开发者需要使用OHAudio进行音频开发，可参考[使用OHAudio开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback)和[使用OHAudio开发音频录制功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-recording)。设置低时延模式开发示例：

1. OH_AudioStream_LatencyMode latencyMode = AUDIOSTREAM_LATENCY_MODE_FAST;
2. OH_AudioStreamBuilder_SetLatencyMode(builder, latencyMode);

应用可以通过[GetLatencyMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audiorenderer-h#oh_audiorenderer_getlatencymode)查询当前时延模式，开发示例：

1. OH_AudioStream_Result OH_AudioRenderer_GetLatencyMode(OH_AudioRenderer *renderer, OH_AudioStream_LatencyMode *latencyMode);

在低时延模式下，应用需要每5ms提供一次数据，如果送数据不及时可能导致杂音等问题。

但在以下场景中，即使设置了低时延模式，系统仍会使用普通模式：

- 当前设备不支持低时延模式。
- 采样率设置为非48K。
- 系统低时延资源已被全部占用。

游戏类应用对时延要求较高，建议使用低时延模式。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-performance "提升音频性能体验")
# 音频工作组管理

更新时间: 2025-12-16 16:35

音频工作组是一套通过标记来帮助系统识别应用内音频关键线程的接口，系统通过应用提供的关键音频线程以及工作组运行信息可以让音频线程的运行状态更加健康。

## 使用说明

对于播放音频类应用，开发者需要先创建音频工作组，再将工作组运行信息的周期性告知系统。当工作结束后，需要对音频工作组进行清理。

### 创建音频工作组示例

开发者在使用OH_AudioWorkgroup的API前，需要先用[OH_AudioManager_GetAudioResourceManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-resource-manager-h#oh_audiomanager_getaudioresourcemanager)获取OH_AudioResourceManager实例。

1. #include <ohaudio/native_audio_resource_manager.h>

2. OH_AudioResourceManager *resMgr;
3. OH_AudioManager_GetAudioResourceManager(&resMgr);

### 创建音频工作组并将关键线程加入音频工作组

开发者先使用[OH_AudioResourceManager_CreateWorkgroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-resource-manager-h#oh_audioresourcemanager_createworkgroup)创建一个新的音频工作组，再使用[OH_AudioWorkgroup_AddCurrentThread](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-audio-resource-manager-h#oh_audioworkgroup_addcurrentthread)将关键线程加入音频工作组。

1. #include <chrono>

2. int32_t tokenId;
3. OH_AudioWorkgroup *grp = nullptr;

4. OH_AudioResourceManager_CreateWorkgroup(resMgr, "workgroup", &grp);
5. OH_AudioWorkgroup_AddCurrentThread(grp, &tokenId);

### 通知系统音频工作组的开始与结束

当音频工作组开始一个工作周期时，开发者可以通知系统任务的开始时间和预期完成时间。在音频工作组完成当前周期内的工作时，开发者应再次通知系统任务已结束。

1. constexpr static uint64_t intervalMs = 20;
2. bool threadShouldRun = true;

3. while (threadShouldRun) {
4.   auto now = std::chrono::system_clock::now().time_since_epoch();
5.   auto startTimeMs = std::chrono::duration_cast<std::chrono::milliseconds>(now).count();

6.   OH_AudioWorkgroup_Start(grp, startTimeMs, startTimeMs + intervalMs);

7.   // 应用音频数据处理。

8.   OH_AudioWorkgroup_Stop(grp);
9. }

### 工作组任务结束后进行清理

1. // 当线程已经不需要接入分组时，将其从工作组中移除。
2. OH_AudioWorkgroup_RemoveThread(grp, tokenId);

3. OH_AudioResourceManager_ReleaseWorkgroup(resMgr, grp);
4. grp = nullptr;

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-latency "音频时延管理")
# 空间音频能力查询和状态订阅

更新时间: 2025-12-16 16:35

从API version 18开始，支持空间音频能力查询和状态订阅。

空间音频是一种能够将传统立体声体验扩展到三维空间的音频技术，在单声道、立体声、环绕声的基础上，增加高度感知，营造全方位的听音体验。空间音频为用户提供沉浸的、有互动的、有空间感的“声”临其境的音频体验。

Audio Vivid是基于AI技术的音频编解码标准，由世界超高清视频产业联盟（UWA）与数字音视频编解码技术标准工作组（AVS）联合制定，共同发布。包含音频PCM数据以及元数据的音频格式，相比传统立体声音源，Audio Vivid包含音频内容源的元数据信息，能够还原物理和感知世界中的真实听感，打造极致的沉浸式听觉体验。

空间音频支持播放多声道、立体声、Audio Vivid等格式音源，并在耳机实现双耳空间音频渲染重放。搭配Audio Vivid格式音源的空间音频渲染，能够将音乐中的人声和各种乐器作为独立的声音对象，重新定义各种声音对象的位置、移动轨迹和声音大小、远近等要素，实现声音在听众四周及上方全面萦绕，实现更佳的空间音频沉浸式体验，获得影院、音乐厅等的临场感与艺术体验。当设备支持空间音频且空间音频开关被打开时，下发Audio Vivid格式音源可以得到更加沉浸的音频体验。关于如何播放Audio Vivid音源，可参考[播放Audio Vivid音源](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-ohaudio-for-playback#%E6%92%AD%E6%94%BEaudio-vivid%E6%A0%BC%E5%BC%8F%E9%9F%B3%E6%BA%90)。

## 使用说明

对于播放音频类的应用，开发者可以查询到设备是否有支持空间音频的能力，以及当前设备空间音频的开关状态。

### 创建空间音频示例

应用开发者在使用AudioSpatializationManager的接口前，需要先调用[getSpatializationManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getspatializationmanager18)创建AudioSpatializationManager实例。

1. import { audio } from '@kit.AudioKit';

2. let audioManager = audio.getAudioManager();
3. let audioSpatializationManager = audioManager.getSpatializationManager();

### 查询设备是否支持空间音频渲染能力

应用开发者可以使用[AudioDeviceDescriptor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-i#audiodevicedescriptor)的spatializationSupported属性获取指定设备是否具有空间音频渲染的能力，需要通过音频框架中其他接口来获取当前已连接设备或当前发声设备的AudioDeviceDescriptor。例如，可以使用[getRoutingManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getroutingmanager9)创建的AudioRoutingManager实例的[getDevicesSync](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audioroutingmanager#getdevicessync10)接口获取。

1. import { audio } from '@kit.AudioKit';
2. let audioRoutingManager = audioManager.getRoutingManager();
3. let deviceDescriptors = audioRoutingManager.getDevicesSync(audio.DeviceFlag.OUTPUT_DEVICES_FLAG);
4. console.info(`Succeeded in getting devices, AudioDeviceDescriptors: ${JSON.stringify(deviceDescriptors)}.`);

### 查询当前发声设备的空间音频渲染效果开关状态

应用开发者可以通过[isSpatializationEnabledForCurrentDevice](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiospatializationmanager#isspatializationenabledforcurrentdevice18)接口查询当前设备的空间音频渲染效果开关状态。

- 该接口返回true表示当前设备空间音频渲染开启，返回false表示当前设备空间音频渲染关闭。
    
- 该状态仅为开关状态，实际是否生效还需依赖当前设备是否支持空间音频渲染。
    
    1. import { audio } from '@kit.AudioKit';
    
    2. let isSpatializationEnabledForCurrentDevice = audioSpatializationManager.isSpatializationEnabledForCurrentDevice();
    3. console.info(`Succeeded in using isSpatializationEnabledForCurrentDevice function, IsSpatializationEnabledForCurrentDevice: ${isSpatializationEnabledForCurrentDevice}.`);
    

**订阅当前发声设备空间音频渲染效果的开关状态变化事件**

应用开发者可以通过[on('spatializationEnabledChangeForCurrentDevice')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiospatializationmanager#onspatializationenabledchangeforcurrentdevice18)接口订阅当前空间音频渲染效果的开关状态变化事件。

该接口返回true表示空间音频渲染被开启，返回false表示空间音频渲染被关闭。

1. import { audio } from '@kit.AudioKit';

2. audioSpatializationManager.on('spatializationEnabledChangeForCurrentDevice', (isSpatializationEnabledForCurrentDevice: boolean) => {
3.   console.info(`Succeeded in using on function, IsSpatializationEnabledForCurrentDevice: ${isSpatializationEnabledForCurrentDevice}.`);
4. });

**取消订阅当前发声设备空间音频渲染效果的开关状态变化事件**

应用开发者可以通过[off('spatializationEnabledChangeForCurrentDevice')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiospatializationmanager#offspatializationenabledchangeforcurrentdevice18)接口取消订阅空间音频渲染效果的开关状态变化事件。

1. import { audio } from '@kit.AudioKit';
2. audioSpatializationManager.off('spatializationEnabledChangeForCurrentDevice');

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-workgroup "音频工作组管理")
# 音频播放流管理

更新时间: 2025-12-16 16:35

对于播放音频类的应用，开发者需要关注该应用的音频流的状态以做出相应的操作，比如监听到状态为播放中/暂停时，及时改变播放按钮的UI显示。

## 读取或监听应用内音频流状态变化

参考[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)或[audio.createAudioRenderer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-f#audiocreateaudiorenderer8)，完成AudioRenderer的创建，然后可以通过以下两种方式查看音频流状态的变化：

- 方法1：直接查看AudioRenderer的[state](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#%E5%B1%9E%E6%80%A7)：
    
    1. import { audio } from '@kit.AudioKit';
    
    2. let audioRendererState: audio.AudioState = audioRenderer.state;
    3. console.info(`Current state is: ${audioRendererState }`)
    
- 方法2：注册stateChange监听AudioRenderer的状态变化：
    
    1. import { audio } from '@kit.AudioKit';
    
    2. audioRenderer.on('stateChange', (rendererState: audio.AudioState) => {
    3.   console.info(`State change to: ${rendererState}`)
    4. });
    

获取state后可对照[AudioState](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiostate8)来进行相应的操作，比如更改暂停播放按钮的显示等。

## 读取或监听所有音频流的变化

如果部分应用需要查询获取所有音频流的变化信息，可以通过AudioStreamManager读取或监听所有音频流的变化。

如下为音频流管理调用关系图：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163537.42669201576463400376309808983591:50001231000000:2800:862E70E5F824082C470FDC3C06B7E2F7E9BE3E1440486B13B7AB8A8BA4B7AA56.png)

在进行应用开发的过程中，开发者需要先调用[getStreamManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getstreammanager9)创建AudioStreamManager实例，进而通过该实例管理音频流。

详细API含义可参考[AudioStreamManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager)。

## 开发步骤及注意事项

1. 创建AudioStreamManager实例。
    
    1. import { audio } from '@kit.AudioKit';
    
    2. let audioManager = audio.getAudioManager();
    3. let audioStreamManager = audioManager.getStreamManager();
    
2. 使用[on('audioRendererChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager#onaudiorendererchange9)监听音频播放流的变化。 如果音频流监听应用需要在音频播放流状态变化、设备变化时获取通知，可以订阅该事件。
    
    1. import { audio } from '@kit.AudioKit';
    
    2. audioStreamManager.on('audioRendererChange',  (AudioRendererChangeInfoArray: audio.AudioRendererChangeInfoArray) => {
    3.   for (let i = 0; i < AudioRendererChangeInfoArray.length; i++) {
    4.     let AudioRendererChangeInfo = AudioRendererChangeInfoArray[i];
    5.     console.info(`## RendererChange on is called for ${i} ##`);
    6.     console.info(`StreamId for ${i} is: ${AudioRendererChangeInfo.streamId}`);
    7.     console.info(`Content ${i} is: ${AudioRendererChangeInfo.rendererInfo.content}`);
    8.     console.info(`Stream ${i} is: ${AudioRendererChangeInfo.rendererInfo.usage}`);
    9.     console.info(`Flag ${i} is: ${AudioRendererChangeInfo.rendererInfo.rendererFlags}`);
    10.     for (let j = 0;j < AudioRendererChangeInfo.deviceDescriptors.length; j++) {
    11.       console.info(`Id: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].id}`);
    12.       console.info(`Type: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceType}`);
    13.       console.info(`Role: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceRole}`);
    14.       console.info(`Name: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].name}`);
    15.       console.info(`Address: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].address}`);
    16.       console.info(`SampleRates: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].sampleRates[0]}`);
    17.       console.info(`ChannelCount ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelCounts[0]}`);
    18.       console.info(`ChannelMask: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelMasks}`);
    19.     }
    20.   }
    21. });
    
3. （可选）使用[off('audioRendererChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager#offaudiorendererchange9)取消监听音频播放流变化。
    
    1. audioStreamManager.off('audioRendererChange');
    2. console.info('RendererChange Off is called ');
    
4. （可选）使用[getCurrentAudioRendererInfoArray](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager#getcurrentaudiorendererinfoarray9)获取所有音频播放流的信息。该接口可获取音频播放流唯一ID、音频渲染器信息以及音频播放设备信息。
    
    说明
    
    对所有音频流状态进行监听的应用需要[声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions)ohos.permission.USE_BLUETOOTH，否则无法获得实际的设备名称和设备地址信息，查询到的设备名称和设备地址（蓝牙设备的相关属性）将为空字符串。
    
    1. import { audio } from '@kit.AudioKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
    3. async function getCurrentAudioRendererInfoArray(): Promise<void> {
    4.   await audioStreamManager.getCurrentAudioRendererInfoArray().then((AudioRendererChangeInfoArray: audio.AudioRendererChangeInfoArray) => {
    5.     console.info(`getCurrentAudioRendererInfoArray  Get Promise is called `);
    6.     if (AudioRendererChangeInfoArray != null) {
    7.       for (let i = 0; i < AudioRendererChangeInfoArray.length; i++) {
    8.         let AudioRendererChangeInfo = AudioRendererChangeInfoArray[i];
    9.         console.info(`StreamId for ${i} is: ${AudioRendererChangeInfo.streamId}`);
    10.         console.info(`Content ${i} is: ${AudioRendererChangeInfo.rendererInfo.content}`);
    11.         console.info(`Stream ${i} is: ${AudioRendererChangeInfo.rendererInfo.usage}`);
    12.         console.info(`Flag ${i} is: ${AudioRendererChangeInfo.rendererInfo.rendererFlags}`);
    13.         for (let j = 0;j < AudioRendererChangeInfo.deviceDescriptors.length; j++) {
    14.           console.info(`Id: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].id}`);
    15.           console.info(`Type: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceType}`);
    16.           console.info(`Role: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceRole}`);
    17.           console.info(`Name: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].name}`);
    18.           console.info(`Address: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].address}`);
    19.           console.info(`SampleRates: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].sampleRates[0]}`);
    20.           console.info(`ChannelCount ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelCounts[0]}`);
    21.           console.info(`ChannelMask: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelMasks}`);
    22.         }
    23.       }
    24.     }
    25.   }).catch((err: BusinessError ) => {
    26.     console.error(`Invoke getCurrentAudioRendererInfoArray failed, code is ${err.code}, message is ${err.message}`);
    27.   });
    28. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/public-audio-spatialization-management "空间音频能力查询和状态订阅")
# 音频播放流管理

更新时间: 2025-12-16 16:35

对于播放音频类的应用，开发者需要关注该应用的音频流的状态以做出相应的操作，比如监听到状态为播放中/暂停时，及时改变播放按钮的UI显示。

## 读取或监听应用内音频流状态变化

参考[使用AudioRenderer开发音频播放功能](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback)或[audio.createAudioRenderer](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-f#audiocreateaudiorenderer8)，完成AudioRenderer的创建，然后可以通过以下两种方式查看音频流状态的变化：

- 方法1：直接查看AudioRenderer的[state](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiorenderer#%E5%B1%9E%E6%80%A7)：
    
    1. import { audio } from '@kit.AudioKit';
    
    2. let audioRendererState: audio.AudioState = audioRenderer.state;
    3. console.info(`Current state is: ${audioRendererState }`)
    
- 方法2：注册stateChange监听AudioRenderer的状态变化：
    
    1. import { audio } from '@kit.AudioKit';
    
    2. audioRenderer.on('stateChange', (rendererState: audio.AudioState) => {
    3.   console.info(`State change to: ${rendererState}`)
    4. });
    

获取state后可对照[AudioState](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-e#audiostate8)来进行相应的操作，比如更改暂停播放按钮的显示等。

## 读取或监听所有音频流的变化

如果部分应用需要查询获取所有音频流的变化信息，可以通过AudioStreamManager读取或监听所有音频流的变化。

如下为音频流管理调用关系图：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163537.42669201576463400376309808983591:50001231000000:2800:862E70E5F824082C470FDC3C06B7E2F7E9BE3E1440486B13B7AB8A8BA4B7AA56.png)

在进行应用开发的过程中，开发者需要先调用[getStreamManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiomanager#getstreammanager9)创建AudioStreamManager实例，进而通过该实例管理音频流。

详细API含义可参考[AudioStreamManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager)。

## 开发步骤及注意事项

1. 创建AudioStreamManager实例。
    
    1. import { audio } from '@kit.AudioKit';
    
    2. let audioManager = audio.getAudioManager();
    3. let audioStreamManager = audioManager.getStreamManager();
    
2. 使用[on('audioRendererChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager#onaudiorendererchange9)监听音频播放流的变化。 如果音频流监听应用需要在音频播放流状态变化、设备变化时获取通知，可以订阅该事件。
    
    1. import { audio } from '@kit.AudioKit';
    
    2. audioStreamManager.on('audioRendererChange',  (AudioRendererChangeInfoArray: audio.AudioRendererChangeInfoArray) => {
    3.   for (let i = 0; i < AudioRendererChangeInfoArray.length; i++) {
    4.     let AudioRendererChangeInfo = AudioRendererChangeInfoArray[i];
    5.     console.info(`## RendererChange on is called for ${i} ##`);
    6.     console.info(`StreamId for ${i} is: ${AudioRendererChangeInfo.streamId}`);
    7.     console.info(`Content ${i} is: ${AudioRendererChangeInfo.rendererInfo.content}`);
    8.     console.info(`Stream ${i} is: ${AudioRendererChangeInfo.rendererInfo.usage}`);
    9.     console.info(`Flag ${i} is: ${AudioRendererChangeInfo.rendererInfo.rendererFlags}`);
    10.     for (let j = 0;j < AudioRendererChangeInfo.deviceDescriptors.length; j++) {
    11.       console.info(`Id: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].id}`);
    12.       console.info(`Type: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceType}`);
    13.       console.info(`Role: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceRole}`);
    14.       console.info(`Name: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].name}`);
    15.       console.info(`Address: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].address}`);
    16.       console.info(`SampleRates: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].sampleRates[0]}`);
    17.       console.info(`ChannelCount ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelCounts[0]}`);
    18.       console.info(`ChannelMask: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelMasks}`);
    19.     }
    20.   }
    21. });
    
3. （可选）使用[off('audioRendererChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager#offaudiorendererchange9)取消监听音频播放流变化。
    
    1. audioStreamManager.off('audioRendererChange');
    2. console.info('RendererChange Off is called ');
    
4. （可选）使用[getCurrentAudioRendererInfoArray](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-audio-audiostreammanager#getcurrentaudiorendererinfoarray9)获取所有音频播放流的信息。该接口可获取音频播放流唯一ID、音频渲染器信息以及音频播放设备信息。
    
    说明
    
    对所有音频流状态进行监听的应用需要[声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions)ohos.permission.USE_BLUETOOTH，否则无法获得实际的设备名称和设备地址信息，查询到的设备名称和设备地址（蓝牙设备的相关属性）将为空字符串。
    
    1. import { audio } from '@kit.AudioKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
    3. async function getCurrentAudioRendererInfoArray(): Promise<void> {
    4.   await audioStreamManager.getCurrentAudioRendererInfoArray().then((AudioRendererChangeInfoArray: audio.AudioRendererChangeInfoArray) => {
    5.     console.info(`getCurrentAudioRendererInfoArray  Get Promise is called `);
    6.     if (AudioRendererChangeInfoArray != null) {
    7.       for (let i = 0; i < AudioRendererChangeInfoArray.length; i++) {
    8.         let AudioRendererChangeInfo = AudioRendererChangeInfoArray[i];
    9.         console.info(`StreamId for ${i} is: ${AudioRendererChangeInfo.streamId}`);
    10.         console.info(`Content ${i} is: ${AudioRendererChangeInfo.rendererInfo.content}`);
    11.         console.info(`Stream ${i} is: ${AudioRendererChangeInfo.rendererInfo.usage}`);
    12.         console.info(`Flag ${i} is: ${AudioRendererChangeInfo.rendererInfo.rendererFlags}`);
    13.         for (let j = 0;j < AudioRendererChangeInfo.deviceDescriptors.length; j++) {
    14.           console.info(`Id: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].id}`);
    15.           console.info(`Type: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceType}`);
    16.           console.info(`Role: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceRole}`);
    17.           console.info(`Name: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].name}`);
    18.           console.info(`Address: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].address}`);
    19.           console.info(`SampleRates: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].sampleRates[0]}`);
    20.           console.info(`ChannelCount ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelCounts[0]}`);
    21.           console.info(`ChannelMask: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelMasks}`);
    22.         }
    23.       }
    24.     }
    25.   }).catch((err: BusinessError ) => {
    26.     console.error(`Invoke getCurrentAudioRendererInfoArray failed, code is ${err.code}, message is ${err.message}`);
    27.   });
    28. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/public-audio-spatialization-management "空间音频能力查询和状态订阅")