<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频处理工具集 - 专业级视频编辑解决方案</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/ffmpeg.wasm@0.11.0/dist/ffmpeg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#64748b',
                        accent: '#06b6d4',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .glass {
                background: rgba(255, 255, 255, 0.25);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.18);
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .transition-all-300 {
                transition: all 300ms ease-in-out;
            }
        }

        /* 自定义样式 */
        .frame-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 6px;
            overflow-y: auto;
            max-height: 300px;
            background-color: #f0f9ff;
            padding: 12px;
            border-radius: 12px;
            border: 1px solid #e0f2fe;
        }
        
        .frame-item {
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #ffffff;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e0f2fe;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .frame-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(59, 130, 246, 0.15);
            border-color: #3b82f6;
        }
        
        .frame-item.selected {
            border: 2px solid #2563eb;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            background-color: #eff6ff;
        }
        
        .progress-bar {
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: #3b82f6;
            transition: width 0.3s ease;
        }
        
        /* 移动端适配 */
        @media (max-width: 640px) {
            .frame-container {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 5px;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-light to-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- 标题区域 -->
        <header class="text-center mb-8 animate-fade-in">
            <div class="inline-block bg-gradient-to-r from-primary to-accent bg-clip-text text-transparent">
                <h1 class="text-4xl md:text-5xl font-bold text-shadow mb-3">视频处理工具集</h1>
            </div>
            <p class="text-secondary text-lg max-w-2xl mx-auto">
                专业级视频编辑解决方案，支持逐帧导出、GIF转换和视频压缩，
                <span class="text-primary font-medium">完全在浏览器中处理，无需安装软件</span>
            </p>
        </header>
        
        <!-- 工具切换导航 -->
        <div class="flex justify-center mb-8 animate-slide-up">
            <div class="bg-white/90 backdrop-blur-sm rounded-full shadow-lg p-1 inline-flex border border-gray-100">
                <button id="frame-extractor-btn" class="tool-nav-btn active px-6 py-3 rounded-full font-medium text-primary bg-blue-50 transition-all duration-300 hover:shadow-md hover:scale-105">
                    <i class="fa fa-film mr-2"></i> 视频逐帧导出
                </button>
                <button id="gif-converter-btn" class="tool-nav-btn px-6 py-3 rounded-full font-medium text-secondary hover:text-primary transition-all duration-300 hover:shadow-md hover:scale-105">
                    <i class="fa fa-image mr-2"></i> 视频转GIF
                </button>
                <button id="compressor-btn" class="tool-nav-btn px-6 py-3 rounded-full font-medium text-secondary hover:text-primary transition-all duration-300 hover:shadow-md hover:scale-105">
                    <i class="fa fa-compress mr-2"></i> 视频压缩器
                </button>
            </div>
        </div>

        <!-- 主要内容区域 -->
        <main>
            <!-- 视频逐帧导出器 -->
            <div id="frame-extractor-tool" class="tool-section glass hover:glass-hover rounded-2xl p-6 shadow-lg transition-all duration-300 hover:shadow-xl">
            <!-- 上传区域 -->
            <section class="mb-8">
                <div id="upload-container" class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center cursor-pointer hover:border-primary hover:bg-blue-50/50 transition-all duration-300 group">
                    <input type="file" id="video-input" class="hidden" accept="video/*">
                    <div class="mb-6 transform transition-transform duration-300 group-hover:scale-110">
                        <i class="fa fa-cloud-upload text-5xl text-primary"></i>
                    </div>
                    <h2 class="text-xl font-semibold mb-3 text-dark">拖放视频文件到此处或点击上传</h2>
                    <p class="text-secondary mb-6 max-w-md mx-auto">支持 MP4、MOV、WebM 等格式，最大文件大小取决于浏览器性能</p>
                    <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                        <button id="upload-btn" class="bg-primary hover:bg-blue-600 text-white font-medium py-3 px-8 rounded-lg transition-all duration-300 hover:shadow-lg hover:scale-105 flex items-center">
                            <i class="fa fa-folder-open mr-2"></i> 选择视频文件
                        </button>
                        <button id="use-sample-extractor-btn" title="下载后选择本地文件即可测试所有功能" class="bg-accent hover:bg-cyan-600 text-white font-medium py-3 px-8 rounded-lg transition-all duration-300 hover:shadow-lg hover:scale-105 flex items-center">
                            <i class="fa fa-download mr-2"></i> 下载测试视频
                        </button>
                    </div>
                </div>

                
            </section>

            <!-- 视频预览和控制区域 -->
            <section id="preview-section" class="mb-8 hidden">
                <div class="bg-black rounded-lg overflow-hidden mb-4">
                    <video id="video-preview" class="w-full h-auto max-h-[400px] object-contain" controls></video>
                </div>
                <!-- 视频信息与提取控制（移动到视频下方） -->
                <div id="video-info" class="hidden mb-4 p-4 bg-gray-50 rounded-lg">
                    <div class="flex flex-col gap-3">
                        <div>
                            <h3 class="font-medium text-dark" id="video-filename">视频文件名</h3>
                            <p class="text-sm text-secondary" id="video-details">分辨率: 1920x1080 | 时长: 00:00:00</p>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <label for="extract-start" class="block text-sm font-medium text-secondary mb-1">开始时间 (秒)</label>
                                <input type="number" id="extract-start" class="w-full px-3 py-2 border border-gray-200 rounded-lg bg-gray-100 input-focus" value="0" min="0" step="0.1">
                            </div>
                            <div>
                                <label for="extract-end" class="block text-sm font-medium text-secondary mb-1">结束时间 (秒)</label>
                                <input type="number" id="extract-end" class="w-full px-3 py-2 border border-gray-200 rounded-lg bg-gray-100 input-focus" value="5" min="0.1" step="0.1">
                            </div>
                            <div>
                                <label for="extract-interval-ms" class="block text-sm font-medium text-secondary mb-1">提取间隔 (毫秒)</label>
                                <input type="number" id="extract-interval-ms" class="w-full px-3 py-2 border border-gray-200 rounded-lg bg-gray-100 input-focus" value="1000" min="1" step="1">
                            </div>
                        </div>
                        <div>
                            <button id="extract-btn" class="bg-accent hover:bg-cyan-600 text-white font-medium py-2 px-6 rounded-lg transition-all-300 flex items-center">
                                <i class="fa fa-download mr-2"></i> 开始提取
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- 视频控制 -->
                <div class="flex flex-wrap items-center justify-between gap-4 mb-4">
                    <div class="flex items-center gap-2">
                        <button id="prev-frame" class="bg-gray-200 hover:bg-gray-300 text-dark font-medium py-2 px-4 rounded-lg transition-all-300">
                            <i class="fa fa-step-backward"></i>
                        </button>
                        <button id="play-pause" class="bg-primary hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-all-300">
                            <i class="fa fa-play"></i>
                        </button>
                        <button id="next-frame" class="bg-gray-200 hover:bg-gray-300 text-dark font-medium py-2 px-4 rounded-lg transition-all-300">
                            <i class="fa fa-step-forward"></i>
                        </button>
                    </div>
                    
                    <div class="flex items-center gap-2">
                        <span class="text-sm text-secondary" id="current-frame">帧: 0</span>
                        <span class="text-sm text-secondary" id="current-time">00:00:00</span>
                    </div>
                </div>
                
                <!-- 进度条 -->
                <div class="progress-bar mb-2">
                    <div id="progress-bar-fill" class="progress-bar-fill" style="width: 0%"></div>
                </div>
                <input type="range" id="video-slider" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="100" value="0">
                <!-- 帧预览和导出区域（移动到视频预览下方） -->
                <section id="frames-section" class="mt-6 hidden">
                    <div class="flex flex-wrap items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold">提取的帧</h2>
                        <div class="flex flex-wrap items-center gap-2">
                            <div class="flex items-center gap-2">
                                <label for="export-interval" class="text-sm font-medium text-secondary">导出间隔:</label>
                                <input type="number" id="export-interval" class="w-16 px-2 py-1 border border-gray-300 rounded-md text-center" value="1" min="1">
                                <span class="text-sm text-secondary">帧</span>
                            </div>
                            <button id="export-all-btn" class="bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg transition-all-300 flex items-center">
                                <i class="fa fa-download mr-2"></i> 导出所有帧
                            </button>
                        </div>
                    </div>
                    <div class="mb-3">
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 flex items-start gap-3">
                            <i class="fa fa-info-circle text-blue-500 mt-1"></i>
                            <div>
                                <p class="text-sm text-blue-800">
                                    <strong>预览提示：</strong>如果预览区域出现白屏或显示异常，这可能是由于浏览器内存限制或页面加载问题导致的。
                                    <br>请点击"导出所有帧"按钮下载完整的帧序列，下载后的文件可以正常查看。
                                </p>
                            </div>
                        </div>
                    </div>
                    <div id="frames-container" class="frame-container mb-4"></div>
                    <div id="export-progress" class="hidden">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-secondary">正在导出...</span>
                            <span id="export-status" class="text-sm text-secondary">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div id="export-progress-bar" class="progress-bar-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </section>
            </section>

            </div>
            
            <!-- 视频转GIF工具 -->
            <div id="gif-converter-tool" class="tool-section glass hover:glass-hover rounded-2xl p-6 shadow-lg transition-all duration-300 hover:shadow-xl hidden">
                <section class="mb-8">
                    <h2 class="text-2xl font-bold text-dark mb-6">视频转 GIF 工具</h2>
                    
                    <!-- 上传区域 -->
                    <div id="gif-upload-container" class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center cursor-pointer hover:border-primary hover:bg-blue-50/50 transition-all duration-300 group mb-6">
                        <input type="file" id="gif-video-input" class="hidden" accept="video/*">
                        <div class="mb-6 transform transition-transform duration-300 group-hover:scale-110">
                            <i class="fa fa-cloud-upload text-5xl text-primary"></i>
                        </div>
                        <h3 class="text-xl font-semibold mb-3 text-dark">拖放视频文件到此处或点击上传</h3>
                        <p class="text-secondary mb-6 max-w-md mx-auto">支持 MP4、MOV、WebM 等格式，推荐使用短视频片段</p>
                        <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                            <button id="gif-upload-btn" class="bg-primary hover:bg-blue-600 text-white font-medium py-3 px-8 rounded-lg transition-all duration-300 hover:shadow-lg hover:scale-105 flex items-center">
                                <i class="fa fa-folder-open mr-2"></i> 选择视频文件
                            </button>
                            <button id="use-sample-gif-btn" title="下载后选择本地文件即可测试所有功能" class="bg-accent hover:bg-cyan-600 text-white font-medium py-3 px-8 rounded-lg transition-all duration-300 hover:shadow-lg hover:scale-105 flex items-center">
                                <i class="fa fa-download mr-2"></i> 下载测试视频
                            </button>
                        </div>
                    </div>
                    
                    <!-- 视频预览 -->
                    <div id="gif-preview-section" class="hidden mb-6">
                        <div class="bg-black rounded-lg overflow-hidden mb-4">
                            <video id="gif-video-preview" class="w-full h-auto max-h-[300px] object-contain" controls></video>
                        </div>
                        <div class="text-sm text-secondary">
                            <span id="gif-video-info">视频信息将显示在这里</span>
                        </div>
                    </div>
                    
                    <!-- 设置区域 -->
                    <div id="gif-settings-section" class="hidden">
                        <div class="bg-white rounded-xl p-6 shadow-md mb-6">
                            <h3 class="text-lg font-semibold mb-4">GIF 导出设置</h3>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <!-- 帧率设置 -->
                                <div>
                                    <label for="gif-fps" class="block text-sm font-medium text-secondary mb-2">帧率 (FPS)</label>
                                    <input type="number" id="gif-fps" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="10" min="1" max="30">
                                    <p class="text-xs text-gray-500 mt-1">建议值：5-15（越低文件越小）</p>
                                </div>
                                
                                <!-- 分辨率设置 -->
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="gif-width" class="block text-sm font-medium text-secondary mb-2">宽度 (px)</label>
                                        <input type="number" id="gif-width" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="640" min="160" max="1920" step="8">
                                    </div>
                                    <div>
                                        <label for="gif-height" class="block text-sm font-medium text-secondary mb-2">高度 (px)</label>
                                        <input type="number" id="gif-height" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="360" min="90" max="1080" step="8">
                                    </div>
                                </div>
                                
                                <!-- 裁剪时间设置 -->
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="gif-start-time" class="block text-sm font-medium text-secondary mb-2">开始时间 (秒)</label>
                                        <input type="number" id="gif-start-time" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="0" min="0" step="0.1">
                                    </div>
                                    <div>
                                        <label for="gif-end-time" class="block text-sm font-medium text-secondary mb-2">结束时间 (秒)</label>
                                        <input type="number" id="gif-end-time" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="5" min="0.1" step="0.1">
                                    </div>
                                </div>
                                
                                <!-- 其他设置 -->
                                <div>
                                    <label for="gif-quality" class="block text-sm font-medium text-secondary mb-2">质量</label>
                                    <select id="gif-quality" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                        <option value="high">高质量</option>
                                        <option value="medium" selected>中等质量</option>
                                        <option value="low">低质量（文件更小）</option>
                                    </select>
                                </div>
                                
                                <div>
                                    <label for="gif-loop" class="flex items-center text-sm font-medium text-secondary cursor-pointer">
                                        <input type="checkbox" id="gif-loop" class="mr-2" checked>
                                        循环播放
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 操作按钮 -->
                        <div class="flex flex-wrap gap-4">
                            <button id="generate-gif-btn" class="bg-accent hover:bg-cyan-600 text-white font-medium py-3 px-6 rounded-lg transition-all-300 flex items-center">
                                <i class="fa fa-magic mr-2"></i> 生成 GIF
                            </button>
                            <button id="reset-gif-btn" class="bg-gray-200 hover:bg-gray-300 text-dark font-medium py-3 px-6 rounded-lg transition-all-300">
                                重置
                            </button>
                            <button id="open-overlay-modal-btn" class="bg-white border border-gray-300 text-secondary hover:text-primary font-medium py-2 px-4 rounded-lg transition-all-300 flex items-center">
                                <i class="fa fa-pencil mr-2"></i> 文字
                            </button>
                            <button id="open-ar-modal-btn" class="bg-white border border-gray-300 text-secondary hover:text-primary font-medium py-2 px-4 rounded-lg transition-all-300 flex items-center">
                                <i class="fa fa-magic mr-2"></i> AR
                            </button>
                            <span id="overlay-status" class="self-center text-sm text-secondary">未添加文字</span>
                            <span id="ar-status" class="self-center text-sm text-secondary">未开启AR</span>
                        </div>
                    </div>
                </section>
                
                <!-- 进度区域 -->
                <div id="gif-progress-section" class="hidden mb-6">
                    <div class="bg-white rounded-xl p-6 shadow-md">
                        <h3 class="text-lg font-semibold mb-4">处理进度</h3>
                        
                        <div class="mb-4">
                            <div class="flex justify-between items-center mb-2">
                                <span id="gif-progress-step" class="text-sm font-medium text-secondary">正在加载 FFmpeg...</span>
                                <span id="gif-progress-percentage" class="text-sm font-medium text-primary">0%</span>
                            </div>
                            <div class="progress-bar">
                                <div id="gif-progress-bar" class="progress-bar-fill" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div id="gif-progress-details" class="text-sm text-gray-600">
                            <!-- 进度详情将在这里显示 -->
                        </div>
                    </div>
                </div>
                
                <!-- 结果预览区域 -->
                <div id="gif-result-section" class="hidden mb-6">
                    <div class="bg-white rounded-xl p-6 shadow-md">
                        <h3 class="text-lg font-semibold mb-4">GIF 预览</h3>
                        
                        <div class="flex flex-col items-center mb-6">
                            <div class="mb-3 w-full">
                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 flex items-start gap-3">
                                    <i class="fa fa-info-circle text-blue-500 mt-1"></i>
                                    <div>
                                        <p class="text-sm text-blue-800">
                                            <strong>预览提示：</strong>如果GIF预览出现白屏、卡顿或显示异常，这可能是由于GIF文件较大或浏览器性能限制导致的。
                                            <br>请点击"下载 GIF"按钮获取完整文件，下载后的GIF可以在本地正常查看和使用。
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <div id="gif-preview-container" class="border border-gray-200 rounded-lg p-4 bg-gray-50 mb-4 w-full">
                                <img id="gif-preview" class="max-w-full h-auto max-h-[300px] mx-auto" alt="GIF 预览">
                            </div>
                            <div id="gif-info" class="text-sm text-secondary">
                                <!-- GIF 信息将在这里显示 -->
                            </div>
                        </div>
                        
                        <div class="flex justify-center">
                            <button id="download-gif-btn" class="bg-green-500 hover:bg-green-600 text-white font-medium py-3 px-6 rounded-lg transition-all-300 flex items-center">
                                <i class="fa fa-download mr-2"></i> 下载 GIF
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 视频压缩器 -->
            <div id="video-compressor-tool" class="tool-section glass hover:glass-hover rounded-2xl p-6 shadow-lg transition-all duration-300 hover:shadow-xl hidden">
                <section class="mb-8">
                    <h2 class="text-2xl font-bold text-dark mb-6">视频压缩器</h2>
                    <div id="compress-upload-container" class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center cursor-pointer hover:border-primary hover:bg-blue-50/50 transition-all duration-300 group mb-6">
                        <input type="file" id="compress-video-input" class="hidden" accept="video/*">
                        <div class="mb-6 transform transition-transform duration-300 group-hover:scale-110">
                            <i class="fa fa-cloud-upload text-5xl text-primary"></i>
                        </div>
                        <h3 class="text-xl font-semibold mb-3 text-dark">拖放视频文件到此处或点击上传</h3>
                        <p class="text-secondary mb-6 max-w-md mx-auto">支持 MP4、MOV、WebM 等格式，可大幅减小文件大小</p>
                        <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                            <button id="compress-upload-btn" class="bg-primary hover:bg-blue-600 text-white font-medium py-3 px-8 rounded-lg transition-all duration-300 hover:shadow-lg hover:scale-105 flex items-center">
                                <i class="fa fa-folder-open mr-2"></i> 选择视频文件
                            </button>
                            <button id="use-sample-compressor-btn" title="下载后选择本地文件即可测试所有功能" class="bg-accent hover:bg-cyan-600 text-white font-medium py-3 px-8 rounded-lg transition-all duration-300 hover:shadow-lg hover:scale-105 flex items-center">
                                <i class="fa fa-download mr-2"></i> 下载测试视频
                            </button>
                        </div>
                    </div>
                    <div id="compress-preview-section" class="hidden mb-6">
                        <div class="text-sm text-secondary mb-2">
                            <span>原始文件大小：</span>
                            <span id="compress-original-size">-</span>
                        </div>
                        <div class="bg-black rounded-lg overflow-hidden mb-4">
                            <video id="compress-video-preview" class="w-full h-auto max-h-[300px] object-contain" controls></video>
                        </div>
                    </div>
                    <div id="compress-settings-section" class="hidden">
                        <div class="bg-white rounded-xl p-6 shadow-md mb-6">
                            <h3 class="text-lg font-semibold mb-4">压缩设置</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <label for="compress-format" class="block text-sm font-medium text-secondary mb-2">输出格式</label>
                                    <select id="compress-format" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                        <option value="mp4" selected>mp4</option>
                                        <option value="webm">webm</option>
                                    </select>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="compress-width" class="block text-sm font-medium text-secondary mb-2">宽度</label>
                                        <input type="number" id="compress-width" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="640" min="16">
                                    </div>
                                    <div>
                                        <label for="compress-height" class="block text-sm font-medium text-secondary mb-2">高度</label>
                                        <input type="number" id="compress-height" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="360" min="16">
                                    </div>
                                </div>
                                <div>
                                    <label for="compress-bitrate" class="block text-sm font-medium text-secondary mb-2">码率</label>
                                    <input type="text" id="compress-bitrate" class="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="例如 1000k 或 1M" value="1000k">
                                </div>
                                <div>
                                    <label for="compress-fps" class="block text-sm font-medium text-secondary mb-2">帧率 (可选)</label>
                                    <input type="number" id="compress-fps" class="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="例如 24" min="1">
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="compress-start-time" class="block text-sm font-medium text-secondary mb-2">起始时间 (秒)</label>
                                        <input type="number" id="compress-start-time" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="0" min="0" step="0.1">
                                    </div>
                                    <div>
                                        <label for="compress-end-time" class="block text-sm font-medium text-secondary mb-2">结束时间 (秒)</label>
                                        <input type="number" id="compress-end-time" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="5" min="0.1" step="0.1">
                                    </div>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-4 mt-4">
                                <button id="compress-btn" class="bg-accent hover:bg-cyan-600 text-white font-medium py-3 px-6 rounded-lg transition-all-300 flex items-center">
                                    <i class="fa fa-compress mr-2"></i> 开始压缩
                                </button>
                                <button id="reset-compressor-btn" class="bg-gray-200 hover:bg-gray-300 text-dark font-medium py-3 px-6 rounded-lg transition-all-300">重置</button>
                            </div>
                        </div>
                    </div>
                    <div id="compress-progress-section" class="hidden mb-6">
                        <div class="bg-white rounded-xl p-6 shadow-md">
                            <h3 class="text-lg font-semibold mb-4">处理进度</h3>
                            <div class="mb-4">
                                <div class="flex justify-between items-center mb-2">
                                    <span id="compress-progress-step" class="text-sm font-medium text-secondary">准备压缩...</span>
                                    <span id="compress-progress-percentage" class="text-sm font-medium text-primary">0%</span>
                                </div>
                                <div class="progress-bar">
                                    <div id="compress-progress-bar" class="progress-bar-fill" style="width: 0%"></div>
                                </div>
                            </div>
                            <div id="compress-progress-details" class="text-sm text-gray-600"></div>
                        </div>
                    </div>
                    <div id="compress-result-section" class="hidden mb-6">
                        <div class="bg-white rounded-xl p-6 shadow-md">
                            <h3 class="text-lg font-semibold mb-4">压缩结果</h3>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                                <div>
                                    <div class="text-sm text-secondary">压缩前文件大小</div>
                                    <div id="compress-result-original" class="text-lg font-medium">-</div>
                                </div>
                                <div>
                                    <div class="text-sm text-secondary">压缩后文件大小</div>
                                    <div id="compress-result-output" class="text-lg font-medium">-</div>
                                </div>
                                <div>
                                    <div class="text-sm text-secondary">压缩比例</div>
                                    <div id="compress-result-ratio" class="text-lg font-medium">-</div>
                                </div>
                            </div>
                            <div class="bg-black rounded-lg overflow-hidden mb-4">
                                <video id="compressed-video-preview" class="w-full h-auto max-h-[300px] object-contain" controls></video>
                            </div>
                            <div class="flex justify-center">
                                <button id="download-compressed-btn" class="bg-green-500 hover:bg-green-600 text-white font-medium py-3 px-6 rounded-lg transition-all-300 flex items-center">
                                    <i class="fa fa-download mr-2"></i> 下载压缩后视频
                                </button>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </main>

        <!-- 底部信息 -->
        <footer class="text-center mt-8 text-secondary text-sm">
            <p>视频处理工具集 &copy; 2025 | 在浏览器中处理视频，无需安装额外软件</p>
        </footer>
    </div>
    <div id="text-overlay-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-lg w-full">
            <h3 class="text-xl font-semibold mb-4">文字设置</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-text">文字内容</label>
                    <input id="overlay-text" type="text" class="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="输入文字">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-color">文字颜色</label>
                    <input id="overlay-color" type="color" class="w-full h-10 border border-gray-300 rounded-lg" value="#ffffff">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-font">字体</label>
                    <select id="overlay-font" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                        <option value="Microsoft YaHei, Arial, sans-serif">微软雅黑</option>
                        <option value="SimHei, Arial, sans-serif">黑体</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Inter, system-ui, sans-serif">Inter</option>
                        <option value="Roboto, Arial, sans-serif">Roboto</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-size">字号</label>
                    <input id="overlay-size" type="number" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="32" min="8" max="128">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-stroke-width">描边粗细</label>
                    <input id="overlay-stroke-width" type="number" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="0" min="0" max="10">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-stroke-color">描边颜色</label>
                    <input id="overlay-stroke-color" type="color" class="w-full h-10 border border-gray-300 rounded-lg" value="#000000">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-shadow-blur">阴影模糊</label>
                    <input id="overlay-shadow-blur" type="number" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="0" min="0" max="20">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-shadow-color">阴影颜色</label>
                    <input id="overlay-shadow-color" type="text" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="rgba(0,0,0,0.5)">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-jitter-amplitude">抖动幅度(px)</label>
                    <input id="overlay-jitter-amplitude" type="number" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="0" min="0" max="20">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-jitter-frequency">抖动频率(Hz)</label>
                    <input id="overlay-jitter-frequency" type="number" class="w-full px-3 py-2 border border-gray-300 rounded-lg" value="0" min="0" max="10" step="0.5">
                </div>
                <div>
                    <label class="block text-sm text-secondary mb-1" for="overlay-position">位置</label>
                    <select id="overlay-position" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                        <option value="bottom">底部居中</option>
                        <option value="top">顶部居中</option>
                        <option value="center">居中</option>
                        <option value="bottom-left">左下角</option>
                        <option value="bottom-right">右下角</option>
                        <option value="top-left">左上角</option>
                        <option value="top-right">右上角</option>
                    </select>
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="overlay-cancel-btn" class="bg-gray-200 hover:bg-gray-300 text-dark font-medium py-2 px-4 rounded-lg">取消</button>
                <button id="overlay-save-btn" class="bg-primary hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg">应用</button>
            </div>
        </div>
    </div>
    <div id="ar-effect-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-lg w-full">
            <h3 class="text-xl font-semibold mb-4">选择 AR 效果</h3>
            <div class="grid grid-cols-3 gap-4 mb-4">
                <label class="flex items-center gap-2 border rounded-lg p-3 cursor-pointer">
                    <input id="ar-type-none" type="radio" name="ar-type" checked>
                    <span>无</span>
                </label>
                <label class="flex items-center gap-2 border rounded-lg p-3 cursor-pointer">
                    <input id="ar-type-confetti" type="radio" name="ar-type">
                    <span>彩屑</span>
                </label>
                <label class="flex items-center gap-2 border rounded-lg p-3 cursor-pointer">
                    <input id="ar-type-snow" type="radio" name="ar-type">
                    <span>飘雪</span>
                </label>
                <label class="flex items-center gap-2 border rounded-lg p-3 cursor-pointer">
                    <input id="ar-type-bubbles" type="radio" name="ar-type">
                    <span>气泡</span>
                </label>
            </div>
            <div class="mb-4">
                <label class="block text-sm text-secondary mb-1" for="ar-intensity">强度</label>
                <select id="ar-intensity" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                    <option value="low">低</option>
                    <option value="medium" selected>中</option>
                    <option value="high">高</option>
                </select>
            </div>
            <div class="flex justify-end gap-3">
                <button id="ar-cancel-btn" class="bg-gray-200 hover:bg-gray-300 text-dark font-medium py-2 px-4 rounded-lg">取消</button>
                <button id="ar-apply-btn" class="bg-primary hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg">确定</button>
            </div>
        </div>
    </div>

    <!-- 加载中弹窗 -->
    <div id="loading-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full text-center">
            <div class="animate-pulse-slow mb-4">
                <i class="fa fa-spinner fa-spin text-4xl text-primary"></i>
            </div>
            <h3 class="text-xl font-semibold mb-2" id="loading-title">正在处理</h3>
            <p class="text-secondary" id="loading-message">请稍候...</p>
        </div>
    </div>

    <script>
        // 全局变量
        let videoFile = null;
        let videoElement = null;
        let canvas = null;
        let ctx = null;
        let frames = [];
        let currentFrame = 0;
        let isPlaying = false;
        let frameInterval = null;
        let ffmpeg = null;
        let videoDuration = 0;
        let videoFPS = 0;
        let totalFrames = 0;
        
        // GIF转换器变量
        let gifVideoFile = null;
        let gifVideoElement = null;
        let gifFfmpeg = null;
        let gifResult = null;
        let isConverting = false;
        let gifWorkerUrl = null;
        let textOverlay = {
            enabled: false,
            text: '',
            color: '#ffffff',
            fontFamily: 'Microsoft YaHei, Arial, sans-serif',
            fontSize: 32,
            strokeWidth: 0,
            strokeColor: '#000000',
            shadowBlur: 0,
            shadowColor: 'rgba(0,0,0,0.5)',
            jitterAmplitude: 0,
            jitterFrequency: 0,
            position: 'bottom'
        };
        let arOverlay = {
            enabled: false,
            type: 'none',
            intensity: 'medium'
        };

        const SAMPLE_VIDEO_URL = 'https://doubao-video.oss-cn-shanghai.aliyuncs.com/testvideo.mp4';

        // DOM 元素
        const uploadContainer = document.getElementById('upload-container');
        const videoInput = document.getElementById('video-input');
        const uploadBtn = document.getElementById('upload-btn');
        const videoInfo = document.getElementById('video-info');
        const videoFilename = document.getElementById('video-filename');
        const videoDetails = document.getElementById('video-details');
        const extractBtn = document.getElementById('extract-btn');
        const previewSection = document.getElementById('preview-section');
        const videoPreview = document.getElementById('video-preview');
        const prevFrameBtn = document.getElementById('prev-frame');
        const playPauseBtn = document.getElementById('play-pause');
        const nextFrameBtn = document.getElementById('next-frame');
        const currentFrameDisplay = document.getElementById('current-frame');
        const currentTimeDisplay = document.getElementById('current-time');
        const progressBarFill = document.getElementById('progress-bar-fill');
        const videoSlider = document.getElementById('video-slider');
        const framesSection = document.getElementById('frames-section');
        const framesContainer = document.getElementById('frames-container');
        const exportInterval = document.getElementById('export-interval');
        const exportAllBtn = document.getElementById('export-all-btn');
        const exportProgress = document.getElementById('export-progress');
        const exportStatus = document.getElementById('export-status');
        const exportProgressBar = document.getElementById('export-progress-bar');
        const loadingModal = document.getElementById('loading-modal');
        const loadingTitle = document.getElementById('loading-title');
        const loadingMessage = document.getElementById('loading-message');

        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化 Canvas
            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');
            
            // 初始化GIF转换器
            initGifConverter();
            prepareGifWorker();
            
            // 事件监听
            setupEventListeners();
        });

        // 初始化 FFmpeg.wasm
        async function initFFmpeg() {
            try {
                ffmpeg = createFFmpeg({
                    log: true,
                    corePath: 'https://cdn.jsdelivr.net/npm/ffmpeg.wasm@0.11.0/dist/ffmpeg-core.js'
                });
                
                showLoading('正在加载FFmpeg', '请稍候，正在准备视频处理环境...');
                await ffmpeg.load();
                hideLoading();
                updateCompressorFormatOptions();
            } catch (error) {
                console.error('FFmpeg初始化失败:', error);
                hideLoading();
            }
        }

        function updateCompressorFormatOptions() {
            const formatSelect = document.getElementById('compress-format');
            if (!formatSelect) return;
            const mp4Option = Array.from(formatSelect.options).find(o => o.value === 'mp4');
            if (!mp4Option) return;
            mp4Option.disabled = false;
        }

        function setupCompressorEventListeners() {
            const uploadBtn = document.getElementById('compress-upload-btn');
            const videoInput = document.getElementById('compress-video-input');
            const uploadContainer = document.getElementById('compress-upload-container');
            const videoPreview = document.getElementById('compress-video-preview');
            const compressBtn = document.getElementById('compress-btn');
            const resetBtn = document.getElementById('reset-compressor-btn');
            const downloadBtn = document.getElementById('download-compressed-btn');
            const startTimeInput = document.getElementById('compress-start-time');
            const endTimeInput = document.getElementById('compress-end-time');
            const useSampleCompressorBtn = document.getElementById('use-sample-compressor-btn');
            updateCompressorFormatOptions();

            uploadBtn.addEventListener('click', () => videoInput.click());
            videoInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    compressVideoFile = e.target.files[0];
                    processCompressorVideoFile();
                }
            });
            uploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadContainer.classList.add('border-primary');
            });
            uploadContainer.addEventListener('dragleave', () => {
                uploadContainer.classList.remove('border-primary');
            });
            uploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadContainer.classList.remove('border-primary');
                if (e.dataTransfer.files.length > 0 && e.dataTransfer.files[0].type.startsWith('video/')) {
                    compressVideoFile = e.dataTransfer.files[0];
                    processCompressorVideoFile();
                } else {
                    alert('请上传有效的视频文件');
                }
            });
            videoPreview.addEventListener('loadedmetadata', handleCompressorLoaded);
            compressBtn.addEventListener('click', startCompression);
            resetBtn.addEventListener('click', resetCompressor);
            downloadBtn.addEventListener('click', downloadCompressed);
            if (useSampleCompressorBtn) {
                useSampleCompressorBtn.addEventListener('click', downloadSampleVideo);
            }

            startTimeInput.addEventListener('input', () => {
                if (compressVideoElement) {
                    const start = parseFloat(startTimeInput.value) || 0;
                    endTimeInput.min = (start + 0.1).toString();
                    if (parseFloat(endTimeInput.value) <= start) {
                        endTimeInput.value = Math.min(start + 5, compressVideoElement.duration).toString();
                    }
                }
            });
        }

        let compressVideoFile = null;
        let compressedResult = null;
        let compressVideoElement = null;

        function processCompressorVideoFile() {
            if (!compressVideoFile) return;
            const previewSection = document.getElementById('compress-preview-section');
            const settingsSection = document.getElementById('compress-settings-section');
            const videoPreview = document.getElementById('compress-video-preview');
            const originalSize = document.getElementById('compress-original-size');
            originalSize.textContent = formatFileSize(compressVideoFile.size);
            const url = URL.createObjectURL(compressVideoFile);
            videoPreview.src = url;
            previewSection.classList.remove('hidden');
            settingsSection.classList.remove('hidden');
        }

        function handleCompressorLoaded() {
            compressVideoElement = document.getElementById('compress-video-preview');
            const duration = compressVideoElement.duration;
            document.getElementById('compress-end-time').value = Math.max(0.1, duration).toFixed(1);
            document.getElementById('compress-end-time').max = duration;
            document.getElementById('compress-start-time').max = Math.max(0, duration - 0.1);
        }

        function updateCompressProgress(step, percentage) {
            const stepEl = document.getElementById('compress-progress-step');
            const percentEl = document.getElementById('compress-progress-percentage');
            const barEl = document.getElementById('compress-progress-bar');
            const detailsEl = document.getElementById('compress-progress-details');
            stepEl.textContent = step;
            percentEl.textContent = `${percentage}%`;
            barEl.style.width = `${percentage}%`;
            const ts = new Date().toLocaleTimeString();
            const item = document.createElement('div');
            item.className = 'text-xs';
            item.textContent = `[${ts}] ${step} - ${percentage}%`;
            detailsEl.appendChild(item);
            detailsEl.scrollTop = detailsEl.scrollHeight;
        }

        async function startCompression() {
            if (!compressVideoFile) return;
            const format = document.getElementById('compress-format').value;
            const width = parseInt(document.getElementById('compress-width').value);
            const height = parseInt(document.getElementById('compress-height').value);
            const bitrate = document.getElementById('compress-bitrate').value.trim();
            const fpsVal = document.getElementById('compress-fps').value.trim();
            const startSec = parseFloat(document.getElementById('compress-start-time').value) || 0;
            const endSec = parseFloat(document.getElementById('compress-end-time').value);
            const progressSection = document.getElementById('compress-progress-section');
            const resultSection = document.getElementById('compress-result-section');
            if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) { alert('请输入有效的分辨率'); return; }
            if (!bitrate) { alert('请输入码率，如 1000k 或 1M'); return; }
            if (isNaN(endSec) || endSec <= startSec) { alert('请填写有效的起始/结束时间'); return; }
            if (!ffmpeg || !ffmpeg.isLoaded()) { await initFFmpeg(); }
            resultSection.classList.add('hidden');
            progressSection.classList.remove('hidden');
            updateCompressProgress('正在准备', 0);
            const hasLocalBlob = (compressVideoFile instanceof File) || (compressVideoFile instanceof Blob);
            if (!ffmpeg || !ffmpeg.isLoaded() || !hasLocalBlob || (format === 'mp4' && (!ffmpeg || !ffmpeg.isLoaded()))) {
                await browserCompressFallback({ format, width, height, bitrate, fpsVal, startSec, endSec });
                return;
            }
            ffmpeg.setProgress(({ ratio }) => {
                const p = Math.min(100, Math.max(0, Math.round(ratio * 100)));
                updateCompressProgress('正在压缩', p);
            });
            try {
                const ext = (compressVideoFile.name.split('.').pop() || 'mp4').toLowerCase();
                const inputName = `input.${ext}`;
                const outputName = format === 'mp4' ? 'output.mp4' : 'output.webm';
                ffmpeg.FS('writeFile', inputName, await fetchFile(compressVideoFile));
                const args = ['-i', inputName];
                if (!isNaN(startSec) && startSec > 0) { args.push('-ss', `${startSec}`); }
                if (!isNaN(endSec)) { args.push('-to', `${endSec}`); }
                args.push('-vf', `scale=${width}:${height}`);
                if (fpsVal) { args.push('-r', `${parseInt(fpsVal)}`); }
                args.push('-b:v', bitrate);
                if (format === 'mp4') {
                    args.push('-c:v', 'mpeg4');
                    args.push('-movflags', 'faststart');
                } else {
                    args.push('-c:v', 'libvpx-vp9');
                }
                args.push('-an');
                args.push(outputName);
                updateCompressProgress('开始执行', 1);
                await ffmpeg.run(...args);
                updateCompressProgress('生成文件', 95);
                const data = ffmpeg.FS('readFile', outputName);
                const blob = new Blob([data.buffer], { type: format === 'mp4' ? 'video/mp4' : 'video/webm' });
                const url = URL.createObjectURL(blob);
            const beforeSize = compressVideoFile && typeof compressVideoFile.size === 'number' ? compressVideoFile.size : 0;
            const afterSize = data.length;
            const ratio = beforeSize > 0 ? (afterSize / beforeSize) : 0;
            compressedResult = { blob, url, format, beforeSize, afterSize, ratio };
            showCompressResult();
            updateCompressProgress('完成', 100);
            } catch (error) {
                await browserCompressFallback({ format, width, height, bitrate, fpsVal, startSec, endSec });
            }
        }

        function parseBitrateToBps(val) {
            const s = (val || '').toLowerCase().trim();
            if (!s) return undefined;
            if (s.endsWith('k')) return Math.max(1, Math.round(parseFloat(s) * 1000));
            if (s.endsWith('m')) return Math.max(1, Math.round(parseFloat(s) * 1000000));
            const n = parseInt(s);
            return isNaN(n) ? undefined : Math.max(1, n);
        }

        async function browserCompressFallback({ format, width, height, bitrate, fpsVal, startSec, endSec }) {
            const previewSection = document.getElementById('compress-preview-section');
            const resultSection = document.getElementById('compress-result-section');
            const progressSection = document.getElementById('compress-progress-section');
            const previewVideo = document.getElementById('compress-video-preview');
            const fps = fpsVal ? Math.max(1, parseInt(fpsVal)) : 25;
            const bps = parseBitrateToBps(bitrate) || 800000;
            const canvasEl = document.createElement('canvas');
            canvasEl.width = width;
            canvasEl.height = height;
            const cctx = canvasEl.getContext('2d');
            const drawIntervalMs = Math.max(10, Math.round(1000 / fps));
            const stream = canvasEl.captureStream(fps);
            let outFormat = 'webm';
            let mime = 'video/webm;codecs=vp9';
            if (format === 'mp4') {
                if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')) {
                    mime = 'video/mp4;codecs=avc1';
                    outFormat = 'mp4';
                } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                    mime = 'video/mp4';
                    outFormat = 'mp4';
                } else {
                    showToast('浏览器不支持MP4录制，已输出WebM');
                    if (!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm;codecs=vp8';
                    outFormat = 'webm';
                }
            } else {
                if (!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm;codecs=vp8';
            }
            const recorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: bps });
            const chunks = [];
            recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };
            const durationMs = Math.max(100, Math.round((endSec - startSec) * 1000));
            let elapsedMs = 0;
            let drawTimer = null;
            const startTime = Date.now();
            updateCompressProgress('正在录制', 1);
            previewVideo.pause();
            previewVideo.currentTime = startSec;
            await new Promise((resolve) => {
                const check = () => { if (Math.abs(previewVideo.currentTime - startSec) < 0.05) resolve(); else requestAnimationFrame(check); };
                check();
            });
            previewVideo.play();
            drawTimer = setInterval(() => {
                try { cctx.drawImage(previewVideo, 0, 0, width, height); } catch (_) {}
                elapsedMs = Date.now() - startTime;
                const p = Math.min(100, Math.max(1, Math.round((elapsedMs / durationMs) * 100)));
                updateCompressProgress('正在压缩', p);
            }, drawIntervalMs);
            recorder.start();
            await new Promise((resolve) => setTimeout(resolve, durationMs));
            recorder.stop();
            previewVideo.pause();
            clearInterval(drawTimer);
            await new Promise((resolve) => { recorder.onstop = resolve; });
            const containerType = outFormat === 'mp4' ? 'video/mp4' : 'video/webm';
            const blob = new Blob(chunks, { type: containerType });
            const url = URL.createObjectURL(blob);
            const beforeSize = compressVideoFile && typeof compressVideoFile.size === 'number' ? compressVideoFile.size : 0;
            const afterSize = blob.size;
            const ratio = beforeSize > 0 ? (afterSize / beforeSize) : 0;
            compressedResult = { blob, url, format: outFormat, beforeSize, afterSize, ratio };
            showCompressResult();
            progressSection.classList.remove('hidden');
            resultSection.classList.remove('hidden');
            updateCompressProgress('完成', 100);
        }

        function showCompressResult() {
            if (!compressedResult) return;
            const resultSection = document.getElementById('compress-result-section');
            const originalEl = document.getElementById('compress-result-original');
            const outputEl = document.getElementById('compress-result-output');
            const ratioEl = document.getElementById('compress-result-ratio');
            const preview = document.getElementById('compressed-video-preview');
            originalEl.textContent = formatFileSize(compressedResult.beforeSize);
            outputEl.textContent = formatFileSize(compressedResult.afterSize);
            ratioEl.textContent = `${(compressedResult.ratio * 100).toFixed(1)}%`;
            preview.src = compressedResult.url;
            resultSection.classList.remove('hidden');
        }

        function downloadCompressed() {
            if (!compressedResult) return;
            const filename = `compressed_${new Date().getTime()}.${compressedResult.format}`;
            saveAs(compressedResult.blob, filename);
        }

        function resetCompressor() {
            compressVideoFile = null;
            compressedResult = null;
            document.getElementById('compress-video-input').value = '';
            document.getElementById('compress-video-preview').src = '';
            document.getElementById('compressed-video-preview').src = '';
            document.getElementById('compress-preview-section').classList.add('hidden');
            document.getElementById('compress-settings-section').classList.add('hidden');
            document.getElementById('compress-progress-section').classList.add('hidden');
            document.getElementById('compress-result-section').classList.add('hidden');
            document.getElementById('compress-progress-details').innerHTML = '';
        }
        
        // 初始化GIF转换器
        function initGifConverter() {
            // 初始化GIF相关的FFmpeg实例
            gifFfmpeg = null;
        }

        async function prepareGifWorker() {
            try {
                const res = await fetch('https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js');
                const code = await res.text();
                const blob = new Blob([code], { type: 'application/javascript' });
                gifWorkerUrl = URL.createObjectURL(blob);
            } catch (_) {
                gifWorkerUrl = null;
            }
        }
        
        // 设置GIF转换器事件监听
        function setupGifConverterEventListeners() {
            const gifUploadBtn = document.getElementById('gif-upload-btn');
            const gifVideoInput = document.getElementById('gif-video-input');
            const gifUploadContainer = document.getElementById('gif-upload-container');
            const gifVideoPreview = document.getElementById('gif-video-preview');
            const generateGifBtn = document.getElementById('generate-gif-btn');
            const resetGifBtn = document.getElementById('reset-gif-btn');
            const downloadGifBtn = document.getElementById('download-gif-btn');
            const openOverlayModalBtn = document.getElementById('open-overlay-modal-btn');
            const openArModalBtn = document.getElementById('open-ar-modal-btn');
            const overlayModal = document.getElementById('text-overlay-modal');
            const arModal = document.getElementById('ar-effect-modal');
            const overlaySaveBtn = document.getElementById('overlay-save-btn');
            const overlayCancelBtn = document.getElementById('overlay-cancel-btn');
            const overlayStatus = document.getElementById('overlay-status');
            const arStatus = document.getElementById('ar-status');
            const overlayText = document.getElementById('overlay-text');
            const overlayColor = document.getElementById('overlay-color');
            const overlayFont = document.getElementById('overlay-font');
            const overlaySize = document.getElementById('overlay-size');
            const overlayStrokeWidth = document.getElementById('overlay-stroke-width');
            const overlayStrokeColor = document.getElementById('overlay-stroke-color');
            const overlayShadowBlur = document.getElementById('overlay-shadow-blur');
            const overlayShadowColor = document.getElementById('overlay-shadow-color');
            const overlayJitterAmplitude = document.getElementById('overlay-jitter-amplitude');
            const overlayJitterFrequency = document.getElementById('overlay-jitter-frequency');
            const overlayPosition = document.getElementById('overlay-position');
            const arTypeNone = document.getElementById('ar-type-none');
            const arTypeConfetti = document.getElementById('ar-type-confetti');
            const arTypeSnow = document.getElementById('ar-type-snow');
            const arTypeBubbles = document.getElementById('ar-type-bubbles');
            const arIntensity = document.getElementById('ar-intensity');
            const arApplyBtn = document.getElementById('ar-apply-btn');
            const arCancelBtn = document.getElementById('ar-cancel-btn');
            const useSampleGifBtn = document.getElementById('use-sample-gif-btn');
            
            // 上传按钮点击
            gifUploadBtn.addEventListener('click', () => gifVideoInput.click());
            
            // 文件选择
            gifVideoInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    gifVideoFile = e.target.files[0];
                    processGifVideoFile();
                }
            });
            
            // 拖放上传
            gifUploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                gifUploadContainer.classList.add('border-primary');
            });
            
            gifUploadContainer.addEventListener('dragleave', () => {
                gifUploadContainer.classList.remove('border-primary');
            });
            
            gifUploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                gifUploadContainer.classList.remove('border-primary');
                
                if (e.dataTransfer.files.length > 0 && e.dataTransfer.files[0].type.startsWith('video/')) {
                    gifVideoFile = e.dataTransfer.files[0];
                    processGifVideoFile();
                } else {
                    alert('请上传有效的视频文件');
                }
            });
            
            // 视频加载完成事件
            gifVideoPreview.addEventListener('loadedmetadata', handleGifVideoLoaded);
            
            // 生成GIF按钮
            generateGifBtn.addEventListener('click', generateGif);
            
            // 重置按钮
            resetGifBtn.addEventListener('click', resetGifConverter);
            
            // 下载按钮
            downloadGifBtn.addEventListener('click', downloadGif);
            if (useSampleGifBtn) {
                useSampleGifBtn.addEventListener('click', downloadSampleVideo);
            }

            openOverlayModalBtn.addEventListener('click', () => {
                overlayText.value = textOverlay.text || '';
                overlayColor.value = textOverlay.color || '#ffffff';
                overlayFont.value = textOverlay.fontFamily || 'Microsoft YaHei, Arial, sans-serif';
                overlaySize.value = textOverlay.fontSize || 32;
                overlayStrokeWidth.value = textOverlay.strokeWidth || 0;
                overlayStrokeColor.value = textOverlay.strokeColor || '#000000';
                overlayShadowBlur.value = textOverlay.shadowBlur || 0;
                overlayShadowColor.value = textOverlay.shadowColor || 'rgba(0,0,0,0.5)';
                overlayJitterAmplitude.value = textOverlay.jitterAmplitude || 0;
                overlayJitterFrequency.value = textOverlay.jitterFrequency || 0;
                overlayPosition.value = textOverlay.position || 'bottom';
                overlayModal.classList.remove('hidden');
            });

            overlaySaveBtn.addEventListener('click', () => {
                textOverlay = {
                    enabled: !!overlayText.value.trim(),
                    text: overlayText.value.trim(),
                    color: overlayColor.value,
                    fontFamily: overlayFont.value,
                    fontSize: parseInt(overlaySize.value) || 32,
                    strokeWidth: parseInt(overlayStrokeWidth.value) || 0,
                    strokeColor: overlayStrokeColor.value,
                    shadowBlur: parseInt(overlayShadowBlur.value) || 0,
                    shadowColor: overlayShadowColor.value,
                    jitterAmplitude: parseFloat(overlayJitterAmplitude.value) || 0,
                    jitterFrequency: parseFloat(overlayJitterFrequency.value) || 0,
                    position: overlayPosition.value || 'bottom'
                };
                overlayStatus.textContent = textOverlay.enabled ? '已添加文字' : '未添加文字';
                overlayModal.classList.add('hidden');
            });

            overlayCancelBtn.addEventListener('click', () => {
                overlayModal.classList.add('hidden');
            });

            openArModalBtn.addEventListener('click', () => {
                arModal.classList.remove('hidden');
                if (arOverlay.type === 'confetti') arTypeConfetti.checked = true;
                else if (arOverlay.type === 'snow') arTypeSnow.checked = true;
                else if (arOverlay.type === 'bubbles') arTypeBubbles.checked = true;
                else arTypeNone.checked = true;
                arIntensity.value = arOverlay.intensity || 'medium';
            });

            arApplyBtn.addEventListener('click', () => {
                const type = arTypeConfetti.checked ? 'confetti' : arTypeSnow.checked ? 'snow' : arTypeBubbles.checked ? 'bubbles' : 'none';
                const intensity = arIntensity.value;
                arOverlay = { enabled: type !== 'none', type, intensity };
                arStatus.textContent = arOverlay.enabled ? `AR: ${type}` : '未开启AR';
                arModal.classList.add('hidden');
            });

            arCancelBtn.addEventListener('click', () => {
                arModal.classList.add('hidden');
            });
            
            // 实时更新结束时间的最大值
            const gifStartTime = document.getElementById('gif-start-time');
            const gifEndTime = document.getElementById('gif-end-time');
            
            gifStartTime.addEventListener('input', () => {
                if (gifVideoElement) {
                    const startTime = parseFloat(gifStartTime.value) || 0;
                    gifEndTime.min = (startTime + 0.1).toString();
                    if (parseFloat(gifEndTime.value) <= startTime) {
                        gifEndTime.value = Math.min(startTime + 5, gifVideoElement.duration).toString();
                    }
                }
            });
        }
        
        // 处理GIF视频文件
        function processGifVideoFile() {
            if (!gifVideoFile) return;
            
            const gifPreviewSection = document.getElementById('gif-preview-section');
            const gifSettingsSection = document.getElementById('gif-settings-section');
            const gifVideoInfo = document.getElementById('gif-video-info');
            const gifVideoPreview = document.getElementById('gif-video-preview');
            
            // 显示视频信息
            gifVideoInfo.textContent = `${gifVideoFile.name} (${formatFileSize(gifVideoFile.size)})`;
            
            // 创建视频URL并设置到预览元素
            const videoURL = URL.createObjectURL(gifVideoFile);
            gifVideoPreview.src = videoURL;
            
            // 显示预览区域和设置区域
            gifPreviewSection.classList.remove('hidden');
            gifSettingsSection.classList.remove('hidden');
        }
        
        // 处理GIF视频加载完成
        function handleGifVideoLoaded() {
            gifVideoElement = document.getElementById('gif-video-preview');
            const duration = gifVideoElement.duration;
            const width = gifVideoElement.videoWidth;
            const height = gifVideoElement.videoHeight;
            
            // 更新视频信息
            const gifVideoInfo = document.getElementById('gif-video-info');
            gifVideoInfo.textContent = `${gifVideoFile.name} | ${width}x${height} | ${formatTime(duration)} | ${formatFileSize(gifVideoFile.size)}`;
            
            // 更新设置默认值
            document.getElementById('gif-width').value = Math.min(640, width);
            document.getElementById('gif-height').value = Math.round(Math.min(640, width) * (height / width));
            document.getElementById('gif-end-time').value = Math.max(0.1, duration).toFixed(1);
            document.getElementById('gif-end-time').max = duration;
            document.getElementById('gif-start-time').max = Math.max(0, duration - 0.1);
        }
        
        // 生成GIF
        async function generateGif() {
            if (!gifVideoFile || !gifVideoElement || isConverting) return;
            
            isConverting = true;
            
            // 获取设置值
            const fps = parseInt(document.getElementById('gif-fps').value) || 10;
            const width = parseInt(document.getElementById('gif-width').value) || 640;
            const height = parseInt(document.getElementById('gif-height').value) || 360;
            const startTime = parseFloat(document.getElementById('gif-start-time').value) || 0;
            const endTime = parseFloat(document.getElementById('gif-end-time').value) || 5;
            const quality = document.getElementById('gif-quality').value;
            const loop = document.getElementById('gif-loop').checked;
            
            // 验证设置
            if (startTime >= endTime) {
                alert('开始时间必须小于结束时间');
                isConverting = false;
                return;
            }
            
            if (endTime > gifVideoElement.duration) {
                alert('结束时间不能超过视频时长');
                isConverting = false;
                return;
            }
            
            // 显示进度区域
            const gifProgressSection = document.getElementById('gif-progress-section');
            const gifResultSection = document.getElementById('gif-result-section');
            const gifProgressDetails = document.getElementById('gif-progress-details');
            
            // 清空之前的进度详情
            gifProgressDetails.innerHTML = '';
            
            gifProgressSection.classList.remove('hidden');
            gifResultSection.classList.add('hidden');
            
            try {
                updateGifProgress('准备生成', 5);
                await generateGifWithCanvas(fps, width, height, startTime, endTime, quality, loop);
            } catch (error) {
                console.error('生成GIF失败:', error);
                
                // 显示详细错误信息
                const errorDiv = document.createElement('div');
                errorDiv.className = 'text-xs p-2 bg-red-50 text-red-700 rounded';
                errorDiv.innerHTML = `
                    <div class="font-medium">错误详情:</div>
                    <div>${error.message}</div>
                    <div class="mt-1">请检查浏览器控制台获取更多信息</div>
                `;
                gifProgressDetails.appendChild(errorDiv);
                
                alert('生成GIF失败，请查看进度区域的详细错误信息');
                updateGifProgress('处理失败', 0);
            } finally {
                isConverting = false;
                
                // 不自动隐藏进度条，让用户可以查看详细信息
                // setTimeout(() => {
                //     const gifProgressSection = document.getElementById('gif-progress-section');
                //     gifProgressSection.classList.add('hidden');
                // }, 1000);
            }
        }
        
        // 获取浏览器名称
        function getBrowserName() {
            const userAgent = navigator.userAgent.toLowerCase();
            if (userAgent.includes('chrome') && !userAgent.includes('edge')) {
                return 'Chrome';
            } else if (userAgent.includes('firefox')) {
                return 'Firefox';
            } else if (userAgent.includes('edge')) {
                return 'Edge';
            } else if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
                return 'Safari';
            } else {
                return '其他浏览器';
            }
        }
        
        // 使用FFmpeg生成GIF
        async function generateGifWithFFmpeg(fps, width, height, startTime, endTime, quality, loop) {
            // 初始化FFmpeg
            await initGifFFmpeg();
            
            // 更新进度
            updateGifProgress('正在解析视频', 10);
            
            // 写入视频文件到FFmpeg虚拟文件系统
            const videoData = await gifVideoFile.arrayBuffer();
            gifFfmpeg.FS('writeFile', 'input.mp4', new Uint8Array(videoData));
            
            updateGifProgress('正在处理视频', 30);
            
            // 根据质量设置滤镜
            let filters = [];
            let palettegenFilters = [];
            
            switch (quality) {
                case 'high':
                    filters.push(`fps=${fps},scale=${width}:${height}:flags=lanczos`);
                    palettegenFilters.push('fps=25');
                    break;
                case 'medium':
                    filters.push(`fps=${fps},scale=${width}:${height}:flags=bilinear`);
                    palettegenFilters.push('fps=15');
                    break;
                case 'low':
                    filters.push(`fps=${fps},scale=${width}:${height}:flags=fast_bilinear,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`);
                    break;
            }
            
            // 构建FFmpeg命令
            const ffmpegArgs = [
                '-ss', startTime.toString(),
                '-to', endTime.toString(),
                '-i', 'input.mp4'
            ];
            
            if (quality !== 'low') {
                // 先生成调色板
                updateGifProgress('正在生成调色板', 50);
                
                await gifFfmpeg.run(
                    ...ffmpegArgs,
                    '-vf', palettegenFilters.join(','),
                    '-y', 'palette.png'
                );
                
                updateGifProgress('正在生成GIF', 70);
                
                // 再生成GIF
                await gifFfmpeg.run(
                    ...ffmpegArgs,
                    '-i', 'palette.png',
                    '-lavfi', `${filters.join(',')}[x];[x][1:v]paletteuse`,
                    '-loop', loop ? '0' : '1',
                    '-y', 'output.gif'
                );
            } else {
                updateGifProgress('正在生成GIF', 60);
                
                // 直接生成GIF（低质量）
                await gifFfmpeg.run(
                    ...ffmpegArgs,
                    '-vf', filters.join(','),
                    '-loop', loop ? '0' : '1',
                    '-y', 'output.gif'
                );
            }
            
            updateGifProgress('正在处理完成', 90);
            
            // 读取生成的GIF文件
            const gifData = gifFfmpeg.FS('readFile', 'output.gif');
            const gifBlob = new Blob([gifData.buffer], { type: 'image/gif' });
            const gifUrl = URL.createObjectURL(gifBlob);
            
            // 保存结果
            gifResult = {
                blob: gifBlob,
                url: gifUrl,
                size: gifBlob.size,
                width: width,
                height: height,
                fps: fps,
                duration: endTime - startTime,
                method: 'FFmpeg'
            };
            
            updateGifProgress('处理完成', 100);
            
            // 显示结果
            showGifResult();
        }
        
        // 使用HTML5 Canvas生成GIF（替代方案）
        async function generateGifWithCanvas(fps, width, height, startTime, endTime, quality, loop) {
            updateGifProgress('使用HTML5 Canvas生成GIF', 30);
            
            const gifProgressDetails = document.getElementById('gif-progress-details');
            
            // 创建临时Canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            // 设置视频位置到开始时间
            gifVideoElement.currentTime = startTime;
            
            // 等待视频加载到指定位置
            await new Promise(resolve => {
                const checkTime = () => {
                    if (Math.abs(gifVideoElement.currentTime - startTime) < 0.1) {
                        resolve();
                    } else {
                        setTimeout(checkTime, 50);
                    }
                };
                checkTime();
            });
            
            updateGifProgress('正在捕获帧', 40);
            
            // 计算需要捕获的帧数
            const duration = endTime - startTime;
            const frameCount = Math.min(Math.round(duration * fps), 100); // 限制最大帧数
            const frameInterval = 1 / fps;
            
            const capturedFrames = [];
            
            // 显示捕获进度
            const progressDiv = document.createElement('div');
            progressDiv.className = 'text-xs mb-2';
            progressDiv.innerHTML = `<div>准备捕获 ${frameCount} 帧...</div>`;
            gifProgressDetails.appendChild(progressDiv);
            
            // 捕获每一帧
            for (let i = 0; i < frameCount; i++) {
                const currentTime = startTime + (i * frameInterval);
                
                // 设置视频位置
                gifVideoElement.currentTime = currentTime;
                
                // 等待视频帧加载
                await new Promise(resolve => {
                    const waitForFrame = () => {
                        if (Math.abs(gifVideoElement.currentTime - currentTime) < 0.05) {
                            requestAnimationFrame(() => {
                                try {
                                    // 绘制视频帧到Canvas
                                    tempCtx.drawImage(gifVideoElement, 0, 0, width, height);
                                    
                                    // 根据质量进行处理
                                    if (quality === 'low') {
                                        // 应用灰度或降低颜色深度
                                        const imageData = tempCtx.getImageData(0, 0, width, height);
                                        const data = imageData.data;
                                        for (let j = 0; j < data.length; j += 4) {
                                            const avg = (data[j] + data[j + 1] + data[j + 2]) / 3;
                                            data[j] = avg;
                                            data[j + 1] = avg;
                                            data[j + 2] = avg;
                                        }
                                        tempCtx.putImageData(imageData, 0, 0);
                                    }
                                    if (textOverlay && textOverlay.enabled) {
                                        drawTextOverlay(tempCtx, width, height, i, fps);
                                    }
                                    
                                    if (arOverlay && arOverlay.enabled) {
                                        drawAREffects(tempCtx, width, height, i, fps);
                                    }
                                    if (textOverlay && textOverlay.enabled) {
                                        drawTextOverlay(tempCtx, width, height, i, fps);
                                    }
                                    
                                    // 转换为图片数据
                                    const imageUrl = tempCanvas.toDataURL('image/png');
                                    capturedFrames.push(imageUrl);
                                    
                                    // 更新进度显示
                                    progressDiv.innerHTML = `<div>正在捕获帧 ${i + 1}/${frameCount} (${Math.round((i + 1) / frameCount * 100)}%)</div>`;
                                    
                                    resolve();
                                } catch (drawError) {
                                    console.error('绘制帧失败:', drawError);
                                    // 使用空白帧替代
                                    tempCtx.fillStyle = '#000000';
                                    tempCtx.fillRect(0, 0, width, height);
                                    if (textOverlay && textOverlay.enabled) {
                                        drawTextOverlay(tempCtx, width, height, i, fps);
                                    }
                                    const blankUrl = tempCanvas.toDataURL('image/png');
                                    capturedFrames.push(blankUrl);
                                    resolve();
                                }
                            });
                        } else {
                            setTimeout(waitForFrame, 30);
                        }
                    };
                    waitForFrame();
                });
                
                // 更新进度
                const progress = 40 + (i / frameCount) * 40;
                updateGifProgress(`正在捕获帧 ${i + 1}/${frameCount}`, Math.round(progress));
            }
            
            updateGifProgress('正在准备下载', 85);
            
            // 显示完成信息
            const completeDiv = document.createElement('div');
            completeDiv.className = 'text-xs mb-2 p-2 bg-green-50 text-green-700 rounded';
            completeDiv.innerHTML = `
                <div class="font-medium">帧捕获完成！</div>
                <div>成功捕获 ${capturedFrames.length} 帧</div>
                <div>准备生成ZIP压缩包...</div>
            `;
            gifProgressDetails.appendChild(completeDiv);
            
            // 尝试使用gif.js编码生成真正的GIF
            let canUseGifJs = typeof GIF !== 'undefined';
            if (canUseGifJs && capturedFrames.length > 0) {
                updateGifProgress('正在合成GIF', 90);
                const gifCanvas = document.createElement('canvas');
                const gifCtx = gifCanvas.getContext('2d');
                gifCanvas.width = width;
                gifCanvas.height = height;

                const qualityMap = { high: 10, medium: 20, low: 30 };
                const encoder = new GIF({
                    workers: 2,
                    quality: qualityMap[quality] || 20,
                    workerScript: gifWorkerUrl || 'https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js',
                    width,
                    height,
                });

                const frameDelay = Math.max(10, Math.round(1000 / fps));

                for (let i = 0; i < capturedFrames.length; i++) {
                    const img = new Image();
                    await new Promise(resolve => {
                        img.onload = () => {
                            gifCtx.clearRect(0, 0, width, height);
                            gifCtx.drawImage(img, 0, 0, width, height);
                            if (arOverlay && arOverlay.enabled) {
                                drawAREffects(gifCtx, width, height, i, fps);
                            }
                            if (textOverlay && textOverlay.enabled) {
                                drawTextOverlay(gifCtx, width, height, i, fps);
                            }
                            encoder.addFrame(gifCtx, { copy: true, delay: frameDelay });
                            resolve();
                        };
                        img.onerror = resolve;
                        img.src = capturedFrames[i];
                    });
                }

                const resultBlob = await new Promise(resolve => {
                    encoder.on('finished', resolve);
                    encoder.render();
                });

                const resultUrl = URL.createObjectURL(resultBlob);

                gifResult = {
                    blob: resultBlob,
                    url: resultUrl,
                    size: resultBlob.size,
                    width,
                    height,
                    fps,
                    duration,
                    frameCount: capturedFrames.length,
                    method: 'Canvas',
                    loop,
                    frames: capturedFrames,
                };

                updateGifProgress('处理完成', 100);
                showGifResult();
            } else {
                // 保底：使用第一帧PNG作为预览
                const gifCanvas = document.createElement('canvas');
                const gifCtx = gifCanvas.getContext('2d');
                gifCanvas.width = width;
                gifCanvas.height = height;

                if (capturedFrames.length > 0) {
                    const img = new Image();
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve;
                        img.src = capturedFrames[0];
                    });
                    gifCtx.drawImage(img, 0, 0, width, height);
                }

                const gifUrl = gifCanvas.toDataURL('image/png');
                const gifBlob = await (await fetch(gifUrl)).blob();

                gifResult = {
                    blob: gifBlob,
                    url: gifUrl,
                    size: gifBlob.size,
                    width,
                    height,
                    fps,
                    duration,
                    frameCount: capturedFrames.length,
                    method: 'Canvas',
                    loop,
                    frames: capturedFrames,
                };

                updateGifProgress('处理完成', 100);
                showGifResult();
            }
        }
        
        // 初始化GIF相关的FFmpeg
        async function initGifFFmpeg() {
            updateGifProgress('正在加载FFmpeg', 0);
            
            // 检查浏览器兼容性
            const compatibility = checkBrowserCompatibility();
            if (!compatibility.supported) {
                console.warn('浏览器不支持FFmpeg.wasm:', compatibility.reason);
                updateGifProgress('浏览器不支持，使用替代方案', 15);
                throw new Error(`浏览器不支持FFmpeg.wasm: ${compatibility.reason}`);
            }
            
            if (!gifFfmpeg) {
                try {
                    // 显示调试信息
                    console.log('开始加载FFmpeg.wasm...');
                    console.log('检查SharedArrayBuffer支持:', typeof SharedArrayBuffer !== 'undefined');
                    
                    // 尝试使用多个CDN源
                    const cdnSources = [
                        {
                            name: 'jsdelivr',
                            corePath: 'https://cdn.jsdelivr.net/npm/ffmpeg.wasm@0.11.0/dist/ffmpeg-core.js',
                            workerPath: 'https://cdn.jsdelivr.net/npm/ffmpeg.wasm@0.11.0/dist/ffmpeg-core.worker.js',
                            assetPath: 'https://cdn.jsdelivr.net/npm/ffmpeg.wasm@0.11.0/dist/'
                        },
                        {
                            name: 'unpkg',
                            corePath: 'https://unpkg.com/ffmpeg.wasm@0.11.0/dist/ffmpeg-core.js',
                            workerPath: 'https://unpkg.com/ffmpeg.wasm@0.11.0/dist/ffmpeg-core.worker.js',
                            assetPath: 'https://unpkg.com/ffmpeg.wasm@0.11.0/dist/'
                        }
                    ];
                    
                    let loadSuccess = false;
                    
                    for (const source of cdnSources) {
                        try {
                            console.log(`尝试从${source.name}加载FFmpeg...`);
                            updateGifProgress(`正在从${source.name}加载FFmpeg`, 5);
                            
                            gifFfmpeg = createFFmpeg({
                                log: true,
                                corePath: source.corePath,
                                workerPath: source.workerPath,
                                assetPath: source.assetPath
                            });
                            
                            await gifFfmpeg.load();
                            console.log(`${source.name}加载成功!`);
                            loadSuccess = true;
                            break;
                        } catch (cdnError) {
                            console.warn(`${source.name}加载失败，尝试下一个源:`, cdnError.message);
                            gifFfmpeg = null;
                        }
                    }
                    
                    if (!loadSuccess) {
                        console.error('所有CDN源都加载失败');
                        updateGifProgress('所有CDN源加载失败', 10);
                        throw new Error('所有CDN源都加载失败，请检查网络连接或稍后重试');
                    }
                    
                    updateGifProgress('FFmpeg加载完成', 20);
                    console.log('FFmpeg.wasm初始化成功!');
                    
                } catch (error) {
                    console.error('处理环境加载失败:', error);
                    updateGifProgress('正在准备替代方案', 15);
                    
                    // 记录详细错误信息
                    const errorInfo = {
                        message: error.message,
                        stack: error.stack,
                        browser: navigator.userAgent,
                        sharedArrayBuffer: typeof SharedArrayBuffer !== 'undefined',
                        date: new Date().toISOString()
                    };
                    
                    console.error('加载失败详情:', errorInfo);
                    
                    throw new Error(`处理环境不可用: ${error.message}`);
                }
            }
        }
        
        // 检查浏览器兼容性
        function checkBrowserCompatibility() {
            const result = {
                supported: true,
                reason: '',
                details: {}
            };
            
            // 检查SharedArrayBuffer支持
            if (typeof SharedArrayBuffer === 'undefined') {
                result.supported = false;
                result.reason = '浏览器不支持SharedArrayBuffer';
                result.details.sharedArrayBuffer = false;
            }
            
            // 检查WebAssembly支持
            if (typeof WebAssembly === 'undefined') {
                result.supported = false;
                result.reason = '浏览器不支持WebAssembly';
                result.details.webAssembly = false;
            }
            
            // 检查浏览器类型
            const userAgent = navigator.userAgent.toLowerCase();
            result.details.browser = {
                chrome: userAgent.includes('chrome') && !userAgent.includes('edge'),
                firefox: userAgent.includes('firefox'),
                edge: userAgent.includes('edge'),
                safari: userAgent.includes('safari') && !userAgent.includes('chrome'),
                mobile: /android|iphone|ipad|ipod|blackberry|windows phone/i.test(userAgent)
            };
            
            // 移动设备警告
            if (result.details.browser.mobile) {
                result.details.mobileWarning = true;
            }
            
            return result;
        }
        
        // 更新GIF进度
        function updateGifProgress(step, percentage) {
            const gifProgressStep = document.getElementById('gif-progress-step');
            const gifProgressPercentage = document.getElementById('gif-progress-percentage');
            const gifProgressBar = document.getElementById('gif-progress-bar');
            const gifProgressDetails = document.getElementById('gif-progress-details');
            
            gifProgressStep.textContent = step;
            gifProgressPercentage.textContent = `${percentage}%`;
            gifProgressBar.style.width = `${percentage}%`;
            
            // 添加进度详情
            const timestamp = new Date().toLocaleTimeString();
            const detailItem = document.createElement('div');
            detailItem.className = 'text-xs';
            detailItem.textContent = `[${timestamp}] ${step} - ${percentage}%`;
            gifProgressDetails.appendChild(detailItem);
            gifProgressDetails.scrollTop = gifProgressDetails.scrollHeight;
        }
        
        // 显示GIF结果
        function showGifResult() {
            if (!gifResult) return;
            
            const gifResultSection = document.getElementById('gif-result-section');
            const gifPreview = document.getElementById('gif-preview');
            const gifInfo = document.getElementById('gif-info');
            const downloadGifBtn = document.getElementById('download-gif-btn');
            
            // 设置预览
            gifPreview.src = gifResult.url;
            
            // 如果是Canvas方式且有多帧，创建简单的动画效果
            if ((!gifResult.blob || gifResult.blob.type !== 'image/gif') && gifResult.frames && gifResult.frames.length > 1) {
                let currentFrameIndex = 0;
                const frameDelay = 1000 / gifResult.fps;
                
                const animateFrames = () => {
                    currentFrameIndex = (currentFrameIndex + 1) % gifResult.frames.length;
                    gifPreview.src = gifResult.frames[currentFrameIndex];
                    if (gifResult.loop) {
                        setTimeout(animateFrames, frameDelay);
                    } else if (currentFrameIndex < gifResult.frames.length - 1) {
                        setTimeout(animateFrames, frameDelay);
                    }
                };
                
                // 开始动画
                setTimeout(animateFrames, frameDelay);
            }
            
            // 更新下载按钮文本
            if (gifResult.blob && gifResult.blob.type === 'image/gif') {
                downloadGifBtn.innerHTML = '<i class="fa fa-download mr-2"></i> 下载 GIF 文件';
                downloadGifBtn.className = 'bg-green-500 hover:bg-green-600 text-white font-medium py-3 px-6 rounded-lg transition-all-300 flex items-center';
            } else {
                downloadGifBtn.innerHTML = '<i class="fa fa-download mr-2"></i> 下载帧序列';
                downloadGifBtn.className = 'bg-orange-500 hover:bg-orange-600 text-white font-medium py-3 px-6 rounded-lg transition-all-300 flex items-center';
            }
            
            // 显示信息
            const methodDisplay = (gifResult.blob && gifResult.blob.type === 'image/gif')
                ? (gifResult.method === 'FFmpeg' 
                    ? '<span class="flex items-center justify-center"><i class="fa fa-check-circle mr-1"></i> FFmpeg.wasm (已生成GIF)</span>'
                    : '<span class="flex items-center justify-center"><i class="fa fa-check-circle mr-1"></i> HTML5 Canvas + gif.js (已生成GIF)</span>')
                : '<span class="flex items-center justify-center"><i class="fa fa-exclamation-triangle mr-1"></i> HTML5 Canvas (替代方案，提供PNG帧序列)</span>';

            gifInfo.innerHTML = `
                <div class="grid grid-cols-2 gap-4 text-center">
                    <div>
                        <div class="font-medium">尺寸</div>
                        <div>${gifResult.width} × ${gifResult.height}</div>
                    </div>
                    <div>
                        <div class="font-medium">帧率</div>
                        <div>${gifResult.fps} FPS</div>
                    </div>
                    <div>
                        <div class="font-medium">时长</div>
                        <div>${gifResult.duration.toFixed(1)} 秒</div>
                    </div>
                    <div>
                        <div class="font-medium">文件大小</div>
                        <div>${formatFileSize(gifResult.size)}</div>
                    </div>
                    <div class="col-span-2">
                        <div class="font-medium">生成方式</div>
                        <div class="text-sm ${gifResult.blob && gifResult.blob.type === 'image/gif' ? 'text-green-600' : 'text-orange-600'}">${methodDisplay}</div>
                    </div>
                    ${(!gifResult.blob || gifResult.blob.type !== 'image/gif') ? `
                    <div class="col-span-2 p-3 bg-blue-50 rounded-lg text-sm text-blue-800">
                        <div class="flex items-start gap-2">
                            <i class="fa fa-info-circle mt-1"></i>
                            <div>
                                <strong>提示：</strong>已生成帧序列（PNG），可使用其他工具合成 GIF。
                                <br><br>
                                <strong>推荐工具：</strong>
                                <ul class="list-disc list-inside mt-1">
                                    <li>在线工具：EZGIF.com, GIPHY.com</li>
                                    <li>桌面软件：Photoshop, GIMP</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
            
            // 显示结果区域
            gifResultSection.classList.remove('hidden');
        }
        
        // 下载GIF
        function downloadGif() {
            if (!gifResult) return;
            
            const isRealGif = gifResult.blob && gifResult.blob.type === 'image/gif';
            if (isRealGif) {
                const filename = `video_to_gif_${new Date().getTime()}.gif`;
                saveAs(gifResult.blob, filename);
                return;
            }

            const previewFilename = `video_to_gif_preview_${new Date().getTime()}.png`;
            if (gifResult.frames && gifResult.frames.length > 1) {
                const zip = new JSZip();
                const frameFolder = zip.folder('frames');
                let completed = 0;
                gifResult.frames.forEach((frameUrl, index) => {
                    const frameName = `frame_${String(index).padStart(4, '0')}.png`;
                    fetch(frameUrl)
                        .then(res => res.blob())
                        .then(blob => {
                            frameFolder.file(frameName, blob);
                            completed++;
                            if (completed === gifResult.frames.length) {
                                zip.generateAsync({ type: 'blob' })
                                    .then(content => {
                                        saveAs(content, `video_frames_${new Date().getTime()}.zip`);
                                    });
                            }
                        });
                });
                saveAs(gifResult.blob, previewFilename);
                // 已自动为您下载帧序列ZIP与预览图片
            } else {
                saveAs(gifResult.blob, previewFilename);
            }
        }
        
        // 重置GIF转换器
        function resetGifConverter() {
            // 清除文件
            gifVideoFile = null;
            gifResult = null;
            
            // 重置UI
            document.getElementById('gif-video-input').value = '';
            document.getElementById('gif-video-preview').src = '';
            document.getElementById('gif-preview').src = '';
            
            // 隐藏相关区域
            document.getElementById('gif-preview-section').classList.add('hidden');
            document.getElementById('gif-settings-section').classList.add('hidden');
            document.getElementById('gif-progress-section').classList.add('hidden');
            document.getElementById('gif-result-section').classList.add('hidden');
            
            // 重置设置
            document.getElementById('gif-fps').value = '10';
            document.getElementById('gif-width').value = '640';
            document.getElementById('gif-height').value = '360';
            document.getElementById('gif-start-time').value = '0';
            document.getElementById('gif-end-time').value = '5';
            document.getElementById('gif-quality').value = 'medium';
            document.getElementById('gif-loop').checked = true;
            
            // 清空进度详情
            document.getElementById('gif-progress-details').innerHTML = '';
            
            // 添加使用提示
            const gifUploadContainer = document.getElementById('gif-upload-container');
            if (!gifUploadContainer.querySelector('.tips-container')) {
                const tipsContainer = document.createElement('div');
                tipsContainer.className = 'tips-container mt-4 p-3 bg-blue-50 rounded-lg text-sm';
                
                // 检查浏览器兼容性
                const compatibility = checkBrowserCompatibility();
                const browserName = getBrowserName();
                const compatibilityClass = compatibility.supported ? 'text-green-600' : 'text-red-600';
                const compatibilityIcon = compatibility.supported ? '✅' : '❌';
                
                tipsContainer.innerHTML = `
                    <div class="flex items-start gap-2">
                        <i class="fa fa-lightbulb-o text-yellow-500 mt-1"></i>
                        <div>
                            <div class="font-medium text-blue-800">使用提示：</div>
                            <ul class="list-disc list-inside text-blue-700 mt-1 space-y-1">
                                <li><strong class="text-red-600">重要：</strong>只有FFmpeg方式才能生成真正的GIF文件</li>
                                <li><strong>当前浏览器：</strong><span class="${compatibilityClass}">${browserName} ${compatibilityIcon}</span></li>
                                <li><strong>SharedArrayBuffer：</strong><span class="${typeof SharedArrayBuffer !== 'undefined' ? 'text-green-600' : 'text-red-600'}">${typeof SharedArrayBuffer !== 'undefined' ? '✅ 支持' : '❌ 不支持'}</span></li>
                                ${!compatibility.supported ? `
                                <li class="text-red-600"><strong>⚠️ 浏览器不兼容：</strong>${compatibility.reason}</li>
                                ` : ''}
                                <li>系统支持HTML5 Canvas方案生成帧序列</li>
                                <li>Canvas替代方案会提供PNG帧序列，需要在其他工具中合成GIF</li>
                                <li>推荐浏览器：Chrome 98+、Firefox 95+（支持SharedArrayBuffer）</li>
                                <li>建议使用较短的视频片段（5秒以内）以获得更好的性能</li>
                                <li>降低分辨率和帧率可以减小文件大小</li>
                            </ul>
                            <div class="mt-2 p-2 bg-yellow-50 text-yellow-700 rounded text-xs">
                                <strong>快速解决方案：</strong>如果一直使用替代方案，请尝试：
                                <ol class="list-decimal list-inside mt-1">
                                    <li>使用Chrome或Firefox浏览器</li>
                                    <li>在新的无痕窗口中打开</li>
                                    <li>确保网络连接稳定</li>
                                    <li>刷新页面重新加载</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                `;
                gifUploadContainer.appendChild(tipsContainer);
            }
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 设置事件监听
        function setupEventListeners() {
            // 工具切换
            const frameExtractorBtn = document.getElementById('frame-extractor-btn');
            const gifConverterBtn = document.getElementById('gif-converter-btn');
            const compressorBtn = document.getElementById('compressor-btn');
            const frameExtractorTool = document.getElementById('frame-extractor-tool');
            const gifConverterTool = document.getElementById('gif-converter-tool');
            const videoCompressorTool = document.getElementById('video-compressor-tool');
            
            frameExtractorBtn.addEventListener('click', () => {
                frameExtractorBtn.classList.add('active', 'bg-blue-50', 'text-primary');
                frameExtractorBtn.classList.remove('text-secondary');
                gifConverterBtn.classList.remove('active', 'bg-blue-50', 'text-primary');
                gifConverterBtn.classList.add('text-secondary');
                compressorBtn.classList.remove('active', 'bg-blue-50', 'text-primary');
                compressorBtn.classList.add('text-secondary');
                
                frameExtractorTool.classList.remove('hidden');
                gifConverterTool.classList.add('hidden');
                videoCompressorTool.classList.add('hidden');
            });
            
            gifConverterBtn.addEventListener('click', () => {
                gifConverterBtn.classList.add('active', 'bg-blue-50', 'text-primary');
                gifConverterBtn.classList.remove('text-secondary');
                frameExtractorBtn.classList.remove('active', 'bg-blue-50', 'text-primary');
                frameExtractorBtn.classList.add('text-secondary');
                compressorBtn.classList.remove('active', 'bg-blue-50', 'text-primary');
                compressorBtn.classList.add('text-secondary');
                
                gifConverterTool.classList.remove('hidden');
                frameExtractorTool.classList.add('hidden');
                videoCompressorTool.classList.add('hidden');
            });

            compressorBtn.addEventListener('click', () => {
                compressorBtn.classList.add('active', 'bg-blue-50', 'text-primary');
                compressorBtn.classList.remove('text-secondary');
                frameExtractorBtn.classList.remove('active', 'bg-blue-50', 'text-primary');
                frameExtractorBtn.classList.add('text-secondary');
                gifConverterBtn.classList.remove('active', 'bg-blue-50', 'text-primary');
                gifConverterBtn.classList.add('text-secondary');
                
                videoCompressorTool.classList.remove('hidden');
                frameExtractorTool.classList.add('hidden');
                gifConverterTool.classList.add('hidden');
            });
            
            // 上传相关
            uploadBtn.addEventListener('click', () => videoInput.click());
            videoInput.addEventListener('change', handleVideoUpload);
            const useSampleExtractorBtn = document.getElementById('use-sample-extractor-btn');
            if (useSampleExtractorBtn) {
                useSampleExtractorBtn.addEventListener('click', downloadSampleVideo);
            }
            
            // 拖放上传
            uploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadContainer.classList.add('border-primary');
            });
            
            uploadContainer.addEventListener('dragleave', () => {
                uploadContainer.classList.remove('border-primary');
            });
            
            uploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadContainer.classList.remove('border-primary');
                
                if (e.dataTransfer.files.length > 0 && e.dataTransfer.files[0].type.startsWith('video/')) {
                    videoFile = e.dataTransfer.files[0];
                    processVideoFile();
                } else {
                    alert('请上传有效的视频文件');
                }
            });
            
            // 视频控制相关
            extractBtn.addEventListener('click', extractFrames);
            prevFrameBtn.addEventListener('click', goToPrevFrame);
            playPauseBtn.addEventListener('click', togglePlayPause);
            nextFrameBtn.addEventListener('click', goToNextFrame);
            videoSlider.addEventListener('input', seekVideo);
            
            // 视频事件
            videoPreview.addEventListener('timeupdate', updateVideoProgress);
            videoPreview.addEventListener('loadedmetadata', handleVideoLoaded);
            
            // 导出相关
            exportAllBtn.addEventListener('click', exportFrames);
            
            // GIF转换器事件
            setupGifConverterEventListeners();
            
            // 视频压缩器事件
            setupCompressorEventListeners();
        }

        // 处理视频上传
        function handleVideoUpload(e) {
            if (e.target.files.length > 0) {
                videoFile = e.target.files[0];
                processVideoFile();
            }
        }

        // 处理视频文件
        function processVideoFile() {
            if (!videoFile) return;
            
            // 显示视频信息
            videoFilename.textContent = videoFile.name;
            videoInfo.classList.remove('hidden');
            
            // 创建视频URL并设置到预览元素
            const videoURL = URL.createObjectURL(videoFile);
            videoPreview.src = videoURL;
            
            // 显示预览区域
            previewSection.classList.remove('hidden');
        }

        // 处理视频加载完成
        function handleVideoLoaded() {
            videoElement = videoPreview;
            videoDuration = videoElement.duration;
            
            // 尝试获取更准确的FPS
            let calculatedFPS = 30; // 默认值
            if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                // 尝试从视频元数据获取FPS
                if (videoElement.mozFrameRate) {
                    calculatedFPS = videoElement.mozFrameRate;
                } else if (videoElement.webkitVideoDecodedByteCount) {
                    calculatedFPS = 30; // WebKit浏览器默认
                } else {
                    calculatedFPS = 30; // 保守估计
                }
            }
            videoFPS = calculatedFPS;
            
            console.log('视频信息:', {
                width: videoElement.videoWidth,
                height: videoElement.videoHeight,
                duration: videoDuration,
                fps: videoFPS
            });
            
            // 更新视频信息
            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            const duration = formatTime(videoDuration);
            videoDetails.textContent = `分辨率: ${width}x${height} | 时长: ${duration} | FPS: ${videoFPS.toFixed(1)}`;
            
            // 设置Canvas尺寸
            canvas.width = width;
            canvas.height = height;
            
            // 计算总帧数
            totalFrames = Math.round(videoDuration * videoFPS);
            
            // 更新滑块最大值
            videoSlider.max = totalFrames;

            const extractEnd = document.getElementById('extract-end');
            const extractStart = document.getElementById('extract-start');
            extractEnd.value = Math.max(0.1, videoDuration).toFixed(1);
            extractEnd.max = videoDuration;
            extractStart.max = Math.max(0, videoDuration - 0.1);
        }

        // 提取帧
        async function extractFrames() {
            if (!videoElement) {
                alert('请先上传视频文件');
                return;
            }
            
            // 获取提取间隔设置
            const startSec = parseFloat(document.getElementById('extract-start').value);
            const endSec = parseFloat(document.getElementById('extract-end').value);
            const intervalMs = parseInt(document.getElementById('extract-interval-ms').value);
            
            // 验证输入
            if (isNaN(startSec) || isNaN(endSec) || startSec < 0 || endSec <= startSec || endSec > videoDuration) {
                alert('请填写有效的开始/结束时间');
                return;
            }
            if (isNaN(intervalMs) || intervalMs <= 0) {
                alert('提取间隔必须大于0毫秒');
                return;
            }
            
            // 显示提取模式信息
            let extractMode = `区间 ${startSec.toFixed(1)}s → ${endSec.toFixed(1)}s，间隔 ${intervalMs}ms`;
            
            console.log('开始提取帧，模式:', extractMode);
            
            // 显示加载提示
            showLoading('正在提取帧', `请稍候，正在处理视频帧...\n模式: ${extractMode}\n\n提示: 提取完成后点击帧卡片可在视频中查看对应画面`);
            
            // 清空之前的帧
            frames = [];
            
            // 清除之前的说明
            const oldInstructions = document.getElementById('frames-instructions');
            if (oldInstructions) {
                oldInstructions.remove();
            }
            
            // 清除之前的调试信息
            const oldDebugInfo = document.querySelector('.text-xs.text-gray-500.mt-3');
            if (oldDebugInfo) {
                oldDebugInfo.remove();
            }
            
            // 清空容器
            framesContainer.innerHTML = '';
            
            try {
                // 记录开始时间
                const startTime = Date.now();
                
                // 使用优化的帧提取方法
                await extractFramesWithCanvasRange(startSec, endSec, intervalMs);
                
                // 计算耗时
                const duration = (Date.now() - startTime) / 1000;
                console.log('帧提取完成，耗时:', duration.toFixed(2), '秒，提取帧数:', frames.length);
                
                // 显示帧预览区域
                framesSection.classList.remove('hidden');
                
                // 生成帧预览
                generateFramePreviews();
                
                // 显示完成信息
                showToast(`成功提取 ${frames.length} 帧 (耗时: ${duration.toFixed(1)} 秒)`);
                
                hideLoading();
                
            } catch (error) {
                console.error('提取帧失败:', error);
                alert('提取帧失败，请重试\n错误信息: ' + error.message);
                hideLoading();
            }
        }

        // 使用FFmpeg提取帧
        async function extractFramesWithFFmpeg(extractIntervalSeconds, extractFrameInterval) {
            // 写入视频文件到FFmpeg虚拟文件系统
            ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(videoFile));
            
            let outputPattern = 'frame_%06d.png';
            let frameIndices = [];
            
            // 判断使用哪种提取方式
            if (!isNaN(extractIntervalSeconds) && extractIntervalSeconds > 0) {
                // 使用时间间隔
                const extractFPS = 1 / extractIntervalSeconds;
                await ffmpeg.run(
                    '-i', 'input.mp4',
                    '-vf', `fps=${extractFPS}`,
                    outputPattern
                );
                
                // 读取提取的帧
                const files = ffmpeg.FS('readdir', '.');
                const pngFiles = files.filter(file => file.endsWith('.png')).sort();
                
                for (let i = 0; i < pngFiles.length; i++) {
                    const data = ffmpeg.FS('readFile', pngFiles[i]);
                    const blob = new Blob([data.buffer], { type: 'image/png' });
                    const url = URL.createObjectURL(blob);
                    
                    // 计算原始帧索引
                    const originalIndex = Math.round(i * extractIntervalSeconds * videoFPS);
                    
                    frames.push({
                        index: originalIndex,
                        url: url,
                        blob: blob
                    });
                    
                    // 更新进度
                    updateLoadingProgress((i + 1) / pngFiles.length);
                }
            } else if (!isNaN(extractFrameInterval) && extractFrameInterval > 0) {
                // 使用帧间隔
                // 先提取所有帧，然后按间隔筛选
                await ffmpeg.run(
                    '-i', 'input.mp4',
                    '-vf', `fps=${videoFPS}`,
                    outputPattern
                );
                
                // 读取提取的帧
                const files = ffmpeg.FS('readdir', '.');
                let pngFiles = files.filter(file => file.endsWith('.png')).sort();
                
                // 按帧间隔筛选
                const filteredFiles = [];
                for (let i = 0; i < pngFiles.length; i += extractFrameInterval) {
                    filteredFiles.push(pngFiles[i]);
                }
                
                // 处理筛选后的帧
                for (let i = 0; i < filteredFiles.length; i++) {
                    const data = ffmpeg.FS('readFile', filteredFiles[i]);
                    const blob = new Blob([data.buffer], { type: 'image/png' });
                    const url = URL.createObjectURL(blob);
                    
                    // 获取原始帧索引（从文件名中提取）
                    const match = filteredFiles[i].match(/frame_(\d+)\.png/);
                    const originalIndex = match ? parseInt(match[1]) : i * extractFrameInterval;
                    
                    frames.push({
                        index: originalIndex,
                        url: url,
                        blob: blob
                    });
                    
                    // 更新进度
                    updateLoadingProgress((i + 1) / filteredFiles.length);
                }
            } else {
                // 提取全部帧
                await ffmpeg.run(
                    '-i', 'input.mp4',
                    '-vf', `fps=${videoFPS}`,
                    outputPattern
                );
                
                // 读取提取的帧
                const files = ffmpeg.FS('readdir', '.');
                const pngFiles = files.filter(file => file.endsWith('.png')).sort();
                
                for (let i = 0; i < pngFiles.length; i++) {
                    const data = ffmpeg.FS('readFile', pngFiles[i]);
                    const blob = new Blob([data.buffer], { type: 'image/png' });
                    const url = URL.createObjectURL(blob);
                    
                    frames.push({
                        index: i,
                        url: url,
                        blob: blob
                    });
                    
                    // 更新进度
                    updateLoadingProgress((i + 1) / pngFiles.length);
                }
            }
        }

        // 使用Canvas提取帧
        async function extractFramesWithCanvas(extractIntervalSeconds, extractFrameInterval) {
            console.log('使用Canvas提取帧，时间间隔:', extractIntervalSeconds, '秒，帧间隔:', extractFrameInterval, '帧');
            
            // 暂停视频
            videoElement.pause();
            
            // 确保Canvas尺寸正确
            if (!canvas.width || !canvas.height) {
                canvas.width = videoElement.videoWidth || 640;
                canvas.height = videoElement.videoHeight || 360;
                console.log('设置Canvas尺寸:', canvas.width, 'x', canvas.height);
            }
            
            // 清空之前的帧数据
            frames = [];
            
            // 判断使用哪种提取方式
            if (!isNaN(extractIntervalSeconds) && extractIntervalSeconds > 0) {
                // 使用时间间隔
                const totalExtractFrames = Math.ceil(videoDuration / extractIntervalSeconds);
                console.log('预计提取帧数:', totalExtractFrames, '基于时间间隔');
                
                for (let i = 0; i < totalExtractFrames; i++) {
                    // 设置视频.currentTime到指定时间点
                    const targetTime = i * extractIntervalSeconds;
                    if (targetTime >= videoDuration) break;
                    
                    videoElement.currentTime = targetTime;
                    
                    // 等待视频帧加载完成
                    await new Promise(resolve => {
                        const checkFrame = () => {
                            if (Math.abs(videoElement.currentTime - targetTime) < 0.01) {
                                resolve();
                            } else {
                                requestAnimationFrame(checkFrame);
                            }
                        };
                        checkFrame();
                    });
                    
                    try {
                        // 绘制当前帧到Canvas
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        
                        // 将Canvas内容转换为Blob (使用默认质量1.0确保图像质量)
                        const blob = await new Promise(resolve => {
                            canvas.toBlob(resolve, 'image/png');
                        });
                        
                        if (!blob) {
                            console.error('无法创建帧图像，Blob为空');
                            continue;
                        }
                        
                        console.log('成功创建帧Blob，大小:', Math.round(blob.size / 1024), 'KB');
                        
                        const url = URL.createObjectURL(blob);
                        
                        // 计算原始帧索引
                        const originalIndex = Math.round(targetTime * videoFPS);
                        
                        frames.push({
                            index: originalIndex,
                            url: url,
                            blob: blob,
                            time: targetTime
                        });
                        
                        console.log('添加帧:', originalIndex, '时间:', targetTime.toFixed(2), '秒');
                        
                    } catch (error) {
                        console.error('处理帧时出错:', error);
                        // 创建备用图像
                        createFallbackFrame(i);
                    }
                    
                    // 更新进度
                    updateLoadingProgress((i + 1) / totalExtractFrames);
                    
                    // 短暂延迟，避免UI卡死
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
            } else if (!isNaN(extractFrameInterval) && extractFrameInterval > 0) {
                // 使用帧间隔
                const interval = 1 / videoFPS; // 帧间隔时间(秒)
                const totalFrames = Math.round(videoDuration * videoFPS);
                const actualFrames = Math.ceil(totalFrames / extractFrameInterval);
                console.log('预计提取帧数:', actualFrames, '基于帧间隔');
                
                for (let i = 0; i < totalFrames; i += extractFrameInterval) {
                    // 设置视频.currentTime到指定帧
                    const targetTime = i * interval;
                    if (targetTime >= videoDuration) break;
                    
                    videoElement.currentTime = targetTime;
                    
                    // 等待视频帧加载完成
                    await new Promise(resolve => {
                        const checkFrame = () => {
                            if (Math.abs(videoElement.currentTime - targetTime) < 0.01) {
                                resolve();
                            } else {
                                requestAnimationFrame(checkFrame);
                            }
                        };
                        checkFrame();
                    });
                    
                    try {
                        // 绘制当前帧到Canvas
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        
                        // 将Canvas内容转换为Blob
                        const blob = await new Promise(resolve => {
                            canvas.toBlob(resolve, 'image/png');
                        });
                        
                        if (!blob) {
                            console.error('无法创建帧图像，Blob为空');
                            continue;
                        }
                        
                        const url = URL.createObjectURL(blob);
                        
                        frames.push({
                            index: i,
                            url: url,
                            blob: blob,
                            time: targetTime
                        });
                        
                        console.log('添加帧:', i, '时间:', targetTime.toFixed(2), '秒');
                        
                    } catch (error) {
                        console.error('处理帧时出错:', error);
                        // 创建备用图像
                        createFallbackFrame(i);
                    }
                    
                    // 更新进度
                    updateLoadingProgress((i + 1) / totalFrames * extractFrameInterval);
                    
                    // 短暂延迟
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
            } else {
                // 提取全部帧
                const interval = 1 / videoFPS; // 帧间隔时间(秒)
                const totalFrames = Math.round(videoDuration * videoFPS);
                console.log('预计提取全部帧:', totalFrames);
                
                // 限制最大帧数，避免浏览器崩溃
                const maxFrames = 500; // 减少最大帧数，提高性能
                const actualFrames = Math.min(totalFrames, maxFrames);
                const frameStep = totalFrames > maxFrames ? Math.ceil(totalFrames / maxFrames) : 1;
                
                if (totalFrames > maxFrames) {
                    console.log('帧数过多，将提取约', maxFrames, '帧，步长:', frameStep);
                }
                
                for (let i = 0; i < totalFrames; i += frameStep) {
                    // 设置视频.currentTime到指定帧
                    const targetTime = i * interval;
                    if (targetTime >= videoDuration) break;
                    
                    videoElement.currentTime = targetTime;
                    
                    // 等待视频帧加载完成
                    await new Promise(resolve => {
                        const checkFrame = () => {
                            if (Math.abs(videoElement.currentTime - targetTime) < 0.01) {
                                resolve();
                            } else {
                                requestAnimationFrame(checkFrame);
                            }
                        };
                        checkFrame();
                    });
                    
                    try {
                        // 绘制当前帧到Canvas
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        
                        // 将Canvas内容转换为Blob
                        const blob = await new Promise(resolve => {
                            canvas.toBlob(resolve, 'image/png');
                        });
                        
                        if (!blob) {
                            console.error('无法创建帧图像，Blob为空');
                            continue;
                        }
                        
                        const url = URL.createObjectURL(blob);
                        
                        frames.push({
                            index: i,
                            url: url,
                            blob: blob,
                            time: targetTime
                        });
                        
                        console.log('添加帧:', i, '时间:', targetTime.toFixed(2), '秒');
                        
                    } catch (error) {
                        console.error('处理帧时出错:', error);
                        // 创建备用图像
                        createFallbackFrame(i);
                    }
                    
                    // 更新进度
                    updateLoadingProgress((i + 1) / totalFrames);
                    
                    // 短暂延迟
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
            }
            
            console.log('Canvas提取完成，实际提取帧数:', frames.length);
        }

        // 使用Canvas按区间和毫秒间隔提取帧
        async function extractFramesWithCanvasRange(startSec, endSec, intervalMs) {
            videoElement.pause();
            if (!canvas.width || !canvas.height) {
                canvas.width = videoElement.videoWidth || 640;
                canvas.height = videoElement.videoHeight || 360;
            }
            frames = [];
            const step = Math.max(0.001, intervalMs / 1000);
            const totalExtractFrames = Math.floor((endSec - startSec) / step) + 1;
            for (let i = 0; i < totalExtractFrames; i++) {
                const targetTime = startSec + i * step;
                if (targetTime > endSec) break;
                videoElement.currentTime = targetTime;
                await new Promise(resolve => {
                    const checkFrame = () => {
                        if (Math.abs(videoElement.currentTime - targetTime) < 0.01) {
                            resolve();
                        } else {
                            requestAnimationFrame(checkFrame);
                        }
                    };
                    checkFrame();
                });
                try {
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    if (!blob) continue;
                    const url = URL.createObjectURL(blob);
                    const originalIndex = Math.round(targetTime * videoFPS);
                    frames.push({ index: originalIndex, url, blob, time: targetTime });
                } catch (_) { createFallbackFrame(Math.round(targetTime * videoFPS)); }
                updateLoadingProgress((i + 1) / totalExtractFrames);
                if (i % 10 === 0) await new Promise(r => setTimeout(r, 8));
            }
            console.log('区间提取完成，帧数:', frames.length);
        }
        
        // 创建备用帧图像（当正常提取失败时使用）
        function createFallbackFrame(frameIndex) {
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 320;
                tempCanvas.height = 180;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 绘制背景
                tempCtx.fillStyle = '#f8fafc';
                tempCtx.fillRect(0, 0, 320, 180);
                
                // 绘制边框
                tempCtx.strokeStyle = '#e2e8f0';
                tempCtx.lineWidth = 2;
                tempCtx.strokeRect(1, 1, 318, 178);
                
                // 绘制文本
                tempCtx.fillStyle = '#64748b';
                tempCtx.font = 'bold 16px Arial';
                tempCtx.textAlign = 'center';
                tempCtx.fillText('帧 ' + frameIndex, 160, 80);
                
                tempCtx.font = '12px Arial';
                tempCtx.fillText('无法提取原始图像', 160, 105);
                tempCtx.fillText('这是一个备用图像', 160, 125);
                
                // 添加时间信息
                const time = (frameIndex / videoFPS).toFixed(2);
                tempCtx.font = '10px Arial';
                tempCtx.fillText(`时间: ${time}s`, 160, 155);
                
                // 转换为Blob
                tempCanvas.toBlob((blob) => {
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        frames.push({
                            index: frameIndex,
                            url: url,
                            blob: blob,
                            time: frameIndex / videoFPS,
                            isFallback: true
                        });
                        console.log('创建备用帧图像:', frameIndex);
                    }
                }, 'image/png');
            } catch (error) {
                console.error('创建备用帧图像失败:', error);
            }
        }

        // 生成帧预览
        function generateFramePreviews() {
            framesContainer.innerHTML = '';
            
            console.log('生成帧预览，总帧数:', frames.length);
            
            // 如果没有帧，显示提示信息
            if (frames.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'text-center py-8 text-gray-500';
                emptyMessage.innerHTML = `
                    <i class="fa fa-image text-4xl mb-2"></i>
                    <p>没有提取到帧</p>
                    <p class="text-xs mt-1">请尝试调整提取参数或检查视频文件</p>
                `;
                framesContainer.appendChild(emptyMessage);
                return;
            }
            
            // 添加使用说明
            const instructions = document.createElement('div');
            instructions.id = 'frames-instructions';
            instructions.className = 'bg-gradient-to-r from-blue-50 to-cyan-50 border border-blue-200 rounded-lg p-4 mb-4 text-sm text-blue-800 shadow-sm';
            instructions.innerHTML = `
                <div class="flex items-start">
                    <i class="fa fa-info-circle mr-2 mt-0.5 text-blue-500"></i> 
                    <div>
                        <div class="font-medium">帧预览</div>
                        <div class="mt-1">点击下方任意帧卡片可在上方视频中查看对应画面</div>
                    </div>
                </div>
            `;
            framesContainer.parentNode.insertBefore(instructions, framesContainer);
            
            frames.forEach((frame, frameIndex) => {
                const frameItem = document.createElement('div');
                frameItem.className = 'frame-item';
                frameItem.dataset.frameIndex = frame.index;
                frameItem.dataset.frameTime = frame.time ? frame.time.toFixed(2) : '0.00';
                
                // 创建图像预览
                const img = document.createElement('img');
                img.className = 'w-full h-24 object-cover';
                img.alt = `帧 ${frame.index}`;
                img.style.opacity = '0'; // 初始透明，加载完成后显示
                img.style.transition = 'opacity 0.3s ease';
                frameItem.appendChild(img);
                
                // 添加帧索引标签（在左上角）
                const indexDiv = document.createElement('div');
                indexDiv.className = 'absolute top-2 left-2 bg-gradient-to-r from-blue-600 to-blue-500 text-white text-xs px-2 py-1 rounded-full shadow-md';
                indexDiv.textContent = `#${frame.index}`;
                frameItem.appendChild(indexDiv);
                
                // 添加时间标签（在右下角）
                const timeDiv = document.createElement('div');
                timeDiv.className = 'absolute bottom-2 right-2 bg-black bg-opacity-60 text-white text-xs px-2 py-0.5 rounded';
                timeDiv.textContent = formatTime(frame.time || 0);
                frameItem.appendChild(timeDiv);
                
                // 设置图像源并处理加载事件
                img.onload = function() {
                    console.log('帧图像加载成功:', frame.index);
                    // 显示图像
                    this.style.opacity = '1';
                };
                
                img.onerror = function() {
                    console.error('无法加载帧图像:', frame.url);
                    // 显示错误状态
                    this.style.opacity = '0';
                    // 添加错误图标
                    const errorIcon = document.createElement('div');
                    errorIcon.className = 'absolute inset-0 flex items-center justify-center bg-red-50';
                    errorIcon.innerHTML = '<i class="fa fa-exclamation-triangle text-red-400 text-xl"></i>';
                    frameItem.appendChild(errorIcon);
                };
                
                // 设置图像源
                if (frame.url) {
                    console.log('设置帧图像URL:', frame.index, frame.url.substring(0, 50) + '...');
                    img.src = frame.url;
                } else {
                    console.error('帧URL不存在:', frame.index);
                    this.style.opacity = '0';
                    // 添加无数据图标
                    const noDataIcon = document.createElement('div');
                    noDataIcon.className = 'absolute inset-0 flex items-center justify-center bg-gray-50';
                    noDataIcon.innerHTML = '<i class="fa fa-image text-gray-300 text-xl"></i>';
                    frameItem.appendChild(noDataIcon);
                }
                
                // 添加点击事件
                frameItem.addEventListener('click', function() {
                    // 移除其他卡片的选中状态
                    document.querySelectorAll('.frame-item.selected').forEach(card => {
                        card.classList.remove('selected');
                    });
                    
                    // 添加当前卡片的选中状态
                    this.classList.add('selected');
                    
                    // 跳转到该帧
                    const frameIdx = parseInt(this.dataset.frameIndex);
                    console.log('跳转到帧:', frameIdx);
                    goToFrame(frameIdx);
                    
                    // 显示操作反馈
                    showToast(`已跳转到帧 ${frameIdx} (${this.dataset.frameTime}s)`);
                    
                    // 添加点击动画效果
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = '';
                    }, 100);
                });
                
                framesContainer.appendChild(frameItem);
            });
            
            // 添加调试信息
            const debugInfo = document.createElement('div');
            debugInfo.className = 'text-xs text-gray-500 mt-2 text-right';
            debugInfo.textContent = `共 ${frames.length} 帧 | 预览生成时间: ${new Date().toLocaleTimeString()}`;
            framesContainer.parentNode.appendChild(debugInfo);
        }
        
        // 显示提示消息
        function showToast(message, duration = 2000) {
            // 移除已存在的toast
            const existingToast = document.querySelector('.toast-message');
            if (existingToast) {
                existingToast.remove();
            }
            
            // 创建新的toast
            const toast = document.createElement('div');
            toast.className = 'toast-message fixed bottom-4 right-4 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg z-50 animate-fade-in-out';
            toast.textContent = message;
            
            // 添加样式
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fade-in-out {
                    0% { opacity: 0; transform: translateY(20px); }
                    10% { opacity: 1; transform: translateY(0); }
                    90% { opacity: 1; transform: translateY(0); }
                    100% { opacity: 0; transform: translateY(20px); }
                }
                .animate-fade-in-out {
                    animation: fade-in-out ${duration / 1000}s ease-in-out forwards;
                }
            `;
            document.head.appendChild(style);
            
            // 添加到页面
            document.body.appendChild(toast);
            
            // 自动移除
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
                if (style.parentNode) {
                    style.remove();
                }
            }, duration);
        }

        // 导出帧
        async function exportFrames() {
            const interval = parseInt(exportInterval.value) || 1;
            if (interval < 1) return;
            
            showLoading('正在导出', '请稍候，正在准备导出文件...');
            
            try {
                // 创建ZIP文件
                const zip = new JSZip();
                const imageFolder = zip.folder('frames');
                
                // 选择要导出的帧
                const framesToExport = frames.filter((_, index) => index % interval === 0);
                
                // 显示导出进度
                exportProgress.classList.remove('hidden');
                
                // 添加帧到ZIP文件
                for (let i = 0; i < framesToExport.length; i++) {
                    const frame = framesToExport[i];
                    
                    // 验证blob数据的有效性
                    if (!frame.blob || !(frame.blob instanceof Blob) || frame.blob.size === 0) {
                        console.error('无效的帧数据:', frame.index);
                        continue;
                    }
                    
                    // 使用更安全的文件名格式
                    const filename = `frame_${frame.index.toString().padStart(6, '0')}.png`;
                    
                    try {
                        // 直接添加blob到ZIP
                        imageFolder.file(filename, frame.blob);
                        console.log('添加到ZIP:', filename, '大小:', Math.round(frame.blob.size / 1024), 'KB');
                    } catch (zipError) {
                        console.error('添加文件到ZIP失败:', filename, zipError);
                        continue;
                    }
                    
                    // 更新导出进度
                    const progress = (i + 1) / framesToExport.length;
                    exportStatus.textContent = `${Math.round(progress * 100)}%`;
                    exportProgressBar.style.width = `${progress * 100}%`;
                    
                    // 等待一小段时间，让UI有机会更新
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // 生成ZIP文件并下载
                const content = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                }, (metadata) => {
                    const progress = metadata.percent / 100;
                    exportStatus.textContent = `压缩中: ${Math.round(progress * 100)}%`;
                    exportProgressBar.style.width = `${progress * 100}%`;
                });
                
                // 验证生成的ZIP文件
                if (!content || content.size === 0) {
                    throw new Error('生成的ZIP文件为空');
                }
                
                console.log('ZIP文件生成成功，大小:', Math.round(content.size / 1024), 'KB');
                
                // 使用当前时间戳确保文件名唯一
                const timestamp = new Date().getTime();
                const zipFilename = `video_frames_${timestamp}.zip`;
                saveAs(content, zipFilename);
                
                // 隐藏导出进度
                exportProgress.classList.add('hidden');
                hideLoading();
                
                showToast(`成功导出 ${framesToExport.length} 帧`);
            } catch (error) {
                console.error('导出帧失败:', error);
                alert('导出帧失败，请重试\n错误信息: ' + error.message);
                exportProgress.classList.add('hidden');
                hideLoading();
            }
        }

        // 视频控制函数
        function goToPrevFrame() {
            if (!videoElement) return;
            
            const interval = 1 / videoFPS;
            const newTime = Math.max(0, videoElement.currentTime - interval);
            videoElement.currentTime = newTime;
            updateCurrentFrameDisplay();
        }

        function goToNextFrame() {
            if (!videoElement) return;
            
            const interval = 1 / videoFPS;
            const newTime = Math.min(videoDuration, videoElement.currentTime + interval);
            videoElement.currentTime = newTime;
            updateCurrentFrameDisplay();
        }

        function goToFrame(frameIndex) {
            if (!videoElement) return;
            
            const interval = 1 / videoFPS;
            const newTime = Math.min(videoDuration, frameIndex * interval);
            videoElement.currentTime = newTime;
            updateCurrentFrameDisplay();
        }

        function togglePlayPause() {
            if (!videoElement) return;
            
            if (isPlaying) {
                videoElement.pause();
                playPauseBtn.innerHTML = '<i class="fa fa-play"></i>';
                isPlaying = false;
            } else {
                videoElement.play();
                playPauseBtn.innerHTML = '<i class="fa fa-pause"></i>';
                isPlaying = true;
            }
        }

        function seekVideo() {
            if (!videoElement) return;
            
            const frameIndex = parseInt(videoSlider.value);
            goToFrame(frameIndex);
        }

        function updateVideoProgress() {
            if (!videoElement) return;
            
            const progress = (videoElement.currentTime / videoDuration) * 100;
            progressBarFill.style.width = `${progress}%`;
            
            // 更新滑块位置
            const currentFrameIndex = Math.round(videoElement.currentTime * videoFPS);
            videoSlider.value = currentFrameIndex;
            
            updateCurrentFrameDisplay();
        }

        function updateCurrentFrameDisplay() {
            if (!videoElement) return;
            
            const currentFrameIndex = Math.round(videoElement.currentTime * videoFPS);
            currentFrameDisplay.textContent = `帧: ${currentFrameIndex}`;
            currentTimeDisplay.textContent = formatTime(videoElement.currentTime);
            
            // 高亮当前帧预览
            const frameItems = framesContainer.querySelectorAll('.frame-item');
            frameItems.forEach((item, index) => {
                if (index === currentFrameIndex) {
                    item.classList.add('ring-2', 'ring-primary', 'ring-offset-2');
                } else {
                    item.classList.remove('ring-2', 'ring-primary', 'ring-offset-2');
                }
            });
        }

        function drawTextOverlay(ctx, width, height, frameIndex, fps) {
            if (!textOverlay || !textOverlay.enabled || !textOverlay.text) return;
            const t = frameIndex / (fps || 1);
            const amp = textOverlay.jitterAmplitude || 0;
            const freq = textOverlay.jitterFrequency || 0;
            const dx = amp ? Math.round(amp * Math.sin(2 * Math.PI * freq * t)) : 0;
            const dy = amp ? Math.round(amp * Math.cos(2 * Math.PI * freq * t)) : 0;
            ctx.save();
            ctx.font = `${textOverlay.fontSize}px ${textOverlay.fontFamily}`;
            ctx.fillStyle = textOverlay.color;
            ctx.lineWidth = textOverlay.strokeWidth || 0;
            ctx.strokeStyle = textOverlay.strokeColor || '#000000';
            ctx.shadowColor = textOverlay.shadowColor || 'rgba(0,0,0,0)';
            ctx.shadowBlur = textOverlay.shadowBlur || 0;
            let x = width / 2;
            let y = height - textOverlay.fontSize - 12;
            let align = 'center';
            if (textOverlay.position === 'top') {
                y = textOverlay.fontSize + 12;
            } else if (textOverlay.position === 'center') {
                y = height / 2;
            } else if (textOverlay.position === 'bottom-left') {
                x = 12;
                y = height - textOverlay.fontSize - 12;
                align = 'left';
            } else if (textOverlay.position === 'bottom-right') {
                x = width - 12;
                y = height - textOverlay.fontSize - 12;
                align = 'right';
            } else if (textOverlay.position === 'top-left') {
                x = 12;
                y = textOverlay.fontSize + 12;
                align = 'left';
            } else if (textOverlay.position === 'top-right') {
                x = width - 12;
                y = textOverlay.fontSize + 12;
                align = 'right';
            }
            ctx.textAlign = align;
            const tx = x + dx;
            const ty = y + dy;
            if (ctx.lineWidth > 0) ctx.strokeText(textOverlay.text, tx, ty);
            ctx.fillText(textOverlay.text, tx, ty);
            ctx.restore();
        }

        function drawAREffects(ctx, width, height, frameIndex, fps) {
            if (!arOverlay || !arOverlay.enabled) return;
            const t = frameIndex / (fps || 1);
            const density = arOverlay.intensity === 'high' ? 120 : arOverlay.intensity === 'low' ? 40 : 80;
            if (arOverlay.type === 'confetti') {
                for (let i = 0; i < density; i++) {
                    const rx = seeded(i * 13 + 7) * width;
                    const ry0 = seeded(i * 17 + 3) * height;
                    const speed = 30 + seeded(i * 19 + 11) * 100;
                    const angle = seeded(i * 23 + 5) * Math.PI * 2;
                    const size = 2 + seeded(i * 29 + 9) * 6;
                    const x = (rx + Math.sin(angle + t) * 20) % width;
                    const y = (ry0 + speed * t) % height;
                    ctx.save();
                    ctx.fillStyle = randomPalette(i);
                    ctx.translate(x, y);
                    ctx.rotate(angle + t);
                    ctx.fillRect(-size / 2, -size / 2, size, size);
                    ctx.restore();
                }
            } else if (arOverlay.type === 'snow') {
                for (let i = 0; i < density; i++) {
                    const rx = seeded(i * 31 + 2) * width;
                    const ry0 = seeded(i * 37 + 4) * height;
                    const speed = 20 + seeded(i * 41 + 6) * 60;
                    const drift = Math.sin(t + i) * 10;
                    const size = 2 + seeded(i * 43 + 8) * 4;
                    const x = (rx + drift) % width;
                    const y = (ry0 + speed * t) % height;
                    ctx.save();
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (arOverlay.type === 'bubbles') {
                for (let i = 0; i < density; i++) {
                    const rx = seeded(i * 47 + 1) * width;
                    const ry0 = seeded(i * 53 + 7) * height;
                    const speed = 15 + seeded(i * 59 + 12) * 50;
                    const size = 4 + seeded(i * 61 + 14) * 10;
                    const x = (rx + Math.sin(t * 0.8 + i) * 15) % width;
                    const y = (ry0 - speed * t + height) % height;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(180,220,255,0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            function seeded(n) {
                let x = Math.sin(n) * 10000;
                return x - Math.floor(x);
            }
            function randomPalette(i) {
                const colors = ['#ff6b6b', '#ffd93d', '#6bcB77', '#4d96ff', '#b07dff'];
                return colors[i % colors.length];
            }
        }

        // 工具函数
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function showLoading(title, message) {
            loadingTitle.textContent = title || '正在处理';
            loadingMessage.textContent = message || '请稍候...';
            loadingModal.classList.remove('hidden');
        }

        function hideLoading() {
            loadingModal.classList.add('hidden');
        }

        function updateLoadingProgress(progress) {
            loadingMessage.textContent = `处理中... ${Math.round(progress * 100)}%`;
        }

        async function fetchSampleFile() {
            showLoading('正在获取测试视频', '正在从远程加载测试视频...');
            try {
                const res = await fetch(SAMPLE_VIDEO_URL, { mode: 'cors' });
                const blob = await res.blob();
                const file = new File([blob], 'testvideo.mp4', { type: blob.type || 'video/mp4' });
                hideLoading();
                return file;
            } catch (error) {
                hideLoading();
                return null;
            }
        }

        async function loadSampleVideoForExtractor() {
            try {
                const file = await fetchSampleFile();
                videoFile = file;
                processVideoFile();
            } catch (_) {
                videoFile = { name: 'testvideo.mp4', size: 0 };
                const videoURL = SAMPLE_VIDEO_URL;
                const videoPreviewEl = document.getElementById('video-preview');
                const previewSectionEl = document.getElementById('preview-section');
                const videoInfoEl = document.getElementById('video-info');
                const videoFilenameEl = document.getElementById('video-filename');
                const videoDetailsEl = document.getElementById('video-details');
                videoPreviewEl.crossOrigin = 'anonymous';
                videoPreviewEl.src = videoURL;
                videoFilenameEl.textContent = 'testvideo.mp4';
                videoDetailsEl.textContent = '远程视频';
                videoInfoEl.classList.remove('hidden');
                previewSectionEl.classList.remove('hidden');
            }
            const el = document.getElementById('upload-container');
            el.classList.add('border-primary');
            setTimeout(() => el.classList.remove('border-primary'), 600);
        }

        async function loadSampleVideoForGif() {
            try {
                const file = await fetchSampleFile();
                gifVideoFile = file;
                processGifVideoFile();
            } catch (_) {
                gifVideoFile = { name: 'testvideo.mp4', size: 0 };
                const videoURL = SAMPLE_VIDEO_URL;
                const gifPreviewSection = document.getElementById('gif-preview-section');
                const gifSettingsSection = document.getElementById('gif-settings-section');
                const gifVideoInfo = document.getElementById('gif-video-info');
                const gifVideoPreview = document.getElementById('gif-video-preview');
                gifVideoPreview.crossOrigin = 'anonymous';
                gifVideoPreview.src = videoURL;
                gifVideoInfo.textContent = 'testvideo.mp4 (远程)';
                gifPreviewSection.classList.remove('hidden');
                gifSettingsSection.classList.remove('hidden');
            }
            const el = document.getElementById('gif-upload-container');
            el.classList.add('border-primary');
            setTimeout(() => el.classList.remove('border-primary'), 600);
        }

        async function loadSampleVideoForCompressor() {
            try {
                const file = await fetchSampleFile();
                compressVideoFile = file;
                processCompressorVideoFile();
            } catch (_) {
                compressVideoFile = { name: 'testvideo.mp4', size: 0 };
                const videoURL = SAMPLE_VIDEO_URL;
                const previewSection = document.getElementById('compress-preview-section');
                const settingsSection = document.getElementById('compress-settings-section');
                const videoPreview = document.getElementById('compress-video-preview');
                const originalSize = document.getElementById('compress-original-size');
                originalSize.textContent = '远程视频';
                videoPreview.crossOrigin = 'anonymous';
                videoPreview.src = videoURL;
                previewSection.classList.remove('hidden');
                settingsSection.classList.remove('hidden');
            }
            const el = document.getElementById('compress-upload-container');
            el.classList.add('border-primary');
            setTimeout(() => el.classList.remove('border-primary'), 600);
        }

        function downloadSampleVideo() {
            try {
                const a = document.createElement('a');
                a.href = SAMPLE_VIDEO_URL;
                a.download = 'testvideo.mp4';
                a.target = '_blank';
                a.rel = 'noopener';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showToast('已开始下载测试视频');
            } catch (error) {
                try {
                    window.open(SAMPLE_VIDEO_URL, '_blank', 'noopener');
                    showToast('已在新标签打开测试视频');
                } catch (_) {}
            }
        }

        // 清理函数
        function cleanup() {
            // 释放视频URL
            if (videoPreview.src) {
                URL.revokeObjectURL(videoPreview.src);
            }
            
            // 释放帧URL
            frames.forEach(frame => {
                if (frame.url) {
                    URL.revokeObjectURL(frame.url);
                }
            });
        }

        // 页面卸载时清理资源
        window.addEventListener('beforeunload', cleanup);
    </script>
</body>
</html>
