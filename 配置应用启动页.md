# 配置应用启动页

更新时间: 2025-12-16 16:39

## 启动页的分类和实现方式

启动页分为简易启动页和增强启动页，开发者通过在module.json5配置文件中的[abilities标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)配置启动页资源，涉及的对应字段及含义如下表所示。

|字段|类型|是否可缺省|含义|
|:--|:--|:--|:--|
|startWindowIcon|string|否|标识当前UIAbility组件简易启动页面图标资源文件的索引，取值为长度不超过255字节的字符串。<br><br>此图标资源会在启动页面上按实际大小居中显示。<br><br>当startWindow被配置时失效。|
|startWindowBackground|string|否|标识当前UIAbility组件简易启动页面背景颜色资源文件的索引，取值为长度不超过255字节的字符串。<br><br>考虑到启动页在各种场景下的显示效果及系统动效的连续性，不建议采用透明色。<br><br>当startWindow被配置时失效。|
|startWindow|string|是|标识当前UIAbility组件增强启动页面配置资源json文件的索引，取值为长度不超过255字节的字符串。<br><br>指向二级配置json文件，当应用需要配置增强启动页时，填写此字段，以提供更丰富的启动页资源配置项。<br><br>从API version 19开始，支持使用startWindow字段配置增强启动页。|

## 配置简易启动页

简易启动页是每个UIAbility都必须配置的能力，开发者通过配置module.json5文件中的[abilities标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities%E6%A0%87%E7%AD%BE)的startWindowIcon和startWindowBackground字段，实现简易启动页的配置。

说明

- startWindowIcon用于展示应用图标，不会随窗口尺寸进行缩放。建议开发者避免设计针对单个产品全屏尺寸的startWindowIcon图标资源，防止在其他尺寸设备的显示效果无法自动适配。
    
- 全屏资源的展示建议采用[配置增强启动页](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/launch-page-config#%E9%85%8D%E7%BD%AE%E5%A2%9E%E5%BC%BA%E5%90%AF%E5%8A%A8%E9%A1%B5)。
    

在创建的UIAbility模板中，简易启动页相关字段的默认配置如下：

1. "startWindowIcon": "$media:startIcon",
2. "startWindowBackground": "$color:start_window_background",

此时，默认启动页呈现示意图如下：

**图1** 默认启动页示意图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163931.35875676219935443129416825639758:50001231000000:2800:BCD6503950D5C3A94E545D9CC4696234A8472955C5413388DEC736A15EF5E4E6.png)

开发者可以根据应用需要，配置使用自定义设计的图标资源和颜色资源。

## 配置增强启动页

从API version 19开始，支持使用startWindow字段配置增强启动页。

startWindow字段提供了增强的启动页配置能力，可用于元素更复杂的启动页配置。同时，相应资源也具备根据窗口尺寸进行缩放的能力，更易于多设备适配设计，更有利于“一次开发，多端部署”。

说明

- 由于应用进程创建包括启动页图片资源的解码，使用适当分辨率的图片是影响应用启动时延体验的关键。若对启动时延体验有较高要求，建议启动页中使用不超过256*256分辨率的图片资源。
    
- 启动页中的图片资源支持的文件格式同[Image组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image)，考虑到解码性能和显示效果，建议启动页中使用jpg或png格式的图片资源。
    

1. 在创建的UIAbility模板中，开发者可以新增startWindow字段指向二级配置json文件，以启用启动页增强配置。
    
    其中，json文件需要由开发者自行创建并放置到工程目录下。推荐的文件名及路径为resources/base/profile/start_window.json，此时需在module.json5的abilities标签中配置如下：
    
    1. "startWindow": "$profile:start_window"
    
2. 配置二级json文件的具体字段。启动页资源主要在上、下两个区域进行展示，如果对应区域的资源未配置，则留空，其他区域的位置和尺寸不受影响。
    
    具体可配置字段、各字段含义及增强启动页示意图请见下文。
    
    |字段|类型|是否可缺省|含义|
    |:--|:--|:--|:--|
    |startWindowType|string|是|标识当前UIAbility组件是否隐藏启动页。<br><br>当前仅支持在2in1设备或平板设备的自由多窗模式下使用。<br><br>不同取值含义如下：<br><br>- "REQUIRED_SHOW"：强制显示启动页。不受[Ability管理服务（即StartOptions中hideStartWindow字段）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions#startoptions)的影响。<br><br>- "REQUIRED_HIDE"：强制隐藏启动页。不受[Ability管理服务（即StartOptions中hideStartWindow字段）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions#startoptions)的影响。<br><br>- "OPTIONAL_SHOW"：可选显示，默认行为为显示启动页，如果[Ability管理服务（即StartOptions中hideStartWindow字段）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-startoptions#startoptions)设置隐藏启动页，则隐藏启动页。<br><br>- 如未配置该字段，默认取值为"REQUIRED_SHOW"，即强制显示启动页。<br><br>从API version 20开始支持该字段。|
    |startWindowAppIcon|string|是|标识当前UIAbility组件增强启动页面图标资源文件的索引，取值为长度不超过255字节的字符串。<br><br>在窗口上部分展示，资源由系统侧进行缩放，使其完全显示在展示区域内，宽高比保持不变。<br><br>图标资源展示区域的尺寸由系统侧根据窗口尺寸选取，取值为128vp*128vp、192vp*192vp或256vp*256vp。<br><br>与插画资源startWindowIllustration同时配置时，仅展示图标资源。<br><br>从API version 19开始支持该字段。|
    |startWindowIllustration|string|是|标识当前UIAbility组件增强启动页面插画资源文件的索引，取值为长度不超过255字节的字符串。<br><br>在窗口上部分展示，如资源尺寸超出其展示区域，将由系统侧保持宽高比缩小，使得资源完全显示在其展示区域内；否则其尺寸保持不变。<br><br>插画资源展示区域宽高比为1。<br><br>与图标资源startWindowAppIcon同时配置时，仅展示图标资源。<br><br>从API version 19开始支持该字段。|
    |startWindowBrandingImage|string|是|标识当前UIAbility组件增强启动页面品牌标识资源文件的索引，取值为长度不超过255字节的字符串。<br><br>在窗口下部分展示，如资源尺寸超出其展示区域，将由系统侧保持宽高比缩小，使得资源完全显示在其展示区域内；否则其尺寸保持不变。<br><br>如果窗口高度不足300vp，此资源将被隐藏。<br><br>从API version 19开始支持该字段。|
    |startWindowBackgroundColor|string|否|标识当前UIAbility组件增强启动背景色资源文件的索引，取值为长度不超过255字节的字符串。<br><br>背景色填充整个窗口，显示层级最低，不建议采用透明色。<br><br>如未配置该字段，则启动页增强配置文件不生效，采用简易启动页配置。<br><br>从API version 19开始支持该字段。|
    |startWindowBackgroundImage|string|是|标识当前UIAbility组件增强启动背景图片资源文件的索引，取值为长度不超过255字节的字符串。<br><br>以整个窗口为容器，填充方式由startWindowBackgroundImageFit字段指定。<br><br>从API version 19开始支持该字段。|
    |startWindowBackgroundImageFit|string|是|标识当前UIAbility组件增强启动背景图片的填充方式，当前支持取值为：<br><br>- "Contain"：保持宽高比进行缩小或者放大，使得图片完全显示在显示边界内。<br><br>- "Cover"：保持宽高比进行缩小或者放大，使得图片两边都大于或等于显示边界。<br><br>- "Auto"：图像会根据其自身尺寸和组件的尺寸进行适当缩放，以在保持比例的同时填充视图。<br><br>- "Fill"：不保持宽高比进行放大缩小，使得图片充满显示边界。<br><br>- "ScaleDown"：保持宽高比显示，图片缩小或者保持不变。<br><br>- "None"：保持原有尺寸显示。<br><br>如未配置该字段，默认采用Cover填充方式。<br><br>从API version 19开始支持该字段。|
    |startWindowColorModeType|string|是|标识当前UIAbility组件启动页深浅色模式，仅作用于同进程间拉起场景。<br><br>不同取值含义如下：<br><br>- "FOLLOW_SYSTEM"：启动页颜色模式跟随系统深浅色。<br><br>- "FOLLOW_APPLICATION"：启动页颜色模式跟随应用深浅色。<br><br>- 如未配置该字段，默认取值为"FOLLOW_SYSTEM"，即启动页颜色模式跟随系统深浅色。<br><br>从API version 20开始支持该字段。|
    

**图2** 增强启动页示意图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163931.12888783037059783990213557940318:50001231000000:2800:D48BEF441D789E5A39DF3608E31AA0F417B6379491203AAE76E0EAC227D3BB4C.png)

示例如下：

1. {
2.   "startWindowType": "REQUIRED_SHOW",
3.   "startWindowColorModeType": "FOLLOW_SYSTEM",
4.   "startWindowAppIcon": "$media:icon",
5.   "startWindowIllustration": "$media:illustration",
6.   "startWindowBrandingImage": "$media:brand",
7.   "startWindowBackgroundColor": "$color:start_window_background",
8.   "startWindowBackgroundImage": "$media:bgImage",
9.   "startWindowBackgroundImageFit": "Contain"
10. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/launch-page-overview "应用启动页简介")
# 启动页资源分类配置

更新时间: 2025-12-16 16:39

启动页资源配置与其他资源配置相同，支持资源分类配置，可针对不同的场景配置不同资源，常用于在深色模式或不同设备类型上配置不同的启动页内容。

## 配置深色模式启动页

- 在API version 20之前，启动页深浅色模式仅支持跟随系统深浅色模式。
- 从API version 20开始，支持通过[增强启动页](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/launch-page-config#%E9%85%8D%E7%BD%AE%E5%A2%9E%E5%BC%BA%E5%90%AF%E5%8A%A8%E9%A1%B5)的startWindowColorModeType字段配置同进程下拉起的UIAbility的启动页深浅色模式跟随应用深浅色模式。对于未配置场景，启动页深浅色模式跟随系统深浅色模式。

以[配置增强启动页](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/launch-page-config#%E9%85%8D%E7%BD%AE%E5%A2%9E%E5%BC%BA%E5%90%AF%E5%8A%A8%E9%A1%B5)的背景色为例：startWindowBackgroundColor字段值为"$color:start_window_background"，按如下方式在resources目录下分别配置字段值对应的颜色值，即可对深色模式生效。其他字段配置方式与背景色相同，在resources目录中配置其字段值对应的资源即可。

1. 修改resources/base/element/color.json中，对应配置项start_window_background的颜色值，对应一般情况下的默认启动页背景色，示例如下：
    
    1. {
    2.   "color": [
    3.     {
    4.       "name": "start_window_background",
    5.       "value": "#FFFFFFFF"
    6.     }
    7.   ]
    8. }
    
2. 修改resources/dark/element/color.json中，对应配置项start_window_background的颜色值，对应深色模式下的默认启动页背景色，示例如下：
    
    1. {
    2.   "color": [
    3.     {
    4.       "name": "start_window_background",
    5.       "value": "#FF000000"
    6.     }
    7.   ]
    8. }
    

## 配置不同设备启动页

与深色模式类似，通过在resources目录新建car、tablet等资源目录，配置上述字段对应的资源，则可在对应设备上配置显示不同的启动页内容，参考[创建资源目录和资源文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resource-categories-and-access#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95%E5%92%8C%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6)。

如未针对特定场景的启动页字段配置资源文件，则该场景下默认以base目录中的对应资源文件为准。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/launch-page-config "配置应用启动页")
# 窗口开发术语

更新时间: 2025-12-16 16:38

## 窗口类型

窗口有系统窗口、应用窗口两种分类。

### 系统窗口

系统窗口指完成系统特定功能的窗口。如音量条、壁纸、通知栏、状态栏、导航栏等。

系统窗口仅系统应用可用。

### 应用窗口

应用窗口区别于系统窗口，指与应用显示相关的窗口，用来显示应用的内容。根据管理方式和用途的不同，应用窗口又可以分为主窗口、辅助窗口两种类型。

- 主窗口
    
    主窗口由UIAbility创建时默认创建，会在“任务管理界面”中以一个独立的任务卡片显示，用于显示应用UIAbility主界面。
    
- 辅助窗口
    
    辅助窗口由应用自行管理创建和销毁，不会在“任务管理界面”中以一个独立的任务卡片显示，可以用于显示应用的辅助内容，例如弹窗等。
    
    辅助窗口包括子窗口、全局悬浮窗、模态窗口、画中画和闪控球。
    

## 悬浮窗

悬浮窗分为智慧多窗悬浮窗和全局悬浮窗。

- 智慧多窗悬浮窗是指设备屏幕上悬浮的、非全屏的应用窗口。
    
    一般用于在已有全屏任务运行的基础上，临时处理另一个任务，或短时间多任务并行使用。如浏览网页的同时回复消息。
    
    相关参考：[智慧多窗简介](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-intro)、[智慧多窗最佳实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-window-practice)。
    
- 全局悬浮窗是指一种特殊的应用辅助窗口，具备在应用主窗口和对应Ability退至后台后仍然可以在前台显示的能力。
    
    全局悬浮窗可以用于应用退至后台后，使用小窗继续显示UI，例如音乐应用用于显示桌面歌词等。
    
    应用在创建全局悬浮窗前，需要申请对应的权限。
    

相关参考：[设置全局悬浮窗](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-window-stage#%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E6%82%AC%E6%B5%AE%E7%AA%97%E5%8F%97%E9%99%90%E5%BC%80%E6%94%BE)。

## 自由窗口

自由窗口是一种允许用户在同一屏幕上以自由大小、位置显示的窗口状态。自由窗口支持拖拽、缩放和分屏组合，从而实现多任务处理。

自由窗口按照打开或者获取焦点的顺序在Z轴层叠排布。当自由窗口被点击或触摸时，将导致其Z轴高度提升，并获取焦点。

启动新的自由窗口时，默认以一定间距在上一个窗口的右下方层叠显示。

每个自由窗口默认会在窗口上方显示窗口标题栏，标题栏左侧显示应用图标，右侧显示三键控制按钮（窗口最大化/还原、窗口最小化和关闭窗口），且窗口标题栏支持额外的[沉浸式配置](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-device-window-immersive#section1477255312219)。

自由窗口可以通过拖动窗口边缘调节窗口大小，可以通过拖动标题栏移动窗口位置。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163853.18137757057179677390279011877807:50001231000000:2800:EB85FA808EF2BA22888F0ECCD1FF321B1DC7A679D4060ECACA500DB4801B3423.png)

当前设备支持情况：

- **2in1设备**：2in1设备上的窗口，默认为自由窗口。
- **Tablet设备**：部分Tablet设备，支持开启[自由多窗模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E5%A4%9A%E7%AA%97%E6%A8%A1%E5%BC%8F)（通过下拉控制中心，点击“自由多窗”按钮开启），开启此模式后，应用窗口默认为自由窗口。
- **Phone设备**：部分Phone设备，支持开启[自由多窗模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E5%A4%9A%E7%AA%97%E6%A8%A1%E5%BC%8F)（通过下拉控制中心，点击“自由多窗”按钮开启），开启此模式后，应用窗口默认为自由窗口。

### 自由多窗模式

自由多窗模式是一种支持用户在移动设备上进行多任务处理的交互方式。

自由多窗下，允许用户在一块屏幕上同时显示多个应用窗口。此时的应用窗口为[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)。

部分Tablet设备上，可通过下拉控制中心，点击“自由多窗”按钮开启自由多窗。

部分Phone设备上，可通过下拉控制中心，点击“自由多窗”按钮开启自由多窗。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163853.36842625508358130049988240342376:50001231000000:2800:8262C134E970B95CEE46BF65C61BDFC0DA7C0B6083C995ABA0FB4B68C0D05074.png)

## 沉浸式布局

沉浸式布局是一种让应用界面聚焦内容，减少无关元素干扰的窗口状态。

非[自由窗口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/window-terminology#%E8%87%AA%E7%94%B1%E7%AA%97%E5%8F%A3)可以通过调用[setWindowLayoutFullScreen](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)进入沉浸式布局。

|非自由窗口的非沉浸式布局示意|非自由窗口的沉浸式布局示意|
|:--|:--|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163853.27164474051368205132342982335008:50001231000000:2800:5B300D822F8D5E8C71AEC5DD13BBD628ED7FA680EF8DE5E2FC818229F087930D.png)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163853.34474697854366408122323919348917:50001231000000:2800:BD9AA7618CF3F879EC853DA6B06F2C9D958BB7FCBCE6B555DC27E2BF20E2200A.png)|

自由窗口可以通过隐藏装饰栏进入沉浸式布局。

|自由窗口的非沉浸式布局示意|自由窗口的沉浸式布局示意|
|:--|:--|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163854.76365501159641981976260350026319:50001231000000:2800:E14AB8F2E0744C387D38B64991413A2B5E1540A8ABCBFD11919C927DCCA2F714.png)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163854.59626983567318213161562839823797:50001231000000:2800:D9FE61B1B72EB2FC08C31DCD69415B3F28D069DA2F59480414D0BAED8FBACA63.png)|

应用窗口进入沉浸式布局之后，页面的所有组件布局范围从安全区域扩展为整个窗口。可以通过[isImmersiveLayout](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#isimmersivelayout20)判断当前窗口是否处于沉浸式布局。

多设备场景下不同窗口形态的沉浸式开发与实现可以参考[窗口沉浸式最佳实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-device-window-immersive)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/launch-page-resource-config "启动页资源分类配置")
# 使用OH_DisplayManager实现屏幕基础信息查询和状态监听 (C/C++)

更新时间: 2025-12-16 16:38

## 场景介绍

[OH_DisplayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-oh-displaymanager)屏幕管理模块用于提供屏幕的信息查询、屏幕状态变化监听、折叠设备的折叠状态变化监听等能力，应用可根据对应的屏幕信息、屏幕状态变化、屏幕折叠状态适配不同的UI界面显示。

- 支持查询的屏幕信息，包括屏幕的分辨率、物理像素密度、逻辑像素密度、刷新率、屏幕尺寸、屏幕旋转方向、屏幕旋转角度等。
    
- 支持屏幕状态变化的监听，包括屏幕旋转变化，屏幕分辨率变化、屏幕刷新率变化等。
    
- 支持查询当前设备是否为可折叠设备，同时支持折叠状态（展开/折叠）变化的监听。
    

## 基本概念

- 屏幕的物理像素密度(densityDPI)：代表每英寸屏幕所拥有的物理像素点数。
    
- 屏幕的逻辑像素的密度(densityPixels)：代表物理像素与逻辑像素的缩放系数比，计算方法为物理像素密度除以160。
    

## 接口说明

常用接口如下表所示。更多API说明请参考[OH_DisplayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-oh-displaymanager)。

|接口名|描述|
|:--|:--|
|OH_NativeDisplayManager_GetDefaultDisplayRotation(NativeDisplayManager_Rotation *displayRotation)|获取默认屏幕的旋转角度。|
|OH_NativeDisplayManager_CreateDefaultDisplayCutoutInfo(NativeDisplayManager_CutoutInfo **cutoutInfo)|获取挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。|
|OH_NativeDisplayManager_DestroyDefaultDisplayCutoutInfo(NativeDisplayManager_CutoutInfo *cutoutInfo)|销毁挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。|
|OH_NativeDisplayManager_IsFoldable()|查询设备是否可折叠。|
|OH_NativeDisplayManager_RegisterDisplayChangeListener( OH_NativeDisplayManager_DisplayChangeCallback displayChangeCallback, uint32_t *listenerIndex)|注册屏幕状态变化监听（如旋转变化、刷新率、DPI、分辨率等）。|
|OH_NativeDisplayManager_UnregisterDisplayChangeListener(uint32_t listenerIndex)|取消屏幕状态变化监听。|
|OH_NativeDisplayManager_RegisterFoldDisplayModeChangeListener( OH_NativeDisplayManager_FoldDisplayModeChangeCallback displayModeChangeCallback, uint32_t *listenerIndex)|注册屏幕展开、折叠状态变化监听。|
|OH_NativeDisplayManager_UnregisterFoldDisplayModeChangeListener(uint32_t listenerIndex)|取消屏幕展开、折叠状态变化监听。|

## 在CMake脚本中链接动态库

1. target_link_libraries(entry PUBLIC libhilog_ndk.z.so)
2. target_link_libraries(entry PUBLIC libnative_display_manager.so )

## 添加头文件

1. #include <window_manager/oh_display_info.h>
2. #include <window_manager/oh_display_manager.h>
3. #include <hilog/log.h>

## 获取屏幕状态

1. 可以通过OH_NativeDisplayManager_GetDefaultDisplayRotation获取默认屏幕的旋转角度。
    
    1. #include "napi/native_api.h"
    2. #include <window_manager/oh_display_info.h>
    3. #include <window_manager/oh_display_manager.h>
    4. #include <hilog/log.h>
    
    5. static napi_value GetDefaultDisplayRotation(napi_env env, napi_callback_info info)
    6. {
    7.     NativeDisplayManager_Rotation displayRotation;
    8.     NativeDisplayManager_ErrorCode errCode = OH_NativeDisplayManager_GetDefaultDisplayRotation(&displayRotation);
    9.     if (errCode == NativeDisplayManager_ErrorCode::DISPLAY_MANAGER_OK) {
    10.         napi_value rotation;
    11.         napi_create_int32(env, displayRotation, &rotation);
    12.         return rotation;
    13.     } else {
    14.         napi_value errorCode;
    15.         napi_create_int32(env, errCode, &errorCode);
    16.         return errorCode;
    17.     }
    18. }
    
    19. EXTERN_C_START
    20. static napi_value Init(napi_env env, napi_value exports) {
    21.     napi_property_descriptor desc[] = {
    22.        {"getDisplayRotation", nullptr, GetDefaultDisplayRotation, nullptr, nullptr, nullptr, napi_default, nullptr},
    23.     };
    24.     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    25.     return exports;
    26. }
    27. EXTERN_C_END
    
2. 可以通过OH_NativeDisplayManager_CreateDefaultDisplayCutoutInfo获取挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。 可通过OH_NativeDisplayManager_DestroyDefaultDisplayCutoutInfo销毁挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。
    
    1. #include "napi/native_api.h"
    2. #include <window_manager/oh_display_info.h>
    3. #include <window_manager/oh_display_manager.h>
    4. #include <hilog/log.h>
    
    5. static napi_value CreateDefaultDisplayCutoutInfo(napi_env env, napi_callback_info info)
    6. {
    7.     NativeDisplayManager_CutoutInfo *cutOutInfo = NULL;
    8.     NativeDisplayManager_ErrorCode errCode = OH_NativeDisplayManager_CreateDefaultDisplayCutoutInfo(&cutOutInfo);
    9.     OH_LOG_INFO(LOG_APP, "GetDefaultCutoutInfo errCode=%{public}d", errCode);
    10.     if (errCode == NativeDisplayManager_ErrorCode::DISPLAY_MANAGER_OK) {
    11.         if (cutOutInfo != NULL && cutOutInfo->boundingRectsLength != 0) {
    12.             OH_LOG_INFO(LOG_APP, "GetDefaultCutoutInfo cutOutInfo length=%{public}d", cutOutInfo->boundingRectsLength);
    13.             for (int i = 0; i < cutOutInfo->boundingRectsLength; i++) {
    14.                 OH_LOG_INFO(LOG_APP, "cutOutInfo[%{public}d]=[%{public}d %{public}d %{public}d %{public}d]",
    15.                     i, cutOutInfo->boundingRects[i].left, cutOutInfo->boundingRects[i].top,
    16.                     cutOutInfo->boundingRects[i].width, cutOutInfo->boundingRects[i].height);
    17.             }
    18.             OH_LOG_INFO(LOG_APP, "cutOutInfo waterfall left rect=[%{public}d %{public}d %{public}d %{public}d]",
    19.             cutOutInfo->waterfallDisplayAreaRects.left.left, cutOutInfo->waterfallDisplayAreaRects.left.top,
    20.             cutOutInfo->waterfallDisplayAreaRects.left.width, cutOutInfo->waterfallDisplayAreaRects.left.height);
    21.             OH_LOG_INFO(LOG_APP, "cutOutInfo waterfall top rect=[%{public}d %{public}d %{public}d %{public}d]",
    22.             cutOutInfo->waterfallDisplayAreaRects.top.left, cutOutInfo->waterfallDisplayAreaRects.top.top,
    23.             cutOutInfo->waterfallDisplayAreaRects.top.width, cutOutInfo->waterfallDisplayAreaRects.top.height);
    24.             OH_LOG_INFO(LOG_APP, "cutOutInfo waterfall right rect=[%{public}d %{public}d %{public}d %{public}d]",
    25.             cutOutInfo->waterfallDisplayAreaRects.right.left, cutOutInfo->waterfallDisplayAreaRects.right.top,
    26.             cutOutInfo->waterfallDisplayAreaRects.right.width, cutOutInfo->waterfallDisplayAreaRects.right.height);
    27.             OH_LOG_INFO(LOG_APP, "cutOutInfo waterfall bottom rect=[%{public}d %{public}d %{public}d %{public}d]",
    28.             cutOutInfo->waterfallDisplayAreaRects.bottom.left, cutOutInfo->waterfallDisplayAreaRects.bottom.top,
    29.             cutOutInfo->waterfallDisplayAreaRects.bottom.width, cutOutInfo->waterfallDisplayAreaRects.bottom.height);
    30.         }
    31.         napi_value boundingRectsLength;
    32.         napi_create_int32(env, cutOutInfo->boundingRectsLength, &boundingRectsLength);
    33.         OH_NativeDisplayManager_DestroyDefaultDisplayCutoutInfo(cutOutInfo);
    34.         return boundingRectsLength;
    35.     } else {
    36.         napi_value errorCode;
    37.         napi_create_int32(env, errCode, &errorCode);
    38.         return errorCode;
    39.     }
    40. }
    
    41. EXTERN_C_START
    42. static napi_value Init(napi_env env, napi_value exports) {
    43.     napi_property_descriptor desc[] = {
    44.         {"getCutoutInfo", nullptr, CreateDefaultDisplayCutoutInfo, nullptr, nullptr, nullptr, napi_default, nullptr},
    45.     };
    46.     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    47.     return exports;
    48. }
    49. EXTERN_C_END
    

## 监听屏幕状态变化

可以通过OH_NativeDisplayManager_RegisterDisplayChangeListener接口注册屏幕变化的监听，包括屏幕旋转、分辨率变化、刷新率变化、DPI变化等。 通过OH_NativeDisplayManager_UnregisterDisplayChangeListener接口取消屏幕状态变化的监听。

1. #include "napi/native_api.h"
2. #include <window_manager/oh_display_info.h>
3. #include <window_manager/oh_display_manager.h>
4. #include <hilog/log.h>

5. void DisplayChangeCallback(uint64_t displayId)
6. {
7.     OH_LOG_INFO(LOG_APP, "DisplayChangeCallback displayId=%{public}lu.", displayId);
8. }

9. static napi_value RegisterDisplayChangeListener(napi_env env, napi_callback_info info)
10. {
11.     uint32_t listenerIndex;
12.     NativeDisplayManager_ErrorCode errCode = OH_NativeDisplayManager_RegisterDisplayChangeListener(
13.         DisplayChangeCallback, &listenerIndex);
14.     OH_LOG_INFO(LOG_APP, "RegisterDisplayChangeListener listenerIndex =%{public}d errCode=%{public}d.",
15.         listenerIndex, errCode);
16.     if (errCode == NativeDisplayManager_ErrorCode::DISPLAY_MANAGER_OK) {
17.         napi_value registerIndex;
18.         napi_create_int32(env, listenerIndex, &registerIndex);
19.         return registerIndex;
20.     } else {
21.         napi_value errorCode;
22.         napi_create_int32(env, errCode, &errorCode);
23.         return errorCode;
24.     }
25. }

26. static napi_value UnregisterDisplayChangeListener(napi_env env, napi_callback_info info)
27. {
28.     size_t argc = 1;
29.     napi_value args[1] = { nullptr };

30.     uint32_t listenerIndex;
31.     napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);
32.     napi_get_value_uint32(env, args[0], &listenerIndex);
33.     OH_LOG_INFO(LOG_APP, "UnregisterDisplayChangeListener listenerIndex =%{public}d.", listenerIndex);
34.     NativeDisplayManager_ErrorCode errCode = OH_NativeDisplayManager_UnregisterDisplayChangeListener(listenerIndex);
35.     OH_LOG_INFO(LOG_APP, "UnregisterDisplayChangeListener errCode=%{public}d.", errCode);
36.     napi_value errorCode;
37.     napi_create_int32(env, errCode, &errorCode);
38.     return errorCode;
39. }

40. EXTERN_C_START
41. static napi_value Init(napi_env env, napi_value exports) {
42.     napi_property_descriptor desc[] = {
43.         {"registerDisplayChange", nullptr, RegisterDisplayChangeListener, nullptr, nullptr, nullptr, napi_default, nullptr},
44.         {"unregisterDisplayChange", nullptr, UnregisterDisplayChangeListener, nullptr, nullptr, nullptr,
45.             napi_default, nullptr},
46.     };
47.     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
48.     return exports;
49. }
50. EXTERN_C_END

## 监听折叠设备状态变化

1. 可以通过OH_NativeDisplayManager_IsFoldable接口查询设备是不是折叠设备。
    
    1. #include "napi/native_api.h"
    2. #include <window_manager/oh_display_manager.h>
    3. #include <hilog/log.h>
    
    4. static napi_value IsFoldable(napi_env env, napi_callback_info info)
    5. {
    6.     bool isFoldDevice = OH_NativeDisplayManager_IsFoldable();
    7.     OH_LOG_INFO(LOG_APP, "IsFoldable isFoldDevice =%{public}d.", isFoldDevice);
    8.     napi_value isFold;
    9.     napi_get_boolean(env, isFoldDevice, &isFold);
    10.     return isFold;
    11. }
    
    12. EXTERN_C_START
    13. static napi_value Init(napi_env env, napi_value exports) {
    14.     napi_property_descriptor desc[] = {
    15.         {"checkIsFoldDevice", nullptr, IsFoldable, nullptr, nullptr, nullptr, napi_default, nullptr},
    16.     };
    17.     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    18.     return exports;
    19. }
    20. EXTERN_C_END
    
2. 可以通过OH_NativeDisplayManager_RegisterFoldDisplayModeChangeListener注册屏幕展开/折叠状态变化的监听。 通过OH_NativeDisplayManager_UnregisterFoldDisplayModeChangeListener接口取消屏幕展开/折叠状态变化的监听。
    
    1. #include "napi/native_api.h"
    2. #include <window_manager/oh_display_info.h>
    3. #include <window_manager/oh_display_manager.h>
    4. #include <hilog/log.h>
    
    5. void FoldDisplayModeChangeCallback(NativeDisplayManager_FoldDisplayMode displayMode)
    6. {
    7.     OH_LOG_INFO(LOG_APP, "displayMode=%{public}d.", displayMode);
    8. }
    
    9. static napi_value RegisterFoldDisplayModeChangeListener(napi_env env, napi_callback_info info)
    10. {
    11.     uint32_t listenerIndex = 0;
    12.     NativeDisplayManager_ErrorCode errCode = OH_NativeDisplayManager_RegisterFoldDisplayModeChangeListener(
    13.         FoldDisplayModeChangeCallback, &listenerIndex);
    14.     OH_LOG_INFO(LOG_APP, "listenerIndex =%{public}d errCode=%{public}d.",
    15.         listenerIndex, errCode);
    16.     if (errCode == NativeDisplayManager_ErrorCode::DISPLAY_MANAGER_OK) {
    17.         napi_value registerIndex;
    18.         napi_create_int32(env, listenerIndex, &registerIndex);
    19.         return registerIndex;
    20.     } else {
    21.         napi_value errorCode;
    22.         napi_create_int32(env, errCode, &errorCode);
    23.         return errorCode;
    24.     }
    25. }
    
    26. static napi_value UnregisterFoldDisplayModeChangeListener(napi_env env, napi_callback_info info)
    27. {
    28.     size_t argc = 1;
    29.     napi_value args[1] = { nullptr };
    30.     uint32_t listenerIndex;
    31.     napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);
    32.     napi_get_value_uint32(env, args[0], &listenerIndex);
    33.     OH_LOG_INFO(LOG_APP, "listenerIndex =%{public}d.", listenerIndex);
    34.     NativeDisplayManager_ErrorCode errCode = OH_NativeDisplayManager_UnregisterFoldDisplayModeChangeListener(listenerIndex);
    35.     OH_LOG_INFO(LOG_APP, "errorCode=%{public}d", errCode);
    36.     napi_value errorCode;
    37.     napi_create_int32(env, errCode, &errorCode);
    38.     return errorCode;
    39. }
    
    40. EXTERN_C_START
    41. static napi_value Init(napi_env env, napi_value exports) {
    42.     napi_property_descriptor desc[] = {
    43.     { "registerFoldDisplayModeChange", nullptr, RegisterFoldDisplayModeChangeListener, nullptr, nullptr, nullptr,
    44.         napi_default, nullptr },
    45.     { "unregisterFoldDisplayModeChange", nullptr, UnregisterFoldDisplayModeChangeListener, nullptr, nullptr,
    46.         nullptr, napi_default, nullptr },
    47.     };
    48.     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    49.     return exports;
    50. }
    51. EXTERN_C_END
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/displaymanager-overview "屏幕管理简介")
# 使用Display实现屏幕属性查询及状态监听 (ArkTS)

更新时间: 2025-12-16 16:38

## 场景介绍

[Display](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-display)屏幕属性提供管理设备屏幕的一些基础能力，例如获取默认显示设备的相关信息、获取全部显示设备的信息，此外还能对显示设备的插拔行为进行监听。应用可以根据对应的屏幕信息、屏幕状态变化、屏幕折叠状态等适配不同的UI界面显示。

屏幕属性的常见使用场景有以下几种：

- 查询屏幕信息：包括屏幕的分辨率、物理像素密度、逻辑像素密度、刷新率、屏幕尺寸、屏幕旋转方向、屏幕旋转角度等，具体可见[Display属性](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-display#%E5%B1%9E%E6%80%A7)。
- 监听屏幕状态变化，包括屏幕旋转变化，屏幕分辨率变化、屏幕刷新率变化等。
- 查询当前设备是否为可折叠设备，同时支持折叠状态（展开/折叠）变化的监听。

## 接口说明

屏幕属性的常用接口如下表所示，更多功能及接口说明和使用请见[@ohos.display (屏幕属性)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-display)。

|接口|描述|
|:--|:--|
|getAllDisplays(): Promise<Array<Display>>|获取当前所有的Display对象，使用Promise异步回调。|
|getDefaultDisplaySync(): Display|获取当前默认的Display对象。|
|getDisplayByIdSync(displayId: number): Display|根据DisplayId获取对应的Display对象。|
|on(type: 'add'\|'remove'\|'change', callback: Callback<number>): void|开启显示设备变化的监听。|
|off(type: 'add'\|'remove'\|'change', callback?: Callback<number>): void|关闭显示设备变化的监听。|
|on(type: 'captureStatusChange', callback: Callback<boolean>): void|开启屏幕截屏、投屏、录屏状态变化的监听。|
|off(type: 'captureStatusChange', callback?: Callback<boolean>): void|关闭屏幕截屏、投屏、录屏状态变化的监听。|
|on(type: 'availableAreaChange', callback: Callback<Rect>): void|开启当前设备屏幕的可用区域监听。当前设备屏幕有可用区域变化时，触发回调函数，返回可用区域。|
|off(type: 'availableAreaChange', callback?: Callback<Rect>): void|关闭当前设备屏幕可用区域变化的监听。|
|isFoldable(): boolean|检查设备是否可折叠，true表示设备可折叠，false表示设备不可折叠。|
|on(type: 'foldStatusChange', callback: Callback<FoldStatus>): void|开启折叠设备折叠状态变化的监听。|
|off(type: 'foldStatusChange', callback?: Callback<FoldStatus>): void|关闭折叠设备折叠状态变化的监听。|

## 获取Display对象

Display对象，即屏幕实例，提供屏幕相关属性及监听变化的接口。目前有以下几种不同获取Display的方式，开发者可根据具体场景需要选择使用。

- 获取当前默认的Display对象：使用getDefaultDisplaySync()接口获取。
- 获取当前所有Display对象：使用getAllDisplays()获取。
- 根据屏幕Id获取对应的Display对象：使用getDisplayByIdSync()接口获取。

此处，以使用getDefaultDisplaySync()获取当前默认Display对象为例，示例如下：

1. import { display } from '@kit.ArkUI';

2. let displayClass: display.Display | null = null;
3. try {
4.   displayClass = display.getDefaultDisplaySync();
5. } catch (exception) {
6.   console.error(`Failed to get default display. Code: ${exception.code}, message: ${exception.message}`);
7. }
8. // 确保获取到Display对象，即displayClass，再进行后续相关屏幕属性信息查询和事件/状态变化监听

## 获取屏幕相关属性

1. 确保获取到Display对象之后（具体可见[获取Display对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/screenproperty-guideline#%E8%8E%B7%E5%8F%96display%E5%AF%B9%E8%B1%A1)），可以通过相关属性查询屏幕的一些基础信息。
    
    1. import { display } from '@kit.ArkUI';
    
    2. let displayClass: display.Display | null = null;
    3. try {
    4.  displayClass = display.getDefaultDisplaySync();
    5.  // 获取屏幕Id
    6.  console.info(`The screen Id is ${displayClass.id}.`);
    7.  // 获取屏幕刷新率
    8.  console.info(`The screen is ${displayClass.refreshRate}.`);
    9.  // 获取屏幕宽度
    10.  console.info(`The screen width is ${displayClass.width}.`);
    11.  // 获取屏幕高度
    12.  console.info(`The screen height is ${displayClass.height}.`);
    13. // ...
    14. } catch (exception) {
    15.  console.error(`Failed to get default display. Code: ${exception.code}, message: ${exception.message}`);
    16. }
    
2. 还可以通过getCutoutInfo()获取挖孔屏、刘海屏、瀑布屏等不可用的屏幕区域信息，以在UI布局时更好地规避该区域。也可以通过getAvailableArea()获取当前设备屏幕的可用区域。
    
    1. import { BusinessError } from '@kit.BasicServicesKit';
    
    2. displayClass.getCutoutInfo().then((cutoutInfo: display.CutoutInfo) => {
    3.   console.info('Succeeded in getting cutoutInfo. Data: ' + JSON.stringify(cutoutInfo));
    4. }).catch((err: BusinessError) => {
    5.   console.error(`Failed to obtain all the display objects. Code: ${err.code}, message: ${err.message}`);
    6. });
    
    7. displayClass.getAvailableArea().then((availableArea) => {
    8.   console.info('Succeeded get the available area in this display. data: ' + JSON.stringify(availableArea));
    9. }).catch((err: BusinessError) => {
    10.   console.error(`Failed to get the available area in this display. Code: ${err.code}, message: ${err.message}`);
    11. });
    
3. 此外，还可以通过display.isCaptured()判断当前设备是否正在截屏、投屏或录屏。
    
    1. console.info(`The screen is captured or not : ${display.isCaptured()}`);
    

## 监听屏幕状态变化

1. 可以通过display.on('add'|'remove'|'change')监听设备屏幕变化，支持监听屏幕设备的增加、移除和改变等，可以通过display.off('add'|'remove'|'change')关闭对应的监听。
    
    1. import { display } from '@kit.ArkUI';
    2. import { Callback } from '@kit.BasicServicesKit';
    
    3. let callback1: Callback<number> = (data: number) => {
    4.   console.info('Listening enabled. Data: ' + JSON.stringify(data));
    5. };
    6. // 此处以监听显示设备的增加为例
    7. display.on("add", callback1);
    
    8. // 关闭单个callback监听
    9. display.off('add', callback1);
    10. // 如果通过on注册多个callback，同时关闭所有callback监听
    11. display.off("add");
    
2. 可以通过display.on('captureStatusChange')开启屏幕截屏、投屏或录屏状态变化的监听；可以通过display.off('captureStatusChange')关闭对应的监听。
    
    1. let callback2: Callback<boolean> = (captureStatus: boolean) => {
    2.     // captureStatus为true表示显示设备开始截屏、投屏或录屏，false表示结束截屏、投屏或录屏
    3.   console.info('Listening capture status: ' + captureStatus);
    4. };
    5. // 开启屏幕截屏、投屏、录屏状态变化的监听
    6. display.on('captureStatusChange', callback2);
    
    7. display.off('captureStatusChange', callback2);
    
3. 此外，还可以通过on('availableAreaChange')监听当前屏幕对象（Display对象）的可用区域变化；可通过off('availableAreaChange')关闭对应的监听。
    
    1. import { Callback } from '@kit.BasicServicesKit';
    2. import { display } from '@kit.ArkUI';
    
    3. let callback3: Callback<display.Rect> = (data: display.Rect) => {
    4.   console.info('Listening enabled. Data: ' + JSON.stringify(data));
    5. };
    6. let displayClass: display.Display | null = null;
    7. try {
    8.   displayClass = display.getDefaultDisplaySync();
    9.   // 开启当前屏幕可用区域变化的监听
    10.   displayClass.on('availableAreaChange', callback3);
    11.   // 关闭当前监听
    12.   displayClass.off('availableAreaChange', callback3);
    13. } catch (exception) {
    14.   console.error(`Failed to register/unregister callback. Code: ${exception.code}, message: ${exception.message}`);
    15. }
    

## 监听折叠设备状态变化

1. 可以通过display.isFoldable()接口查询当前设备是不是折叠设备。
    
    1. import { display } from '@kit.ArkUI';
    
    2. let ret: boolean = false;
    3. ret = display.isFoldable();
    
2. 若当前设备为折叠设备，可以通过display.on('foldStatusChange')开启折叠设备折叠状态变化的监听；可通过display.off('foldStatusChange')关闭对应的监听。
    
    1. import { Callback } from '@kit.BasicServicesKit';
    
    2. /**
    3.  * 注册监听的callback参数要采用对象传递.
    4.  * 若使用匿名函数注册，每次调用会创建一个新的底层对象，引起内存泄漏问题。
    5. */
    6. let callback: Callback<display.FoldStatus> = (data: display.FoldStatus) => {
    7.   console.info('Listening enabled. Data: ' + JSON.stringify(data));
    8. };
    9. display.on('foldStatusChange', callback);
    
    10. // 如果通过on注册多个callback，同时关闭所有callback监听
    11. display.off('foldStatusChange');
    12. // 关闭单个callback监听
    13. display.off('foldStatusChange', callback);
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-display-manager "使用OH_DisplayManager实现屏幕基础信息查询和状态监听 (C/C++)")
# 屏幕开发常见问题

更新时间: 2025-12-16 16:38

## 三折叠设备中，调用on('FoldDisplayModeChange')监听接口获取到的FoldDisplayMode值为5代表什么含义

**问题现象**

三折叠设备中，调用[on('foldDisplayModeChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-display#displayonfolddisplaymodechange10)接口监听显示模式变化获取到的值为5，而调用[getFoldDisplayMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-display#displaygetfolddisplaymode10)接口时的返回值却不是5。

**产生原因**

1. FoldDisplayMode=5的含义
    
    在三折叠设备中，当FoldDisplayMode的值为5时，表示设备当前处于全展开显示模式，即三块屏幕完全展开，设备以最大可用屏幕尺寸进行内容展示。
    
2. on('foldDisplayModeChange')返回5的原因
    
    on('foldDisplayModeChange')接口用于实时监听设备显示状态的变化，因此会返回包括5在内的所有实际显示模式值。当监听到值为5时，可以判断设备已进入全展开状态。
    
3. 调用getFoldDisplayMode()接口不返回5的原因
    
    为了降低多设备适配的开发成本，不与设备形态绑定，因此getFoldDisplayMode()接口不返回5，开发者需要通过统一的断点管理机制来适配不同显示状态，采用“[一次开发，多端部署](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-device-overview)”方案进行开发，简化布局适配的开发流程。
    

**开发建议**

虽然通过监听事件可以获取到FoldDisplayMode为5并进行特定处理，但为了更好的开发效率和兼容性，建议使用“[一次开发，多端部署](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-device-overview)”方案进行UI布局适配，其中三折叠应用开发可见[三折叠应用开发](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-matext-guide)。这样不仅能减少重复开发工作，还能确保应用在多种设备上的一致性和稳定性。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/screenproperty-guideline "使用Display实现屏幕属性查询及状态监听 (ArkTS)")
