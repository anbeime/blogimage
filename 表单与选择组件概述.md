# 按钮 (Button)

更新时间: 2025-12-16 16:39

Button是按钮组件，通常用于响应用户的点击操作，其类型包括胶囊按钮、圆形按钮、普通按钮、圆角矩形按钮。Button作为容器使用时可以通过添加子组件实现包含文字、图片等元素的按钮。具体用法请参考[Button](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button)。

## 创建按钮

Button通过调用接口来创建，接口调用有以下两种形式：

- 通过label和[ButtonOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button#buttonoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)创建不包含子组件的按钮。以ButtonOptions中的type和stateEffect为例。
    
    1. Button(label?: ResourceStr, options?: { type?: ButtonType, stateEffect?: boolean })
    
    其中，label用来设置按钮文字，type用于设置Button类型，stateEffect属性设置Button是否开启点击效果。
    
    2. Button('Ok', { type: ButtonType.Normal, stateEffect: true })
    3.   .borderRadius(8)
    4.   .backgroundColor(0x317aff)
    5.   .width(90)
    6.   .height(40)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.48735471090824010955679180324272:50001231000000:2800:A70CB07D19042FADAAEA76169BC0BA54BBCEF72EC508AC675B7FDEA23951F9ED.png)
    
- 通过[ButtonOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button#buttonoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)创建包含子组件的按钮。以ButtonOptions中的type和stateEffect为例。
    
    1. Button(options?: {type?: ButtonType, stateEffect?: boolean})
    
    只支持包含一个子组件，子组件可以是基础组件或者容器组件。
    
    2. Button({ type: ButtonType.Normal, stateEffect: true }) {
    3.   Row() {
    4.     Image($r('app.media.loading')).width(20).height(40).margin({ left: 12 })
    5.     Text('loading').fontSize(12).fontColor(0xffffff).margin({ left: 5, right: 12 })
    6.   }.alignItems(VerticalAlign.Center)
    7. }.borderRadius(8).backgroundColor(0x317aff).width(90).height(40)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.76299416517273180245910745509559:50001231000000:2800:4D8FB1D449E82C2F7E1203D046B7FC191ED241AD38B20C242B594C596A70261E.png)
    

## 设置按钮类型

Button有四种可选类型，分别为胶囊类型（Capsule）、圆形按钮（Circle）、普通按钮（Normal）和圆角矩形按钮（ROUNDED_RECTANGLE），通过type进行设置。

- 胶囊按钮（默认类型）。
    
    此类型按钮的圆角自动设置为高度的一半，不支持通过borderRadius属性重新设置圆角。
    
    1. Button('Disable', { type: ButtonType.Capsule, stateEffect: false })
    2.   .backgroundColor(0x317aff)
    3.   .width(90)
    4.   .height(40)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.44852461639285259344931446930804:50001231000000:2800:98F32100644D7D8805D37ADD6D8F00B7E84BDF622DC6C08F57834876BC364067.png)
    
- 圆形按钮。
    
    此类型按钮为圆形，不支持通过borderRadius属性重新设置圆角。
    
    1. Button('Circle', { type: ButtonType.Circle, stateEffect: false })
    2.   .backgroundColor(0x317aff)
    3.   .width(90)
    4.   .height(90)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.48952318876916903295619820328914:50001231000000:2800:BAB1F3ADC5131269D95E8935074955EF37B75992C3155C35E6359F63C9269C68.png)
    
- 普通按钮。
    
    此类型的按钮默认圆角为0，支持通过borderRadius属性重新设置圆角。
    
    1. Button('Ok', { type: ButtonType.Normal, stateEffect: true })
    2.   .borderRadius(8)
    3.   .backgroundColor(0x317aff)
    4.   .width(90)
    5.   .height(40)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.49839306010940134999975724872424:50001231000000:2800:1EFC94C0D4D684F1727EE879C686687EEB2547623F24332EA52E746D678FBDCD.png)
    
- 圆角矩形按钮。
    
    当[controlSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button#controlsize11)为NORMAL时，默认圆角大小为20vp，[controlSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-button#controlsize11)为SMALL时，圆角大小为14vp，支持通过borderRadius属性重新设置圆角。
    
    1. Button('Disable', { type: ButtonType.ROUNDED_RECTANGLE, stateEffect: true })
    2.   .backgroundColor(0x317aff)
    3.   .width(90)
    4.   .height(40)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.32867550326515805576867253781606:50001231000000:2800:30BECF45C996E463A0E901A3FDDD46EFF4A2829DE6913D6EAEEFC2AF0971D94C.png)
    

## 自定义样式

- 设置边框弧度。
    
    使用通用属性来自定义按钮样式。例如通过borderRadius属性设置按钮的边框弧度。
    
    1. Button('circle border', { type: ButtonType.Normal })
    2.   .borderRadius(20)
    3.   .height(40)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.89711763732221911420647944492129:50001231000000:2800:8DEA68C775271069F02D994F7D6512B04EC0F1728207584D9C096DBF90459B23.png)
    
- 设置文本样式。
    
    通过添加文本样式设置按钮文本的展示样式。
    
    1. Button('font style', { type: ButtonType.Normal })
    2.   .fontSize(20)
    3.   .fontColor(Color.Pink)
    4.   .fontWeight(800)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.33588878530236950544444144394074:50001231000000:2800:7F66EF15912979997B3AA9B59069FE567729229FCF47A6C43CFCCFA570240121.png)
    
- 设置背景颜色。
    
    添加backgroundColor属性设置按钮的背景颜色。
    
    1. Button('background color').backgroundColor(0xF55A42)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.55582860005793339190494853668560:50001231000000:2800:6714E5D691FBA43D2B6ECF0B9E11C92EE0CB7C2067F6D085B70427938D42FDF5.png)
    
- 创建功能型按钮。
    

创建删除操作的按钮。

1. let MarLeft: Record<string, number> = { 'left': 20 }
2. Button({ type: ButtonType.Circle, stateEffect: true }) {
3.   Image($r('app.media.ic_public_delete_filled')).width(30).height(30)
4. }.width(55).height(55).margin(MarLeft).backgroundColor(0xF55A42)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.54914221836042499493481838801963:50001231000000:2800:A8B0FAD21D3DF8EB9C4934EEFF0351120403C99B6A5EFFC876E737A4CF949146.png)

## 添加事件

Button组件通常用于触发某些操作，可以绑定onClick事件来响应点击操作后的自定义行为。

1. Button('Ok', { type: ButtonType.Normal, stateEffect: true })
2.   .onClick(()=>{
3.     console.info('Button onClick')
4.   })

## 场景示例

- 用于启动操作。
    
    可以用按钮启动任何用户界面元素，按钮会根据用户的操作触发相应的事件。例如，在List容器里通过点击按钮进行页面跳转。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ButtonCase1 {
    5.   pathStack: NavPathStack = new NavPathStack();
    
    6.   @Builder
    7.   PageMap(name: string) {
    8.     if (name === "first_page") {
    9.       pageOneTmp()
    10.     } else if (name === "second_page") {
    11.       pageTwoTmp()
    12.     } else if (name === "third_page") {
    13.       pageThreeTmp()
    14.     }
    15.   }
    
    16.   build() {
    17.     Navigation(this.pathStack) {
    18.       List({ space: 4 }) {
    19.         ListItem() {
    20.           Button("First").onClick(() => {
    21.             this.pathStack.pushPath({ name: "first_page"});
    22.           })
    23.             .width('100%')
    24.         }
    
    25.         ListItem() {
    26.           Button("Second").onClick(() => {
    27.             this.pathStack.pushPath({ name: "second_page"});
    28.           })
    29.             .width('100%')
    30.         }
    
    31.         ListItem() {
    32.           Button("Third").onClick(() => {
    33.             this.pathStack.pushPath({ name: "third_page"});
    34.           })
    35.             .width('100%')
    36.         }
    37.       }
    38.       .listDirection(Axis.Vertical)
    39.       .backgroundColor(0xDCDCDC).padding(20)
    40.     }
    41.     .mode(NavigationMode.Stack)
    42.     .navDestination(this.PageMap)
    43.   }
    44. }
    
    45. // pageOne
    46. @Component
    47. export struct pageOneTmp {
    48.   pathStack: NavPathStack = new NavPathStack();
    
    49.   build() {
    50.     NavDestination() {
    51.       Column() {
    52.         Text("first_page")
    53.       }.width('100%').height('100%')
    54.     }.title("pageOne")
    55.     .onBackPressed(() => {
    56.       const popDestinationInfo = this.pathStack.pop(); // 弹出路由栈栈顶元素
    57.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
    58.       return true
    59.     })
    60.     .onReady((context: NavDestinationContext) => {
    61.       this.pathStack = context.pathStack;
    62.     })
    63.   }
    64. }
    
    65. // pageTwo
    66. @Component
    67. export struct pageTwoTmp {
    68.   pathStack: NavPathStack = new NavPathStack();
    
    69.   build() {
    70.     NavDestination() {
    71.       Column() {
    72.         Text("second_page")
    73.       }.width('100%').height('100%')
    74.     }.title("pageTwo")
    75.     .onBackPressed(() => {
    76.       const popDestinationInfo = this.pathStack.pop(); // 弹出路由栈栈顶元素
    77.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
    78.       return true
    79.     })
    80.     .onReady((context: NavDestinationContext) => {
    81.       this.pathStack = context.pathStack;
    82.     })
    83.   }
    84. }
    
    85. // pageThree
    86. @Component
    87. export struct pageThreeTmp {
    88.   pathStack: NavPathStack = new NavPathStack();
    
    89.   build() {
    90.     NavDestination() {
    91.       Column() {
    92.         Text("third_page")
    93.       }.width('100%').height('100%')
    94.     }.title("pageThree")
    95.     .onBackPressed(() => {
    96.       const popDestinationInfo = this.pathStack.pop(); // 弹出路由栈栈顶元素
    97.       console.info('pop' + '返回值' + JSON.stringify(popDestinationInfo));
    98.       return true
    99.     })
    100.     .onReady((context: NavDestinationContext) => {
    101.       this.pathStack = context.pathStack;
    102.     })
    103.   }
    104. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.33010771898163815238151760700289:50001231000000:2800:FB7651232DC4EA0DF073411103A19BCCFDA430FFBFA65EF89EEC0B03809E7FC3.gif)
    
- 用于提交表单。
    
    在用户登录/注册页面，使用按钮进行登录或注册操作。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ButtonCase2 {
    5.   build() {
    6.     Column() {
    7.       TextInput({ placeholder: 'input your username' }).margin({ top: 20 })
    8.       TextInput({ placeholder: 'input your password' }).type(InputType.Password).margin({ top: 20 })
    9.       Button('Register').width(300).margin({ top: 20 })
    10.         .onClick(() => {
    11.           // 需要执行的操作
    12.         })
    13.     }.padding(20)
    14.   }
    15. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.89544586776251987716205807503057:50001231000000:2800:23B8BC436E86FD0B82F3C00F787734553118D7DF00D49CC13EACB38787A09731.png)
    
- 悬浮按钮。
    
    在可以滑动的界面，滑动时按钮始终保持悬浮状态。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct HoverButtonExample {
    5.   private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    6.   build() {
    7.     Stack() {
    8.       List({ space: 20, initialIndex: 0 }) {
    9.         ForEach(this.arr, (item:number) => {
    10.           ListItem() {
    11.             Text('' + item)
    12.               .width('100%').height(100).fontSize(16)
    13.               .textAlign(TextAlign.Center).borderRadius(10).backgroundColor(0xFFFFFF)
    14.           }
    15.         }, (item:number) => item.toString())
    16.       }.width('90%')
    17.       Button() {
    18.         Image($r('app.media.ic_public_add'))
    19.           .width(50)
    20.           .height(50)
    21.       }
    22.       .width(60)
    23.       .height(60)
    24.       .position({x: '80%', y: 600})
    25.       .shadow({radius: 10})
    26.       .onClick(() => {
    27.         // 需要执行的操作
    28.       })
    29.     }
    30.     .width('100%')
    31.     .height('100%')
    32.     .backgroundColor(0xDCDCDC)
    33.     .padding({ top: 5 })
    34.   }
    35. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163919.58325577727979731466286181446850:50001231000000:2800:3FC8B42573FCC8103F29000263849C99586DA9E9A6D01C33E33A599D341D684C.gif)
    

[表单与选择组件概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-forms-overview "表单与选择组件概述")
# 弧形按钮 (ArcButton)

更新时间: 2025-12-16 16:39

从API version 18开始支持ArcButton。ArcButton是弧形按钮组件，用于圆形屏幕。为手表用户提供强调、普通、警告等样式按钮。具体用法请参考[ArcButton](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton)。

## 创建按钮

ArcButton通过调用以下接口来创建。

1. ArcButton({
2.   options: new ArcButtonOptions({
3.     label: 'OK',
4.     position: ArcButtonPosition.TOP_EDGE,
5.     styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT
6.   })
7. })

其中，[label](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)设置按钮文字，[position](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)设置按钮类型，[styleMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)设置按钮样式。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.40592645885091266013439837792005:50001231000000:2800:BA4BFDD41C78EC9A7FF49B3D7BBFB131A250060C4D371248EB9F58E6EEA47135.png)

## 设置按钮类型

ArcButton有上弧形按钮和下弧形按钮两种类型。使用[position](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)设置按钮类型。

- 下弧形按钮（默认类型）。
    
    通过将[position](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)属性设置为ArcButtonPosition.BOTTOM_EDGE，可以将按钮设置为下弧形按钮。
    
    1. ArcButton({
    2.   options: new ArcButtonOptions({
    3.     label: 'OK',
    4.     position: ArcButtonPosition.BOTTOM_EDGE,
    5.     styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT
    6.   })
    7. })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.65321421033316599011139904818232:50001231000000:2800:17EA15867E0DC50A829C3E16118897F57CA42A6A0CED9128A94B259FAE6EB5F6.png)
    
- 上弧形按钮。
    
    通过将[position](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)属性设置为ArcButtonPosition.TOP_EDGE，可以将按钮设置为上弧形按钮。
    
    1. ArcButton({
    2.   options: new ArcButtonOptions({
    3.     label: 'OK',
    4.     position: ArcButtonPosition.TOP_EDGE,
    5.     styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT
    6.   })
    7. })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.63636444545043532615981242021296:50001231000000:2800:76BEE66A016CA9972ECF65BCEBCCE7404E09B58808E0AEEA9BA6AEDE781B65FA.png)
    

## 自定义样式

- 设置背景色。
    
    使用[backgroundColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)属性设置按钮的背景色。
    
    1. ArcButton({
    2.   options: new ArcButtonOptions({
    3.     label: 'OK',
    4.     styleMode: ArcButtonStyleMode.CUSTOM,
    5.     backgroundColor: ColorMetrics.resourceColor('#707070')
    6.   })
    7. })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.74761140474772704668578399565671:50001231000000:2800:BE7868BB967E5A369C5A8711ADB0A7D9CF4F6067569C2511D1E13D40908E5AC1.png)
    
- 设置文本颜色。
    
    使用[fontColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)属性设置按钮的文本颜色。
    
    1. ArcButton({
    2.   options: new ArcButtonOptions({
    3.     label: 'OK',
    4.     styleMode: ArcButtonStyleMode.CUSTOM,
    5.     backgroundColor: ColorMetrics.resourceColor('#E84026'),
    6.     fontColor: ColorMetrics.resourceColor('#707070')
    7.   })
    8. })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.74182900420347828889330277620231:50001231000000:2800:F7CEF39A35990A22D0E7D7B25A541601929A173B77B696FD8CC4208F53D65F7A.png)
    
- 设置阴影颜色。
    
    使用[shadowEnabled](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)属性启用按钮阴影，并通过[shadowColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-arcbutton#arcbuttonoptions)属性设置按钮的阴影颜色。
    
    1. ArcButton({
    2.   options: new ArcButtonOptions({
    3.     label: 'OK',
    4.     shadowEnabled: true,
    5.     shadowColor: ColorMetrics.resourceColor('#ffec1022')
    6.   })
    7. })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.58152362901423796636332143447974:50001231000000:2800:D18645B3881A033BBF27E278CFAB36D342B14BD5AD712BAEF489C7D03B51C440.png)
    

## 添加事件

- 绑定onClick事件来响应点击操作后的自定义行为。
    
    1. ArcButton({
    2.   options: new ArcButtonOptions({
    3.     label: 'OK',
    4.     onClick: () => {
    5.       console.info('ArcButton onClick')
    6.     }
    7.   })
    8. })
    
- 绑定onTouch事件来响应触摸操作后的自定义行为。
    
    1. ArcButton({
    2.   options: new ArcButtonOptions({
    3.     label: 'OK',
    4.     onTouch: (event: TouchEvent) => {
    5.       console.info('ArcButton onTouch')
    6.     }
    7.   })
    8. })
    

## 场景示例

在亮度设置界面，进度条显示当前亮度为30%。点击重置后，亮度值将被重置为默认的50%。

运行该示例需要Wearable设备的支持。在src/main目录下的工程配置文件[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中[deviceTypes标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#devicetypes%E6%A0%87%E7%AD%BE)内配置wearable。

1. // module.json5
2. {
3.   "module": {
4.     // ...
5.     "deviceTypes": [
6.       "wearable",
7.       "phone"
8.     ]
9.     // ...
10.   }
11. }

12. import { LengthMetrics, LengthUnit, ArcButton, ArcButtonOptions, ArcButtonStyleMode } from '@kit.ArkUI';

13. @Entry
14. @ComponentV2
15. struct BrightnessPage {
16.   @Local brightnessValue: number = 30;
17.   private defaultBrightnessValue: number = 50;

18.   build() {
19.     RelativeContainer() {
20.       Text('设置亮度')
21.         .fontColor(Color.White)
22.         .id('id_brightness_set_text')
23.         .fontSize(24)
24.         .margin({ top: 16 })
25.         .alignRules({
26.           middle: { anchor: '__container__', align: HorizontalAlign.Center }
27.         })

28.       Text(`${this.brightnessValue} %`)
29.         .fontColor(Color.White)
30.         .id('id_brightness_min_text')
31.         .margin({ left: 16 })
32.         .alignRules({
33.           start: { anchor: '__container__', align: HorizontalAlign.Start },
34.           center: { anchor: '__container__', align: VerticalAlign.Center }
35.         })

36.       Slider({
37.         value: this.brightnessValue,
38.         min: 0,
39.         max: 100,
40.         style: SliderStyle.InSet
41.       })
42.         .blockColor('#191970')
43.         .trackColor('#ADD8E6')
44.         .selectedColor('#4169E1')
45.         .width(150)
46.         .id('id_brightness_slider')
47.         .margin({ left: 16, right: 16 })
48.         .onChange((value: number, mode: SliderChangeMode) => {
49.           this.brightnessValue = value;
50.         })
51.         .alignRules({
52.           center: { anchor: 'id_brightness_min_text', align: VerticalAlign.Center },
53.           start: { anchor: 'id_brightness_min_text', align: HorizontalAlign.End }
54.         })

55.       ArcButton({
56.         options: new ArcButtonOptions({
57.           label: '重置',
58.           styleMode: ArcButtonStyleMode.EMPHASIZED_LIGHT,
59.           fontSize: new LengthMetrics(19, LengthUnit.FP),
60.           onClick: () => {
61.             this.brightnessValue = this.defaultBrightnessValue;
62.           }
63.         })
64.       })
65.         .alignRules({
66.           middle: { anchor: '__container__', align: HorizontalAlign.Center },
67.           bottom: { anchor: '__container__', align: VerticalAlign.Bottom }
68.         })
69.     }
70.     .height('100%')
71.     .width('100%')
72.     .backgroundColor(Color.Black)
73.   }
74. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.63941195127920536924629852849221:50001231000000:2800:63098CDCE3DC577B45D6ED7A93F39060C5897B708B631F8C148A389D1123DC88.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-button "按钮 (Button)")

# 单选框 (Radio)

更新时间: 2025-12-16 16:39

Radio是单选框组件，通常用于提供相应的用户交互选择项，同一组的Radio中只有一个可以被选中。具体用法请参考[Radio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-radio)。

## 创建单选框

Radio通过调用[RadioOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-radio#radiooptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)来创建，以RadioOptions中的value和group为例：

1. Radio(options: {value: string, group: string})

其中，value是单选框的名称，group是单选框的所属群组名称。checked属性可以设置单选框的状态，状态分别为false和true，设置为true时表示单选框被选中。

Radio支持设置选中状态和非选中状态的样式。

1. Radio({ value: 'Radio1', group: 'radioGroup' })
2.   .checked(false)
3. Radio({ value: 'Radio2', group: 'radioGroup' })
4.   .checked(true)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.11292523839678813927943023808807:50001231000000:2800:A34C0A54483E0285E0AD9E06A21752A205C6BA7564EB1F5FD66657A0AF716C70.png)

## 添加事件

除支持[通用事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-component-general-events)外，Radio还用于选中后触发某些操作，可以绑定onChange事件来响应选中操作后的自定义行为。

1.   Radio({ value: 'Radio1', group: 'radioGroup' })
2.     .onChange((isChecked: boolean) => {
3.       if(isChecked) {
4.         //需要执行的操作
5.       }
6.     })
7.   Radio({ value: 'Radio2', group: 'radioGroup' })
8.     .onChange((isChecked: boolean) => {
9.       if(isChecked) {
10.         //需要执行的操作
11.       }
12.     })

## 场景示例

通过点击Radio切换声音模式。

1. // xxx.ets
2. import { promptAction } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct RadioExample {
6.   @State Rst: promptAction.ShowToastOptions = { 'message': 'Ringing mode.' };
7.   @State Vst: promptAction.ShowToastOptions = { 'message': 'Vibration mode.' };
8.   @State Sst: promptAction.ShowToastOptions = { 'message': 'Silent mode.' };

9.   build() {
10.     Row() {
11.       Column() {
12.         Radio({ value: 'Radio1', group: 'radioGroup' }).checked(true)
13.           .height(50)
14.           .width(50)
15.           .onChange((isChecked: boolean) => {
16.             if (isChecked) {
17.               // 切换为响铃模式
18.               this.getUIContext().getPromptAction().showToast(this.Rst);
19.             }
20.           })
21.         Text('Ringing')
22.       }

23.       Column() {
24.         Radio({ value: 'Radio2', group: 'radioGroup' })
25.           .height(50)
26.           .width(50)
27.           .onChange((isChecked: boolean) => {
28.             if (isChecked) {
29.               // 切换为振动模式
30.               this.getUIContext().getPromptAction().showToast(this.Vst);
31.             }
32.           })
33.         Text('Vibration')
34.       }

35.       Column() {
36.         Radio({ value: 'Radio3', group: 'radioGroup' })
37.           .height(50)
38.           .width(50)
39.           .onChange((isChecked: boolean) => {
40.             if (isChecked) {
41.               // 切换为静音模式
42.               this.getUIContext().getPromptAction().showToast(this.Sst);
43.             }
44.           })
45.         Text('Silent')
46.       }
47.     }.height('100%').width('100%').justifyContent(FlexAlign.Center)
48.   }
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163950.73860700956108613050233922544230:50001231000000:2800:C27098831755C3465870E03EB18AE14357B6A0576C18F4E63ADD5D4028A69843.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-advanced-components-arcbutton "弧形按钮 (ArcButton)")
# 切换按钮 (Toggle)

更新时间: 2025-12-16 16:39

Toggle组件提供状态按钮样式、勾选框样式和开关样式，一般用于两种状态之间的切换。具体用法请参考[Toggle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-toggle)。

## 创建切换按钮

Toggle通过调用[ToggleOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-toggle#toggleoptions18%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)来创建，具体调用形式如下：

1. Toggle(options: { type: ToggleType, isOn?: boolean })

其中，ToggleType为开关类型，包括Button、Checkbox和Switch，isOn为切换按钮的状态。

API version 11开始，Checkbox默认样式由圆角方形变为圆形。

接口调用有以下两种形式：

- 创建不包含子组件的Toggle。
    
    当ToggleType为Checkbox或者Switch时，用于创建不包含子组件的Toggle：
    
    1. Toggle({ type: ToggleType.Checkbox, isOn: false })
    2. Toggle({ type: ToggleType.Checkbox, isOn: true })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.54628697033111647731742650419454:50001231000000:2800:3FB116EEF8404D9D0AF794D30FE71D087061A2B37A547E44080599B1698E62F3.png)
    
    1. Toggle({ type: ToggleType.Switch, isOn: false })
    2. Toggle({ type: ToggleType.Switch, isOn: true })
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.82249823037731770259305716867615:50001231000000:2800:2FA934335FA9CC1938AD71FDED636ED3677B00CA55DCD868C485BFEFEDFA842C.png)
    
- 创建包含子组件的Toggle。
    
    当ToggleType为Button时，只能包含一个子组件，如果子组件有文本设置，则相应的文本内容会显示在按钮上。
    
    1. Toggle({ type: ToggleType.Button, isOn: false }) {
    2.   Text('status button')
    3.     .fontColor('#182431')
    4.     .fontSize(12)
    5. }.width(100)
    6. Toggle({ type: ToggleType.Button, isOn: true }) {
    7.   Text('status button')
    8.     .fontColor('#182431')
    9.     .fontSize(12)
    10. }.width(100)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163956.03309670528326233435716627011998:50001231000000:2800:1D819F8696458A9C671BAD927CCD48CDBE4C37B45B6DA98F0A7000502F3A769D.png)
    

## 自定义样式

- 通过selectedColor属性设置Toggle打开选中后的背景颜色。
    
    1. Toggle({ type: ToggleType.Button, isOn: true }) {
    2.   Text('status button')
    3.   .fontColor('#182431')
    4.   .fontSize(12)
    5. }.width(100).selectedColor(Color.Pink)
    6. Toggle({ type: ToggleType.Checkbox, isOn: true })
    7.   .selectedColor(Color.Pink)
    8. Toggle({ type: ToggleType.Switch, isOn: true })
    9.   .selectedColor(Color.Pink)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163957.36671078762386622090099757801632:50001231000000:2800:90777353876F8515FC38F4AA408DD65A10613035767B2696BE87883692996A6D.png)
    
- 通过switchPointColor属性设置Switch类型的圆形滑块颜色，仅对type为ToggleType.Switch生效。
    
    1. Toggle({ type: ToggleType.Switch, isOn: false })
    2.   .switchPointColor(Color.Pink)
    3. Toggle({ type: ToggleType.Switch, isOn: true })
    4.   .switchPointColor(Color.Pink)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163957.51137998133246330881588103161110:50001231000000:2800:47E14EEE96D22CBA6FCDE5E4FBF12226748BF07DC039A8E3CD26A2B6C080B275.png)
    

## 添加事件

除支持[通用事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-component-general-events)外，Toggle还用于选中和取消选中后触发某些操作，可以绑定onChange事件来响应操作后的自定义行为。

1. Toggle({ type: ToggleType.Switch, isOn: false })
2.   .onChange((isOn: boolean) => {
3.       if(isOn) {
4.         // 需要执行的操作
5.       }
6.   })

## 场景示例

Toggle用于切换蓝牙开关状态。

1. // xxx.ets
2. import { promptAction } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ToggleExample {
6.   @State bOnSt: promptAction.ShowToastOptions = { 'message': 'Bluetooth is on.' };
7.   @State bOffSt: promptAction.ShowToastOptions = { 'message': 'Bluetooth is off.' };

8.   build() {
9.     Column() {
10.       Row() {
11.         Text("Bluetooth Mode")
12.           .height(50)
13.           .fontSize(16)
14.       }

15.       Row() {
16.         Text("Bluetooth")
17.           .height(50)
18.           .padding({ left: 10 })
19.           .fontSize(16)
20.           .textAlign(TextAlign.Start)
21.           .backgroundColor(0xFFFFFF)
22.         Toggle({ type: ToggleType.Switch })
23.           .margin({ left: 200, right: 10 })
24.           .onChange((isOn: boolean) => {
25.             if (isOn) {
26.               this.getUIContext().getPromptAction().showToast(this.bOnSt);
27.             } else {
28.               this.getUIContext().getPromptAction().showToast(this.bOffSt);
29.             }
30.           })
31.       }
32.       .backgroundColor(0xFFFFFF)
33.     }
34.     .padding(10)
35.     .backgroundColor(0xDCDCDC)
36.     .width('100%')
37.     .height('100%')
38.   }
39. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163957.94290174858701220400011407384185:50001231000000:2800:60812A0B0A6BAD28C92598A5B318DD4DE16425C72DF76559D14E41B8943EA13A.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-radio-button "单选框 (Radio)")
# 自定义渲染 (XComponent)

更新时间: 2025-12-16 16:38

## 概述

XComponent组件作为一种渲染组件，可用于EGL/OpenGLES和媒体数据写入，通过使用XComponent持有的“[NativeWindow](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-window-guidelines)”来渲染画面，通常用于满足开发者较为复杂的自定义渲染需求，例如相机预览流的显示和游戏画面的渲染。其可通过指定type字段来实现不同的渲染方式，分别为[XComponentType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#xcomponenttype10).SURFACE和XComponentType.TEXTURE。对于SURFACE类型，开发者将定制的绘制内容单独展示到屏幕上。对于TEXTURE类型，开发者将定制的绘制内容和XComponent组件的内容合成后展示到屏幕上。

XComponent持有一个Surface，开发者能通过调用[NativeWindow](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/native-window-guidelines)等接口，申请并提交Buffer至图形队列，以此方式将自绘制内容传送至该Surface。XComponent负责将此Surface整合进UI界面，其中展示的内容正是开发者传送的自绘制内容。Surface的默认位置与大小与XComponent组件一致，开发者可利用[setXComponentSurfaceRect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent#setxcomponentsurfacerect12)接口自定义调整Surface的位置和大小。XComponent组件负责创建Surface，并通过回调将Surface的相关信息告知应用。应用可以通过一系列接口设定Surface的属性。该组件本身不对所绘制的内容进行感知，亦不提供渲染绘制的接口。

目前XComponent组件主要有三个应用场景：

|XComponent组件应用场景|场景简介|场景特点|
|:--|:--|:--|
|[使用XComponentController管理Surface生命周期场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-xcomponent-guidelines#%E4%BD%BF%E7%94%A8xcomponentcontroller%E7%AE%A1%E7%90%86surface%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)|该场景在ArkTS侧的XComponentController获取SurfaceId，生命周期回调、触摸、鼠标、按键等事件回调等均在ArkTS侧触发。|适用于视频播放、相机预览等媒体播放类场景，该场景需要在ArkTS侧获取SurfaceId，并将SurfaceId传入对应接口。|
|[使用OH_ArkUI_SurfaceHolder管理Surface生命周期场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-xcomponent-guidelines#%E4%BD%BF%E7%94%A8oh_arkui_surfaceholder%E7%AE%A1%E7%90%86surface%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)|该场景根据XComponent组件对应的ArkUI_NodeHandle创建OH_ArkUI_SurfaceHolder，生命周期回调、触摸等事件回调、无障碍和可变帧率回调等均在Native侧触发。|适用于如下场景：<br><br>1.有较复杂的交互逻辑、对频繁跨语言调用导致性能损耗敏感的场景。<br><br>2.希望能控制Surface生命周期触发时机的场景。|
|[使用NativeXComponent管理Surface生命周期场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-xcomponent-guidelines#%E4%BD%BF%E7%94%A8nativexcomponent%E7%AE%A1%E7%90%86surface%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)|该场景在native层获取Native XComponent实例，在Native侧注册XComponent的生命周期回调，以及触摸、鼠标、按键等事件回调。|与[使用OH_ArkUI_SurfaceHolder管理Surface生命周期场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-xcomponent-guidelines#%E4%BD%BF%E7%94%A8oh_arkui_surfaceholder%E7%AE%A1%E7%90%86surface%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)类似，但交互事件接口不够丰富，且使用不当容易出现稳定性问题，建议使用OH_ArkUI_SurfaceHolder的接口。|

## 约束与限制

当开发者传输的绘制内容包含透明元素时，Surface区域的显示效果会与下方内容进行合成展示。例如，若传输的内容完全透明，且XComponent的背景色被设置为黑色，同时Surface保持默认的大小与位置，则最终显示的将是一片黑色区域。

## 使用XComponentController管理Surface生命周期

本场景通过在ArkTS侧获取SurfaceId，布局信息、生命周期回调、触摸、鼠标、按键等事件回调等均在ArkTS侧触发，按需传递到Native侧进行处理。主要开发场景如下：

- 基于ArkTS侧获取的SurfaceId，在Native侧调用OH_NativeWindow_CreateNativeWindowFromSurfaceId接口创建出NativeWindow实例。
- 利用NativeWindow和EGL接口开发自定义绘制内容以及申请和提交Buffer到图形队列。
- ArkTS侧获取生命周期、事件等信息传递到Native侧处理。

说明

1. Native侧的NativeWindow缓存在字典中，其key需要保证其唯一性，当对应的XComponent销毁后，需要及时从字典里将其删除。
    
2. 对于使用[typeNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-framenode#typenode12)创建的SURFACE或TEXTURE类型的XComponent组件，由于typeNode组件的生命周期与声明式组件存在差异，组件在创建后的缓冲区尺寸为未设置状态，因此在开始绘制内容之前，应调用[OH_NativeWindow_NativeWindowHandleOpt](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-external-window-h#oh_nativewindow_nativewindowhandleopt)接口进行缓冲区尺寸设置。
    
3. 多个XComponent开发时，缓存Native侧资源需要保证key是唯一的，key推荐使用id+随机数或者surfaceId。
    
4. 在onSurfaceCreated回调触发后，才能获取到有效的surfaceId。
    

**效果预览**

|主页|绘制五角星|改变颜色|
|:--|:--|:--|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.90770238566232478831425172637846:50001231000000:2800:2F3D26BF1C1D4B10F4B58F8AE035ABB3898FFC4F03E0FF68FC5500C98F389C67.png)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.51638869093319867989208888748132:50001231000000:2800:64C9A84E81FB2E340849D399B47444ABA9A673D497234952FB445B1D16FC4007.png)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.74887373977950431871182894503384:50001231000000:2800:69C7BE87FB09FF8C140166425A07381993DAF03B0F6402331B4985C8F3EC31B5.png)|

说明

1. 安装编译生成的hap包，并打开应用。
    
2. 点击页面底部“Draw Star”按钮，页面将绘制一个五角星。
    
3. 点击XComponent组件区域（页面中灰色区域）改变五角星颜色。
    

**生命周期**：

- onSurfaceCreated回调
    
    触发时刻：XComponent创建完成且创建好Surface后触发。
    
    ArkTS侧onSurfaceCreated的时序如下图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.61877770757912109978402749394416:50001231000000:2800:1C0EC5E48900D05D1862968FDD714E303668963F6125F078E43E447DE208C3AD.png)
    
- onSurfaceChanged回调
    
    触发时刻：Surface大小变化触发重新布局之后触发。
    
    ArkTS侧onSurfaceChanged的时序如下图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.53994553919637498091931027708630:50001231000000:2800:ED7F6EA59C41366A328046123FCD8C98EB14220D88B6B9524BB2F12911EE562F.png)
    
- onSurfaceDestroyed回调
    
    触发时刻：XComponent组件被销毁时触发，与一般ArkUI的组件销毁时机一致。
    
    ArkTS侧onSurfaceDestroyed的时序图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.13549316891851568816052435749702:50001231000000:2800:540B3BB541578CEBF3215FE720E7ADC972FFF751BD2743C30FB4968EB0E271E0.png)
    

**接口说明**

ArkTS侧的XComponentController

|接口名|描述|
|:--|:--|
|getXComponentSurfaceId(): string|获取XComponent对应Surface的ID。|
|onSurfaceCreated(surfaceId: string): void|当XComponent持有的Surface创建后进行该回调。|
|onSurfaceChanged(surfaceId: string, rect: SurfaceRect): void|当XComponent持有的Surface大小改变后（包括首次创建时的大小改变）进行该回调。|
|onSurfaceDestroyed(surfaceId: string): void|当XComponent持有的Surface销毁后进行该回调。|

Native侧

|接口名|描述|
|:--|:--|
|int32_t OH_NativeWindow_CreateNativeWindowFromSurfaceId (uint64_t surfaceId, OHNativeWindow **window )|通过surfaceId创建对应的OHNativeWindow。|
|void OH_NativeWindow_DestroyNativeWindow (OHNativeWindow* window)|将OHNativeWindow对象的引用计数减1，当引用计数为0的时候，该OHNativeWindow对象会被析构掉。|

**开发步骤**

核心开发流程如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.07086121799357086292023621500176:50001231000000:2800:F05E849D07B124B9D8794C1C3F175B4021DF89C7BD23C39D7B392FBCEBF6C77F.png)

以下步骤以SURFACE类型为例，描述了如何使用XComponent组件在ArkTS侧传入SurfaceId，在Native侧创建NativeWindow实例，然后创建EGL/GLES环境，实现在主页面绘制图形，并可以改变图形的颜色。

1. 在界面中定义XComponent，在cpp/types/libnativerender/Index.d.ts中声明接口，具体实现位于Native侧。
    
    1. // 函数声明，在cpp/types/libnativerender/Index.d.ts中定义
    2. type XComponentContextStatus = {
    3.     hasDraw: boolean,
    4.     hasChangeColor: boolean,
    5. };
    6. export const SetSurfaceId: (id: BigInt) => any;
    7. export const ChangeSurface: (id: BigInt, w: number, h: number) =>any;
    8. export const DrawPattern: (id: BigInt) => any;
    9. export const GetXComponentStatus: (id: BigInt) => XComponentContextStatus
    10. export const ChangeColor: (id: BigInt) => any;
    11. export const DestroySurface: (id: BigInt) => any;
    
    12. import nativeRender from 'libnativerender.so';
    
    13. // 重写XComponentController，设置生命周期回调
    14. class MyXComponentController extends XComponentController {
    15.     onSurfaceCreated(surfaceId: string): void {
    16.         console.info(`onSurfaceCreated surfaceId: ${surfaceId}`)
    17.         nativeRender.SetSurfaceId(BigInt(surfaceId));
    18.     }
    
    19.     onSurfaceChanged(surfaceId: string, rect: SurfaceRect): void {
    20.         console.info(`onSurfaceChanged surfaceId: ${surfaceId}, rect: ${JSON.stringify(rect)}}`)
    21.         // 在onSurfaceChanged中调用ChangeSurface绘制内容
    22.         nativeRender.ChangeSurface(BigInt(surfaceId), rect.surfaceWidth, rect.surfaceHeight)
    23.     }
    
    24.     onSurfaceDestroyed(surfaceId: string): void {
    25.         console.info(`onSurfaceDestroyed surfaceId: ${surfaceId}`)
    26.         nativeRender.DestroySurface(BigInt(surfaceId))
    27.     }
    28. }
    
    29. @Entry
    30. @Component
    31. struct Index {
    32.     @State currentStatus: string = "index";
    33.     xComponentController: XComponentController = new MyXComponentController();
    
    34.     build() {
    35.         Column() {
    36.             //...
    37.             //在xxx.ets 中定义 XComponent
    38.             Column({ space: 10 }) {
    39.                 XComponent({
    40.                     type: XComponentType.SURFACE,
    41.                     controller: this.xComponentController
    42.                 })
    43.             Text(this.currentStatus)
    44.                 .fontSize('24fp')
    45.                 .fontWeight(500)
    46.             }
    47.             .onClick(() => {
    48.                 let surfaceId = this.xComponentController.getXComponentSurfaceId()
    49.                 nativeRender.ChangeColor(BigInt(surfaceId))
    50.                 let hasChangeColor: boolean = false;
    51.                 if (nativeRender.GetXComponentStatus(BigInt(surfaceId))) {
    52.                     hasChangeColor = nativeRender.GetXComponentStatus(BigInt(surfaceId)).hasChangeColor;
    53.                 }
    54.                 if (hasChangeColor) {
    55.                     this.currentStatus = "change color";
    56.                 }
    57.             })
    
    58.             //...
    59.             Row() {
    60.                 Button('Draw Star')
    61.                     .fontSize('16fp')
    62.                     .fontWeight(500)
    63.                     .margin({ bottom: 24 })
    64.                     .onClick(() => {
    65.                         let surfaceId = this.xComponentController.getXComponentSurfaceId()
    66.                         nativeRender.DrawPattern(BigInt(surfaceId))
    67.                         let hasDraw: boolean = false;
    68.                         if (nativeRender.GetXComponentStatus(BigInt(surfaceId))) {
    69.                             hasDraw = nativeRender.GetXComponentStatus(BigInt(surfaceId)).hasDraw;
    70.                         }
    71.                         if (hasDraw) {
    72.                             this.currentStatus = "draw star"
    73.                         }
    74.                     })
    75.                     .width('53.6%')
    76.                     .height(40)
    77.             }
    78.             .width('100%')
    79.             .justifyContent(FlexAlign.Center)
    80.             .alignItems(VerticalAlign.Bottom)
    81.             .layoutWeight(1)
    82.         }
    83.         .width('100%')
    84.         .height('100%')
    85.     }
    86. }
    
2. Node-API模块注册，具体使用请参考[Node-API开发规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-guidelines)。
    
    1. #include <hilog/log.h>
    2. #include "common/common.h"
    3. #include "manager/plugin_manager.h"
    4. namespace NativeXComponentSample {
    5. // 在napi_init.cpp文件中，Init方法注册接口函数，从而将封装的C++方法传递出来，供ArkTS侧调用
    6. EXTERN_C_START
    7. static napi_value Init(napi_env env, napi_value exports) {
    8.     // ...
    9.     // 向ArkTS侧暴露接口SetSurfaceId(),ChangeSurface(),DestroySurface(),
    10.     // DrawPattern(),ChangeColor(),GetXComponentStatus()
    11.     napi_property_descriptor desc[] = {
    12.         {"SetSurfaceId", nullptr, PluginManager::SetSurfaceId, nullptr, nullptr, nullptr, napi_default, nullptr},
    13.         {"ChangeSurface", nullptr, PluginManager::ChangeSurface, nullptr, nullptr, nullptr, napi_default, nullptr},
    14.         {"DestroySurface", nullptr, PluginManager::DestroySurface, nullptr, nullptr, nullptr, napi_default, nullptr},
    15.         {"DrawPattern", nullptr, PluginManager::DrawPattern, nullptr, nullptr, nullptr, napi_default, nullptr},
    16.         {"ChangeColor", nullptr, PluginManager::ChangeColor, nullptr, nullptr, nullptr, napi_default, nullptr},
    17.         {"GetXComponentStatus", nullptr, PluginManager::GetXComponentStatus, nullptr, nullptr, nullptr, napi_default,
    18.          nullptr}};
    19.     if (napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc) != napi_ok) {
    20.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Init", "napi_define_properties failed");
    21.         return nullptr;
    22.     }
    23.     return exports;
    24. }
    25. EXTERN_C_END
    26. // 编写接口的描述信息，根据实际需要可以修改对应参数
    27. static napi_module nativerenderModule = {.nm_version = 1,
    28.                                          .nm_flags = 0,
    29.                                          .nm_filename = nullptr,
    30.                                          // 入口函数
    31.                                          .nm_register_func = Init,
    32.                                          // 模块名称
    33.                                          .nm_modname = "nativerender",
    34.                                          .nm_priv = ((void *)0),
    35.                                          .reserved = {0}};
    36. } // namespace NativeXComponentSample
    37. // __attribute__((constructor))修饰的方法由系统自动调用，使用Node-API接口napi_module_register()传入模块描述信息进行模块注册
    38. extern "C" __attribute__((constructor)) void RegisterModule(void) {
    39.     napi_module_register(&NativeXComponentSample::nativerenderModule);
    40. }
    
3. 上述注册的六个函数在Native侧的具体实现如下：ChangeColor和DrawPattern利用OpenGL(https://developer.huawei.com/consumer/cn/doc/harmonyos-references/opengl)进行五角星的绘制；ChangeSurface根据传入的surfaceId、width、height调整Surface的大小；SetSurfaceId基于SurfaceId完成NativeWindow的初始化；DestroySurface销毁与Surface相关的资源；GetXComponentStatus获取xcomponent状态并返回至ArkTS侧。
    
    1. // PluginManager类定义
    2. class PluginManager {
    3. public:
    4.     ~PluginManager();
    5.     static PluginRender *GetPluginRender(int64_t &id);
    6.     static napi_value ChangeColor(napi_env env, napi_callback_info info);
    7.     static napi_value DrawPattern(napi_env env, napi_callback_info info);
    8.     static napi_value SetSurfaceId(napi_env env, napi_callback_info info);
    9.     static napi_value ChangeSurface(napi_env env, napi_callback_info info);
    10.     static napi_value DestroySurface(napi_env env, napi_callback_info info);
    11.     static napi_value GetXComponentStatus(napi_env env, napi_callback_info info);
    
    12. public:
    13.     static std::unordered_map<int64_t, PluginRender *> pluginRenderMap_;
    14.     static std::unordered_map<int64_t, OHNativeWindow *> windowMap_;
    15. };
    
    16. // 解析从ArkTS侧传入的surfaceId，此处surfaceId是一个64位int值
    17. int64_t ParseId(napi_env env, napi_callback_info info) {
    18.     if ((env == nullptr) || (info == nullptr)) {
    19.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "ParseId", "env or info is null");
    20.         return -1;
    21.     }
    22.     size_t argc = 1;
    23.     napi_value args[1] = {nullptr};
    24.     if (napi_ok != napi_get_cb_info(env, info, &argc, args, nullptr, nullptr)) {
    25.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "ParseId", "GetContext napi_get_cb_info failed");
    26.         return -1;
    27.     }
    28.     int64_t value = 0;
    29.     bool lossless = true;
    30.     if (napi_ok != napi_get_value_bigint_int64(env, args[0], &value, &lossless)) {
    31.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "ParseId", "Get value failed");
    32.         return -1;
    33.     }
    34.     return value;
    35. }
    
    36. // 设置SurfaceId，基于SurfaceId完成对NativeWindow的初始化
    37. napi_value PluginManager::SetSurfaceId(napi_env env, napi_callback_info info) {
    38.     int64_t surfaceId = ParseId(env, info);
    39.     OHNativeWindow *nativeWindow;
    40.     PluginRender *pluginRender;
    41.     if (windowMap_.find(surfaceId) == windowMap_.end()) {
    42.         OH_NativeWindow_CreateNativeWindowFromSurfaceId(surfaceId, &nativeWindow);
    43.         windowMap_[surfaceId] = nativeWindow;
    44.     } else {
    45.         return nullptr;
    46.     }
    47.     if (pluginRenderMap_.find(surfaceId) == pluginRenderMap_.end()) {
    48.         pluginRender = new PluginRender(surfaceId);
    49.         pluginRenderMap_[surfaceId] = pluginRender;
    50.     }
    51.     pluginRender->InitNativeWindow(nativeWindow);
    52.     return nullptr;
    53. }
    
    54. void PluginRender::InitNativeWindow(OHNativeWindow *window) {
    55.     eglCore_->EglContextInit(window); // 参考Native XComponent场景EglContextInit的实现
    56. }
    
    57. // 根据传入的surfaceId、width、height实现Surface大小的变动
    58. napi_value PluginManager::ChangeSurface(napi_env env, napi_callback_info info) {
    59.     if ((env == nullptr) || (info == nullptr)) {
    60.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    61.                      "ChangeSurface: OnLoad env or info is null");
    62.         return nullptr;
    63.     }
    64.     int64_t surfaceId = 0;
    65.     size_t argc = 3;
    66.     napi_value args[3] = {nullptr};
    
    67.     if (napi_ok != napi_get_cb_info(env, info, &argc, args, nullptr, nullptr)) {
    68.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    69.                      "ChangeSurface: GetContext napi_get_cb_info failed");
    70.         return nullptr;
    71.     }
    72.     bool lossless = true;
    73.     int index = 0;
    74.     if (napi_ok != napi_get_value_bigint_int64(env, args[index++], &surfaceId, &lossless)) {
    75.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "ChangeSurface: Get value failed");
    76.         return nullptr;
    77.     }
    78.     double width;
    79.     if (napi_ok != napi_get_value_double(env, args[index++], &width)) {
    80.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "ChangeSurface: Get width failed");
    81.         return nullptr;
    82.     }
    83.     double height;
    84.     if (napi_ok != napi_get_value_double(env, args[index++], &height)) {
    85.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "ChangeSurface: Get height failed");
    86.         return nullptr;
    87.     }
    88.     auto pluginRender = GetPluginRender(surfaceId);
    89.     if (pluginRender == nullptr) {
    90.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "ChangeSurface: Get pluginRender failed");
    91.         return nullptr;
    92.     }
    93.     pluginRender->UpdateNativeWindowSize(width, height);
    94.     return nullptr;
    95. }
    
    96. void PluginRender::UpdateNativeWindowSize(int width, int height) {
    97.     eglCore_->UpdateSize(width, height); // 参考Native XComponent场景UpdateSize的实现
    98.     if (!hasChangeColor_ && !hasDraw_) {
    99.         eglCore_->Background(); // 参考Native XComponent场景Background的实现
    100.     }
    101. }
    
    102. // 销毁Surface
    103. napi_value PluginManager::DestroySurface(napi_env env, napi_callback_info info) {
    104.     int64_t surfaceId = ParseId(env, info);
    105.     auto pluginRenderMapIter = pluginRenderMap_.find(surfaceId);
    106.     if (pluginRenderMapIter != pluginRenderMap_.end()) {
    107.         delete pluginRenderMapIter->second;
    108.         pluginRenderMap_.erase(pluginRenderMapIter);
    109.     }
    110.     auto windowMapIter = windowMap_.find(surfaceId);
    111.     if (windowMapIter != windowMap_.end()) {
    112.         OH_NativeWindow_DestroyNativeWindow(windowMapIter->second);
    113.         windowMap_.erase(windowMapIter);
    114.     }
    115.     return nullptr;
    116. }
    
    117. // 实现EGL绘画逻辑
    118. napi_value PluginManager::DrawPattern(napi_env env, napi_callback_info info) {
    119.     int64_t surfaceId = ParseId(env, info);
    120.     auto pluginRender = GetPluginRender(surfaceId);
    121.     if (pluginRender == nullptr) {
    122.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "DrawPattern: Get pluginRender failed");
    123.         return nullptr;
    124.     }
    125.     pluginRender->DrawPattern();
    126.     return nullptr;
    127. }
    
    128. PluginRender *PluginManager::GetPluginRender(int64_t &id) {
    129.     if (pluginRenderMap_.find(id) != pluginRenderMap_.end()) {
    130.         return pluginRenderMap_[id];
    131.     }
    132.     return nullptr;
    133. }
    
    134. void PluginRender::DrawPattern() {
    135.     eglCore_->Draw(hasDraw_); // 参考Native XComponent场景Draw实现
    136. }
    
    137. // 实现改变绘制图形颜色的功能
    138. napi_value PluginManager::ChangeColor(napi_env env, napi_callback_info info) {
    139.     int64_t surfaceId = ParseId(env, info);
    140.     auto pluginRender = GetPluginRender(surfaceId);
    141.     if (pluginRender == nullptr) {
    142.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "ChangeColor: Get pluginRender failed");
    143.         return nullptr;
    144.     }
    145.     pluginRender->ChangeColor(); // 参考Native XComponent场景ChangeColor实现
    146.     return nullptr;
    147. }
    
    148. void PluginRender::ChangeColor() { eglCore_->ChangeColor(hasChangeColor_); }
    
    149. // 获得xcomponent状态，并返回至ArkTS侧
    150. napi_value PluginManager::GetXComponentStatus(napi_env env, napi_callback_info info) {
    151.     int64_t surfaceId = ParseId(env, info);
    152.     auto pluginRender = GetPluginRender(surfaceId);
    153.     if (pluginRender == nullptr) {
    154.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    155.                      "GetXComponentStatus: Get pluginRender failed");
    156.         return nullptr;
    157.     }
    158.     napi_value hasDraw;
    159.     napi_value hasChangeColor;
    160.     napi_status ret = napi_create_int32(env, pluginRender->HasDraw(), &(hasDraw));
    161.     if (ret != napi_ok) {
    162.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    163.                      "GetXComponentStatus: napi_create_int32 hasDraw_ error");
    164.         return nullptr;
    165.     }
    166.     ret = napi_create_int32(env, pluginRender->HasChangedColor(), &(hasChangeColor));
    167.     if (ret != napi_ok) {
    168.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    169.                      "GetXComponentStatus: napi_create_int32 hasChangeColor_ error");
    170.         return nullptr;
    171.     }
    172.     napi_value obj;
    173.     ret = napi_create_object(env, &obj);
    174.     if (ret != napi_ok) {
    175.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    176.                      "GetXComponentStatus: napi_create_object error");
    177.         return nullptr;
    178.     }
    179.     ret = napi_set_named_property(env, obj, "hasDraw", hasDraw);
    180.     if (ret != napi_ok) {
    181.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    182.                      "GetXComponentStatus: napi_set_named_property hasDraw error");
    183.         return nullptr;
    184.     }
    185.     ret = napi_set_named_property(env, obj, "hasChangeColor", hasChangeColor);
    186.     if (ret != napi_ok) {
    187.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    188.                      "GetXComponentStatus: napi_set_named_property hasChangeColor error");
    189.         return nullptr;
    190.     }
    191.     return obj;
    192. }
    
    193. int32_t PluginRender::HasDraw() { return hasDraw_; }
    
    194. int32_t PluginRender::HasChangedColor() { return hasChangeColor_; }
    
4. 配置具体的CMakeLists，使用CMake工具链将C++源代码编译成动态链接库文件。
    
    1. # 设置CMake最小版本
    2. cmake_minimum_required(VERSION 3.4.1)
    3. # 项目名称
    4. project(XComponent)
    
    5. set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})
    6. add_definitions(-DOHOS_PLATFORM)
    7. # 设置头文件搜索目录
    8. include_directories(
    9.     ${NATIVERENDER_ROOT_PATH}
    10.     ${NATIVERENDER_ROOT_PATH}/include
    11. )
    12. # 添加名为nativerender的动态库，库文件名为libnativerender.so，添加cpp文件
    13. add_library(nativerender SHARED
    14.     render/egl_core.cpp
    15.     render/plugin_render.cpp
    16.     manager/plugin_manager.cpp
    17.     napi_init.cpp
    18. )
    
    19. find_library(
    20.     # 设置路径变量的名称。
    21.     EGL-lib
    22.     # 指定要让CMake查找的NDK库的名称。
    23.     EGL
    24. )
    
    25. find_library(
    26.     # 设置路径变量的名称。
    27.     GLES-lib
    28.     # 指定要让CMake查找的NDK库的名称。
    29.     GLESv3
    30. )
    
    31. find_library(
    32.     # 设置路径变量的名称。
    33.     hilog-lib
    34.     # 指定要让CMake查找的NDK库的名称。
    35.     hilog_ndk.z
    36. )
    
    37. find_library(
    38.     # 设置路径变量的名称。
    39.     libace-lib
    40.     # 指定要让CMake查找的NDK库的名称。
    41.     ace_ndk.z
    42. )
    
    43. find_library(
    44.     # 设置路径变量的名称。
    45.     libnapi-lib
    46.     # 指定要让CMake查找的NDK库的名称。
    47.     ace_napi.z
    48. )
    
    49. find_library(
    50.     # 设置路径变量的名称。
    51.     libuv-lib
    52.     # 指定要让CMake查找的NDK库的名称。
    53.     uv
    54. )
    55. # 添加构建需要链接的库
    56. target_link_libraries(nativerender PUBLIC
    57.     ${EGL-lib} ${GLES-lib} ${hilog-lib} ${libace-lib} ${libnapi-lib} ${libuv-lib} libnative_window.so)
    

上述用例具体实现可参考[ArkTSXComponent（API12）](https://gitcode.com/openharmony/applications_app_samples/tree/master/code/BasicFeature/Native/ArkTSXComponent)。

## 使用OH_ArkUI_SurfaceHolder管理Surface生命周期

与使用XComponentController管理Surface生命周期场景不同，本场景允许应用根据XComponent组件对应的ArkUI_NodeHandle中创建OH_ArkUI_SurfaceHolder，并通过OH_ArkUI_SurfaceHolder上的相关接口注册Surface生命周期，XComponent组件相关的无障碍、可变帧率等能力也可根据ArkUI_NodeHandle通过相关接口来实现。同时，XComponent组件上的基础/手势事件也可通过ArkUI_NodeHandle对象使用ArkUI NDK接口来监听（具体可参考：[监听组件事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ndk-listen-to-component-events)）。主要开发场景如下：

- 在ArkTS侧创建的XComponent组件可以将其对应的FrameNode节点传递到Native侧以获取ArkUI_NodeHandle，或者在Native侧直接创建XComponent组件对应的ArkUI_NodeHandle，然后调用OH_ArkUI_SurfaceHolder_Create接口创建OH_ArkUI_SurfaceHolder实例。
- 基于OH_ArkUI_SurfaceHolder实例注册相应的生命周期回调、事件回调，获取NativeWindow实例。
- 利用NativeWindow和EGL接口开发自定义绘制内容以及申请和提交Buffer到图形队列。

**生命周期**：

- OnSurfaceCreated回调
    
    触发时刻：XComponent创建完成且创建好Surface后达成以下两个条件中的一个触发。
    
    1. 组件上树且autoInitialize = true。
    2. 调用OH_ArkUI_XComponent_Initialize。
    
    Native侧OnSurfaceCreated的时序如下图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.23975468306957285756576217445962:50001231000000:2800:DA1D7588D921AF68C73163CD58AC8E0F0179493F8BFF502C2ED7F971A50058AC.png)
    
- OnSurfaceChanged回调
    
    触发时刻：OnSurfaceCreated回调成功触发且Surface大小变化触发重新布局之后触发。
    
    Native侧OnSurfaceChanged的时序如下图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163858.95871572407991544420515631371666:50001231000000:2800:49DC18F3F8AB7181D4B43F99CF42082A21214D0659F45D761F8B07EF7B4DF35A.png)
    
- OnSurfaceDestroyed回调
    
    触发时刻：组件下树且autoInitialize=true 或者调用 OH_ArkUI_XComponent_Finalize后触发。
    
    Native侧OnSurfaceDestroyed的时序图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.34087607720943853916137807571362:50001231000000:2800:2707CBECCDD6F67774D4585AD48DC1F8964DB5C91BC1E53FDBBCEABA918DF311.png)
    

**接口说明**

|接口名|描述|
|:--|:--|
|OH_ArkUI_QueryModuleInterfaceByName(ArkUI_NativeAPIVariantKind type, const char* structName)|获取指定类型的Native模块接口集合。|
|OH_ArkUI_XComponent_GetNativeWindow(OH_ArkUI_SurfaceHolder* surfaceHolder)|获取与OH_ArkUI_SurfaceHolder实例关联的nativeWindow。|
|OH_ArkUI_SurfaceHolder_RemoveSurfaceCallback(OH_ArkUI_SurfaceHolder* surfaceHolder, OH_ArkUI_SurfaceCallback* callback)|从OH_ArkUI_SurfaceHolder实例中移除先前添加的Surface生命周期回调。|
|OH_ArkUI_SurfaceCallback_Dispose(OH_ArkUI_SurfaceCallback* callback)|释放OH_ArkUI_SurfaceCallback对象。|
|OH_ArkUI_SurfaceHolder_Dispose(OH_ArkUI_SurfaceHolder* surfaceHolder)|释放OH_ArkUI_SurfaceHolder对象。|
|OH_ArkUI_NodeEvent_GetEventType(ArkUI_NodeEvent* event)|从组件事件获取事件类型。|
|OH_ArkUI_NodeEvent_GetNodeHandle(ArkUI_NodeEvent* event)|获取触发组件事件的组件对象。|
|OH_ArkUI_GetNodeHandleFromNapiValue(napi_env env, napi_value frameNode, ArkUI_NodeHandle* handle)|获取ArkTS侧创建的FrameNode节点对象映射到Native侧的ArkUI_NodeHandle。|
|OH_ArkUI_SurfaceHolder_Create(ArkUI_NodeHandle node)|从XComponent节点创建一个OH_ArkUI_SurfaceHolder对象。|
|OH_ArkUI_SurfaceCallback_Create()|创建一个OH_ArkUI_SurfaceCallback对象。|
|OH_ArkUI_SurfaceCallback_SetSurfaceCreatedEvent(OH_ArkUI_SurfaceCallback* callback, void (*onSurfaceCreated)(OH_ArkUI_SurfaceHolder* surfaceHolder))|往OH_ArkUI_SurfaceCallback对象中注册onSurfaceCreated回调。|
|OH_ArkUI_SurfaceCallback_SetSurfaceChangedEvent(OH_ArkUI_SurfaceCallback* callback, void (*onSurfaceChanged)(OH_ArkUI_SurfaceHolder* surfaceHolder, uint64_t width, uint64_t height))|往OH_ArkUI_SurfaceCallback对象中注册onSurfaceChanged回调。|
|OH_ArkUI_SurfaceCallback_SetSurfaceDestroyedEvent(OH_ArkUI_SurfaceCallback* callback, void (*onSurfaceDestroyed)(OH_ArkUI_SurfaceHolder* surfaceHolder))|往OH_ArkUI_SurfaceCallback对象中注册onSurfaceDestroyed回调。|
|OH_ArkUI_SurfaceCallback_SetSurfaceShowEvent(OH_ArkUI_SurfaceCallback* callback, void (*onSurfaceShow)(OH_ArkUI_SurfaceHolder* surfaceHolder))|往OH_ArkUI_SurfaceCallback对象中注册onSurfaceShow回调。|
|OH_ArkUI_SurfaceCallback_SetSurfaceHideEvent(OH_ArkUI_SurfaceCallback* callback, void (*onSurfaceHide)(OH_ArkUI_SurfaceHolder* surfaceHolder))|往OH_ArkUI_SurfaceCallback对象中注册onSurfaceHide回调。|
|OH_ArkUI_XComponent_RegisterOnFrameCallback(ArkUI_NodeHandle node, void (*callback)(ArkUI_NodeHandle node, uint64_t timestamp, uint64_t targetTimestamp))|为XComponent节点注册onFrame回调。|
|OH_ArkUI_SurfaceHolder_AddSurfaceCallback(OH_ArkUI_SurfaceHolder* surfaceHolder, OH_ArkUI_SurfaceCallback* callback)|往OH_ArkUI_SurfaceHolder实例注册OH_ArkUI_SurfaceCallback对象。|
|OH_ArkUI_AccessibilityProvider_Create(ArkUI_NodeHandle node)|从XComponent节点创建一个ArkUI_AccessibilityProvider对象。|
|OH_ArkUI_XComponent_UnregisterOnFrameCallback(ArkUI_NodeHandle node)|取消注册XComponent节点的onFrame回调。|
|OH_ArkUI_AccessibilityProvider_Dispose(ArkUI_AccessibilityProvider* provider)|释放ArkUI_AccessibilityProvider对象。|
|OH_ArkUI_XComponent_SetExpectedFrameRateRange(ArkUI_NodeHandle node, OH_NativeXComponent_ExpectedRateRange range)|为XComponent节点设置预期的帧率范围。|
|OH_ArkUI_XComponent_SetNeedSoftKeyboard(ArkUI_NodeHandle node, bool needSoftKeyboard)|设置XComponent节点在获得焦点时是否需要显示软键盘。|

**开发步骤**

以下步骤通过在ArkTS侧创建SURFACE类型的XComponent为例（Native侧如何创建XComponent组件对应的ArkUI_NodeHandle可参考[ArkUI_NativeNodeAPI_1](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-arkui-nativemodule-arkui-nativenodeapi-1)），描述了如何使用XComponent组件调用OH_ArkUI_SurfaceHolder相关接口管理Surface生命周期，并在Native侧创建EGL/GLES环境，实现在主页面绘制图形，以及可以改变图形的颜色。

1. 在界面中定义XComponent。
    
    1. import native from 'libnativerender.so';
    
    2. @Entry
    3. @Component
    4. struct Index {
    5.     xcomponentId: string = 'xcp' + (new Date().getTime());
    6.     @State isShow: boolean = true;
    7.     @State minRate: number = 0;
    8.     @State maxRate: number = 120;
    9.     @State expected: number = 60;
    10.     needSoftKeyboard: boolean = false;
    11.     @State needSoftKeyboardState: string = 'needSoftKeyboard=' + this.needSoftKeyboard;
    12.     @State text: string = '单指点击XComponent软件盘消失'
    13.     controller: TextInputController = new TextInputController()
    
    14.     build() {
    15.         Column() {
    16.             TextInput({ text: this.text, placeholder: 'please input ...', controller: this.controller })
    17.                 .placeholderColor(Color.Grey)
    18.                 .placeholderFont({ size: 14, weight: 400 })
    19.                 .caretColor(Color.Blue)
    20.                 .width(400)
    21.                 .height(40)
    22.                 .margin(20)
    23.                 .fontSize(14)
    24.                 .fontColor(Color.Black)
    25.                 .onChange((value: string) => {
    26.                     this.text = value
    27.                 })
    28.             Column() {
    29.                 if (this.isShow) {
    30.                     XComponent({
    31.                         type: XComponentType.SURFACE
    32.                     })
    33.                         .id(this.xcomponentId)
    34.                         .onAttach(() => {
    35.                             let node = this.getUIContext().getFrameNodeById(this.xcomponentId)
    36.                             native.bindNode(this.xcomponentId, node)
    37.                         })
    38.                         .onDetach(() => {
    39.                             native.unbindNode(this.xcomponentId)
    40.                         })
    41.                         .width(200)
    42.                         .height(200)
    43.                         .focusable(true)
    44.                         .focusOnTouch(true)
    45.                         .defaultFocus(true)
    46.                 }
    47.             }.height(200)
    
    48.             Button('创建/销毁').onClick(() => {
    49.                 this.isShow = !this.isShow;
    50.             })
    
    51.             Column() {
    52.                 Text('期望帧率设置：')
    53.                     .textAlign(TextAlign.Start)
    54.                     .fontSize(15)
    55.                     .border({ width: 1 })
    56.                     .padding(10)
    57.                     .width('100%')
    58.                     .margin(5)
    59.                 Text('min: ' + this.minRate)
    60.                 Slider({
    61.                     value: this.minRate,
    62.                     min: 0,
    63.                     max: 240,
    64.                     step: 1
    65.                 }).onChange((value: number, mode: SliderChangeMode) => {
    66.                     this.minRate = value;
    67.                     native.setFrameRate(this.xcomponentId, this.minRate, this.maxRate, this.expected)
    68.                 }).width('100%')
    69.                 Text('max: ' + this.maxRate)
    70.                 Slider({
    71.                     value: this.maxRate,
    72.                     min: 0,
    73.                     max: 240,
    74.                     step: 1
    75.                 }).onChange((value: number, mode: SliderChangeMode) => {
    76.                     this.maxRate = value;
    77.                     native.setFrameRate(this.xcomponentId, this.minRate, this.maxRate, this.expected)
    78.                 }).width('100%')
    79.                 Text('expected: ' + this.expected)
    80.                 Slider({
    81.                     value: this.expected,
    82.                     min: 0,
    83.                     max: 240,
    84.                     step: 1
    85.                 }).onChange((value: number, mode: SliderChangeMode) => {
    86.                     this.expected = value;
    87.                     native.setFrameRate(this.xcomponentId, this.minRate, this.maxRate, this.expected)
    88.                 }).width('100%')
    89.             }.backgroundColor("#F0FAFF")
    
    90.             Button(this.needSoftKeyboardState)
    91.                 .onClick(() => {
    92.                     this.needSoftKeyboard = !this.needSoftKeyboard;
    93.                     this.needSoftKeyboardState = 'needSoftKeyboard=' + this.needSoftKeyboard;
    94.                     native.setNeedSoftKeyboard(this.xcomponentId, this.needSoftKeyboard);
    95.                     this.text = this.needSoftKeyboard ? '单指点击XComponent软键盘不消失' : '单指点击XComponent软件盘消失'
    96.                 })
    97.         }
    98.         .width('100%')
    99.     }
    100. }
    
2. Node-API模块注册，具体使用请参考[Node-API开发规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-guidelines)。
    
    1. #include "manager/plugin_manager.h"
    
    2. namespace NativeXComponentSample {
    
    3. // 在napi_init.cpp文件中，Init方法注册接口函数，从而将封装的C++方法传递出来，供ArkTS侧调用
    4. EXTERN_C_START
    5. static napi_value Init(napi_env env, napi_value exports)
    6. {
    7.     // 向ArkTS侧暴露接口
    8.     napi_property_descriptor desc[] = {
    9.         {"bindNode", nullptr, PluginManager::BindNode,
    10.             nullptr, nullptr, nullptr, napi_default, nullptr},
    11.         {"unbindNode", nullptr, PluginManager::UnbindNode,
    12.             nullptr, nullptr, nullptr, napi_default, nullptr},
    13.         {"setFrameRate", nullptr, PluginManager::SetFrameRate,
    14.             nullptr, nullptr, nullptr, napi_default, nullptr},
    15.         {"setNeedSoftKeyboard", nullptr, PluginManager::SetNeedSoftKeyboard,
    16.             nullptr, nullptr, nullptr, napi_default, nullptr},
    17.     };
    18.     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    19.     return exports;
    20. }
    21. EXTERN_C_END
    
    22. // 编写接口的描述信息，根据实际需要可以修改对应参数
    23. static napi_module demoModule = {
    24.     .nm_version = 1,
    25.     .nm_flags = 0,
    26.     .nm_filename = nullptr,
    27.     // 入口函数
    28.     .nm_register_func = Init, // 指定加载对应模块时的回调函数
    29.     // 模块名称
    30.     .nm_modname = "nativerender", // 指定模块名称，对于XComponent相关开发，这个名称必须和ArkTS侧XComponent中libraryname的值保持一致
    31.     .nm_priv = ((void*)0),
    32.     .reserved = { 0 },
    33. };
    34. }
    
    35. // __attribute__((constructor))修饰的方法由系统自动调用，使用Node-API接口napi_module_register()传入模块描述信息进行模块注册
    36. extern "C" __attribute__((constructor)) void RegisterEntryModule(void)
    37. {
    38.     napi_module_register(&NativeXComponentSample::demoModule);
    39. }
    
3. 注册XComponent生命周期、事件、无障碍和可变帧率回调，使用CAPI实现往XComponent注册回调函数。
    
    (1) 定义BindNode、UnbindNode、SetFrameRate、SetNeedSoftKeyboard方法，暴露到ArkTS侧的bindNode、unbindNode、setFrameRate、setNeedSoftKeyboard方法会执行该方法。
    
    1. // plugin_manager.h
    2. namespace NativeXComponentSample {
    3. class PluginManager {
    4. public:
    5.     ~PluginManager();
    6.     static napi_value BindNode(napi_env env, napi_callback_info info);
    7.     static napi_value UnbindNode(napi_env env, napi_callback_info info);
    8.     static napi_value SetFrameRate(napi_env env, napi_callback_info info);
    9.     static napi_value SetNeedSoftKeyboard(napi_env env, napi_callback_info info);
    
    10. public:
    11.     static std::unordered_map<std::string, ArkUI_NodeHandle> nodeHandleMap_;
    12.     static std::unordered_map<void *, EGLRender *> renderMap_;
    13.     static std::unordered_map<void *, OH_ArkUI_SurfaceCallback *> callbackMap_;
    14.     static std::unordered_map<void *, OH_ArkUI_SurfaceHolder *> surfaceHolderMap_;
    15.     static ArkUI_AccessibilityProvider* provider_;
    16. };
    17. }
    
    18. // plugin_manager.cpp
    19. std::unordered_map<std::string, ArkUI_NodeHandle> PluginManager::nodeHandleMap_;
    20. std::unordered_map<void *, EGLRender *> PluginManager::renderMap_;
    21. std::unordered_map<void *, OH_ArkUI_SurfaceCallback *> PluginManager::callbackMap_;
    22. std::unordered_map<void *, OH_ArkUI_SurfaceHolder *> PluginManager::surfaceHolderMap_;
    23. ArkUI_NativeNodeAPI_1 *nodeAPI = reinterpret_cast<ArkUI_NativeNodeAPI_1 *>(
    24.     OH_ArkUI_QueryModuleInterfaceByName(ARKUI_NATIVE_NODE, "ArkUI_NativeNodeAPI_1"));
    
    25. std::string value2String(napi_env env, napi_value value) { // 将napi_value转化为string类型的变量
    26.     size_t stringSize = 0;
    27.     napi_get_value_string_utf8(env, value, nullptr, 0, &stringSize);
    28.     std::string valueString;
    29.     valueString.resize(stringSize);
    30.     napi_get_value_string_utf8(env, value, &valueString[0], stringSize + 1, &stringSize);
    31.     return valueString;
    32. }
    
    33. napi_value PluginManager::BindNode(napi_env env, napi_callback_info info) {
    34.     size_t argc = 2;
    35.     napi_value args[2] = {nullptr};
    36.     napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    37.     std::string nodeId = value2String(env, args[0]);
    38.     ArkUI_NodeHandle handle;
    39.     OH_ArkUI_GetNodeHandleFromNapiValue(env, args[1], &handle); // 获取nodeHandle
    40.     OH_ArkUI_SurfaceHolder *holder = OH_ArkUI_SurfaceHolder_Create(handle); // 获取SurfaceHolder
    41.     nodeHandleMap_[nodeId] = handle;
    42.     surfaceHolderMap_[handle] = holder;
    43.     auto callback = OH_ArkUI_SurfaceCallback_Create(); // 创建SurfaceCallback
    44.     callbackMap_[holder] = callback;
    45.     OH_ArkUI_SurfaceCallback_SetSurfaceCreatedEvent(callback, OnSurfaceCreated); // 注册OnSurfaceCreated回调
    46.     OH_ArkUI_SurfaceCallback_SetSurfaceChangedEvent(callback, OnSurfaceChanged); // 注册OnSurfaceChanged回调
    47.     OH_ArkUI_SurfaceCallback_SetSurfaceDestroyedEvent(callback, OnSurfaceDestroyed); // 注册OnSurfaceDestroyed回调
    48.     OH_ArkUI_SurfaceCallback_SetSurfaceShowEvent(callback, OnSurfaceShow); // 注册OnSurfaceShow回调
    49.     OH_ArkUI_SurfaceCallback_SetSurfaceHideEvent(callback, OnSurfaceHide); // 注册OnSurfaceHide回调
    50.     OH_ArkUI_XComponent_RegisterOnFrameCallback(handle, OnFrameCallback); // 注册OnFrameCallback回调
    51.     OH_ArkUI_SurfaceHolder_AddSurfaceCallback(holder, callback); // 注册SurfaceCallback回调
    52.     if (!nodeAPI->addNodeEventReceiver(handle, onEvent)) { // 添加事件监听，返回成功码 0
    53.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "onBind", "addNodeEventReceiver error");
    54.     }
    55.     if (!nodeAPI->registerNodeEvent(handle, NODE_TOUCH_EVENT, 0, nullptr)) { // 用C接口注册touch事件，返回成功码 0
    56.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "onBind", "registerTouchEvent error");
    57.     }
    58.     provider_ = OH_ArkUI_AccessibilityProvider_Create(handle); // 创建一个ArkUI_AccessibilityProvider类型的对象
    59.     /**
    60.     * 获取ArkUI_AccessibilityProvider后，如果注册无障碍回调函数请参考：
    61.     * https://gitcode.com/openharmony/docs/blob/HarmonyOS-5.1.0-Release/zh-cn/application-dev/ui/ndk-accessibility-xcomponent.md
    62.     * **/
    63.     return nullptr;
    64. }
    
    65. napi_value PluginManager::UnbindNode(napi_env env, napi_callback_info info)
    66. {
    67.     size_t argc = 1;
    68.     napi_value args[1] = {nullptr};
    69.     napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    70.     std::string nodeId = value2String(env, args[0]);
    71.     auto node = nodeHandleMap_[nodeId];
    72.     OH_ArkUI_XComponent_UnregisterOnFrameCallback(node); // 解注册帧回调
    73.     OH_ArkUI_AccessibilityProvider_Dispose(provider_); // 销毁ArkUI_AccessibilityProvider
    74.     nodeAPI->disposeNode(node); // 销毁nodeHandle
    75.     nodeHandleMap_.erase(nodeId);
    76.     return nullptr;
    77. }
    
    78. napi_value PluginManager::SetFrameRate(napi_env env, napi_callback_info info)
    79. {
    80.     size_t argc = 4;
    81.     napi_value args[4] = {nullptr};
    82.     napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    83.     std::string nodeId = value2String(env, args[0]);
    84.     auto node = nodeHandleMap_[nodeId];
    
    85.     int32_t min = 0;
    86.     napi_get_value_int32( env, args[1], &min);
    
    87.     int32_t max = 0;
    88.     napi_get_value_int32(env, args[2], &max);
    
    89.     int32_t expected = 0;
    90.     napi_get_value_int32(env, args[3], &expected);
    91.     OH_NativeXComponent_ExpectedRateRange range = {
    92.         .min = min,
    93.         .max = max,
    94.         .expected = expected
    95.     };
    96.     OH_ArkUI_XComponent_SetExpectedFrameRateRange(node, range); // 设置期望帧率
    97.     return nullptr;
    98. }
    
    99. napi_value PluginManager::SetNeedSoftKeyboard(napi_env env, napi_callback_info info)
    100. {
    101.     size_t argc = 2;
    102.     napi_value args[2] = {nullptr};
    103.     napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    104.     std::string nodeId = value2String(env, args[0]);
    105.     auto node = nodeHandleMap_[nodeId];
    
    106.     bool needSoftKeyboard = false;
    107.     napi_get_value_bool( env, args[1], &needSoftKeyboard);
    108.     OH_ArkUI_XComponent_SetNeedSoftKeyboard(node, needSoftKeyboard); // 设置是否需要软键盘
    109.     return nullptr;
    110. }
    
    (2) 定义Surface创建成功，发生改变，销毁和事件，可变帧率回调接口。
    
    111. void OnSurfaceCreated(OH_ArkUI_SurfaceHolder *holder) {
    112.     auto window = OH_ArkUI_XComponent_GetNativeWindow(holder); // 获取native window
    113.     auto render = new EGLRender();
    114.     PluginManager::renderMap_[holder] = render;
    115.     render->SetUpEGLContext(window);
    116. }
    
    117. void OnSurfaceChanged(OH_ArkUI_SurfaceHolder *holder, uint64_t width, uint64_t height) {
    118.     if (PluginManager::renderMap_.count(holder)) {
    119.         auto render = PluginManager::renderMap_[holder];
    120.         render->SetEGLWindowSize(width, height); // 设置绘制区域大小
    121.         render->DrawStar(true); // 绘制五角星
    122.     }
    123. }
    
    124. void OnSurfaceDestroyed(OH_ArkUI_SurfaceHolder *holder) {
    125.     OH_LOG_Print(LOG_APP, LOG_ERROR, 0xff00, "onBind", "on destroyed");
    126.     if (PluginManager::renderMap_.count(holder)) { // 销毁render对象
    127.         auto render = PluginManager::renderMap_[holder];
    128.         delete render;
    129.         PluginManager::renderMap_.erase(holder);
    130.     }
    131.     if (PluginManager::callbackMap_.count(holder)) {
    132.         auto callback = PluginManager::callbackMap_[holder];
    133.         OH_ArkUI_SurfaceHolder_RemoveSurfaceCallback(holder, callback); // 移除SurfaceCallback
    134.         OH_ArkUI_SurfaceCallback_Dispose(callback); // 销毁surfaceCallback
    135.         PluginManager::callbackMap_.erase(holder);
    136.     }
    137.     OH_ArkUI_SurfaceHolder_Dispose(holder); // 销毁surfaceHolder
    138. }
    
    139. void OnSurfaceShow(OH_ArkUI_SurfaceHolder* holder)
    140. {
    141.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "onBind", "on surface show");
    142. }
    
    143. void OnSurfaceHide(OH_ArkUI_SurfaceHolder* holder)
    144. {
    145.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "onBind", "on surface hide");
    146. }
    
    147. void OnFrameCallback(ArkUI_NodeHandle node, uint64_t timestamp, uint64_t targetTimestamp)
    148. {
    149.     if (!PluginManager::surfaceHolderMap_.count(node)) {
    150.         return;
    151.     }
    152.     static uint64_t count = 0;
    153.     count++;
    154.     if (count % 50 == 0) {
    155.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "onBind", "OnFrameCallback count = %{public}ld", count);
    156.     }
    157. }
    
    158. void onEvent(ArkUI_NodeEvent *event) {
    159.     auto eventType = OH_ArkUI_NodeEvent_GetEventType(event); // 获取组件事件类型
    160.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "onBind", "on event");
    161.     if (eventType == NODE_TOUCH_EVENT) {
    162.         ArkUI_NodeHandle handle = OH_ArkUI_NodeEvent_GetNodeHandle(event); // 获取触发该事件的组件对象
    163.         auto holder = PluginManager::surfaceHolderMap_[handle];
    164.         if (PluginManager::renderMap_.count(holder)) {
    165.             auto render = PluginManager::renderMap_[holder];
    166.             render->DrawStar(false); // 绘制五角星
    167.         }
    168.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "onBind", "on touch");
    169.     }
    170. }
    
4. 初始化环境，包括初始化可用的EGLDisplay、确定可用的Surface配置、创建渲染区域Surface、创建并关联上下文等。
    
    1. // EGLConst.h
    2. #include <EGL/egl.h>
    3. #include <EGL/eglext.h>
    4. #include <GLES3/gl3.h>
    
    5. const unsigned int LOG_PRINT_DOMAIN = 0xFF00;
    
    6. /**
    7. * Program 错误。
    8. */
    9. const GLuint PROGRAM_ERROR = 0;
    
    10. /**
    11. * 位置错误。
    12. */
    13. const GLint POSITION_ERROR = -1;
    
    14. /**
    15. * 默认x坐标。
    16. */
    17. const int DEFAULT_X_POSITION = 0;
    
    18. /**
    19. * 默认y坐标。
    20. */
    21. const int DEFAULT_Y_POSITION = 0;
    
    22. /**
    23. * Gl 红色默认值。
    24. */
    25. const GLfloat GL_RED_DEFAULT = 0.0;
    
    26. /**
    27. * Gl 绿色默认值。
    28. */
    29. const GLfloat GL_GREEN_DEFAULT = 0.0;
    
    30. /**
    31. * Gl 蓝色默认值。
    32. */
    33. const GLfloat GL_BLUE_DEFAULT = 0.0;
    
    34. /**
    35. * Gl 透明度。
    36. */
    37. const GLfloat GL_ALPHA_DEFAULT = 1.0;
    
    38. /**
    39. * Pointer 数量。
    40. */
    41. const GLint POINTER_SIZE = 2;
    
    42. /**
    43. * Triangle fan 尺寸。
    44. */
    45. const GLsizei TRIANGLE_FAN_SIZE = 4;
    
    46. /**
    47. *  50%。
    48. */
    49. const float FIFTY_PERCENT = 0.5;
    
    50. /**
    51. * 位置句柄名字。
    52. */
    53. const char POSITION_NAME[] = "a_position";
    
    54. /**
    55. * 背景色 #f4f4f4。
    56. */
    57. const GLfloat BACKGROUND_COLOR[] = {244.0f / 255, 244.0f / 255, 244.0f / 255, 1.0f};
    
    58. /**
    59. * Draw 颜色 #7E8FFB。
    60. */
    61. const GLfloat DRAW_COLOR[] = {126.0f / 255, 143.0f / 255, 251.0f / 255, 1.0f};
    
    62. /**
    63. * Change 颜色 #92D6CC。
    64. */
    65. const GLfloat CHANGE_COLOR[] = {146.0f / 255, 214.0f / 255, 204.0f / 255, 1.0f};
    
    66. /**
    67. * 背景区域。
    68. */
    69. const GLfloat BACKGROUND_RECTANGLE_VERTICES[] = {-1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f};
    
    70. const EGLint ATTRIB_LIST[] = {
    71.     // 键，值。
    72.     EGL_SURFACE_TYPE, EGL_WINDOW_BIT, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8,
    73.     EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
    74.     // 结束。
    75.     EGL_NONE};
    
    76. const EGLint CONTEXT_ATTRIBS[] = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE};
    
    77. /**
    78. * 顶点着色器。
    79. */
    80. const char VERTEX_SHADER[] = "#version 300 es\n"
    81.                             "layout(location = 0) in vec4 a_position;\n"
    82.                             "layout(location = 1) in vec4 a_color;   \n"
    83.                             "out vec4 v_color;                       \n"
    84.                             "void main()                             \n"
    85.                             "{                                       \n"
    86.                             "   gl_Position = a_position;            \n"
    87.                             "   v_color = a_color;                   \n"
    88.                             "}                                       \n";
    
    89. /**
    90. * 片元着色器。
    91. */
    92. const char FRAGMENT_SHADER[] = "#version 300 es\n"
    93.                             "precision mediump float;                  \n"
    94.                             "in vec4 v_color;                          \n"
    95.                             "out vec4 fragColor;                       \n"
    96.                             "void main()                               \n"
    97.                             "{                                         \n"
    98.                             "   fragColor = v_color;                   \n"
    99.                             "}                                         \n";
    
    100. // EGLRender.h
    101. #include "EGLConst.h"
    102. #include <EGL/egl.h>
    103. #include <EGL/eglext.h>
    104. #include <EGL/eglplatform.h>
    105. #include <GLES3/gl3.h>
    106. #include <string>
    
    107. class EGLRender {
    108. public:
    109.     bool SetUpEGLContext(void *window);
    110.     void SetEGLWindowSize(int width, int height);
    111.     void DrawStar(bool drawColor);
    
    112.     std::string xcomponentId;
    113.     EGLNativeWindowType eglWindow_;
    
    114.     EGLDisplay eglDisplay_ = EGL_NO_DISPLAY;
    115.     EGLConfig eglConfig_ = EGL_NO_CONFIG_KHR;
    116.     EGLSurface eglSurface_ = EGL_NO_SURFACE;
    117.     EGLContext eglContext_ = EGL_NO_CONTEXT;
    118.     GLuint program_;
    119.     int width_ = 0;
    120.     int height_ = 0;
    121.     ~EGLRender();
    
    122. private:
    123.     GLint PrepareDraw();
    124.     bool ExecuteDraw(GLint position, const GLfloat *color, const GLfloat shapeVertices[]);
    125. };
    
    126. // EGLRender.cpp
    127. #include "EGLRender.h"
    128. #include "EGLConst.h"
    129. #include <EGL/egl.h>
    130. #include <EGL/eglext.h>
    131. #include <GLES3/gl3.h>
    132. #include <cmath>
    133. #include <cstdio>
    134. #include <algorithm>
    135. #include <hilog/log.h>
    136. #include <iostream>
    
    137. namespace {
    138. void Rotate2d(GLfloat centerX, GLfloat centerY, GLfloat *rotateX, GLfloat *rotateY, GLfloat theta) {
    139.     GLfloat tempX = cos(theta) * (*rotateX - centerX) - sin(theta) * (*rotateY - centerY);
    140.     GLfloat tempY = sin(theta) * (*rotateX - centerX) + cos(theta) * (*rotateY - centerY);
    141.     *rotateX = tempX + centerX;
    142.     *rotateY = tempY + centerY;
    143. }
    
    144. GLuint LoadShader(GLenum type, const char *shaderSrc) {
    145.     if ((type == 0) || (shaderSrc == nullptr)) {
    146.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "glCreateShader type or shaderSrc error");
    147.         return PROGRAM_ERROR;
    148.     }
    
    149.     GLuint shader = glCreateShader(type);
    150.     if (shader == 0) {
    151.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "glCreateShader unable to load shader");
    152.         return PROGRAM_ERROR;
    153.     }
    
    154.     // The gl function has no return value.
    155.     glShaderSource(shader, 1, &shaderSrc, nullptr);
    156.     glCompileShader(shader);
    
    157.     GLint compiled;
    158.     glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
    159.     if (compiled != 0) {
    160.         return shader;
    161.     }
    
    162.     GLint infoLen = 0;
    163.     glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
    164.     if (infoLen <= 1) {
    165.         glDeleteShader(shader);
    166.         return PROGRAM_ERROR;
    167.     }
    
    168.     char *infoLog = (char *)malloc(sizeof(char) * (infoLen + 1));
    169.     if (infoLog != nullptr) {
    170.         memset(infoLog, 0, infoLen + 1);
    171.         glGetShaderInfoLog(shader, infoLen, nullptr, infoLog);
    172.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "glCompileShader error = %s", infoLog);
    173.         free(infoLog);
    174.         infoLog = nullptr;
    175.     }
    176.     glDeleteShader(shader);
    177.     return PROGRAM_ERROR;
    178. }
    
    179. // 创建program
    180. GLuint CreateProgram(const char *vertexShader, const char *fragShader) {
    181.     if ((vertexShader == nullptr) || (fragShader == nullptr)) {
    182.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender",
    183.                     "createProgram: vertexShader or fragShader is null");
    184.         return PROGRAM_ERROR;
    185.     }
    
    186.     GLuint vertex = LoadShader(GL_VERTEX_SHADER, vertexShader);
    187.     if (vertex == PROGRAM_ERROR) {
    188.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "createProgram vertex error");
    189.         return PROGRAM_ERROR;
    190.     }
    
    191.     GLuint fragment = LoadShader(GL_FRAGMENT_SHADER, fragShader);
    192.     if (fragment == PROGRAM_ERROR) {
    193.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "createProgram fragment error");
    194.         return PROGRAM_ERROR;
    195.     }
    
    196.     GLuint program = glCreateProgram();
    197.     if (program == PROGRAM_ERROR) {
    198.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "createProgram program error");
    199.         glDeleteShader(vertex);
    200.         glDeleteShader(fragment);
    201.         return PROGRAM_ERROR;
    202.     }
    
    203.     //  该gl函数没有返回值。
    204.     glAttachShader(program, vertex);
    205.     glAttachShader(program, fragment);
    206.     glLinkProgram(program);
    
    207.     GLint linked;
    208.     glGetProgramiv(program, GL_LINK_STATUS, &linked);
    209.     if (linked != 0) {
    210.         glDeleteShader(vertex);
    211.         glDeleteShader(fragment);
    212.         return program;
    213.     }
    
    214.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "createProgram linked error");
    215.     GLint infoLen = 0;
    216.     glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLen);
    217.     if (infoLen > 1) {
    218.         char *infoLog = (char *)malloc(sizeof(char) * (infoLen + 1));
    219.         memset(infoLog, 0, infoLen + 1);
    220.         glGetProgramInfoLog(program, infoLen, nullptr, infoLog);
    221.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "glLinkProgram error = %s", infoLog);
    222.         free(infoLog);
    223.         infoLog = nullptr;
    224.     }
    225.     glDeleteShader(vertex);
    226.     glDeleteShader(fragment);
    227.     glDeleteProgram(program);
    228.     return PROGRAM_ERROR;
    229. }
    230. } // namespace
    
    231. bool EGLRender::SetUpEGLContext(void *window) {
    232.     OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "EGLRender", "EglContextInit execute");
    233.     eglWindow_ = (EGLNativeWindowType)(window);
    234.     // 初始化display。
    235.     eglDisplay_ = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    236.     if (eglDisplay_ == EGL_NO_DISPLAY) {
    237.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "eglGetDisplay: unable to get EGL display");
    238.         return false;
    239.     }
    240.     EGLint majorVersion;
    241.     EGLint minorVersion;
    242.     if (!eglInitialize(eglDisplay_, &majorVersion, &minorVersion)) {
    243.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender",
    244.                     "eglInitialize: unable to get initialize EGL display");
    245.         return false;
    246.     };
    247.     // 选择配置。
    248.     const EGLint maxConfigSize = 1;
    249.     EGLint numConfigs;
    250.     if (!eglChooseConfig(eglDisplay_, ATTRIB_LIST, &eglConfig_, maxConfigSize, &numConfigs)) {
    251.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "eglChooseConfig: unable to choose configs");
    252.         return false;
    253.     };
    254.     // 创建环境。
    255.     // 创建 Surface。
    256.     eglSurface_ = eglCreateWindowSurface(eglDisplay_, eglConfig_, eglWindow_, NULL);
    257.     if (eglSurface_ == nullptr) {
    258.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender",
    259.                     "eglCreateWindowSurface: unable to create Surface");
    260.         return false;
    261.     }
    262.     // 创建上下文。
    263.     eglContext_ = eglCreateContext(eglDisplay_, eglConfig_, EGL_NO_CONTEXT, CONTEXT_ATTRIBS);
    264.     if (!eglMakeCurrent(eglDisplay_, eglSurface_, eglSurface_, eglContext_)) {
    265.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "eglMakeCurrent failed");
    266.         return false;
    267.     }
    268.     // 创建program。
    269.     program_ = CreateProgram(VERTEX_SHADER, FRAGMENT_SHADER);
    270.     if (program_ == PROGRAM_ERROR) {
    271.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "CreateProgram: unable to create program");
    272.         return false;
    273.     }
    274.     return true;
    275. }
    
    276. GLint EGLRender::PrepareDraw() {
    277.     if ((eglDisplay_ == nullptr) || (eglSurface_ == nullptr) || (eglContext_ == nullptr) ||
    278.         (!eglMakeCurrent(eglDisplay_, eglSurface_, eglSurface_, eglContext_))) {
    279.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "PrepareDraw: param error");
    280.         return POSITION_ERROR;
    281.     }
    
    282.     // 该gl函数没有返回值。
    283.     glViewport(DEFAULT_X_POSITION, DEFAULT_Y_POSITION, width_, height_);
    284.     glClearColor(GL_RED_DEFAULT, GL_GREEN_DEFAULT, GL_BLUE_DEFAULT, GL_ALPHA_DEFAULT);
    285.     glClear(GL_COLOR_BUFFER_BIT);
    286.     glUseProgram(program_);
    
    287.     return glGetAttribLocation(program_, POSITION_NAME);
    288. }
    
    289. // 绘制五角星
    290. void EGLRender::DrawStar(bool drawColor) {
    291.     OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "EGLRender", "Draw");
    292.     GLint position = PrepareDraw();
    293.     if (position == POSITION_ERROR) {
    294.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "Draw get position failed");
    295.         return;
    296.     }
    
    297.     // 绘制背景
    298.     if (!ExecuteDraw(position, BACKGROUND_COLOR, BACKGROUND_RECTANGLE_VERTICES)) {
    299.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "Draw execute draw background failed");
    300.         return;
    301.     }
    
    302.     // 将其划分为五个四边形，并计算其中一个四边形的顶点
    303.     GLfloat rotateX = 0;
    304.     GLfloat rotateY = FIFTY_PERCENT * height_;
    305.     GLfloat centerX = 0;
    306.     // 将角度 54° 和 18° 转换为弧度
    307.     GLfloat centerY = -rotateY * (M_PI / 180 * 54) * (M_PI / 180 * 18);
    308.     // 将角度 18° 转换为弧度
    309.     GLfloat leftX = -rotateY * (M_PI / 180 * 18);
    310.     GLfloat leftY = 0;
    311.     // 将角度 18° 转换为弧度
    312.     GLfloat rightX = rotateY * (M_PI / 180 * 18);
    313.     GLfloat rightY = 0;
    
    314.     // 确定绘制四边形的顶点，使用绘制区域的百分比表示
    315.     const GLfloat shapeVertices[] = {centerX / width_, centerY / height_, leftX / width_,  leftY / height_,
    316.                                     rotateX / width_, rotateY / height_, rightX / width_, rightY / height_};
    317.     auto color = drawColor ? DRAW_COLOR : CHANGE_COLOR;
    318.     if (!ExecuteDraw(position, color, shapeVertices)) {
    319.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "Draw execute draw shape failed");
    320.         return;
    321.     }
    
    322.     // 将角度 72° 转换为弧度
    323.     GLfloat rad = M_PI / 180 * 72;
    324.     // 旋转四次。
    325.     for (int i = 0; i < 4; ++i) {
    326.         // 旋转得其他四个四边形的顶点
    327.         Rotate2d(centerX, centerY, &rotateX, &rotateY, rad);
    328.         Rotate2d(centerX, centerY, &leftX, &leftY, rad);
    329.         Rotate2d(centerX, centerY, &rightX, &rightY, rad);
    
    330.         // 确定绘制四边形的顶点，使用绘制区域的百分比表示
    331.         const GLfloat shapeVertices[] = {centerX / width_, centerY / height_, leftX / width_,  leftY / height_,
    332.                                         rotateX / width_, rotateY / height_, rightX / width_, rightY / height_};
    
    333.         // 绘制图形
    334.         if (!ExecuteDraw(position, color, shapeVertices)) {
    335.             OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "Draw execute draw shape failed");
    336.             return;
    337.         }
    338.     }
    339.     // 将绘制命令提交给GPU，GPU执行完成后将渲染结果显示到屏幕
    340.     glFlush();
    341.     glFinish();
    342.     if (!eglSwapBuffers(eglDisplay_, eglSurface_)) {
    343.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "Draw FinishDraw failed");
    344.         return;
    345.     }
    346. }
    
    347. bool EGLRender::ExecuteDraw(GLint position, const GLfloat *color, const GLfloat shapeVertices[]) {
    348.     if ((position > 0) || (color == nullptr)) {
    349.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLRender", "ExecuteDraw: param error");
    350.         return false;
    351.     }
    
    352.     // 该gl函数没有返回值。
    353.     glVertexAttribPointer(position, POINTER_SIZE, GL_FLOAT, GL_FALSE, 0, shapeVertices);
    354.     glEnableVertexAttribArray(position);
    355.     glVertexAttrib4fv(1, color);
    356.     glDrawArrays(GL_TRIANGLE_FAN, 0, TRIANGLE_FAN_SIZE);
    357.     glDisableVertexAttribArray(position);
    
    358.     return true;
    359. }
    
    360. void EGLRender::SetEGLWindowSize(int width, int height) {
    361.     width_ = width;
    362.     height_ = height;
    363. }
    
    364. // 释放相关资源
    365. EGLRender::~EGLRender() {
    366.     if ((eglDisplay_ == nullptr) || (eglSurface_ == nullptr) || (!eglDestroySurface(eglDisplay_, eglSurface_))) {
    367.         OH_LOG_Print(LOG_APP, LOG_ERROR, 0xff00, "EGLRender", "Release eglDestroySurface failed");
    368.     }
    
    369.     if ((eglDisplay_ == nullptr) || (eglContext_ == nullptr) || (!eglDestroyContext(eglDisplay_, eglContext_))) {
    370.         OH_LOG_Print(LOG_APP, LOG_ERROR, 0xff00, "EGLRender", "Release eglDestroySurface failed");
    371.     }
    
    372.     if ((eglDisplay_ == nullptr) || (!eglTerminate(eglDisplay_))) {
    373.         OH_LOG_Print(LOG_APP, LOG_ERROR, 0xff00, "EGLRender", "Release eglDestroySurface failed");
    374.     }
    375. }
    
5. CMakeLists，使用CMake工具链将C++源代码编译成动态链接库文件。
    
    1. # the minimum version of CMake.
    2. cmake_minimum_required(VERSION 3.5.0)
    3. project(LCNXComponent2)
    
    4. set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})
    
    5. if(DEFINED PACKAGE_FIND_FILE)
    6.     include(${PACKAGE_FIND_FILE})
    7. endif()
    
    8. include_directories(${NATIVERENDER_ROOT_PATH}
    9.                     ${NATIVERENDER_ROOT_PATH}/render
    10.                     ${NATIVERENDER_ROOT_PATH}/manager)
    
    11. add_library(nativerender SHARED
    12.             render/EGLRender.cpp
    13.             manager/plugin_manager.cpp
    14.             napi_init.cpp)
    15. find_library(
    16.     # 设置路径变量的名称。
    17.     EGL-lib
    18.     # 指定要让CMake查找的NDK库的名称。
    19.     EGL
    20. )
    
    21. find_library(
    22.     # 设置路径变量的名称。
    23.     GLES-lib
    24.     # 指定要让CMake查找的NDK库的名称。
    25.     GLESv3
    26. )
    
    27. find_library(
    28.     # 设置路径变量的名称。
    29.     hilog-lib
    30.     # 指定要让CMake查找的NDK库的名称。
    31.     hilog_ndk.z
    32. )
    
    33. find_library(
    34.     # 设置路径变量的名称。
    35.     libace-lib
    36.     # 指定要让CMake查找的NDK库的名称。
    37.     ace_ndk.z
    38. )
    
    39. find_library(
    40.     # 设置路径变量的名称。
    41.     libnapi-lib
    42.     # 指定要让CMake查找的NDK库的名称。
    43.     ace_napi.z
    44. )
    
    45. find_library(
    46.     # 设置路径变量的名称。
    47.     libuv-lib
    48.     # 指定要让CMake查找的NDK库的名称。
    49.     uv
    50. )
    
    51. target_link_libraries(nativerender PUBLIC ${EGL-lib} ${GLES-lib} ${hilog-lib} ${libace-lib} ${libnapi-lib} ${libuv-lib} libnative_window.so)
    
    上述用例具体实现可参考[NativeXComponent](https://gitcode.com/openharmony/applications_app_samples/tree/master/code/DocsSample/ArkUISample/NativeXComponentSample)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.73868134330404526842172557099737:50001231000000:2800:0BFA8D90A4E18DEBA48C32813DBA4E61582EE53998DD33B8E2D0A7D69D3A1EAB.jpeg)
    

## 使用NativeXComponent管理Surface生命周期

与上述两种场景不同，本场景在Native侧使用ArkUI NDK 接口创建XComponent组件进行自定义绘制。具体步骤包括：创建组件，获取NativeXComponent实例，注册XComponent的生命周期回调及触摸、鼠标、按键等事件回调，通过回调获取NativeWindow，使用OpenGL ES/EGL接口在XComponent组件上进行图形绘制，最后在ArkTS层使用ContentSlot占位组件进行挂载显示。针对Native侧创建XComponent的主要开发场景如下：

- 利用Native XComponent提供的接口注册XComponent的生命周期和事件回调。
- 在这些回调中进行初始化环境、获取当前状态、响应各类事件的开发。
- 利用NativeWindow和EGL接口开发自定义绘制内容以及申请和提交Buffer到图形队列。

**约束条件**：

构造XComponent时需要根据需要的type使用对应的节点类型。

说明

1. Native侧的OH_NativeXComponent缓存在字典中，其key需要保证其唯一性，当对应的XComponent销毁后，需要及时从字典里将其删除。
    
2. 多个XComponent开发时，缓存Native侧资源需要保证key是唯一的，key推荐使用id+随机数或者surfaceId。
    

**生命周期**：

- OnSurfaceCreated回调
    
    触发时刻：XComponent创建完成且创建好Surface后触发。
    
    Native侧OnSurfaceCreated的时序如下图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.50045618735610932448387749836830:50001231000000:2800:BAA38FF3C6D4DD090C49C90FC5F79BF89CC082CDCB374D499E86922F94DF50A3.png)
    
- OnSurfaceChanged回调
    
    触发时刻：Surface大小变化触发重新布局后触发。
    
    Native侧OnSurfaceChanged的时序如下图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.96176101706335168220975550289824:50001231000000:2800:86C4E53E6E4941801F54C6CD07543419940965032815152835F05855A3957FE3.png)
    
- OnSurfaceDestroyed回调
    
    触发时刻：XComponent组件被销毁时触发，与一般ArkUI的组件销毁时机一致。
    
    Native侧OnSurfaceDestroyed的时序图：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.87580267477678252230937986941826:50001231000000:2800:0E1A43470321034099165209FA9B10883BD754AAA14432E09892FF0C0FAFCEC9.png)
    

**接口说明**

|接口名|描述|
|:--|:--|
|OH_NativeXComponent_GetXComponentId(OH_NativeXComponent* component, char* id, uint64_t* size)|获取XComponent的id。|
|OH_NativeXComponent_GetXComponentSize(OH_NativeXComponent* component, const void* window, uint64_t* width, uint64_t* height)|获取XComponent持有的Surface的大小。|
|OH_NativeXComponent_GetXComponentOffset(OH_NativeXComponent* component, const void* window, double* x, double* y)|获取XComponent持有的Surface相对其父组件左顶点的偏移量。|
|OH_NativeXComponent_GetTouchEvent(OH_NativeXComponent* component, const void* window, OH_NativeXComponent_TouchEvent* touchEvent)|获取由XComponent触发的触摸事件。touchEvent内的具体属性值可参考[OH_NativeXComponent_TouchEvent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/t-native-xcomponent-oh-nativexcomponent-touchevent)。|
|OH_NativeXComponent_GetTouchPointToolType(OH_NativeXComponent* component, uint32_t pointIndex, OH_NativeXComponent_TouchPointToolType* toolType)|获取XComponent触摸点的工具类型。|
|OH_NativeXComponent_GetTouchPointTiltX(OH_NativeXComponent* component, uint32_t pointIndex, float* tiltX)|获取XComponent触摸点处相对X轴的倾斜角度。|
|OH_NativeXComponent_GetTouchPointTiltY(OH_NativeXComponent* component, uint32_t pointIndex, float* tiltY)|获取XComponent触摸点处相对Y轴的倾斜角度。|
|OH_NativeXComponent_GetMouseEvent(OH_NativeXComponent* component, const void* window, OH_NativeXComponent_MouseEvent* mouseEvent)|获取由XComponent触发的鼠标事件。|
|OH_NativeXComponent_RegisterCallback(OH_NativeXComponent* component, OH_NativeXComponent_Callback* callback)|为此OH_NativeXComponent实例注册生命周期和触摸事件回调。|
|OH_NativeXComponent_RegisterMouseEventCallback(OH_NativeXComponent* component, OH_NativeXComponent_MouseEvent_Callback* callback)|为此OH_NativeXComponent实例注册鼠标事件回调。|
|OH_NativeXComponent_RegisterFocusEventCallback(OH_NativeXComponent* component, void (*callback)(OH_NativeXComponent* component, void* window))|为此OH_NativeXComponent实例注册获得焦点事件回调。|
|OH_NativeXComponent_RegisterKeyEventCallback(OH_NativeXComponent* component, void (*callback)(OH_NativeXComponent* component, void* window))|为此OH_NativeXComponent实例注册按键事件回调。|
|OH_NativeXComponent_RegisterBlurEventCallback(OH_NativeXComponent* component, void (*callback)(OH_NativeXComponent* component, void* window))|为此OH_NativeXComponent实例注册失去焦点事件回调。|
|OH_NativeXComponent_GetKeyEvent(OH_NativeXComponent* component, OH_NativeXComponent_KeyEvent** keyEvent)|获取由XComponent触发的按键事件。|
|OH_NativeXComponent_GetKeyEventAction(OH_NativeXComponent_KeyEvent* keyEvent, OH_NativeXComponent_KeyAction* action)|获取按键事件的动作。|
|OH_NativeXComponent_GetKeyEventCode(OH_NativeXComponent_KeyEvent* keyEvent, OH_NativeXComponent_KeyCode* code)|获取按键事件的键码值。|
|OH_NativeXComponent_GetKeyEventSourceType(OH_NativeXComponent_KeyEvent* keyEvent, OH_NativeXComponent_EventSourceType* sourceType)|获取按键事件的输入源类型。|
|OH_NativeXComponent_GetKeyEventDeviceId(OH_NativeXComponent_KeyEvent* keyEvent, int64_t* deviceId)|获取按键事件的设备ID。|
|OH_NativeXComponent_GetKeyEventTimestamp(OH_NativeXComponent_KeyEvent* keyEvent, int64_t* timestamp)|获取按键事件的时间戳。|
|OH_ArkUI_QueryModuleInterfaceByName(ArkUI_NativeAPIVariantKind type, const char* structName)|获取指定类型的Native模块接口集合。|
|OH_ArkUI_GetNodeContentFromNapiValue(napi_env env, napi_value value, ArkUI_NodeContentHandle* content)|获取ArkTS侧创建的NodeContent对象映射到Native侧的ArkUI_NodeContentHandle。|
|OH_ArkUI_NodeContent_SetUserData(ArkUI_NodeContentHandle content, void* userData)|在NodeContent对象上保存自定义数据。|
|OH_ArkUI_NodeContentEvent_GetNodeContentHandle(ArkUI_NodeContentEvent* event)|获取触发事件的NodeContent对象。|
|OH_ArkUI_NodeContent_GetUserData(ArkUI_NodeContentHandle content)|获取在NodeContent对象上保存的自定义数据。|
|OH_ArkUI_NodeContentEvent_GetEventType(ArkUI_NodeContentEvent* event)|获取触发NodeContent事件的事件类型。|
|OH_ArkUI_NodeContent_AddNode(ArkUI_NodeContentHandle content, ArkUI_NodeHandle node)|将一个ArkUI组件节点添加到对应的NodeContent对象下。|
|OH_ArkUI_NodeContent_RegisterCallback(ArkUI_NodeContentHandle content, ArkUI_NodeContentCallback callback)|注册NodeContent事件函数。|
|OH_NativeXComponent_GetNativeXComponent(ArkUI_NodeHandle node)|基于Native接口创建的组件实例获取OH_NativeXComponent类型的指针。|
|OH_NativeXComponent_GetHistoricalPoints(OH_NativeXComponent* component, const void* window, int32_t* size, OH_NativeXComponent_HistoricalPoint** historicalPoints )|获取当前XComponent触摸事件的历史点信息。由于部分输入设备上报触点的频率非常高（最高可达每1 ms上报一次），而对输入事件的响应通常是为了使UI界面发生变化以响应用户操作，如果将触摸事件按照上报触点的频率如此高频率上报给应用，大多会造成冗余，因此触摸事件在一帧内只会上报一次给应用。在当前帧内上报的触点均作为历史点保存，如果应用需要直接处理这些数据，可调用该接口获取历史点信息。历史接触点historicalPoints的具体规格可参考[重采样与历史点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-touch-screen#%E9%87%8D%E9%87%87%E6%A0%B7%E4%B8%8E%E5%8E%86%E5%8F%B2%E7%82%B9)。|

说明

上述接口不支持跨线程访问。

XComponent销毁（onSurfaceDestroyed回调触发后）时会释放上述接口中获取的OH_NativeXComponent和window对象。如果再次使用获取的对象，有可能会导致使用野指针或空指针的崩溃问题。

**开发步骤**

以下步骤以SURFACE类型为例，描述了如何使用XComponent组件调用Node-API接口来创建EGL/GLES环境，实现在主页面绘制图形，并可以改变图形的颜色。以下仅包含主要步骤，详细工程请参见[NativeXComponent](https://gitcode.com/openharmony/applications_app_samples/tree/master/code/DocsSample/ArkUISample/NativeXComponentSample)。

1. 在界面中定义XComponent。
    
    1. import nativeNode from 'libnativenode.so';
    2. import {NodeContent} from '@kit.ArkUI';
    
    3. @Entry
    4. @Component
    5. struct Index {
    6.   @State currentStatus: string = "init";
    7.   private nodeContent: NodeContent = new NodeContent();
    8.   aboutToAppear():void{
    9.     // 通过C-API创建节点，并添加到管理器nodeContent上
    10.     nativeNode.createNativeNode(this.nodeContent);
    11.   }
    
    12.   build() {
    13.     Column() {
    14.       Row() {
    15.         Text('Native XComponent Sample')
    16.         .fontSize('24fp')
    17.         .fontWeight(500)
    18.         .margin({
    19.             left: 24,
    20.             top: 12
    21.         })
    22.       }
    23.       .margin({ top: 24 })
    24.       .width('100%')
    25.       .height(56)
    
    26.       Column({ space: 10 }) {
    27.         // 显示nodeContent管理器里存放的Native侧的组件
    28.         ContentSlot(this.nodeContent);
    
    29.         Text(this.currentStatus)
    30.         .fontSize('24fp')
    31.         .fontWeight(500)
    32.       }
    33.       .onClick(() => {
    34.         let hasChangeColor: boolean = false;
    35.         // 获取当前绘制内容状态
    36.         if (nativeNode.getStatus()) {
    37.           hasChangeColor = nativeNode.getStatus().hasChangeColor;
    38.         }
    39.         if (hasChangeColor) {
    40.           this.currentStatus = "change color";
    41.         }
    42.       })
    43.       .margin({
    44.         top: 27,
    45.         left: 12,
    46.         right: 12
    47.       })
    48.       .height('40%')
    49.       .width('90%')
    
    50.       Row() {
    51.         Button('Draw Star')
    52.         .fontSize('16fp')
    53.         .fontWeight(500)
    54.         .margin({ bottom: 24 })
    55.         .onClick(() => {
    56.           // 调用drawPattern绘制内容
    57.           nativeNode.drawPattern();
    58.           let hasDraw: boolean = false;
    59.           // 获取当前绘制内容状态
    60.           if (nativeNode.getStatus()) {
    61.             hasDraw = nativeNode.getStatus().hasDraw;
    62.           }
    63.           if (hasDraw) {
    64.             this.currentStatus = "draw star";
    65.           }
    66.         })
    67.         .width('53.6%')
    68.         .height(40)
    69.       }
    70.       .width('100%')
    71.       .justifyContent(FlexAlign.Center)
    72.       .alignItems(VerticalAlign.Bottom)
    73.       .layoutWeight(1)
    74.     }
    75.     .width('100%')
    76.     .height('100%')
    77.   }
    78. }
    
2. Node-API模块注册，具体使用请参考[Node-API开发规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-guidelines)。
    
    1. #include <hilog/log.h>
    2. #include "common/common.h"
    3. #include "manager/plugin_manager.h"
    
    4. // 在napi_init.cpp文件中，Init方法注册接口函数，从而将封装的C++方法传递出来，供ArkTS侧调用
    5. EXTERN_C_START
    6. static napi_value Init(napi_env env, napi_value exports) {
    7.     // ...
    8.     // 向ArkTS侧暴露接口
    9.     napi_property_descriptor desc[] = {
    10.         {"createNativeNode", nullptr, PluginManager::createNativeNode, nullptr, nullptr, nullptr,
    11.         napi_default, nullptr },
    12.         {"getStatus", nullptr, PluginManager::GetXComponentStatus, nullptr, nullptr,
    13.         nullptr, napi_default, nullptr},
    14.         {"drawPattern", nullptr, PluginManager::NapiDrawPattern, nullptr, nullptr,
    15.         nullptr, napi_default, nullptr}
    16.     };
    17.     if (napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc) != napi_ok) {
    18.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Init", "napi_define_properties failed");
    19.         return nullptr;
    20.     }
    21.     return exports;
    22. }
    23. EXTERN_C_END
    
    24. // 编写接口的描述信息，根据实际需要可以修改对应参数
    25. static napi_module nativerenderModule = {
    26.     .nm_version = 1,
    27.     .nm_flags = 0,
    28.     .nm_filename = nullptr,
    29.     // 入口函数
    30.     .nm_register_func = Init,// 指定加载对应模块时的回调函数
    31.     // 模块名称
    32.     .nm_modname =
    33.         "nativerender", // 指定模块名称，对于XComponent相关开发，这个名称必须和ArkTS侧XComponent中libraryname的值保持一致
    34.     .nm_priv = ((void *)0),
    35.     .reserved = {0}};
    
    36. // __attribute__((constructor))修饰的方法由系统自动调用，使用Node-API接口napi_module_register()传入模块描述信息进行模块注册
    37. extern "C" __attribute__((constructor)) void RegisterModule(void) { napi_module_register(&nativerenderModule); }
    
3. 注册XComponent事件回调，使用Node-API实现XComponent事件回调函数。
    
    (1) 定义Surface创建成功，发生改变，销毁和XComponent的touch事件回调接口。
    
    1. // 在头文件中定义PluginManager类
    2. class PluginManager {
    3. public:
    4.     static OH_NativeXComponent_Callback callback_;
    5.     PluginManager();
    6.     ~PluginManager();
    7.     static PluginManager* GetInstance()
    8.     {
    9.         return &PluginManager::pluginManager_;
    10.     }
    
    11.     static napi_value createNativeNode(napi_env env, napi_callback_info info);
    12.     static napi_value GetXComponentStatus(napi_env env, napi_callback_info info);
    13.     static napi_value NapiDrawPattern(napi_env env, napi_callback_info info);
    
    14.     // CAPI XComponent
    15.     void OnSurfaceChanged(OH_NativeXComponent* component, void* window);
    16.     void OnSurfaceDestroyed(OH_NativeXComponent* component, void* window);
    17.     void DispatchTouchEvent(OH_NativeXComponent* component, void* window);
    18.     void OnSurfaceCreated(OH_NativeXComponent* component, void* window);
    
    19. public:
    20.     EGLCore *eglcore_;
    21.     uint64_t width_;
    22.     uint64_t height_;
    23.     OH_NativeXComponent_TouchEvent touchEvent_;
    24.     static int32_t hasDraw_;
    25.     static int32_t hasChangeColor_;
    
    26. private:
    27.     static PluginManager pluginManager_;
    28.     std::unordered_map<std::string, OH_NativeXComponent*> nativeXComponentMap_;
    29.     std::unordered_map<std::string, PluginManager*> pluginManagerMap_;
    30. };
    
    31. // 定义一个函数OnSurfaceCreatedCB()，封装初始化环境与绘制背景
    32. void OnSurfaceCreatedCB(OH_NativeXComponent *component, void *window) {
    33.     // ...
    34.     // 初始化环境与绘制背景
    35.     auto *pluginManager = PluginManager::GetInstance();
    36.     pluginManager->OnSurfaceCreated(component, window);
    37. }
    
    38. // 定义一个函数OnSurfaceChangedCB()
    39. void OnSurfaceChangedCB(OH_NativeXComponent *component, void *window) {
    40.     // ...
    41.     auto *pluginManager = PluginManager::GetInstance();
    42.     // 封装OnSurfaceChanged方法
    43.     pluginManager->OnSurfaceChanged(component, window);
    44. }
    
    45. // 定义一个函数OnSurfaceDestroyedCB()，将PluginRender类内释放资源的方法Release()封装在其中
    46. void OnSurfaceDestroyedCB(OH_NativeXComponent *component, void *window) {
    47.     // ...
    48.     auto *pluginManager = PluginManager::GetInstance();
    49.     pluginManager->OnSurfaceDestroyed(component, window);
    50. }
    
    51. // 定义一个函数DispatchTouchEventCB()，响应触摸事件时触发该回调
    52. void DispatchTouchEventCB(OH_NativeXComponent *component, void *window) {
    53.     // ...
    54.     auto *pluginManager = PluginManager::GetInstance();
    55.     pluginManager->DispatchTouchEvent(component, window);
    56. }
    
    (2) 定义createNativeNode方法，暴露到ArkTS侧的createNativeNode()方法会执行该方法。
    
    57. napi_value PluginManager::createNativeNode(napi_env env, napi_callback_info info)
    58. {
    59.     if ((env == nullptr) || (info == nullptr)) {
    60.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "CreateNativeNode env or info is null");
    61.         return nullptr;
    62.     }
    63.     size_t argCnt = 2;
    64.     napi_value args[2] = { nullptr, nullptr };
    65.     if (napi_get_cb_info(env, info, &argCnt, args, nullptr, nullptr) != napi_ok) {
    66.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "CreateNativeNode napi_get_cb_info failed");
    67.         return nullptr;
    68.     }
    69.     if (argCnt != ARG_CNT) {
    70.         napi_throw_type_error(env, NULL, "Wrong number of arguments");
    71.         return nullptr;
    72.     }
    73.     ArkUI_NodeContentHandle nodeContentHandle_ = nullptr;
    74.     OH_ArkUI_GetNodeContentFromNapiValue(env, args[0], &nodeContentHandle_);
    75.     nodeAPI = reinterpret_cast<ArkUI_NativeNodeAPI_1*>(
    76.         OH_ArkUI_QueryModuleInterfaceByName(ARKUI_NATIVE_NODE, "ArkUI_NativeNodeAPI_1")
    77.     );
    78.     std::string tag = value2String(env, args[1]);
    79.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "tag=%{public}s", tag.c_str());
    80.     int32_t ret = OH_ArkUI_NodeContent_SetUserData(nodeContentHandle_, new std::string(tag));
    81.     if (ret != ARKUI_ERROR_CODE_NO_ERROR) {
    82.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "setUserData failed error=%{public}d", ret);
    83.     }
    84.     if (nodeAPI != nullptr && nodeAPI->createNode != nullptr && nodeAPI->addChild != nullptr) {
    85.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager",
    86.                     "CreateNativeNode tag=%{public}s", tag.c_str());
    87.         auto nodeContentEvent = [](ArkUI_NodeContentEvent *event) {
    88.             ArkUI_NodeContentHandle handle = OH_ArkUI_NodeContentEvent_GetNodeContentHandle(event);
    89.             std::string *userDate = reinterpret_cast<std::string*>(OH_ArkUI_NodeContent_GetUserData(handle));
    90.             if (OH_ArkUI_NodeContentEvent_GetEventType(event) == NODE_CONTENT_EVENT_ON_ATTACH_TO_WINDOW) {
    91.                 ArkUI_NodeHandle testNode;
    92.                 if (userDate) {
    93.                     testNode = CreateNodeHandle(*userDate);
    94.                     delete userDate;
    95.                     userDate = nullptr;
    96.                 } else {
    97.                     testNode = CreateNodeHandle("noUserData");
    98.                 }
    99.                 OH_ArkUI_NodeContent_AddNode(handle, testNode);
    100.             }
    101.         };
    102.         OH_ArkUI_NodeContent_RegisterCallback(nodeContentHandle_, nodeContentEvent);
    103.     }
    104.     return nullptr;
    105. }
    
    106. ArkUI_NodeHandle CreateNodeHandle(const std::string &tag)
    107. {
    108.     ArkUI_NodeHandle column = nodeAPI->createNode(ARKUI_NODE_COLUMN);
    109.     ArkUI_NumberValue value[] = {480};
    110.     ArkUI_NumberValue value1[] = {{.u32 = 15}, {.f32 = 15}};
    111.     ArkUI_AttributeItem item = {value, 1, "changeSize"};
    112.     ArkUI_AttributeItem item1 = {value1, 2};
    113.     nodeAPI->setAttribute(column, NODE_WIDTH, &item);
    114.     value[0].f32 = COLUMN_MARGIN;
    115.     nodeAPI->setAttribute(column, NODE_MARGIN, &item);
    116.     // 创建XComponent组件
    117.     xc = nodeAPI->createNode(ARKUI_NODE_XCOMPONENT);
    118.     // 设置XComponent组件属性
    119.     value[0].u32 = ARKUI_XCOMPONENT_TYPE_SURFACE;
    120.     nodeAPI->setAttribute(xc, NODE_XCOMPONENT_TYPE, &item);
    121.     nodeAPI->setAttribute(xc, NODE_XCOMPONENT_ID, &item);
    122.     nodeAPI->setAttribute(xc, NODE_XCOMPONENT_SURFACE_SIZE, &item1);
    123.     ArkUI_NumberValue focusable[] = {1};
    124.     focusable[0].i32 = 1;
    125.     ArkUI_AttributeItem focusableItem = {focusable, 1};
    126.     nodeAPI->setAttribute(xc, NODE_FOCUSABLE, &focusableItem);
    127.     ArkUI_NumberValue valueSize[] = {480};
    128.     ArkUI_AttributeItem itemSize = {valueSize, 1};
    129.     valueSize[0].f32 = XC_WIDTH;
    130.     nodeAPI->setAttribute(xc, NODE_WIDTH, &itemSize);
    131.     valueSize[0].f32 = XC_HEIGHT;
    132.     nodeAPI->setAttribute(xc, NODE_HEIGHT, &itemSize);
    133.     ArkUI_AttributeItem item2 = {value, 1, "ndkxcomponent"};
    134.     nodeAPI->setAttribute(xc, NODE_ID, &item2);
    
    135.     auto *nativeXComponent = OH_NativeXComponent_GetNativeXComponent(xc);
    136.     if (!nativeXComponent) {
    137.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "GetNativeXComponent error");
    138.         return column;
    139.     }
    140.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "GetNativeXComponent success");
    141.     // 注册XComponent回调函数
    142.     OH_NativeXComponent_RegisterCallback(nativeXComponent, &PluginManager::callback_);
    143.     auto typeRet = nodeAPI->getAttribute(xc, NODE_XCOMPONENT_TYPE);
    144.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "xcomponent type: %{public}d",
    145.                 typeRet->value[0].i32);
    146.     auto idRet = nodeAPI->getAttribute(xc, NODE_XCOMPONENT_ID);
    147.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "xcomponent id: %{public}s",
    148.                 idRet->string);
    149.     nodeAPI->addChild(column, xc);
    150.     return column;
    151. }
    
    (3) 定义NapiDrawPattern方法，暴露到ArkTS侧的drawPattern()方法会执行该方法。
    
    152. napi_value PluginManager::NapiDrawPattern(napi_env env, napi_callback_info info) {
    153.     // ...
    154.     // 获取环境变量参数
    155.     napi_value thisArg;
    156.     if (napi_get_cb_info(env, info, nullptr, nullptr, &thisArg, nullptr) != napi_ok) {
    157.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager", "NapiDrawPattern: napi_get_cb_info fail");
    158.         return nullptr;
    159.     }
    
    160.     auto *pluginManager = PluginManager::GetInstance();
    161.     // 调用绘制方法
    162.     pluginManager->eglcore_->Draw(hasDraw_);
    163.     OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "PluginManager", "render->eglCore_->Draw() executed");
    
    164.     return nullptr;
    165. }
    
4. 初始化环境，包括初始化可用的EGLDisplay、确定可用的Surface配置、创建渲染区域Surface、创建并关联上下文等。
    
    1. void EGLCore::UpdateSize(int width, int height) {
    2.     // width_和height_在头文件中定义
    3.     width_ = width;
    4.     height_ = height;
    5.     if (width_ > 0) {
    6.         widthPercent_ = FIFTY_PERCENT * height_ / width_;
    7.     }
    8. }
    
    9. bool EGLCore::EglContextInit(void *window, int width, int height) {
    10.     // ...
    11.     UpdateSize(width, height);
    12.     eglWindow_ = static_cast<EGLNativeWindowType>(window);
    
    13.     // 初始化display
    14.     eglDisplay_ = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    15.     if (eglDisplay_ == EGL_NO_DISPLAY) {
    16.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "eglGetDisplay: unable to get EGL display");
    17.         return false;
    18.     }
    
    19.     // 初始化EGL
    20.     EGLint majorVersion;
    21.     EGLint minorVersion;
    22.     if (!eglInitialize(eglDisplay_, &majorVersion, &minorVersion)) {
    23.         OH_LOG_Print(
    24.             LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "eglInitialize: unable to get initialize EGL display");
    25.         return false;
    26.     }
    
    27.     // 选择配置
    28.     const EGLint maxConfigSize = 1;
    29.     EGLint numConfigs;
    30.     if (!eglChooseConfig(eglDisplay_, ATTRIB_LIST, &eglConfig_, maxConfigSize, &numConfigs)) {
    31.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "eglChooseConfig: unable to choose configs");
    32.         return false;
    33.     }
    34.     // 创建环境
    35.     return CreateEnvironment();
    36.     }
    
    37. bool EGLCore::CreateEnvironment() {
    38.     // 创建Surface
    39.     if (eglWindow_ == nullptr) {
    40.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "eglWindow_ is null");
    41.         return false;
    42.     }
    43.     eglSurface_ = eglCreateWindowSurface(eglDisplay_, eglConfig_, eglWindow_, NULL);
    44.     if (eglSurface_ == nullptr) {
    45.         OH_LOG_Print(
    46.             LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "eglCreateWindowSurface: unable to create surface");
    47.         return false;
    48.     }
    
    49.     // 创建context
    50.     eglContext_ = eglCreateContext(eglDisplay_, eglConfig_, EGL_NO_CONTEXT, CONTEXT_ATTRIBS);
    51.     if (!eglMakeCurrent(eglDisplay_, eglSurface_, eglSurface_, eglContext_)) {
    52.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "eglMakeCurrent failed");
    53.         return false;
    54.     }
    
    55.     // 创建program
    56.     program_ = CreateProgram(VERTEX_SHADER, FRAGMENT_SHADER);
    57.     if (program_ == PROGRAM_ERROR) {
    58.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "CreateProgram: unable to create program");
    59.         return false;
    60.     }
    61.     return true;
    62. }
    
    63. GLuint EGLCore::CreateProgram(const char* vertexShader, const char* fragShader) {
    64.     if ((vertexShader == nullptr) || (fragShader == nullptr)) {
    65.         OH_LOG_Print(
    66.             LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "createProgram: vertexShader or fragShader is null");
    67.         return PROGRAM_ERROR;
    68.     }
    
    69.     GLuint vertex = LoadShader(GL_VERTEX_SHADER, vertexShader);
    70.     if (vertex == PROGRAM_ERROR) {
    71.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "createProgram vertex error");
    72.         return PROGRAM_ERROR;
    73.     }
    
    74.     GLuint fragment = LoadShader(GL_FRAGMENT_SHADER, fragShader);
    75.     if (fragment == PROGRAM_ERROR) {
    76.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "createProgram fragment error");
    77.         return PROGRAM_ERROR;
    78.     }
    
    79.     GLuint program = glCreateProgram();
    80.     if (program == PROGRAM_ERROR) {
    81.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "createProgram program error");
    82.         glDeleteShader(vertex);
    83.         glDeleteShader(fragment);
    84.         return PROGRAM_ERROR;
    85.     }
    
    86.     // 该gl函数没有返回值。
    87.     glAttachShader(program, vertex);
    88.     glAttachShader(program, fragment);
    89.     glLinkProgram(program);
    
    90.     GLint linked;
    91.     glGetProgramiv(program, GL_LINK_STATUS, &linked);
    92.     if (linked != 0) {
    93.         glDeleteShader(vertex);
    94.         glDeleteShader(fragment);
    95.         return program;
    96.     }
    
    97.     OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "createProgram linked error");
    98.     GLint infoLen = 0;
    99.     glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLen);
    100.     if (infoLen > 1) {
    101.         char* infoLog = (char*)malloc(sizeof(char) * (infoLen + 1));
    102.         memset(infoLog, 0, infoLen + 1);
    103.         glGetProgramInfoLog(program, infoLen, nullptr, infoLog);
    104.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "glLinkProgram error = %s", infoLog);
    105.         free(infoLog);
    106.         infoLog = nullptr;
    107.     }
    108.     glDeleteShader(vertex);
    109.     glDeleteShader(fragment);
    110.     glDeleteProgram(program);
    111.     return PROGRAM_ERROR;
    112. }
    
    113. GLuint EGLCore::LoadShader(GLenum type, const char* shaderSrc) {
    114.     if ((type == 0) || (shaderSrc == nullptr)) {
    115.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "glCreateShader type or shaderSrc error");
    116.         return PROGRAM_ERROR;
    117.     }
    
    118.     GLuint shader = glCreateShader(type);
    119.     if (shader == 0) {
    120.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "glCreateShader unable to load shader");
    121.         return PROGRAM_ERROR;
    122.     }
    
    123.     // 该gl函数没有返回值。
    124.     glShaderSource(shader, 1, &shaderSrc, nullptr);
    125.     glCompileShader(shader);
    
    126.     GLint compiled;
    127.     glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
    128.     if (compiled != 0) {
    129.         return shader;
    130.     }
    
    131.     GLint infoLen = 0;
    132.     glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
    133.     if (infoLen <= 1) {
    134.         glDeleteShader(shader);
    135.         return PROGRAM_ERROR;
    136.     }
    
    137.     char *infoLog = (char*)malloc(sizeof(char) * (infoLen + 1));
    138.     if (infoLog != nullptr) {
    139.         memset(infoLog, 0, infoLen + 1);
    140.         glGetShaderInfoLog(shader, infoLen, nullptr, infoLog);
    141.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "glCompileShader error = %s", infoLog);
    142.         free(infoLog);
    143.         infoLog = nullptr;
    144.     }
    145.     glDeleteShader(shader);
    146.     return PROGRAM_ERROR;
    147. }
    
5. 渲染功能实现。
    
    (1) 绘制背景。
    
    1. // ...
    2. // 绘制背景颜色 #f4f4f4
    3. const GLfloat BACKGROUND_COLOR[] = { 244.0f / 255, 244.0f / 255, 244.0f / 255, 1.0f };
    
    4. // 绘制图案颜色
    5. const GLfloat DRAW_COLOR[] = {126.0f / 255, 143.0f / 255, 251.0f / 255, 1.0f};
    
    6. // 绘制图案改变后的颜色
    7. const GLfloat CHANGE_COLOR[] = {146.0f / 255, 214.0f / 255, 204.0f / 255, 1.0f};
    
    8. // 绘制背景顶点
    9. const GLfloat BACKGROUND_RECTANGLE_VERTICES[] = {
    10.     -1.0f, 1.0f,
    11.     1.0f, 1.0f,
    12.     1.0f, -1.0f,
    13.     -1.0f, -1.0f
    14. };
    15. // ...
    
    16. // 绘制背景颜色
    17. void EGLCore::Background() {
    18.     GLint position = PrepareDraw();
    19.     if (position == POSITION_ERROR) {
    20.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Background get position failed");
    21.         return;
    22.     }
    
    23.     if (!ExecuteDraw(position, BACKGROUND_COLOR, BACKGROUND_RECTANGLE_VERTICES,
    24.                      sizeof(BACKGROUND_RECTANGLE_VERTICES))) {
    25.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Background execute draw failed");
    26.         return;
    27.     }
    
    28.     if (!FinishDraw()) {
    29.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Background FinishDraw failed");
    30.         return;
    31.     }
    32. }
    
    33. // 绘前准备，获取position，创建成功时position值从0开始
    34. GLint EGLCore::PrepareDraw() {
    35.     if ((eglDisplay_ == nullptr) || (eglSurface_ == nullptr) || (eglContext_ == nullptr) ||
    36.         (!eglMakeCurrent(eglDisplay_, eglSurface_, eglSurface_, eglContext_))) {
    37.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "PrepareDraw: param error");
    38.         return POSITION_ERROR;
    39.     }
    
    40.     // 该gl函数没有返回值。
    41.     glViewport(DEFAULT_X_POSITION, DEFAULT_Y_POSITION, width_, height_);
    42.     glClearColor(GL_RED_DEFAULT, GL_GREEN_DEFAULT, GL_BLUE_DEFAULT, GL_ALPHA_DEFAULT);
    43.     glClear(GL_COLOR_BUFFER_BIT);
    44.     glUseProgram(program_);
    
    45.     return glGetAttribLocation(program_, POSITION_NAME);
    46. }
    
    47. // 依据传入参数在指定区域绘制指定颜色
    48. bool EGLCore::ExecuteDraw(GLint position, const GLfloat *color, const GLfloat shapeVertices[], unsigned long vertSize) {
    49.     if ((position > 0) || (color == nullptr) || (vertSize / sizeof(shapeVertices[0])) != SHAPE_VERTICES_SIZE) {
    50.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "ExecuteDraw: param error");
    51.         return false;
    52.     }
    
    53.     // 该gl函数没有返回值。
    54.     glVertexAttribPointer(position, POINTER_SIZE, GL_FLOAT, GL_FALSE, 0, shapeVertices);
    55.     glEnableVertexAttribArray(position);
    56.     glVertexAttrib4fv(1, color);
    57.     glDrawArrays(GL_TRIANGLE_FAN, 0, TRIANGLE_FAN_SIZE);
    58.     glDisableVertexAttribArray(position);
    
    59.     return true;
    60. }
    
    61. // 结束绘制操作
    62. bool EGLCore::FinishDraw() {
    63.     // 强制刷新缓冲
    64.     glFlush();
    65.     glFinish();
    66.     return eglSwapBuffers(eglDisplay_, eglSurface_);
    67. }
    
    (2) 绘制图形。
    
    68. void EGLCore::Draw(int& hasDraw) {
    69.     flag_ = false;
    70.     OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "EGLCore", "Draw");
    71.     GLint position = PrepareDraw();
    72.     if (position == POSITION_ERROR) {
    73.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Draw get position failed");
    74.         return;
    75.     }
    
    76.     // 绘制背景
    77.     if (!ExecuteDraw(position, BACKGROUND_COLOR,
    78.                     BACKGROUND_RECTANGLE_VERTICES, sizeof(BACKGROUND_RECTANGLE_VERTICES))) {
    79.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Draw execute draw background failed");
    80.         return;
    81.     }
    
    82.     // 将五角星分为五个四边形，计算其中一个四边形的四个顶点
    83.     GLfloat rotateX = 0;
    84.     GLfloat rotateY = FIFTY_PERCENT * height_;
    85.     GLfloat centerX = 0;
    86.     GLfloat centerY = -rotateY * (M_PI / 180 * 54) * (M_PI / 180 * 18);
    87.     GLfloat leftX = -rotateY * (M_PI / 180 * 18);
    88.     GLfloat leftY = 0;
    89.     GLfloat rightX = rotateY * (M_PI / 180 * 18);
    90.     GLfloat rightY = 0;
    
    91.     // 确定绘制四边形的顶点，使用绘制区域的百分比表示
    92.     const GLfloat shapeVertices[] = {
    93.         centerX / width_, centerY / height_,
    94.         leftX / width_, leftY / height_,
    95.         rotateX / width_, rotateY / height_,
    96.         rightX / width_, rightY / height_
    97.     };
    
    98.     if (!ExecuteDrawStar(position, DRAW_COLOR, shapeVertices, sizeof(shapeVertices))) {
    99.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Draw execute draw star failed");
    100.         return;
    101.     }
    
    102.     GLfloat rad = M_PI / 180 * 72;
    103.     for (int i = 0; i < NUM_4; ++i) {
    104.         // 旋转得其他四个四边形的顶点
    105.         Rotate2d(centerX, centerY, &rotateX, &rotateY, rad);
    106.         Rotate2d(centerX, centerY, &leftX, &leftY, rad);
    107.         Rotate2d(centerX, centerY, &rightX, &rightY, rad);
    
    108.         // 确定绘制四边形的顶点，使用绘制区域的百分比表示
    109.         const GLfloat shapeVertices[] = {
    110.             centerX / width_, centerY / height_,
    111.             leftX / width_, leftY / height_,
    112.             rotateX / width_, rotateY / height_,
    113.             rightX / width_, rightY / height_
    114.         };
    
    115.         // 绘制图形
    116.         if (!ExecuteDrawStar(position, DRAW_COLOR, shapeVertices, sizeof(shapeVertices))) {
    117.             OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Draw execute draw shape failed");
    118.             return;
    119.         }
    120.     }
    
    121.     // 结束绘制
    122.     if (!FinishDraw()) {
    123.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Draw FinishDraw failed");
    124.         return;
    125.     }
    126.     hasDraw = 1;
    
    127.     flag_ = true;
    128. }
    
    (3) 改变颜色，重新画一个大小相同颜色不同的图形，与原图形替换，达到改变颜色的效果。
    
    129. void EGLCore::ChangeColor(int& hasChangeColor) {
    130.     if (!flag_) {
    131.         return;
    132.     }
    133.     OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "EGLCore", "ChangeColor");
    134.     GLint position = PrepareDraw();
    135.     if (position == POSITION_ERROR) {
    136.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "ChangeColor get position failed");
    137.         return;
    138.     }
    
    139.     // 绘制背景
    140.     if (!ExecuteDraw(position, BACKGROUND_COLOR,
    141.                     BACKGROUND_RECTANGLE_VERTICES, sizeof(BACKGROUND_RECTANGLE_VERTICES))) {
    142.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "ChangeColor execute draw background failed");
    143.         return;
    144.     }
    
    145.     // 确定绘制四边形的顶点，使用绘制区域的百分比表示
    146.     GLfloat rotateX = 0;
    147.     GLfloat rotateY = FIFTY_PERCENT * height_;
    148.     GLfloat centerX = 0;
    149.     GLfloat centerY = -rotateY * (M_PI / 180 * 54) * (M_PI / 180 * 18);
    150.     GLfloat leftX = -rotateY * (M_PI / 180 * 18);
    151.     GLfloat leftY = 0;
    152.     GLfloat rightX = rotateY * (M_PI / 180 * 18);
    153.     GLfloat rightY = 0;
    
    154.     // 确定绘制四边形的顶点，使用绘制区域的百分比表示
    155.     const GLfloat shapeVertices[] = {
    156.         centerX / width_, centerY / height_,
    157.         leftX / width_, leftY / height_,
    158.         rotateX / width_, rotateY / height_,
    159.         rightX / width_, rightY / height_
    160.     };
    
    161.     // 使用新的颜色绘制
    162.     if (!ExecuteDrawNewStar(position, CHANGE_COLOR, shapeVertices, sizeof(shapeVertices))) {
    163.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Draw execute draw star failed");
    164.         return;
    165.     }
    
    166.     GLfloat rad = M_PI / 180 * 72;
    167.     for (int i = 0; i < NUM_4; ++i) {
    168.         // 旋转得其他四个四边形的顶点
    169.         Rotate2d(centerX, centerY, &rotateX, &rotateY, rad);
    170.         Rotate2d(centerX, centerY, &leftX, &leftY, rad);
    171.         Rotate2d(centerX, centerY, &rightX, &rightY, rad);
    
    172.         // 确定绘制四边形的顶点，使用绘制区域的百分比表示
    173.         const GLfloat shapeVertices[] = {
    174.             centerX / width_, centerY / height_,
    175.             leftX / width_, leftY / height_,
    176.             rotateX / width_, rotateY / height_,
    177.             rightX / width_, rightY / height_
    178.         };
    
    179.         // 使用新的颜色绘制
    180.         if (!ExecuteDrawNewStar(position, CHANGE_COLOR, shapeVertices, sizeof(shapeVertices))) {
    181.             OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Draw execute draw shape failed");
    182.             return;
    183.         }
    184.     }
    
    185.     // 结束绘制
    186.     if (!FinishDraw()) {
    187.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "ChangeColor FinishDraw failed");
    188.     }
    189.     hasChangeColor = 1;
    190. }
    
    191. bool EGLCore::ExecuteDrawNewStar(
    192.    GLint position, const GLfloat* color, const GLfloat shapeVertices[], unsigned long vertSize) {
    193.    if ((position > 0) || (color == nullptr) || (vertSize / sizeof(shapeVertices[0])) != SHAPE_VERTICES_SIZE) {
    194.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "ExecuteDraw: param error");
    195.         return false;
    196.     }
    
    197.     // 该gl函数没有返回值。
    198.     glVertexAttribPointer(position, POINTER_SIZE, GL_FLOAT, GL_FALSE, 0, shapeVertices);
    199.     glEnableVertexAttribArray(position);
    200.     glVertexAttrib4fv(1, color);
    201.     glDrawArrays(GL_TRIANGLE_FAN, 0, TRIANGLE_FAN_SIZE);
    202.     glDisableVertexAttribArray(position);
    
    203.    return true;
    204. }
    
6. 释放相关资源。
    
    EGLCore类下创建Release()方法，释放初始化环境时申请的资源，包含窗口display、渲染区域surface、环境上下文context等。
    
    1. void EGLCore::Release() {
    2.     // 释放Surface
    3.     if ((eglDisplay_ == nullptr) || (eglSurface_ == nullptr) || (!eglDestroySurface(eglDisplay_, eglSurface_))) {
    4.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Release eglDestroySurface failed");
    5.     }
    6.     // 释放context
    7.     if ((eglDisplay_ == nullptr) || (eglContext_ == nullptr) || (!eglDestroyContext(eglDisplay_, eglContext_))) {
    8.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Release eglDestroyContext failed");
    9.     }
    10.     // 释放display
    11.     if ((eglDisplay_ == nullptr) || (!eglTerminate(eglDisplay_))) {
    12.         OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "EGLCore", "Release eglTerminate failed");
    13.     }
    14. }
    
7. CMakeLists，使用CMake工具链将C++源代码编译成动态链接库文件。
    
    1. # 设置CMake最小版本
    2. cmake_minimum_required(VERSION 3.4.1)
    3. # 项目名称
    4. project(XComponent)
    
    5. set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})
    6. add_definitions(-DOHOS_PLATFORM)
    7. # 设置头文件搜索目录
    8. include_directories(
    9.     ${NATIVERENDER_ROOT_PATH}
    10.     ${NATIVERENDER_ROOT_PATH}/include
    11. )
    12. # 添加名为nativerender的动态库，库文件名为libnativerender.so，添加cpp文件
    13. add_library(nativerender SHARED
    14.     render/egl_core.cpp
    15.     render/plugin_render.cpp
    16.     manager/plugin_manager.cpp
    17.     napi_init.cpp
    18. )
    
    19. find_library(
    20.     EGL-lib
    21.     EGL
    22. )
    
    23. find_library(
    24.     GLES-lib
    25.     GLESv3
    26. )
    
    27. find_library(
    28.     hilog-lib
    29.     hilog_ndk.z
    30. )
    
    31. find_library(
    32.     libace-lib
    33.     ace_ndk.z
    34. )
    
    35. find_library(
    36.     libnapi-lib
    37.     ace_napi.z
    38. )
    
    39. find_library(
    40.     libuv-lib
    41.     uv
    42. )
    43. # 添加构建需要链接的库
    44. target_link_libraries(nativerender PUBLIC
    45.     ${EGL-lib} ${GLES-lib} ${hilog-lib} ${libace-lib} ${libnapi-lib} ${libuv-lib})
    

## 示例代码

- [ArkTS XComponent](https://gitcode.com/HarmonyOS_Samples/guide-snippets/tree/master/ArkUIKit/ArkTSXComponent)
- [NdkXComponent](https://gitcode.com/HarmonyOS_Samples/guide-snippets/tree/master/ArkUIKit/NdkXComponent)
- [NativeXComponent](https://gitcode.com/HarmonyOS_Samples/guide-snippets/tree/master/ArkUIKit/NativeXComponent)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-add-component "添加组件")
# 弹窗概述

更新时间: 2025-12-16 16:38

弹窗一般指打开应用时自动弹出或者用户行为操作时弹出的UI界面，用于短时间内展示用户需关注的信息或待处理的操作。

从ArkUI组件树层级上来看，Overlay浮层、弹窗、模态、带Order的Overlay浮层都挂载在Root节点下。弹窗、模态、带Order的Overlay浮层根据设置的层级（数字大小）进行逐层显示，并且全部显示在Overlay浮层上面。如图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.47905315952728899149288016005171:50001231000000:2800:727FDD44B11980EC6DDDBEF6F9BAC5C6AB22FFEE4F729066D2FC8CD2AC6F2B0D.png)

对于一个多页面应用，基本树结构如下所示。多个Page页面之间使用[Router](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-router)的接口进行跳转。[NavBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navbar12)和[Navdestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)组成的页面可以通过[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)接口进行跳转。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.65022434038069772931138844948914:50001231000000:2800:A99B886B614C527DA964C0DD0D1DAD2CECE296F634F87C78A69B9F26F035D85C.png)

而[Dialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview)、[Popup](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-overview)、[Menu](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-menu-overview)、[OverlayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-overlaymanager)、[Toast](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-toast)、[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sheet-page)以及[bindContentCover](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-contentcover-page)的组件在结合路由、导航使用时存在如下几种显示模式。

- 弹窗显示在当前应用窗口最上层，层级高于应用主窗内所有页面（默认行为）。
    
    如下图所示，触发弹窗显示时，弹窗层级要高于Page页面和Navigation页面，即如果弹窗组件没有被关闭的话，页面切换前后，弹窗组件都会显示在页面上方，而不会出现新的路由/导航页面覆盖在弹窗之上的情况。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.95607431044978805052089431190893:50001231000000:2800:8EA9808DD31AD47CEC2C5496D42218D5AAEA3AEE42CD64159A9C6BD6C40DB465.png)
    
    说明
    
    如果Popup或Menu等存在绑定组件的弹窗组件，在页面跳转后因为所绑定的组件不在新页面显示，系统内部会自动关闭对应弹窗组件。但因为弹窗组件显示同时受开发者配置的参数控制，例如当[Popup](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-overview)的show参数设置为显示时，弹窗组件会覆盖在下一个页面上显示。
    
- 弹窗显示在当前页面内，层级低于下一跳页面。
    
    当开发者期望弹窗是一个页面内的弹窗，即当路由/导航切换页面时，弹窗会被跳转的页面覆盖，随着页面切回原页面，弹窗仍然正常显示。此时弹窗层级如下图所示：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.56912508335594871821255385755841:50001231000000:2800:B852C16F11DD991C8B40FC10C64ED4EAFCA43F5F174AD0FF87DB6588F5B68103.png)
    
    页面级弹窗功能需要结合弹窗组件的页面级能力使用，当前支持页面级能力的有[Dialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview)和[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sheet-page)。
    
- 弹窗显示在独立窗口内，窗口层级高于应用所在窗口。
    
    在PC/2in1等设备上，开发者常期望弹窗的显示在应用窗口之外，此时需要借助子窗的能力。例如自定义弹窗可以通过[CustomDialogControllerOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-custom-dialog-box#customdialogcontrolleroptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)中的showInSubwindow属性控制是否使用子窗功能。基于子窗显示的弹窗效果如下图所示。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.08076725336062733914660833609975:50001231000000:2800:58AE00C6368238975B87DDC0C60DF3AFFC2A0818D48AC53D4EB63BB36F23F003.png)
    
    此时弹窗组件的显示层级受窗口的层级管理控制，会高于当前应用所在的窗口，低于系统窗口（如系统输入法、系统弹窗等）。
    

## 弹窗的种类

根据用户交互操作场景，弹窗可分为**模态弹窗**和**非模态弹窗**两种类型，其区别在于用户是否必须对其做出响应。

- **模态弹窗：** 为强交互形式，会中断用户当前的操作流程，要求用户必须做出响应才能继续其他操作，通常用于需要向用户传达重要信息的场景。
- **非模态弹窗：** 为弱交互形式，不会影响用户当前操作行为，用户可以不对其进行回应，通常都有时间限制，出现一段时间后会自动消失。一般用于告诉用户信息内容外还需要用户进行功能操作的场景。

说明

当前模态弹窗通过设置指定属性变成非模态，例如AlertDialog，可以设置[isModal](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-alert-dialog-box#alertdialogparam%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)为false变成非模态，其他弹窗详见API说明。

不建议在非前台状态下，调用弹窗显示接口。

系统弹窗由系统弹出，出于安全考虑，不支持自定义样式。

系统弹窗出现时，调用非系统弹窗的显示接口（例如：promptAction的openCustomDialog、CustomDialogController的open等），禁止该类弹窗显示。

## 使用场景

开发者可根据实际应用场景选择合适的弹窗进行页面开发。

|弹窗名称|应用场景|
|:--|:--|
|[弹出框（Dialog）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview)|当需要展示用户当前需要或必须关注的信息内容或操作时，例如二次退出应用等，应优先考虑使用此弹出框。|
|[菜单（Menu/openMenu）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-menu-overview)|当需要给用户提供可执行的操作时，例如长按图标展示操作选项等，应优先考虑使用此弹窗。|
|[气泡提示（Popup/openPopup）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-overview)|当需要给用户提供提示时，例如点击一个问号图标弹出一段帮助提示等，应优先考虑使用此弹窗。|
|[绑定模态页面（bindContentCover/bindSheet）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-modal-overview)|当需要新的界面覆盖在旧的界面上，且旧的界面不消失的一种转场方式时，例如缩略图片点击后查看大图等，应优先考虑使用此弹窗。|
|[即时反馈（Toast）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-toast)|当需要在一个小的窗口中提供用户当前操作的简单反馈时，例如提示文件保存成功等，应优先考虑使用此弹窗。|
|[设置浮层（OverlayManager）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-overlaymanager)|当需要完全自定义内容、行为、样式时，可以使用浮层将UI展示在页面之上，例如音乐/语音播放悬浮球/胶囊等，应优先考虑使用此弹窗。|

## 规格约束

- 多个弹窗组件先后弹出时，后弹出的组件的层级高于先弹出的层级，退出时按照层级从高到低的顺序逐次退出。
    
- 在移动设备中，子窗模式的弹窗当前无法超出主窗口。而在2in1设备上，使用模态类弹窗时，会出现需要超出主窗口显示的场景，开发者可以通过设置showInSubWindow为true实现超出主窗口的显示效果。如下图所示：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163859.83241927172757125380529191817531:50001231000000:2800:098E1911BA7254145EE785FBFD23E7532693A1941FEB6C8455E0B79B05ADC8E9.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-dialog "使用弹窗")
# 弹出框概述

更新时间: 2025-12-16 16:40

弹出框是一种模态窗口，通常用于在保持当前上下文环境的同时，临时展示用户需关注的信息或待处理的操作。用户需在模态弹出框内完成相关交互任务之后，才能退出模态模式。弹出框可以不与任何组件绑定，其内容通常由多种组件组成，如文本、列表、输入框、图片等，以实现布局。ArkUI当前提供了**自定义**和**固定样式**两类弹出框组件。

- **自定义弹出框：** 开发者需要根据使用场景，传入自定义组件填充在弹出框中实现自定义的弹出框内容。主要包括基础自定义弹出框 (CustomDialog)、不依赖UI组件的自定义弹出框 (openCustomDialog)。
- **固定样式弹出框：** 开发者可使用固定样式弹出框，指定需要显示的文本内容和按钮操作，完成简单的交互效果。主要包括警告弹窗 (AlertDialog)、列表选择弹窗 (ActionSheet)、选择器弹窗 (PickerDialog)、对话框 (showDialog)、操作菜单 (showActionMenu)。

## 使用场景

|名称|描述|
|:--|:--|
|[不依赖UI组件的全局自定义弹出框 (openCustomDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|当用户需要在自定义弹出框内动态更新弹出框属性时使用。|
|[基础自定义弹出框 (CustomDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|当用户需要自定义弹出框内的组件和内容时使用。|
|[警告弹窗 (AlertDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E8%AD%A6%E5%91%8A%E5%BC%B9%E7%AA%97-alertdialog)|固定样式，通常用来展示用户当前需要或必须关注的信息或操作。如用户操作一个敏感行为时响应一个二次确认的弹出框。|
|[列表选择弹窗 (ActionSheet)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E5%BC%B9%E7%AA%97-actionsheet)|固定样式，当用户需要关注或确认的信息存在列表选择时使用。|
|[选择器弹窗 (PickerDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E9%80%89%E6%8B%A9%E5%99%A8%E5%BC%B9%E7%AA%97-pickerdialog)|固定样式，当用户需要在弹出框内选择日期、时间和文本时使用。|
|[对话框 (showDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%AF%B9%E8%AF%9D%E6%A1%86-showdialog)|固定样式，当用户需要处理弹出框响应后的异步返回结果时调用。|
|[操作菜单 (showActionMenu)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E6%93%8D%E4%BD%9C%E8%8F%9C%E5%8D%95-showactionmenu)|固定样式，当用户需要处理操作菜单响应后的异步返回结果时调用。|
|[页面级弹出框](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-embedded-dialog)|页面级弹出框，当用户期望弹出框跟随导航页面切换时使用。|
|[弹出框层级管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-levelorder)|从API version 18开始，可以通过设置[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来管理弹出框的显示顺序。|
|[弹出框控制器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-controller)|从API version 18开始，可设置controller参数以绑定[DialogController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#dialogcontroller18)控制器，通过控制器可以对弹出框进行操作。|
|[弹出框焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-focusable)|从API version 19开始，可以通过设置[focusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来管理弹出框是否获取焦点。|
|[弹出框蒙层控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-mask)|开发者可以通过设置maskColor、maskRect等参数来对弹出框蒙层进行定制。|

## 规格约束

- 建议使用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中的弹出框方法。
- 可以通过使用UIContext中的[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取当前UI上下文关联的[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象。
- 由于系统安全管控原因，当弹出系统权限弹窗等场景时，弹出框在此状态下无法显示。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-dialogs "弹出框 (Dialog)")
# 弹出框概述

更新时间: 2025-12-16 16:40

弹出框是一种模态窗口，通常用于在保持当前上下文环境的同时，临时展示用户需关注的信息或待处理的操作。用户需在模态弹出框内完成相关交互任务之后，才能退出模态模式。弹出框可以不与任何组件绑定，其内容通常由多种组件组成，如文本、列表、输入框、图片等，以实现布局。ArkUI当前提供了**自定义**和**固定样式**两类弹出框组件。

- **自定义弹出框：** 开发者需要根据使用场景，传入自定义组件填充在弹出框中实现自定义的弹出框内容。主要包括基础自定义弹出框 (CustomDialog)、不依赖UI组件的自定义弹出框 (openCustomDialog)。
- **固定样式弹出框：** 开发者可使用固定样式弹出框，指定需要显示的文本内容和按钮操作，完成简单的交互效果。主要包括警告弹窗 (AlertDialog)、列表选择弹窗 (ActionSheet)、选择器弹窗 (PickerDialog)、对话框 (showDialog)、操作菜单 (showActionMenu)。

## 使用场景

|名称|描述|
|:--|:--|
|[不依赖UI组件的全局自定义弹出框 (openCustomDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|当用户需要在自定义弹出框内动态更新弹出框属性时使用。|
|[基础自定义弹出框 (CustomDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|当用户需要自定义弹出框内的组件和内容时使用。|
|[警告弹窗 (AlertDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E8%AD%A6%E5%91%8A%E5%BC%B9%E7%AA%97-alertdialog)|固定样式，通常用来展示用户当前需要或必须关注的信息或操作。如用户操作一个敏感行为时响应一个二次确认的弹出框。|
|[列表选择弹窗 (ActionSheet)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E5%BC%B9%E7%AA%97-actionsheet)|固定样式，当用户需要关注或确认的信息存在列表选择时使用。|
|[选择器弹窗 (PickerDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E9%80%89%E6%8B%A9%E5%99%A8%E5%BC%B9%E7%AA%97-pickerdialog)|固定样式，当用户需要在弹出框内选择日期、时间和文本时使用。|
|[对话框 (showDialog)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%AF%B9%E8%AF%9D%E6%A1%86-showdialog)|固定样式，当用户需要处理弹出框响应后的异步返回结果时调用。|
|[操作菜单 (showActionMenu)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E6%93%8D%E4%BD%9C%E8%8F%9C%E5%8D%95-showactionmenu)|固定样式，当用户需要处理操作菜单响应后的异步返回结果时调用。|
|[页面级弹出框](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-embedded-dialog)|页面级弹出框，当用户期望弹出框跟随导航页面切换时使用。|
|[弹出框层级管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-levelorder)|从API version 18开始，可以通过设置[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来管理弹出框的显示顺序。|
|[弹出框控制器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-controller)|从API version 18开始，可设置controller参数以绑定[DialogController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#dialogcontroller18)控制器，通过控制器可以对弹出框进行操作。|
|[弹出框焦点策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-focusable)|从API version 19开始，可以通过设置[focusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来管理弹出框是否获取焦点。|
|[弹出框蒙层控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-mask)|开发者可以通过设置maskColor、maskRect等参数来对弹出框蒙层进行定制。|

## 规格约束

- 建议使用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中的弹出框方法。
- 可以通过使用UIContext中的[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取当前UI上下文关联的[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象。
- 由于系统安全管控原因，当弹出系统权限弹窗等场景时，弹出框在此状态下无法显示。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-dialogs "弹出框 (Dialog)")
# 不依赖UI组件的全局自定义弹出框 (openCustomDialog)

更新时间: 2025-12-16 16:40

在广告、中奖、警告、软件更新等与用户交互响应操作的场景下，可以使用UIContext中获取到的PromptAction对象提供的[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12)接口来实现自定义弹出框。相较于[CustomDialogController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-custom-dialog-box#customdialogcontroller)优势点在于页面解耦，支持[动态刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-componentcontent#update)。

说明

弹出框（openCustomDialog）存在两种入参方式创建自定义弹出框：

- openCustomDialog（传参为ComponentContent形式）：通过ComponentContent封装内容可以与UI界面解耦，调用更加灵活，可以满足开发者的封装诉求。具有较高的灵活性，弹出框样式完全自定义，并且在弹出框打开后可以使用updateCustomDialog方法动态更新弹出框的参数。
- openCustomDialog（传参为builder形式）：相对于ComponentContent，builder必须要与上下文做绑定，与UI存在一定耦合。此方法有用默认的弹出框样式，适合于开发者想要实现与系统弹窗默认风格一致的效果。

本文介绍通过入参形式为ComponentContent创建自定义弹出框，传builder形式的弹出框使用方法可参考[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12-1)。

弹出框（openCustomDialog）默认为模态弹窗且有蒙层，不可与蒙层下方控件进行交互（不支持点击和手势等向下透传）。可以通过配置[promptAction.BaseDialogOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)类型中的isModal属性来实现模态和非模态弹窗，详细说明可参考[弹窗的种类](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-overview#%E5%BC%B9%E7%AA%97%E7%9A%84%E7%A7%8D%E7%B1%BB)。

当isModal为true时，弹出框为模态弹窗，且弹窗周围的蒙层区不支持透传。isModal为false时，弹出框为非模态弹窗，且弹窗周围的蒙层区可以透传。因此如果需要同时允许弹出框的交互和弹出框外页面的交互行为，需要将弹出框设置为非模态。

## 生命周期

弹出框提供了生命周期函数用于通知用户该弹出框的生命周期。生命周期的触发时序依次为：onWillAppear -> onDidAppear -> onWillDisappear -> onDidDisappear。

|名称|类型|说明|
|:--|:--|:--|
|onDidAppear|() => void|弹出框弹出后的事件回调。|
|onDidDisappear|() => void|弹出框消失后的事件回调。|
|onWillAppear|() => void|弹出框显示动效前的事件回调。|
|onWillDisappear|() => void|弹出框退出动效前的事件回调。|

## 自定义弹出框的打开与关闭

说明

详细变量定义请参考[完整示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B)。

1. 创建ComponentContent。
    
    ComponentContent用于定义自定义弹出框的内容。其中，wrapBuilder(buildText)封装自定义组件，new Params(this.message)是自定义组件的入参，可以缺省，也可以传入基础数据类型。
    
    1. private contentNode: ComponentContent<Object> = new ComponentContent(this.ctx, wrapBuilder(buildText), new Params(this.message));
    
2. 打开自定义弹出框。
    
    调用openCustomDialog接口打开的弹出框默认customStyle为true，即弹出框的内容样式完全按照contentNode自定义样式显示。
    
    1. PromptActionClass.ctx.getPromptAction().openCustomDialog(PromptActionClass.contentNode, PromptActionClass.options)
    2.   .then(() => {
    3.     console.info('OpenCustomDialog complete.');
    4.   })
    5.   .catch((error: BusinessError) => {
    6.     let message = (error as BusinessError).message;
    7.     let code = (error as BusinessError).code;
    8.     console.error(`OpenCustomDialog args error code is ${code}, message is ${message}`);
    9.   })
    
3. 关闭自定义弹出框。
    
    由于closeCustomDialog接口需要传入待关闭弹出框对应的ComponentContent。因此，如果需要在弹出框中设置关闭方法，则可参考完整示例封装静态方法来实现。
    
    关闭弹出框之后若需要释放对应的ComponentContent，则需要调用ComponentContent的[dispose](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-componentcontent#dispose)方法。
    
    1. PromptActionClass.ctx.getPromptAction().closeCustomDialog(PromptActionClass.contentNode)
    2.   .then(() => {
    3.     console.info('CloseCustomDialog complete.');
    4.     if (this.contentNode !== null) {
    5.          this.contentNode.dispose();   // 释放contentNode
    6.      }
    7.   })
    8.   .catch((error: BusinessError) => {
    9.     let message = (error as BusinessError).message;
    10.     let code = (error as BusinessError).code;
    11.     console.error(`CloseCustomDialog args error code is ${code}, message is ${message}`);
    12.   })
    

## 更新自定义弹出框的内容

ComponentContent与[BuilderNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-buildernode)有相同的使用限制，不支持自定义组件使用[@Reusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable)、[@Link](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-link)、[@Provide](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume)、[@Consume](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume)等装饰器，来同步弹出框弹出的页面与ComponentContent中自定义组件的状态。因此，若需要更新弹出框中自定义组件的内容可以通过ComponentContent提供的update方法来实现。

1. this.contentNode.update(new Params('update'))

## 更新自定义弹出框的属性

通过updateCustomDialog可以动态更新弹出框的属性。目前支持更新弹出框的对齐方式、基于对齐方式的偏移量、是否点击蒙层自动关闭以及蒙层颜色，对应的属性分别为alignment、offset、autoCancel、maskColor。

更新属性时，未设置的属性会恢复为默认值。例如，初始设置{ alignment: DialogAlignment.Top, offset: { dx: 0, dy: 50 } }，更新时设置{ alignment: DialogAlignment.Bottom }，则初始设置的offset: { dx: 0, dy: 50 }不会保留，会恢复为默认值。

1. PromptActionClass.ctx.getPromptAction().updateCustomDialog(PromptActionClass.contentNode, options)
2.   .then(() => {
3.     console.info('UpdateCustomDialog complete.');
4.   })
5.   .catch((error: BusinessError) => {
6.     let message = (error as BusinessError).message;
7.     let code = (error as BusinessError).code;
8.     console.error(`UpdateCustomDialog args error code is ${code}, message is ${message}`);
9.   })

## 为弹出框内容和蒙层设置不同的动画效果

当弹出框出现时，内容与蒙层显示动效一致。若开发者希望为弹出框内容及蒙层设定不同动画效果，从API version 19开始，可通过[BaseDialogOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)中dialogTransition和maskTransition属性单独配置弹窗内容与蒙层的动画。具体的动画效果请参考[组件内转场 (transition)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-component)。

说明

当isModal为true时，蒙层将显示，此时可以设置蒙层的动画效果；否则，maskTransition将不生效。

1. import { BusinessError } from '@kit.BasicServicesKit';

2. @Entry
3. @Component
4. struct Index {
5.   private customDialogComponentId: number = 0;

6.   @Builder
7.   customDialogComponent() {
8.     Row({ space: 50 }) {
9.       Button("这是一个弹窗")
10.     }.height(200).padding(5)
11.   }

12.   build() {
13.     Row() {
14.       Row({ space: 20 }) {
15.         Text('打开弹窗')
16.           .fontSize(30)
17.           .onClick(() => {
18.             this.getUIContext()
19.               .getPromptAction()
20.               .openCustomDialog({
21.                 builder: () => {
22.                   this.customDialogComponent()
23.                 },
24.                 isModal: true,
25.                 showInSubWindow: false,
26.                 maskColor: Color.Pink,
27.                 maskRect: {
28.                   x: 20,
29.                   y: 20,
30.                   width: '90%',
31.                   height: '90%'
32.                 },

33.                 dialogTransition: // 设置弹窗内容显示的过渡效果
34.                 TransitionEffect.translate({ x: 0, y: 290, z: 0 })
35.                   .animation({ duration: 4000, curve: Curve.Smooth }), // 四秒钟的偏移渐变动画

36.                 maskTransition: // 设置蒙层显示的过渡效果
37.                 TransitionEffect.opacity(0)
38.                   .animation({ duration: 4000, curve: Curve.Smooth }) // 四秒钟的透明渐变动画

39.               })
40.               .then((dialogId: number) => {
41.                 this.customDialogComponentId = dialogId;
42.               })
43.               .catch((error: BusinessError) => {
44.                 console.error(`openCustomDialog error code is ${error.code}, message is ${error.message}`);
45.               })
46.           })
47.       }
48.       .width('100%')
49.     }
50.     .height('100%')
51.   }
52. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164024.95440222609066584645048640299426:50001231000000:2800:DFE861D18A9E6FA08A5A906DF33B30B2EF1D2CBD67A068E32C1AC78A116B66EF.gif)

## 设置弹出框避让软键盘的距离

为显示弹出框的独立性，弹出框弹出时会与周边进行避让，包括状态栏、导航条以及键盘等留有间距。故当软键盘弹出时，默认情况下，弹出框会自动避开软键盘，并与之保持16vp的距离。从API version 15开始，开发者可以利用[BaseDialogOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)中的keyboardAvoidMode和keyboardAvoidDistance这两个配置项，来设置弹出框在软键盘弹出时的行为，包括是否需要避开软键盘以及与软键盘之间的距离。

设置软键盘间距时，需要将keyboardAvoidMode值设为KeyboardAvoidMode.DEFAULT。

1. import { BusinessError } from '@kit.BasicServicesKit';
2. import { LengthMetrics } from '@kit.ArkUI'

3. @Entry
4. @Component
5. struct Index {
6.   @Builder
7.   customDialogComponent() {
8.       Column() {
9.         Text('keyboardAvoidDistance: 0vp')
10.           .fontSize(20)
11.           .margin({ bottom: 36 })
12.         TextInput({ placeholder: '' })
13.       }.backgroundColor('#FFF0F0F0')
14.   }

15.   build() {
16.     Row() {
17.       Row({ space: 20 }) {
18.         Text('打开弹窗')
19.           .fontSize(30)
20.           .onClick(() => {
21.             this.getUIContext().getPromptAction().openCustomDialog({
22.               builder: () => {
23.                 this.customDialogComponent()
24.               },
25.               alignment: DialogAlignment.Bottom,
26.               keyboardAvoidMode: KeyboardAvoidMode.DEFAULT, // 软键盘弹出时，弹出框自动避让
27.               keyboardAvoidDistance: LengthMetrics.vp(0) // 软键盘弹出时与弹出框的距离为0vp
28.             }).catch((error: BusinessError) => {
29.                 console.error(`openCustomDialog error code is ${error.code}, message is ${error.message}`)
30.               })
31.           })
32.       }
33.       .width('100%')
34.     }
35.     .height('100%')
36.   }
37. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164024.19716129370408479274617568197657:50001231000000:2800:B7DCA6DBA29C2B6067E60C86D5DF3B72B0A350670499600173ED0C2F51E37A16.gif)

## 完整示例

1. // PromptActionClass.ets
2. import { BusinessError } from '@kit.BasicServicesKit';
3. import { ComponentContent, promptAction, UIContext } from '@kit.ArkUI';

4. export class PromptActionClass {
5.   static ctx: UIContext;
6.   static contentNode: ComponentContent<Object>;
7.   static options: promptAction.BaseDialogOptions;

8.   static setContext(context: UIContext) {
9.     PromptActionClass.ctx = context;
10.   }

11.   static setContentNode(node: ComponentContent<Object>) {
12.     PromptActionClass.contentNode = node;
13.   }

14.   static setOptions(options: promptAction.BaseDialogOptions) {
15.     PromptActionClass.options = options;
16.   }

17.   static openDialog() {
18.     if (PromptActionClass.contentNode !== null) {
19.       PromptActionClass.ctx.getPromptAction().openCustomDialog(PromptActionClass.contentNode, PromptActionClass.options)
20.         .then(() => {
21.           console.info('OpenCustomDialog complete.');
22.         })
23.         .catch((error: BusinessError) => {
24.           let message = (error as BusinessError).message;
25.           let code = (error as BusinessError).code;
26.           console.error(`OpenCustomDialog args error code is ${code}, message is ${message}`);
27.         })
28.     }
29.   }

30.   static closeDialog() {
31.     if (PromptActionClass.contentNode !== null) {
32.       PromptActionClass.ctx.getPromptAction().closeCustomDialog(PromptActionClass.contentNode)
33.         .then(() => {
34.           console.info('CloseCustomDialog complete.');
35.         })
36.         .catch((error: BusinessError) => {
37.           let message = (error as BusinessError).message;
38.           let code = (error as BusinessError).code;
39.           console.error(`CloseCustomDialog args error code is ${code}, message is ${message}`);
40.         })
41.     }
42.   }

43.   static updateDialog(options: promptAction.BaseDialogOptions) {
44.     if (PromptActionClass.contentNode !== null) {
45.       PromptActionClass.ctx.getPromptAction().updateCustomDialog(PromptActionClass.contentNode, options)
46.         .then(() => {
47.           console.info('UpdateCustomDialog complete.');
48.         })
49.         .catch((error: BusinessError) => {
50.           let message = (error as BusinessError).message;
51.           let code = (error as BusinessError).code;
52.           console.error(`UpdateCustomDialog args error code is ${code}, message is ${message}`);
53.         })
54.     }
55.   }
56. }

57. // Index.ets
58. import { ComponentContent } from '@kit.ArkUI';
59. import { PromptActionClass } from './PromptActionClass';

60. class Params {
61.   text: string = "";

62.   constructor(text: string) {
63.     this.text = text;
64.   }
65. }

66. @Builder
67. function buildText(params: Params) {
68.   Column() {
69.     Text(params.text)
70.       .fontSize(50)
71.       .fontWeight(FontWeight.Bold)
72.       .margin({ bottom: 36 })
73.     Button('Close')
74.       .onClick(() => {
75.         PromptActionClass.closeDialog();
76.       })
77.   }.backgroundColor('#FFF0F0F0')
78. }

79. @Entry
80. @Component
81. struct Index {
82.   @State message: string = "hello";
83.   private ctx: UIContext = this.getUIContext();
84.   private contentNode: ComponentContent<Object> =
85.     new ComponentContent(this.ctx, wrapBuilder(buildText), new Params(this.message));

86.   aboutToAppear(): void {
87.     PromptActionClass.setContext(this.ctx);
88.     PromptActionClass.setContentNode(this.contentNode);
89.     PromptActionClass.setOptions({ alignment: DialogAlignment.Top, offset: { dx: 0, dy: 50 } });
90.   }

91.   build() {
92.     Row() {
93.       Column() {
94.         Button("open dialog and update options")
95.           .margin({ top: 50 })
96.           .onClick(() => {
97.             PromptActionClass.openDialog();

98.             setTimeout(() => {
99.               PromptActionClass.updateDialog({
100.                 alignment: DialogAlignment.Bottom,
101.                 offset: { dx: 0, dy: -50 }
102.               });
103.             }, 1500)
104.           })
105.         Button("open dialog and update content")
106.           .margin({ top: 50 })
107.           .onClick(() => {
108.             PromptActionClass.openDialog();

109.             setTimeout(() => {
110.               this.contentNode.update(new Params('update'));
111.             }, 1500)
112.           })
113.       }
114.       .width('100%')
115.       .height('100%')
116.     }
117.     .height('100%')
118.   }
119. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164024.44978225973075438303013617287744:50001231000000:2800:1E2655AC29E8396776B4B23E425126B154B6F419DF64435B5874F2518C6BDED9.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview "弹出框概述")
# 固定样式弹出框

更新时间: 2025-12-16 16:40

固定样式弹出框采用固定的布局格式，这使得开发者无需关心具体的显示布局细节，只需输入所需显示的文本内容，从而简化了使用流程，提升了便捷性。

## 使用约束

- 可以通过调用UIContext或getUIContext，在非UI页面或某些异步回调中使用本文中的接口。CalendarPickerDialog当前不支持此操作。
    
- 操作菜单 (showActionMenu)、对话框 (showDialog)需先使用UIContext中的[getPromptAction()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取到PromptAction对象，再通过该对象调用对应方法。
    
- 列表选择弹出框 (ActionSheet)、警告弹出框 (AlertDialog)、选择器弹出框 (PickerDialog)中除CalendarPickerDialog都需先使用ohos.window中的[getUIContext()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getuicontext10)方法获取UIContext实例，再通过此实例调用对应方法。或者可以通过自定义组件内置方法[getUIContext()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-api#getuicontext)获取。
    

操作菜单 (showActionMenu)、对话框 (showDialog)、列表选择弹出框 (ActionSheet)、警告弹出框 (AlertDialog)可以设置isModal为false变成非模态弹窗。

操作菜单 (showActionMenu)、对话框 (showDialog)、列表选择弹出框 (ActionSheet)和警告弹出框 (AlertDialog)不支持设置内容区的字体样式，如字体颜色、大小换行等操作，如需自定义样式，建议使用[不依赖UI组件的全局自定义弹出框](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)或者[基础自定义弹出框](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)。

## 生命周期

弹出框提供了生命周期函数，用于通知用户该弹出框的生命周期。生命周期的触发时序依次为：onWillAppear -> onDidAppear -> onWillDisappear -> onDidDisappear，也可参照各组件API。

从API version 19开始，对话框（showDialog）、列表选择弹出框（ActionSheet）、警告弹出框（AlertDialog）支持以下生命周期。

|名称|类型|说明|
|:--|:--|:--|
|onWillAppear|Callback<void>|弹出框显示动效前的事件回调。|
|onDidAppear|Callback<void>|弹出框弹出后的事件回调。|
|onWillDisappear|Callback<void>|弹出框退出动效前的事件回调。|
|onDidDisappear|Callback<void>|弹出框消失后的事件回调。|

## 操作菜单 (showActionMenu)

操作菜单通过UIContext中的getPromptAction方法获取到PromptAction对象，再通过该对象调用[showActionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showactionmenu11)接口实现，支持在回调或开发者自定义类中使用。

操作菜单中，title字段的字体最大放大倍数为2。

创建并显示操作菜单后，菜单的响应结果会异步返回选中按钮在buttons数组中的索引。

1. import { PromptAction } from '@kit.ArkUI';

2. @Entry
3. @Component
4. struct Index {
5.   promptAction: PromptAction = this.getUIContext().getPromptAction();

6.   build() {
7.     Column() {
8.       Button('showActionMenu')
9.         .onClick(() => {
10.           this.promptAction.showActionMenu({
11.             title: 'showActionMenu Title Info',
12.             buttons: [
13.               {
14.                 text: 'item1',
15.                 color: '#666666'
16.               },
17.               {
18.                 text: 'item2',
19.                 color: '#000000'
20.               },
21.             ]
22.           })
23.             .then(data => {
24.               console.info('showActionMenu success, click button: ' + data.index);
25.             })
26.             .catch((err: Error) => {
27.               console.error('showActionMenu error: ' + err);
28.             })
29.         })
30.     }.height('100%').width('100%').justifyContent(FlexAlign.Center)
31.   }
32. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164046.48010366630437602699077062624803:50001231000000:2800:8A395E74AB91ABFBEFEB8DEDC255CD6B4BC3F400923E4F0F94C781AB667DBB0C.gif)

## 对话框 (showDialog)

对话框通过UIContext中的getPromptAction方法获取到PromptAction对象，再通过该对象调用[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showdialog)接口实现，支持在回调或开发者自定义类中使用。

对话框中，title字段的字体最大放大倍数为2。

创建并显示对话框，对话框响应后异步返回选中按钮在buttons数组中的索引。

1. // xxx.ets
2. import { PromptAction } from '@kit.ArkUI';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct Index {
7.   promptAction: PromptAction = this.getUIContext().getPromptAction();

8.   build() {
9.     Column() {
10.       Button('showDialog')
11.         .onClick(() => {
12.           try {
13.             this.promptAction.showDialog({
14.               title: 'showDialog Title Info',
15.               message: 'Message Info',
16.               buttons: [
17.                 {
18.                   text: 'button1',
19.                   color: '#000000'
20.                 },
21.                 {
22.                   text: 'button2',
23.                   color: '#000000'
24.                 }
25.               ]
26.             }, (err, data) => {
27.               if (err) {
28.                 console.error('showDialog err: ' + err);
29.                 return;
30.               }
31.               console.info('showDialog success callback, click button: ' + data.index);
32.             });
33.           } catch (error) {
34.             let message = (error as BusinessError).message;
35.             let code = (error as BusinessError).code;
36.             console.error(`showDialog args error code is ${code}, message is ${message}`);
37.           };
38.         })
39.     }.height('100%').width('100%').justifyContent(FlexAlign.Center)
40.   }
41. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164046.39694699676052850466746988738047:50001231000000:2800:2EF5BC8DC1EACFB59318D974BBD76A75089D10B9EC83A2A0EDFA0010DEE5D79E.gif)

## 选择器弹窗 (PickerDialog)

选择器弹窗通常用于在用户进行某些操作（如点击按钮）时显示特定的信息或选项。

### 日历选择器弹窗 (CalendarPickerDialog)

日历选择器弹窗提供日历视图，包含年、月和星期信息，通过[CalendarPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-calendarpicker-dialog)接口实现。开发者可调用show函数，定义并弹出日历选择器弹窗。

日历选择器弹窗的弹出依赖UI的执行上下文，不可在[UI上下文不明确](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-global-interface#ui%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8D%E6%98%8E%E7%A1%AE)的地方使用，具体约束参见[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)说明。

通过配置 acceptButtonStyle、cancelButtonStyle可以实现自定义按钮样式。

1. // xxx.ets
2. @Entry
3. @Component
4. struct CalendarPickerDialogExample {
5.   private selectedDate: Date = new Date('2024-04-23');

6.   build() {
7.     NavDestination() {
8.       Column({ space: 12 }) {

9.         Column() {
10.           Button('Show CalendarPicker Dialog')
11.             .margin(20)
12.             .onClick(() => {
13.               console.info('CalendarDialog.show');
14.               CalendarPickerDialog.show({
15.                 selected: this.selectedDate,
16.                 acceptButtonStyle: {
17.                   fontColor: '#2787d9',
18.                   fontSize: '16fp',
19.                   backgroundColor: '#f7f7f7',
20.                   borderRadius: 10
21.                 },
22.                 cancelButtonStyle: {
23.                   fontColor: Color.Red,
24.                   fontSize: '16fp',
25.                   backgroundColor: '#f7f7f7',
26.                   borderRadius: 10
27.                 },
28.                 onAccept: (date: Date) => {
29.                   // 当弹出框再次弹出时显示选中的是上一次确定的日期
30.                   this.selectedDate = date;
31.                 }
32.               })
33.             })
34.         }.width('100%')

35.       }
36.       .width('100%')
37.       .height('100%')
38.       .padding({ left: 12, right: 12 })
39.     }
40.     // ···
41.     // $r('app.string.xxx')需要替换为开发者所需的字符串资源文件
42.     .title($r('app.string.CustomDialog_calender'))
43.   }
44. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164046.50696574207854953631689363021075:50001231000000:2800:FB814C1FAC0F5801BC76C9BFEC876F189338387B3A95963CF5C097635EA75D84.gif)

### 日期滑动选择器弹窗 (DatePickerDialog)

开发者可以利用指定的日期范围，创建日期滑动选择器弹窗，将日期信息清晰地展示在弹出的窗口上。

日期滑动选择器弹窗通过UIContext中的[showDatePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showdatepickerdialog)接口实现。

弹窗中配置[DatePickerDialogOprions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-datepicker-dialog#datepickerdialogoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)的lunarSwitch、showTime属性为true时，会展示切换农历的开关和时间，当checkbox被选中时，会显示农历。当按下确定按钮时，弹窗会通过onDateAccept返回目前所选中的日期。如需弹窗再次弹出时显示选中的是上一次确定的日期，就要在回调中重新给selectTime进行赋值。

1. @Entry
2. @Component
3. struct DatePickerDialogExample {
4.   @State selectTime: Date = new Date('2023-12-25T08:30:00');

5.   build() {
6.     Column() {
7.       Button('showDatePickerDialog')
8.         .margin(30)
9.         .onClick(() => {
10.           this.getUIContext().showDatePickerDialog({
11.             start: new Date("2000-1-1"),
12.             end: new Date("2100-12-31"),
13.             selected: this.selectTime,
14.             lunarSwitch: true,
15.             showTime: true,
16.             onDateAccept: (value: Date) => {
17.               this.selectTime = value;
18.               console.info("DatePickerDialog:onAccept()" + JSON.stringify(value));
19.             },
20.           });
21.         })
22.     }.width('100%').margin({ top: 5 })
23.   }
24. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164046.15449835043171978333784908806667:50001231000000:2800:A41935FB755D9786F8D59792A6C7BB8316EF5EB8B3894D86FAE07FD820ED5D17.gif)

该示例通过配置disappearTextStyle、textStyle、selectedTextStyle、acceptButtonStyle、cancelButtonStyle实现了自定义文本以及按钮样式。

1. @Entry
2. @Component
3. struct DatePickerDialogExample {
4.   @State selectTime: Date = new Date('2023-12-25T08:30:00');

5.   build() {
6.     Column() {
7.       Button('showDatePickerDialog')
8.         .margin(30)
9.         .onClick(() => {
10.           this.getUIContext().showDatePickerDialog({
11.             start: new Date("2000-1-1"),
12.             end: new Date("2100-12-31"),
13.             selected: this.selectTime,
14.             textStyle: { color: '#2787d9', font: { size: '14fp', weight: FontWeight.Normal } },
15.             selectedTextStyle: { color: '#004aaf', font: { size: '18fp', weight: FontWeight.Regular } },
16.             acceptButtonStyle: {
17.               fontColor: '#2787d9',
18.               fontSize: '16fp',
19.               backgroundColor: '#f7f7f7',
20.               borderRadius: 10
21.             },
22.             cancelButtonStyle: {
23.               fontColor: Color.Red,
24.               fontSize: '16fp',
25.               backgroundColor: '#f7f7f7',
26.               borderRadius: 10
27.             }
28.           })
29.         })
30.     }.width('100%').margin({ top: 5 })
31.   }
32. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164046.35906431104439587642869029841309:50001231000000:2800:C13EFB1C6A9216305E1E0A5CDCEAFC6AE4B5F37D01AA546C53042F8C48178855.gif)

### 时间滑动选择器弹窗 (TimePickerDialog)

开发者可根据24小时的时间区间，创建时间滑动选择器弹窗，将时间信息清晰地展示在弹出的窗口上。

时间滑动选择器弹窗通过UIContext中的[showTimePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtimepickerdialog)接口实现。

该示例通过配置[disappearTextStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker#disappeartextstyle10)、[textStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker#textstyle10)、[selectedTextStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker#selectedtextstyle10)、[acceptButtonStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-timepicker-dialog#timepickerdialogoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)、[cancelButtonStyle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-timepicker-dialog#timepickerdialogoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E)实现了自定义文本以及按钮样式。

1. // xxx.ets

2. @Entry
3. @Component
4. struct TimePickerDialogExample {
5.   @State selectTime: Date = new Date('2023-12-25T08:30:00');

6.   build() {
7.     Column() {
8.       Button('showTimePickerDialog')
9.         .margin(30)
10.         .onClick(() => {
11.           this.getUIContext().showTimePickerDialog({
12.             selected: this.selectTime,
13.             textStyle: { color: '#2787d9', font: { size: '14fp', weight: FontWeight.Normal } },
14.             selectedTextStyle: { color: '#004aaf', font: { size: '18fp', weight: FontWeight.Regular } },
15.             acceptButtonStyle: {
16.               fontColor: '#2787d9',
17.               fontSize: '16fp',
18.               backgroundColor: '#f7f7f7',
19.               borderRadius: 10
20.             },
21.             cancelButtonStyle: {
22.               fontColor: Color.Red,
23.               fontSize: '16fp',
24.               backgroundColor: '#f7f7f7',
25.               borderRadius: 10
26.             }
27.           });
28.         })
29.     }.width('100%').margin({ top: 5 })
30.   }
31. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164046.32434650097467908414251715750438:50001231000000:2800:5F19A24787947C6245415BBA0F5323E153FE1D0510D67BA9426FBE57A33F3705.gif)

### 文本滑动选择器弹窗 (TextPickerDialog)

开发者可根据指定的选择范围，创建文本滑动选择器弹窗，将文本信息清晰地展示在弹出的窗口上。

文本滑动选择器弹窗通过UIContext中的[showTextPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtextpickerdialog)接口实现。

该示例通过设置range的参数类型为TextCascadePickerRangeContent[]，实现3列文本选择器弹窗。当按下确定按钮时，弹窗会通过onAccept返回目前所选中文本和索引值。如需弹窗再次弹出时显示选中的是上一次确定的文本，就要在回调中重新给select进行赋值。

1. @Entry
2. @Component
3. struct TextPickerDialogExample {
4.   private fruits: TextCascadePickerRangeContent[] = [
5.     {
6.       text: '辽宁省',
7.       children: [{ text: '沈阳市', children: [{ text: '沈河区' }, { text: '和平区' }, { text: '浑南区' }] },
8.         { text: '大连市', children: [{ text: '中山区' }, { text: '金州区' }, { text: '长海县' }] }]
9.     },
10.     {
11.       text: '吉林省',
12.       children: [{ text: '长春市', children: [{ text: '南关区' }, { text: '宽城区' }, { text: '朝阳区' }] },
13.         { text: '四平市', children: [{ text: '铁西区' }, { text: '铁东区' }, { text: '梨树县' }] }]
14.     },
15.     {
16.       text: '黑龙江省',
17.       children: [{ text: '哈尔滨市', children: [{ text: '道里区' }, { text: '道外区' }, { text: '南岗区' }] },
18.         { text: '牡丹江市', children: [{ text: '东安区' }, { text: '西安区' }, { text: '爱民区' }] }]
19.     }
20.   ];
21.   private select : number  = 0;
22.   build() {
23.     Column() {
24.       Button('showTextPickerDialog')
25.         .margin(30)
26.         .onClick(() => {
27.           this.getUIContext().showTextPickerDialog({
28.             range: this.fruits,
29.             selected: this.select,
30.             onAccept: (value: TextPickerResult) => {
31.               this.select = value.index as number
32.             }
33.           });
34.         })
35.     }.width('100%').margin({ top: 5 })
36.   }
37. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164046.76022984833929227600461365805503:50001231000000:2800:D2AE2F58637D1DE0EEC00BD21DB137AB6CC662310DF0E23ABBEFBBEAB7316FD8.gif)

## 列表选择弹窗 (ActionSheet)

列表选择器弹窗适用于呈现多个操作选项，尤其当界面中仅需展示操作列表而无其他内容时。

列表选择器弹窗通过UIContext中的[showActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showactionsheet)接口实现。

列表选择弹窗中，title字段的字体最大放大倍数为2。

该示例通过配置width、height、transition等接口，定义了弹窗的样式以及弹出动效。

1. @Entry
2. @Component
3. struct showActionSheetExample {
4.   build() {
5.     Column() {
6.       Button('showActionSheet')
7.         .margin(30)
8.         .onClick(() => {
9.           this.getUIContext().showActionSheet({
10.             title: 'ActionSheet title',
11.             message: 'message',
12.             autoCancel: false,
13.             width: 300,
14.             height: 300,
15.             cornerRadius: 20,
16.             borderWidth: 1,
17.             borderStyle: BorderStyle.Solid,
18.             borderColor: Color.Blue,
19.             backgroundColor: Color.White,
20.             transition: TransitionEffect.asymmetric(TransitionEffect.OPACITY
21.               .animation({ duration: 3000, curve: Curve.Sharp })
22.               .combine(TransitionEffect.scale({ x: 1.5, y: 1.5 }).animation({ duration: 3000, curve: Curve.Sharp })),
23.               TransitionEffect.OPACITY.animation({ duration: 100, curve: Curve.Smooth })
24.                 .combine(TransitionEffect.scale({ x: 0.5, y: 0.5 }).animation({ duration: 100, curve: Curve.Smooth }))),
25.             confirm: {
26.               value: 'Confirm button',
27.               action: () => {
28.                 console.info('Get Alert Dialog handled');
29.               }
30.             },
31.             alignment: DialogAlignment.Center,
32.             sheets: [
33.               {
34.                 title: 'apples',
35.                 action: () => {
36.                 }
37.               },
38.               {
39.                 title: 'bananas',
40.                 action: () => {
41.                 }
42.               },
43.               {
44.                 title: 'pears',
45.                 action: () => {
46.                   console.info('pears');
47.                 }
48.               }
49.             ]
50.           });
51.         })
52.     }.width('100%').margin({ top: 5 })
53.   }
54. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.18617839074040639343670041922249:50001231000000:2800:9B4362671C6A6263BEBFF21F7451EF61A993AE32940B3B87C80E3AAA77749A85.gif)

## 警告弹窗 (AlertDialog)

向用户提问或得到用户的许可时，使用警告弹窗。

- 警告弹窗用来提示重要信息，但会中断当前任务，尽量提供必要的信息和有用的操作。
- 避免仅使用警告弹窗提供信息，用户不喜欢被信息丰富但不可操作的警告打断。

警告弹窗通过UIContext中的[showAlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showalertdialog)接口实现。

警告弹窗中，title和subtitle字段的字体最大放大倍数为2。

该示例通过配置width、height、transition等接口，定义了多个按钮弹窗的样式以及弹出动效。

1. @Entry
2. @Component
3. struct showAlertDialogExample {
4.   build() {
5.     Column() {
6.       Button('showAlertDialog')
7.         .margin(30)
8.         .onClick(() => {
9.           this.getUIContext().showAlertDialog(
10.             {
11.               title: 'title',
12.               message: 'text',
13.               autoCancel: true,
14.               alignment: DialogAlignment.Center,
15.               offset: { dx: 0, dy: -20 },
16.               gridCount: 3,
17.               transition: TransitionEffect.asymmetric(TransitionEffect.OPACITY
18.                 .animation({ duration: 3000, curve: Curve.Sharp })
19.                 .combine(TransitionEffect.scale({ x: 1.5, y: 1.5 }).animation({ duration: 3000, curve: Curve.Sharp })),
20.                 TransitionEffect.OPACITY.animation({ duration: 100, curve: Curve.Smooth })
21.                   .combine(TransitionEffect.scale({ x: 0.5, y: 0.5 })
22.                     .animation({ duration: 100, curve: Curve.Smooth }))),
23.               buttons: [{
24.                 value: 'cancel',
25.                 action: () => {
26.                   console.info('Callback when the first button is clicked');
27.                 }
28.               },
29.                 {
30.                   enabled: true,
31.                   defaultFocus: true,
32.                   style: DialogButtonStyle.HIGHLIGHT,
33.                   value: 'ok',
34.                   action: () => {
35.                     console.info('Callback when the second button is clicked');
36.                   }
37.                 }],
38.             }
39.           );
40.         })
41.     }.width('100%').margin({ top: 5 })
42.   }
43. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164047.35111603936278141106311715616620:50001231000000:2800:A6195A6DB3E5C9FC1A13621331B857F3F6BBE41C9175CE328508E8DF294C6E77.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog "基础自定义弹出框 (CustomDialog)")
# 弹出框层级管理

更新时间: 2025-12-16 16:40

ArkUI的弹出框节点都是直接挂载在根节点上，会根据层级从小到大依次挂载。根节点下，右边的弹出框节点会覆盖显示在左边的弹出框节点上，新创建的弹出框节点会根据层级大小插入到对应的位置，同一层级大小的弹窗节点按照创建的先后顺序进行挂载。

从API version 18开始，可以通过设置[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来管理弹出框的显示顺序，确保层级较高的弹出框覆盖在层级较低的弹出框之上，从而根据需要灵活控制各层弹出框的显示效果。

## 使用约束

目前[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)、[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)、[AlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E8%AD%A6%E5%91%8A%E5%BC%B9%E7%AA%97-alertdialog)、[ActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E5%BC%B9%E7%AA%97-actionsheet)、[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%AF%B9%E8%AF%9D%E6%A1%86-showdialog)支持通过levelOrder参数来管理弹出框的层次。

说明

弹出框层级管理不支持子窗场景，即当showInSubWindow设置为true时，levelOrder参数设置无效。不支持动态刷新弹出框的显示顺序。

## 创建不同层级的弹出框

说明

详细变量定义请参考[完整示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-levelorder#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B)。

1.初始化一个弹出框内容区，内部包含一个Text组件。

1. @Builder normalCustomDialog(index: number) {
2.   Column() {
3.     Text("我是普通弹窗" + index).fontSize(30)
4.   }.height(400).padding(5).justifyContent(FlexAlign.SpaceBetween)
5. }

2.初始化另一个弹出框内容区，内部包含一个点击打开普通弹出框的按钮，点击事件中通过调用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象，再通过该对象调用[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12)接口，并且设置层级为0的[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来创建普通层级弹出框。

1. @Builder topCustomDialog() {
2.   Column() {
3.     Text("我是置顶弹窗").fontSize(30)
4.     Row({ space: 50 }) {
5.       Button('点我打开普通弹窗')
6.         .onClick(() => {
7.           this.getUIContext().getPromptAction().openCustomDialog({
8.             builder: () => {
9.               this.normalCustomDialog(this.dialogIndex)
10.             },
11.             levelOrder: LevelOrder.clamp(0),
12.           })
13.             .catch((err: BusinessError) => {
14.               console.error("openCustomDialog error: " + err.code + " " + err.message)
15.             })
16.           this.dialogIndex++
17.         })
18.     }
19.   }.height(200).padding(5).justifyContent(FlexAlign.SpaceBetween)
20. }

3.通过调用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象，再通过该对象调用[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12)接口，并且设置层级为100000的[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来创建最高层级弹出框。

1. this.getUIContext().getPromptAction().openCustomDialog({
2.   builder: () => {
3.     this.topCustomDialog()
4.   },
5.   levelOrder: LevelOrder.clamp(100000)
6. }).catch((err: BusinessError) => {
7.   console.error("openCustomDialog error: " + err.code + " " + err.message)
8. })

## 完整示例

1. import { LevelOrder } from '@kit.ArkUI';
2. import { BusinessError } from '@kit.BasicServicesKit';

3. @Entry
4. @Component
5. struct Index {
6.   @StorageLink('dialogIndex') dialogIndex: number = 0

7.   @Builder normalCustomDialog(index: number) {
8.     Column() {
9.       Text('我是普通弹窗' + index).fontSize(30)
10.     }.height(400).padding(5).justifyContent(FlexAlign.SpaceBetween)
11.   }

12.   @Builder topCustomDialog() {
13.     Column() {
14.       Text('我是置顶弹窗').fontSize(30)
15.       Row({ space: 50 }) {
16.         Button('点我打开普通弹窗')
17.           .onClick(() => {
18.             this.getUIContext().getPromptAction().openCustomDialog({
19.               builder: () => {
20.                 this.normalCustomDialog(this.dialogIndex)
21.               },
22.               levelOrder: LevelOrder.clamp(0),
23.             })
24.               .catch((err: BusinessError) => {
25.                 console.error('openCustomDialog error: ' + err.code + '' + err.message)
26.               })
27.             this.dialogIndex++
28.           })
29.       }
30.     }.height(200).padding(5).justifyContent(FlexAlign.SpaceBetween)
31.   }

32.   build() {
33.     Row() {
34.       Column({ space: 5 }) {
35.         Button('点击弹窗')
36.           .fontSize(20)
37.           .onClick(() => {
38.             this.getUIContext().getPromptAction().openCustomDialog({
39.               builder: () => {
40.                 this.topCustomDialog()
41.               },
42.               levelOrder: LevelOrder.clamp(100000)
43.             }).catch((err: BusinessError) => {
44.               console.error('openCustomDialog error: ' + err.code + '' + err.message)
45.             })
46.           })
47.       }.width('100%')
48.     }
49.   }
50. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164059.58867436415869263391606819944224:50001231000000:2800:19D6E49EBF2B2E3BCBB26ADA32FF3B9DAA9688D97DACBEE57B9A52A0EEC1D0EB.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-embedded-dialog "页面级弹出框")
# 弹出框层级管理

更新时间: 2025-12-16 16:40

ArkUI的弹出框节点都是直接挂载在根节点上，会根据层级从小到大依次挂载。根节点下，右边的弹出框节点会覆盖显示在左边的弹出框节点上，新创建的弹出框节点会根据层级大小插入到对应的位置，同一层级大小的弹窗节点按照创建的先后顺序进行挂载。

从API version 18开始，可以通过设置[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来管理弹出框的显示顺序，确保层级较高的弹出框覆盖在层级较低的弹出框之上，从而根据需要灵活控制各层弹出框的显示效果。

## 使用约束

目前[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)、[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)、[AlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E8%AD%A6%E5%91%8A%E5%BC%B9%E7%AA%97-alertdialog)、[ActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E5%BC%B9%E7%AA%97-actionsheet)、[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%AF%B9%E8%AF%9D%E6%A1%86-showdialog)支持通过levelOrder参数来管理弹出框的层次。

说明

弹出框层级管理不支持子窗场景，即当showInSubWindow设置为true时，levelOrder参数设置无效。不支持动态刷新弹出框的显示顺序。

## 创建不同层级的弹出框

说明

详细变量定义请参考[完整示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-levelorder#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B)。

1.初始化一个弹出框内容区，内部包含一个Text组件。

1. @Builder normalCustomDialog(index: number) {
2.   Column() {
3.     Text("我是普通弹窗" + index).fontSize(30)
4.   }.height(400).padding(5).justifyContent(FlexAlign.SpaceBetween)
5. }

2.初始化另一个弹出框内容区，内部包含一个点击打开普通弹出框的按钮，点击事件中通过调用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象，再通过该对象调用[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12)接口，并且设置层级为0的[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来创建普通层级弹出框。

1. @Builder topCustomDialog() {
2.   Column() {
3.     Text("我是置顶弹窗").fontSize(30)
4.     Row({ space: 50 }) {
5.       Button('点我打开普通弹窗')
6.         .onClick(() => {
7.           this.getUIContext().getPromptAction().openCustomDialog({
8.             builder: () => {
9.               this.normalCustomDialog(this.dialogIndex)
10.             },
11.             levelOrder: LevelOrder.clamp(0),
12.           })
13.             .catch((err: BusinessError) => {
14.               console.error("openCustomDialog error: " + err.code + " " + err.message)
15.             })
16.           this.dialogIndex++
17.         })
18.     }
19.   }.height(200).padding(5).justifyContent(FlexAlign.SpaceBetween)
20. }

3.通过调用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象，再通过该对象调用[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12)接口，并且设置层级为100000的[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来创建最高层级弹出框。

1. this.getUIContext().getPromptAction().openCustomDialog({
2.   builder: () => {
3.     this.topCustomDialog()
4.   },
5.   levelOrder: LevelOrder.clamp(100000)
6. }).catch((err: BusinessError) => {
7.   console.error("openCustomDialog error: " + err.code + " " + err.message)
8. })

## 完整示例

1. import { LevelOrder } from '@kit.ArkUI';
2. import { BusinessError } from '@kit.BasicServicesKit';

3. @Entry
4. @Component
5. struct Index {
6.   @StorageLink('dialogIndex') dialogIndex: number = 0

7.   @Builder normalCustomDialog(index: number) {
8.     Column() {
9.       Text('我是普通弹窗' + index).fontSize(30)
10.     }.height(400).padding(5).justifyContent(FlexAlign.SpaceBetween)
11.   }

12.   @Builder topCustomDialog() {
13.     Column() {
14.       Text('我是置顶弹窗').fontSize(30)
15.       Row({ space: 50 }) {
16.         Button('点我打开普通弹窗')
17.           .onClick(() => {
18.             this.getUIContext().getPromptAction().openCustomDialog({
19.               builder: () => {
20.                 this.normalCustomDialog(this.dialogIndex)
21.               },
22.               levelOrder: LevelOrder.clamp(0),
23.             })
24.               .catch((err: BusinessError) => {
25.                 console.error('openCustomDialog error: ' + err.code + '' + err.message)
26.               })
27.             this.dialogIndex++
28.           })
29.       }
30.     }.height(200).padding(5).justifyContent(FlexAlign.SpaceBetween)
31.   }

32.   build() {
33.     Row() {
34.       Column({ space: 5 }) {
35.         Button('点击弹窗')
36.           .fontSize(20)
37.           .onClick(() => {
38.             this.getUIContext().getPromptAction().openCustomDialog({
39.               builder: () => {
40.                 this.topCustomDialog()
41.               },
42.               levelOrder: LevelOrder.clamp(100000)
43.             }).catch((err: BusinessError) => {
44.               console.error('openCustomDialog error: ' + err.code + '' + err.message)
45.             })
46.           })
47.       }.width('100%')
48.     }
49.   }
50. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164059.58867436415869263391606819944224:50001231000000:2800:19D6E49EBF2B2E3BCBB26ADA32FF3B9DAA9688D97DACBEE57B9A52A0EEC1D0EB.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-embedded-dialog "页面级弹出框")
# 弹出框层级管理

更新时间: 2025-12-16 16:40

ArkUI的弹出框节点都是直接挂载在根节点上，会根据层级从小到大依次挂载。根节点下，右边的弹出框节点会覆盖显示在左边的弹出框节点上，新创建的弹出框节点会根据层级大小插入到对应的位置，同一层级大小的弹窗节点按照创建的先后顺序进行挂载。

从API version 18开始，可以通过设置[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来管理弹出框的显示顺序，确保层级较高的弹出框覆盖在层级较低的弹出框之上，从而根据需要灵活控制各层弹出框的显示效果。

## 使用约束

目前[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)、[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)、[AlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E8%AD%A6%E5%91%8A%E5%BC%B9%E7%AA%97-alertdialog)、[ActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E5%BC%B9%E7%AA%97-actionsheet)、[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fixes-style-dialog#%E5%AF%B9%E8%AF%9D%E6%A1%86-showdialog)支持通过levelOrder参数来管理弹出框的层次。

说明

弹出框层级管理不支持子窗场景，即当showInSubWindow设置为true时，levelOrder参数设置无效。不支持动态刷新弹出框的显示顺序。

## 创建不同层级的弹出框

说明

详细变量定义请参考[完整示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-levelorder#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B)。

1.初始化一个弹出框内容区，内部包含一个Text组件。

1. @Builder normalCustomDialog(index: number) {
2.   Column() {
3.     Text("我是普通弹窗" + index).fontSize(30)
4.   }.height(400).padding(5).justifyContent(FlexAlign.SpaceBetween)
5. }

2.初始化另一个弹出框内容区，内部包含一个点击打开普通弹出框的按钮，点击事件中通过调用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象，再通过该对象调用[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12)接口，并且设置层级为0的[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来创建普通层级弹出框。

1. @Builder topCustomDialog() {
2.   Column() {
3.     Text("我是置顶弹窗").fontSize(30)
4.     Row({ space: 50 }) {
5.       Button('点我打开普通弹窗')
6.         .onClick(() => {
7.           this.getUIContext().getPromptAction().openCustomDialog({
8.             builder: () => {
9.               this.normalCustomDialog(this.dialogIndex)
10.             },
11.             levelOrder: LevelOrder.clamp(0),
12.           })
13.             .catch((err: BusinessError) => {
14.               console.error("openCustomDialog error: " + err.code + " " + err.message)
15.             })
16.           this.dialogIndex++
17.         })
18.     }
19.   }.height(200).padding(5).justifyContent(FlexAlign.SpaceBetween)
20. }

3.通过调用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中[getPromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getpromptaction)方法获取[PromptAction](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction)对象，再通过该对象调用[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialog12)接口，并且设置层级为100000的[levelOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11)参数来创建最高层级弹出框。

1. this.getUIContext().getPromptAction().openCustomDialog({
2.   builder: () => {
3.     this.topCustomDialog()
4.   },
5.   levelOrder: LevelOrder.clamp(100000)
6. }).catch((err: BusinessError) => {
7.   console.error("openCustomDialog error: " + err.code + " " + err.message)
8. })

## 完整示例

1. import { LevelOrder } from '@kit.ArkUI';
2. import { BusinessError } from '@kit.BasicServicesKit';

3. @Entry
4. @Component
5. struct Index {
6.   @StorageLink('dialogIndex') dialogIndex: number = 0

7.   @Builder normalCustomDialog(index: number) {
8.     Column() {
9.       Text('我是普通弹窗' + index).fontSize(30)
10.     }.height(400).padding(5).justifyContent(FlexAlign.SpaceBetween)
11.   }

12.   @Builder topCustomDialog() {
13.     Column() {
14.       Text('我是置顶弹窗').fontSize(30)
15.       Row({ space: 50 }) {
16.         Button('点我打开普通弹窗')
17.           .onClick(() => {
18.             this.getUIContext().getPromptAction().openCustomDialog({
19.               builder: () => {
20.                 this.normalCustomDialog(this.dialogIndex)
21.               },
22.               levelOrder: LevelOrder.clamp(0),
23.             })
24.               .catch((err: BusinessError) => {
25.                 console.error('openCustomDialog error: ' + err.code + '' + err.message)
26.               })
27.             this.dialogIndex++
28.           })
29.       }
30.     }.height(200).padding(5).justifyContent(FlexAlign.SpaceBetween)
31.   }

32.   build() {
33.     Row() {
34.       Column({ space: 5 }) {
35.         Button('点击弹窗')
36.           .fontSize(20)
37.           .onClick(() => {
38.             this.getUIContext().getPromptAction().openCustomDialog({
39.               builder: () => {
40.                 this.topCustomDialog()
41.               },
42.               levelOrder: LevelOrder.clamp(100000)
43.             }).catch((err: BusinessError) => {
44.               console.error('openCustomDialog error: ' + err.code + '' + err.message)
45.             })
46.           })
47.       }.width('100%')
48.     }
49.   }
50. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164059.58867436415869263391606819944224:50001231000000:2800:19D6E49EBF2B2E3BCBB26ADA32FF3B9DAA9688D97DACBEE57B9A52A0EEC1D0EB.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-embedded-dialog "页面级弹出框")
# 弹出框蒙层控制

更新时间: 2025-12-16 16:41

开发者对弹出框的定制不仅限于弹出框里的内容，对弹出框蒙层的定制需求也逐渐增加。本文介绍ArkUI弹出框的蒙层控制，包括点击蒙层时是否消失、蒙层区域、蒙层颜色和蒙层动画等特性。

## 使用约束

ArkUI提供多种弹出框，不同类型的弹出框具备不同的蒙层定制能力。详情请参阅下表：

|接口&组件|autoCancel|maskRect|isModal|immersiveMode|
|:--|:--|:--|:--|:--|
|[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|支持|支持|支持|支持|
|[openCustomDialogWithController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialogwithcontroller18)|支持|支持|支持|支持|
|[presentCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#presentcustomdialog18)|支持|支持|支持|支持|
|[updateCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatecustomdialog12)|支持|不支持|不支持|不支持|
|[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|支持|支持|支持|支持|
|[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showdialog)|不支持|支持|支持|支持|
|[showAlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showalertdialog)|支持|支持|支持|支持|
|[showActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showactionsheet)|支持|支持|支持|支持|
|[showActionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showactionmenu11)|不支持|不支持|支持|支持|
|[showDatePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showdatepickerdialog)|不支持|支持|不支持|不支持|
|[CalendarPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-calendarpicker-dialog)|不支持|不支持|不支持|不支持|
|[showTimePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtimepickerdialog)|不支持|支持|不支持|不支持|
|[showTextPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtextpickerdialog)|不支持|支持|不支持|不支持|

说明

- 设置autoCancel参数，可控制弹出框蒙层被点击时是否消失。
    
- 设置maskRect参数，可定制弹出框的蒙层的大小和位置。此外，蒙层范围内的事件无法透传，而蒙层范围外的事件可以透传。
    
- 设置isModal参数，可定制弹出框的模态状态：非模态弹出框无蒙层，支持与周围组件交互；模态弹出框有蒙层，禁止与周围组件交互。
    
- 从API version 15开始，当levelMode属性设置为LevelMode.EMBEDDED时，设置immersiveMode参数，可定制弹出框蒙层是否延伸至状态栏及导航栏。
    

|接口&组件|maskColor|transition|maskTransition|
|:--|:--|:--|:--|
|[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|支持|支持|支持|
|[openCustomDialogWithController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialogwithcontroller18)|支持|支持|支持|
|[presentCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#presentcustomdialog18)|支持|支持|支持|
|[updateCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatecustomdialog12)|支持|不支持|不支持|
|[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|支持|不支持（可由openAnimation和closeAnimation替代）|不支持|
|[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showdialog)|不支持|不支持|不支持|
|[showAlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showalertdialog)|不支持|支持|不支持|
|[showActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showactionsheet)|不支持|支持|不支持|
|[showActionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showactionmenu11)|不支持|不支持|不支持|
|[showDatePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showdatepickerdialog)|不支持|不支持|不支持|
|[CalendarPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-calendarpicker-dialog)|不支持|不支持|不支持|
|[showTimePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtimepickerdialog)|不支持|不支持|不支持|
|[showTextPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtextpickerdialog)|不支持|不支持|不支持|

说明

- 设置maskColor参数，可定制弹出框蒙层的颜色。
    
- 设置openAnimation参数，可定制弹出框的进入动画，同时影响蒙层动画。该接口仅支持简单的动画设置，不支持复杂动画定制。
    
- 设置closeAnimation参数，可定制弹出框的退出动画，同时影响蒙层动画。该接口仅支持简单的动画设置，不支持复杂动画定制。
    
- 设置transition参数，可定制弹出框的进入和退出动画，同时影响蒙层动画。
    
- 从API version 19开始，设置maskTransition参数，可定制弹出框的蒙层动画。
    

## 弹出框蒙层显隐控制

通过autoCancel和isModal属性控制弹出框的蒙层显隐。

设置autoCancel为false，取消默认点击蒙层时弹窗消失。

1. // xxx.ets
2.   autoCancelOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     autoCancel: false,
7.   } as promptAction.CustomDialogOptions;

8.   Button("openCustomDialog autoCancel:false")
9.     .width('100%')
10.     .margin({ top: 10 })
11.     .onClick(() => {
12.       this.getUIContext().getPromptAction().openCustomDialog(this.autoCancelOpt)
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164102.67445658885575987297684002068773:50001231000000:2800:DCD25B4A42804EA4E3807F694DB312869BDD0E92FDD3404FD8BB773B25082A2E.gif)

设置isModal为false，将默认的模态弹出框变为非模态弹出框。

1. // xxx.ets
2. modalOpt: promptAction.CustomDialogOptions = {
3.   builder: () => {
4.     this.myBuilder();
5.   },
6.   isModal: false,
7. } as promptAction.CustomDialogOptions;

8. Button("openCustomDialog isModal:false")
9.   .width('100%')
10.   .margin({ top: 10 })
11.   .onClick(() => {
12.     this.getUIContext().getPromptAction().openCustomDialog(this.modalOpt)
13.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.61488763794139288576216220804106:50001231000000:2800:5F07C1BAD63C3A1E13A184B385514C02F9E5F54803F04BB2A87A9C200D94740B.png)

## 弹出框蒙层样式控制

该示例通过maskRect、immersiveMode和maskColor展示弹出框在蒙层样式控制方面的能力。

设置maskRect和maskColor，实现蒙层区域和蒙层颜色的设置。

1. // xxx.ets
2.   maskOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     maskRect: {
7.       x: 0,
8.       y: 10,
9.       width: '100%',
10.       height: '90%'
11.     },
12.     maskColor: "#33AA0000"
13.   } as promptAction.CustomDialogOptions;

14.   Button("openCustomDialog maskOpt")
15.     .width('100%')
16.     .margin({ top: 10 })
17.     .onClick(() => {
18.       this.getUIContext().getPromptAction().openCustomDialog(this.maskOpt)
19.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.24281706041332550278325943132208:50001231000000:2800:73D8022C6F76B43720695A0EEBC9735D0D8EE931E0B3DDE929EFF65D9F3B4CFF.png)

在levelMode为LevelMode.EMBEDDED下，展示不同immersiveMode对蒙层在导航栏和状态栏的延伸效果。

1. // xxx.ets
2.   @State immersiveMode: ImmersiveMode = ImmersiveMode.DEFAULT;

3.   Button("openCustomDialog immersiveMode")
4.     .width('100%')
5.     .margin({ top: 10 })
6.     .onClick(() => {
7.       this.immersiveMode =
8.         this.immersiveMode == ImmersiveMode.DEFAULT ? ImmersiveMode.EXTEND : ImmersiveMode.DEFAULT;
9.       this.getUIContext().getPromptAction().openCustomDialog({
10.         builder: () => {
11.           this.myBuilder();
12.         },
13.         levelMode: LevelMode.EMBEDDED,
14.         immersiveMode: this.immersiveMode,
15.       })
16.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.38533289165607749205203991523454:50001231000000:2800:C797FBAFB205BBB59F79CFD4CDDF03188FDCEFE6E3FB2BEB29F127C1ABF60168.gif)

## 弹出框蒙层动画控制

该示例通过transition和maskTransition分别展示弹出框在蒙层动画方面的能力。

设置transition，实现弹出框与蒙层整体的动画。

1. // xxx.ets
2.   transitionOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     transition: TransitionEffect.OPACITY.animation({ duration: 3000 })
7.   } as promptAction.CustomDialogOptions;

8.   Button("openCustomDialog transition")
9.     .width('100%')
10.     .margin({ top: 10 })
11.     .onClick(() => {
12.       this.getUIContext().getPromptAction().openCustomDialog(this.transitionOpt);
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.58606572351260459563762200108056:50001231000000:2800:FF9D0EB99582F9651E58B50CB65151293B1456170E4195814C565D513AD07C22.gif)

设置maskTransition，实现弹出框中蒙层单独的动画定制能力。

1. // xxx.ets
2.   Button("openCustomDialog maskTransition")
3.     .width('100%')
4.     .margin({ top: 10 })
5.     .onClick(() => {
6.       this.getUIContext().getPromptAction().openCustomDialog({
7.         builder: () => {
8.           this.myBuilder();
9.         },
10.         maskTransition: TransitionEffect.OPACITY.animation({ duration: 2000 })
11.           .combine(TransitionEffect.rotate({ z: 1, angle: 180 })),
12.       });
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.18215723761995601093433378631077:50001231000000:2800:F68E7BD8FB4C6A9E52905924656E36A9E03D2C4E28EBC039796FEEE1BDF97C2C.gif)

[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)虽然不支持transition接口，但与之对应的openAnimation和closeAnimation接口在动画的打开和关闭时可进行定制，示例代码如下：

1. // xxx.ets

2. @CustomDialog
3. @Component
4. struct CustomDialogExample {
5.   controller?: CustomDialogController;

6.   build() {
7.     Column() {
8.       Text("title")
9.         .margin(10)
10.         .fontSize(20)
11.       Button("button1")
12.         .margin(10)
13.         .fontSize(20)
14.         .onClick(() => {
15.           this.controller?.close();
16.         })
17.       Button("button2")
18.         .margin(10)
19.         .fontSize(20)
20.         .onClick(() => {
21.           this.controller?.close();
22.         })
23.     }.width('100%')
24.     .height('50%')
25.   }
26. }

27. @Entry
28. @Component
29. struct Index {
30.   animationController: CustomDialogController | null
31.     = new CustomDialogController({
32.     builder: CustomDialogExample(),
33.     closeAnimation: { duration: 2000 },
34.     openAnimation: { duration: 2000 }
35.   });

36.   aboutToDisappear(): void {
37.     this.animationController = null;
38.   }

39.   build() {
40.     Column() {
41.       Button("CustomDialogController animate")
42.         .width('100%')
43.         .margin({ top: 10 })
44.         .onClick(() => {
45.           this.animationController?.open();
46.         })
47.     }
48.   }
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.55672919783428905493289020614173:50001231000000:2800:56853D1697A19114EADEFB7929ED2CF3CAA98D809783A01217327B2B39CE9450.gif)

## 完整示例

1. // xxx.ets
2. import { ImmersiveMode, LevelMode, promptAction } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct Index {
6.   @State immersiveMode: ImmersiveMode = ImmersiveMode.DEFAULT;
7.   autoCancelOpt: promptAction.CustomDialogOptions = {
8.     builder: () => {
9.       this.myBuilder();
10.     },
11.     autoCancel: false,
12.   } as promptAction.CustomDialogOptions;
13.   modalOpt: promptAction.CustomDialogOptions = {
14.     builder: () => {
15.       this.myBuilder();
16.     },
17.     isModal: false,
18.   } as promptAction.CustomDialogOptions;
19.   maskOpt: promptAction.CustomDialogOptions = {
20.     builder: () => {
21.       this.myBuilder();
22.     },
23.     maskRect: {
24.       x: 0,
25.       y: 10,
26.       width: '100%',
27.       height: '90%'
28.     },
29.     maskColor: "#33AA0000"
30.   } as promptAction.CustomDialogOptions;
31.   transitionOpt: promptAction.CustomDialogOptions = {
32.     builder: () => {
33.       this.myBuilder();
34.     },
35.     transition: TransitionEffect.OPACITY.animation({ duration: 3000 })
36.   } as promptAction.CustomDialogOptions;

37.   @Builder
38.   myBuilder() {
39.     Column() {
40.       Text("title").margin(10).fontSize(20)
41.       Button("button1").margin(10).fontSize(20)
42.       Button("button2").margin(10).fontSize(20)
43.     }.width('100%').height('50%')
44.   }

45.   build() {
46.     Column() {
47.       Button("openCustomDialog autoCancel:false")
48.         .width('100%')
49.         .margin({ top: 10 })
50.         .onClick(() => {
51.           this.getUIContext().getPromptAction().openCustomDialog(this.autoCancelOpt)
52.         })
53.       Button("openCustomDialog isModal:false")
54.         .width('100%')
55.         .margin({ top: 10 })
56.         .onClick(() => {
57.           this.getUIContext().getPromptAction().openCustomDialog(this.modalOpt)
58.         })
59.       Button("openCustomDialog maskOpt")
60.         .width('100%')
61.         .margin({ top: 10 })
62.         .onClick(() => {
63.           this.getUIContext().getPromptAction().openCustomDialog(this.maskOpt)
64.         })
65.       Button("openCustomDialog transition")
66.         .width('100%')
67.         .margin({ top: 10 })
68.         .onClick(() => {
69.           this.getUIContext().getPromptAction().openCustomDialog(this.transitionOpt);
70.         })
71.       Button("openCustomDialog immersiveMode")
72.         .width('100%')
73.         .margin({ top: 10 })
74.         .onClick(() => {
75.           this.immersiveMode =
76.             this.immersiveMode == ImmersiveMode.DEFAULT ? ImmersiveMode.EXTEND : ImmersiveMode.DEFAULT;
77.           this.getUIContext().getPromptAction().openCustomDialog({
78.             builder: () => {
79.               this.myBuilder();
80.             },
81.             levelMode: LevelMode.EMBEDDED,
82.             immersiveMode: this.immersiveMode,
83.           })
84.         })
85.       Button("openCustomDialog maskTransition")
86.         .width('100%')
87.         .margin({ top: 10 })
88.         .onClick(() => {
89.           this.getUIContext().getPromptAction().openCustomDialog({
90.             builder: () => {
91.               this.myBuilder();
92.             },
93.             maskTransition: TransitionEffect.OPACITY.animation({ duration: 2000 })
94.               .combine(TransitionEffect.rotate({ z: 1, angle: 180 })),
95.           });
96.         })
97.     }
98.     .width('100%')
99.     .height('100%')
100.   }
101. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.52416544369434622370432548826851:50001231000000:2800:9CAD9BAC394EBE4210FCB16EE778C52C1B9D60318E2EDFD833F856BD5F90C09F.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-focusable "弹出框焦点策略")
# 弹出框蒙层控制

更新时间: 2025-12-16 16:41

开发者对弹出框的定制不仅限于弹出框里的内容，对弹出框蒙层的定制需求也逐渐增加。本文介绍ArkUI弹出框的蒙层控制，包括点击蒙层时是否消失、蒙层区域、蒙层颜色和蒙层动画等特性。

## 使用约束

ArkUI提供多种弹出框，不同类型的弹出框具备不同的蒙层定制能力。详情请参阅下表：

|接口&组件|autoCancel|maskRect|isModal|immersiveMode|
|:--|:--|:--|:--|:--|
|[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|支持|支持|支持|支持|
|[openCustomDialogWithController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialogwithcontroller18)|支持|支持|支持|支持|
|[presentCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#presentcustomdialog18)|支持|支持|支持|支持|
|[updateCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatecustomdialog12)|支持|不支持|不支持|不支持|
|[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|支持|支持|支持|支持|
|[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showdialog)|不支持|支持|支持|支持|
|[showAlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showalertdialog)|支持|支持|支持|支持|
|[showActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showactionsheet)|支持|支持|支持|支持|
|[showActionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showactionmenu11)|不支持|不支持|支持|支持|
|[showDatePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showdatepickerdialog)|不支持|支持|不支持|不支持|
|[CalendarPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-calendarpicker-dialog)|不支持|不支持|不支持|不支持|
|[showTimePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtimepickerdialog)|不支持|支持|不支持|不支持|
|[showTextPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtextpickerdialog)|不支持|支持|不支持|不支持|

说明

- 设置autoCancel参数，可控制弹出框蒙层被点击时是否消失。
    
- 设置maskRect参数，可定制弹出框的蒙层的大小和位置。此外，蒙层范围内的事件无法透传，而蒙层范围外的事件可以透传。
    
- 设置isModal参数，可定制弹出框的模态状态：非模态弹出框无蒙层，支持与周围组件交互；模态弹出框有蒙层，禁止与周围组件交互。
    
- 从API version 15开始，当levelMode属性设置为LevelMode.EMBEDDED时，设置immersiveMode参数，可定制弹出框蒙层是否延伸至状态栏及导航栏。
    

|接口&组件|maskColor|transition|maskTransition|
|:--|:--|:--|:--|
|[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|支持|支持|支持|
|[openCustomDialogWithController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialogwithcontroller18)|支持|支持|支持|
|[presentCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#presentcustomdialog18)|支持|支持|支持|
|[updateCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatecustomdialog12)|支持|不支持|不支持|
|[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|支持|不支持（可由openAnimation和closeAnimation替代）|不支持|
|[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showdialog)|不支持|不支持|不支持|
|[showAlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showalertdialog)|不支持|支持|不支持|
|[showActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showactionsheet)|不支持|支持|不支持|
|[showActionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showactionmenu11)|不支持|不支持|不支持|
|[showDatePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showdatepickerdialog)|不支持|不支持|不支持|
|[CalendarPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-calendarpicker-dialog)|不支持|不支持|不支持|
|[showTimePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtimepickerdialog)|不支持|不支持|不支持|
|[showTextPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtextpickerdialog)|不支持|不支持|不支持|

说明

- 设置maskColor参数，可定制弹出框蒙层的颜色。
    
- 设置openAnimation参数，可定制弹出框的进入动画，同时影响蒙层动画。该接口仅支持简单的动画设置，不支持复杂动画定制。
    
- 设置closeAnimation参数，可定制弹出框的退出动画，同时影响蒙层动画。该接口仅支持简单的动画设置，不支持复杂动画定制。
    
- 设置transition参数，可定制弹出框的进入和退出动画，同时影响蒙层动画。
    
- 从API version 19开始，设置maskTransition参数，可定制弹出框的蒙层动画。
    

## 弹出框蒙层显隐控制

通过autoCancel和isModal属性控制弹出框的蒙层显隐。

设置autoCancel为false，取消默认点击蒙层时弹窗消失。

1. // xxx.ets
2.   autoCancelOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     autoCancel: false,
7.   } as promptAction.CustomDialogOptions;

8.   Button("openCustomDialog autoCancel:false")
9.     .width('100%')
10.     .margin({ top: 10 })
11.     .onClick(() => {
12.       this.getUIContext().getPromptAction().openCustomDialog(this.autoCancelOpt)
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164102.67445658885575987297684002068773:50001231000000:2800:DCD25B4A42804EA4E3807F694DB312869BDD0E92FDD3404FD8BB773B25082A2E.gif)

设置isModal为false，将默认的模态弹出框变为非模态弹出框。

1. // xxx.ets
2. modalOpt: promptAction.CustomDialogOptions = {
3.   builder: () => {
4.     this.myBuilder();
5.   },
6.   isModal: false,
7. } as promptAction.CustomDialogOptions;

8. Button("openCustomDialog isModal:false")
9.   .width('100%')
10.   .margin({ top: 10 })
11.   .onClick(() => {
12.     this.getUIContext().getPromptAction().openCustomDialog(this.modalOpt)
13.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.61488763794139288576216220804106:50001231000000:2800:5F07C1BAD63C3A1E13A184B385514C02F9E5F54803F04BB2A87A9C200D94740B.png)

## 弹出框蒙层样式控制

该示例通过maskRect、immersiveMode和maskColor展示弹出框在蒙层样式控制方面的能力。

设置maskRect和maskColor，实现蒙层区域和蒙层颜色的设置。

1. // xxx.ets
2.   maskOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     maskRect: {
7.       x: 0,
8.       y: 10,
9.       width: '100%',
10.       height: '90%'
11.     },
12.     maskColor: "#33AA0000"
13.   } as promptAction.CustomDialogOptions;

14.   Button("openCustomDialog maskOpt")
15.     .width('100%')
16.     .margin({ top: 10 })
17.     .onClick(() => {
18.       this.getUIContext().getPromptAction().openCustomDialog(this.maskOpt)
19.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.24281706041332550278325943132208:50001231000000:2800:73D8022C6F76B43720695A0EEBC9735D0D8EE931E0B3DDE929EFF65D9F3B4CFF.png)

在levelMode为LevelMode.EMBEDDED下，展示不同immersiveMode对蒙层在导航栏和状态栏的延伸效果。

1. // xxx.ets
2.   @State immersiveMode: ImmersiveMode = ImmersiveMode.DEFAULT;

3.   Button("openCustomDialog immersiveMode")
4.     .width('100%')
5.     .margin({ top: 10 })
6.     .onClick(() => {
7.       this.immersiveMode =
8.         this.immersiveMode == ImmersiveMode.DEFAULT ? ImmersiveMode.EXTEND : ImmersiveMode.DEFAULT;
9.       this.getUIContext().getPromptAction().openCustomDialog({
10.         builder: () => {
11.           this.myBuilder();
12.         },
13.         levelMode: LevelMode.EMBEDDED,
14.         immersiveMode: this.immersiveMode,
15.       })
16.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.38533289165607749205203991523454:50001231000000:2800:C797FBAFB205BBB59F79CFD4CDDF03188FDCEFE6E3FB2BEB29F127C1ABF60168.gif)

## 弹出框蒙层动画控制

该示例通过transition和maskTransition分别展示弹出框在蒙层动画方面的能力。

设置transition，实现弹出框与蒙层整体的动画。

1. // xxx.ets
2.   transitionOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     transition: TransitionEffect.OPACITY.animation({ duration: 3000 })
7.   } as promptAction.CustomDialogOptions;

8.   Button("openCustomDialog transition")
9.     .width('100%')
10.     .margin({ top: 10 })
11.     .onClick(() => {
12.       this.getUIContext().getPromptAction().openCustomDialog(this.transitionOpt);
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.58606572351260459563762200108056:50001231000000:2800:FF9D0EB99582F9651E58B50CB65151293B1456170E4195814C565D513AD07C22.gif)

设置maskTransition，实现弹出框中蒙层单独的动画定制能力。

1. // xxx.ets
2.   Button("openCustomDialog maskTransition")
3.     .width('100%')
4.     .margin({ top: 10 })
5.     .onClick(() => {
6.       this.getUIContext().getPromptAction().openCustomDialog({
7.         builder: () => {
8.           this.myBuilder();
9.         },
10.         maskTransition: TransitionEffect.OPACITY.animation({ duration: 2000 })
11.           .combine(TransitionEffect.rotate({ z: 1, angle: 180 })),
12.       });
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.18215723761995601093433378631077:50001231000000:2800:F68E7BD8FB4C6A9E52905924656E36A9E03D2C4E28EBC039796FEEE1BDF97C2C.gif)

[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)虽然不支持transition接口，但与之对应的openAnimation和closeAnimation接口在动画的打开和关闭时可进行定制，示例代码如下：

1. // xxx.ets

2. @CustomDialog
3. @Component
4. struct CustomDialogExample {
5.   controller?: CustomDialogController;

6.   build() {
7.     Column() {
8.       Text("title")
9.         .margin(10)
10.         .fontSize(20)
11.       Button("button1")
12.         .margin(10)
13.         .fontSize(20)
14.         .onClick(() => {
15.           this.controller?.close();
16.         })
17.       Button("button2")
18.         .margin(10)
19.         .fontSize(20)
20.         .onClick(() => {
21.           this.controller?.close();
22.         })
23.     }.width('100%')
24.     .height('50%')
25.   }
26. }

27. @Entry
28. @Component
29. struct Index {
30.   animationController: CustomDialogController | null
31.     = new CustomDialogController({
32.     builder: CustomDialogExample(),
33.     closeAnimation: { duration: 2000 },
34.     openAnimation: { duration: 2000 }
35.   });

36.   aboutToDisappear(): void {
37.     this.animationController = null;
38.   }

39.   build() {
40.     Column() {
41.       Button("CustomDialogController animate")
42.         .width('100%')
43.         .margin({ top: 10 })
44.         .onClick(() => {
45.           this.animationController?.open();
46.         })
47.     }
48.   }
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.55672919783428905493289020614173:50001231000000:2800:56853D1697A19114EADEFB7929ED2CF3CAA98D809783A01217327B2B39CE9450.gif)

## 完整示例

1. // xxx.ets
2. import { ImmersiveMode, LevelMode, promptAction } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct Index {
6.   @State immersiveMode: ImmersiveMode = ImmersiveMode.DEFAULT;
7.   autoCancelOpt: promptAction.CustomDialogOptions = {
8.     builder: () => {
9.       this.myBuilder();
10.     },
11.     autoCancel: false,
12.   } as promptAction.CustomDialogOptions;
13.   modalOpt: promptAction.CustomDialogOptions = {
14.     builder: () => {
15.       this.myBuilder();
16.     },
17.     isModal: false,
18.   } as promptAction.CustomDialogOptions;
19.   maskOpt: promptAction.CustomDialogOptions = {
20.     builder: () => {
21.       this.myBuilder();
22.     },
23.     maskRect: {
24.       x: 0,
25.       y: 10,
26.       width: '100%',
27.       height: '90%'
28.     },
29.     maskColor: "#33AA0000"
30.   } as promptAction.CustomDialogOptions;
31.   transitionOpt: promptAction.CustomDialogOptions = {
32.     builder: () => {
33.       this.myBuilder();
34.     },
35.     transition: TransitionEffect.OPACITY.animation({ duration: 3000 })
36.   } as promptAction.CustomDialogOptions;

37.   @Builder
38.   myBuilder() {
39.     Column() {
40.       Text("title").margin(10).fontSize(20)
41.       Button("button1").margin(10).fontSize(20)
42.       Button("button2").margin(10).fontSize(20)
43.     }.width('100%').height('50%')
44.   }

45.   build() {
46.     Column() {
47.       Button("openCustomDialog autoCancel:false")
48.         .width('100%')
49.         .margin({ top: 10 })
50.         .onClick(() => {
51.           this.getUIContext().getPromptAction().openCustomDialog(this.autoCancelOpt)
52.         })
53.       Button("openCustomDialog isModal:false")
54.         .width('100%')
55.         .margin({ top: 10 })
56.         .onClick(() => {
57.           this.getUIContext().getPromptAction().openCustomDialog(this.modalOpt)
58.         })
59.       Button("openCustomDialog maskOpt")
60.         .width('100%')
61.         .margin({ top: 10 })
62.         .onClick(() => {
63.           this.getUIContext().getPromptAction().openCustomDialog(this.maskOpt)
64.         })
65.       Button("openCustomDialog transition")
66.         .width('100%')
67.         .margin({ top: 10 })
68.         .onClick(() => {
69.           this.getUIContext().getPromptAction().openCustomDialog(this.transitionOpt);
70.         })
71.       Button("openCustomDialog immersiveMode")
72.         .width('100%')
73.         .margin({ top: 10 })
74.         .onClick(() => {
75.           this.immersiveMode =
76.             this.immersiveMode == ImmersiveMode.DEFAULT ? ImmersiveMode.EXTEND : ImmersiveMode.DEFAULT;
77.           this.getUIContext().getPromptAction().openCustomDialog({
78.             builder: () => {
79.               this.myBuilder();
80.             },
81.             levelMode: LevelMode.EMBEDDED,
82.             immersiveMode: this.immersiveMode,
83.           })
84.         })
85.       Button("openCustomDialog maskTransition")
86.         .width('100%')
87.         .margin({ top: 10 })
88.         .onClick(() => {
89.           this.getUIContext().getPromptAction().openCustomDialog({
90.             builder: () => {
91.               this.myBuilder();
92.             },
93.             maskTransition: TransitionEffect.OPACITY.animation({ duration: 2000 })
94.               .combine(TransitionEffect.rotate({ z: 1, angle: 180 })),
95.           });
96.         })
97.     }
98.     .width('100%')
99.     .height('100%')
100.   }
101. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.52416544369434622370432548826851:50001231000000:2800:9CAD9BAC394EBE4210FCB16EE778C52C1B9D60318E2EDFD833F856BD5F90C09F.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-focusable "弹出框焦点策略")
# 弹出框蒙层控制

更新时间: 2025-12-16 16:41

开发者对弹出框的定制不仅限于弹出框里的内容，对弹出框蒙层的定制需求也逐渐增加。本文介绍ArkUI弹出框的蒙层控制，包括点击蒙层时是否消失、蒙层区域、蒙层颜色和蒙层动画等特性。

## 使用约束

ArkUI提供多种弹出框，不同类型的弹出框具备不同的蒙层定制能力。详情请参阅下表：

|接口&组件|autoCancel|maskRect|isModal|immersiveMode|
|:--|:--|:--|:--|:--|
|[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|支持|支持|支持|支持|
|[openCustomDialogWithController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialogwithcontroller18)|支持|支持|支持|支持|
|[presentCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#presentcustomdialog18)|支持|支持|支持|支持|
|[updateCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatecustomdialog12)|支持|不支持|不支持|不支持|
|[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|支持|支持|支持|支持|
|[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showdialog)|不支持|支持|支持|支持|
|[showAlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showalertdialog)|支持|支持|支持|支持|
|[showActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showactionsheet)|支持|支持|支持|支持|
|[showActionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showactionmenu11)|不支持|不支持|支持|支持|
|[showDatePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showdatepickerdialog)|不支持|支持|不支持|不支持|
|[CalendarPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-calendarpicker-dialog)|不支持|不支持|不支持|不支持|
|[showTimePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtimepickerdialog)|不支持|支持|不支持|不支持|
|[showTextPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtextpickerdialog)|不支持|支持|不支持|不支持|

说明

- 设置autoCancel参数，可控制弹出框蒙层被点击时是否消失。
    
- 设置maskRect参数，可定制弹出框的蒙层的大小和位置。此外，蒙层范围内的事件无法透传，而蒙层范围外的事件可以透传。
    
- 设置isModal参数，可定制弹出框的模态状态：非模态弹出框无蒙层，支持与周围组件交互；模态弹出框有蒙层，禁止与周围组件交互。
    
- 从API version 15开始，当levelMode属性设置为LevelMode.EMBEDDED时，设置immersiveMode参数，可定制弹出框蒙层是否延伸至状态栏及导航栏。
    

|接口&组件|maskColor|transition|maskTransition|
|:--|:--|:--|:--|
|[openCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-uicontext-custom-dialog)|支持|支持|支持|
|[openCustomDialogWithController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#opencustomdialogwithcontroller18)|支持|支持|支持|
|[presentCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#presentcustomdialog18)|支持|支持|支持|
|[updateCustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatecustomdialog12)|支持|不支持|不支持|
|[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)|支持|不支持（可由openAnimation和closeAnimation替代）|不支持|
|[showDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showdialog)|不支持|不支持|不支持|
|[showAlertDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showalertdialog)|不支持|支持|不支持|
|[showActionSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showactionsheet)|不支持|支持|不支持|
|[showActionMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#showactionmenu11)|不支持|不支持|不支持|
|[showDatePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showdatepickerdialog)|不支持|不支持|不支持|
|[CalendarPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-methods-calendarpicker-dialog)|不支持|不支持|不支持|
|[showTimePickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtimepickerdialog)|不支持|不支持|不支持|
|[showTextPickerDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#showtextpickerdialog)|不支持|不支持|不支持|

说明

- 设置maskColor参数，可定制弹出框蒙层的颜色。
    
- 设置openAnimation参数，可定制弹出框的进入动画，同时影响蒙层动画。该接口仅支持简单的动画设置，不支持复杂动画定制。
    
- 设置closeAnimation参数，可定制弹出框的退出动画，同时影响蒙层动画。该接口仅支持简单的动画设置，不支持复杂动画定制。
    
- 设置transition参数，可定制弹出框的进入和退出动画，同时影响蒙层动画。
    
- 从API version 19开始，设置maskTransition参数，可定制弹出框的蒙层动画。
    

## 弹出框蒙层显隐控制

通过autoCancel和isModal属性控制弹出框的蒙层显隐。

设置autoCancel为false，取消默认点击蒙层时弹窗消失。

1. // xxx.ets
2.   autoCancelOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     autoCancel: false,
7.   } as promptAction.CustomDialogOptions;

8.   Button("openCustomDialog autoCancel:false")
9.     .width('100%')
10.     .margin({ top: 10 })
11.     .onClick(() => {
12.       this.getUIContext().getPromptAction().openCustomDialog(this.autoCancelOpt)
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164102.67445658885575987297684002068773:50001231000000:2800:DCD25B4A42804EA4E3807F694DB312869BDD0E92FDD3404FD8BB773B25082A2E.gif)

设置isModal为false，将默认的模态弹出框变为非模态弹出框。

1. // xxx.ets
2. modalOpt: promptAction.CustomDialogOptions = {
3.   builder: () => {
4.     this.myBuilder();
5.   },
6.   isModal: false,
7. } as promptAction.CustomDialogOptions;

8. Button("openCustomDialog isModal:false")
9.   .width('100%')
10.   .margin({ top: 10 })
11.   .onClick(() => {
12.     this.getUIContext().getPromptAction().openCustomDialog(this.modalOpt)
13.   })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.61488763794139288576216220804106:50001231000000:2800:5F07C1BAD63C3A1E13A184B385514C02F9E5F54803F04BB2A87A9C200D94740B.png)

## 弹出框蒙层样式控制

该示例通过maskRect、immersiveMode和maskColor展示弹出框在蒙层样式控制方面的能力。

设置maskRect和maskColor，实现蒙层区域和蒙层颜色的设置。

1. // xxx.ets
2.   maskOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     maskRect: {
7.       x: 0,
8.       y: 10,
9.       width: '100%',
10.       height: '90%'
11.     },
12.     maskColor: "#33AA0000"
13.   } as promptAction.CustomDialogOptions;

14.   Button("openCustomDialog maskOpt")
15.     .width('100%')
16.     .margin({ top: 10 })
17.     .onClick(() => {
18.       this.getUIContext().getPromptAction().openCustomDialog(this.maskOpt)
19.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.24281706041332550278325943132208:50001231000000:2800:73D8022C6F76B43720695A0EEBC9735D0D8EE931E0B3DDE929EFF65D9F3B4CFF.png)

在levelMode为LevelMode.EMBEDDED下，展示不同immersiveMode对蒙层在导航栏和状态栏的延伸效果。

1. // xxx.ets
2.   @State immersiveMode: ImmersiveMode = ImmersiveMode.DEFAULT;

3.   Button("openCustomDialog immersiveMode")
4.     .width('100%')
5.     .margin({ top: 10 })
6.     .onClick(() => {
7.       this.immersiveMode =
8.         this.immersiveMode == ImmersiveMode.DEFAULT ? ImmersiveMode.EXTEND : ImmersiveMode.DEFAULT;
9.       this.getUIContext().getPromptAction().openCustomDialog({
10.         builder: () => {
11.           this.myBuilder();
12.         },
13.         levelMode: LevelMode.EMBEDDED,
14.         immersiveMode: this.immersiveMode,
15.       })
16.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.38533289165607749205203991523454:50001231000000:2800:C797FBAFB205BBB59F79CFD4CDDF03188FDCEFE6E3FB2BEB29F127C1ABF60168.gif)

## 弹出框蒙层动画控制

该示例通过transition和maskTransition分别展示弹出框在蒙层动画方面的能力。

设置transition，实现弹出框与蒙层整体的动画。

1. // xxx.ets
2.   transitionOpt: promptAction.CustomDialogOptions = {
3.     builder: () => {
4.       this.myBuilder();
5.     },
6.     transition: TransitionEffect.OPACITY.animation({ duration: 3000 })
7.   } as promptAction.CustomDialogOptions;

8.   Button("openCustomDialog transition")
9.     .width('100%')
10.     .margin({ top: 10 })
11.     .onClick(() => {
12.       this.getUIContext().getPromptAction().openCustomDialog(this.transitionOpt);
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.58606572351260459563762200108056:50001231000000:2800:FF9D0EB99582F9651E58B50CB65151293B1456170E4195814C565D513AD07C22.gif)

设置maskTransition，实现弹出框中蒙层单独的动画定制能力。

1. // xxx.ets
2.   Button("openCustomDialog maskTransition")
3.     .width('100%')
4.     .margin({ top: 10 })
5.     .onClick(() => {
6.       this.getUIContext().getPromptAction().openCustomDialog({
7.         builder: () => {
8.           this.myBuilder();
9.         },
10.         maskTransition: TransitionEffect.OPACITY.animation({ duration: 2000 })
11.           .combine(TransitionEffect.rotate({ z: 1, angle: 180 })),
12.       });
13.     })

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.18215723761995601093433378631077:50001231000000:2800:F68E7BD8FB4C6A9E52905924656E36A9E03D2C4E28EBC039796FEEE1BDF97C2C.gif)

[CustomDialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-custom-dialog)虽然不支持transition接口，但与之对应的openAnimation和closeAnimation接口在动画的打开和关闭时可进行定制，示例代码如下：

1. // xxx.ets

2. @CustomDialog
3. @Component
4. struct CustomDialogExample {
5.   controller?: CustomDialogController;

6.   build() {
7.     Column() {
8.       Text("title")
9.         .margin(10)
10.         .fontSize(20)
11.       Button("button1")
12.         .margin(10)
13.         .fontSize(20)
14.         .onClick(() => {
15.           this.controller?.close();
16.         })
17.       Button("button2")
18.         .margin(10)
19.         .fontSize(20)
20.         .onClick(() => {
21.           this.controller?.close();
22.         })
23.     }.width('100%')
24.     .height('50%')
25.   }
26. }

27. @Entry
28. @Component
29. struct Index {
30.   animationController: CustomDialogController | null
31.     = new CustomDialogController({
32.     builder: CustomDialogExample(),
33.     closeAnimation: { duration: 2000 },
34.     openAnimation: { duration: 2000 }
35.   });

36.   aboutToDisappear(): void {
37.     this.animationController = null;
38.   }

39.   build() {
40.     Column() {
41.       Button("CustomDialogController animate")
42.         .width('100%')
43.         .margin({ top: 10 })
44.         .onClick(() => {
45.           this.animationController?.open();
46.         })
47.     }
48.   }
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.55672919783428905493289020614173:50001231000000:2800:56853D1697A19114EADEFB7929ED2CF3CAA98D809783A01217327B2B39CE9450.gif)

## 完整示例

1. // xxx.ets
2. import { ImmersiveMode, LevelMode, promptAction } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct Index {
6.   @State immersiveMode: ImmersiveMode = ImmersiveMode.DEFAULT;
7.   autoCancelOpt: promptAction.CustomDialogOptions = {
8.     builder: () => {
9.       this.myBuilder();
10.     },
11.     autoCancel: false,
12.   } as promptAction.CustomDialogOptions;
13.   modalOpt: promptAction.CustomDialogOptions = {
14.     builder: () => {
15.       this.myBuilder();
16.     },
17.     isModal: false,
18.   } as promptAction.CustomDialogOptions;
19.   maskOpt: promptAction.CustomDialogOptions = {
20.     builder: () => {
21.       this.myBuilder();
22.     },
23.     maskRect: {
24.       x: 0,
25.       y: 10,
26.       width: '100%',
27.       height: '90%'
28.     },
29.     maskColor: "#33AA0000"
30.   } as promptAction.CustomDialogOptions;
31.   transitionOpt: promptAction.CustomDialogOptions = {
32.     builder: () => {
33.       this.myBuilder();
34.     },
35.     transition: TransitionEffect.OPACITY.animation({ duration: 3000 })
36.   } as promptAction.CustomDialogOptions;

37.   @Builder
38.   myBuilder() {
39.     Column() {
40.       Text("title").margin(10).fontSize(20)
41.       Button("button1").margin(10).fontSize(20)
42.       Button("button2").margin(10).fontSize(20)
43.     }.width('100%').height('50%')
44.   }

45.   build() {
46.     Column() {
47.       Button("openCustomDialog autoCancel:false")
48.         .width('100%')
49.         .margin({ top: 10 })
50.         .onClick(() => {
51.           this.getUIContext().getPromptAction().openCustomDialog(this.autoCancelOpt)
52.         })
53.       Button("openCustomDialog isModal:false")
54.         .width('100%')
55.         .margin({ top: 10 })
56.         .onClick(() => {
57.           this.getUIContext().getPromptAction().openCustomDialog(this.modalOpt)
58.         })
59.       Button("openCustomDialog maskOpt")
60.         .width('100%')
61.         .margin({ top: 10 })
62.         .onClick(() => {
63.           this.getUIContext().getPromptAction().openCustomDialog(this.maskOpt)
64.         })
65.       Button("openCustomDialog transition")
66.         .width('100%')
67.         .margin({ top: 10 })
68.         .onClick(() => {
69.           this.getUIContext().getPromptAction().openCustomDialog(this.transitionOpt);
70.         })
71.       Button("openCustomDialog immersiveMode")
72.         .width('100%')
73.         .margin({ top: 10 })
74.         .onClick(() => {
75.           this.immersiveMode =
76.             this.immersiveMode == ImmersiveMode.DEFAULT ? ImmersiveMode.EXTEND : ImmersiveMode.DEFAULT;
77.           this.getUIContext().getPromptAction().openCustomDialog({
78.             builder: () => {
79.               this.myBuilder();
80.             },
81.             levelMode: LevelMode.EMBEDDED,
82.             immersiveMode: this.immersiveMode,
83.           })
84.         })
85.       Button("openCustomDialog maskTransition")
86.         .width('100%')
87.         .margin({ top: 10 })
88.         .onClick(() => {
89.           this.getUIContext().getPromptAction().openCustomDialog({
90.             builder: () => {
91.               this.myBuilder();
92.             },
93.             maskTransition: TransitionEffect.OPACITY.animation({ duration: 2000 })
94.               .combine(TransitionEffect.rotate({ z: 1, angle: 180 })),
95.           });
96.         })
97.     }
98.     .width('100%')
99.     .height('100%')
100.   }
101. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164103.52416544369434622370432548826851:50001231000000:2800:9CAD9BAC394EBE4210FCB16EE778C52C1B9D60318E2EDFD833F856BD5F90C09F.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dialog-focusable "弹出框焦点策略")
