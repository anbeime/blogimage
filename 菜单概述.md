# 菜单概述

更新时间: 2025-12-16 16:40

菜单是一种用于给用户提供可执行的操作的弹窗，一般用于鼠标右键弹窗、点击弹窗等。

## 使用场景

|接口|使用场景|
|:--|:--|
|[菜单控制 (Menu)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-menu)|用于需要给指定的组件绑定用户可执行的操作时，例如长按图标展示操作选项等。|
|[不依赖UI组件的全局菜单 (openMenu)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-uicontext-menu)|用于在无法直接访问UI组件的场景向用户提供可执行操作，例如在事件回调中展示操作选项等。|

## 规格约束

- [bindMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#bindmenu11)通过调用isShow参数或[bindContextMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#bindcontextmenu12)调用isShown参数弹出时，需要等待页面全部构建完成才能展示。因此isShow或isShown不能在页面构建中设置为true，否则会导致menu弹窗显示位置及形状错误。
- openMenu的弹出需要传入有效的[TargetInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-i#targetinfo18)，否则无法弹出气泡。
- 其他规格约束，具体可参考[菜单控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu)、[openMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#openmenu18) 说明。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-menu "菜单")
# 菜单控制（Menu）

更新时间: 2025-12-16 16:40

Menu是菜单接口，一般用于鼠标右键弹窗、点击弹窗等。具体用法请参考[菜单控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu)。

使用[bindContextMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#bindcontextmenu12)并设置预览图，菜单弹出时有蒙层，此时为模态。

使用[bindMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#bindmenu11)或bindContextMenu未设置预览图时，菜单弹出无蒙层，此时为非模态。

## 生命周期

|名称|类型|说明|
|:--|:--|:--|
|aboutToAppear|() => void|菜单显示动效前的事件回调。|
|onAppear|() => void|菜单弹出后的事件回调。|
|aboutToDisappear|() => void|菜单退出动效前的事件回调。|
|onDisappear|() => void|菜单消失后的事件回调。|

## 创建默认样式的菜单

菜单需要调用bindMenu接口来实现。bindMenu响应绑定组件的点击事件，绑定组件后手势点击对应组件后即可弹出。

1. Button('click for Menu')
2.   .bindMenu([
3.     {
4.       value: 'Menu1',
5.       action: () => {
6.         console.info('handle Menu1 select');
7.       }
8.     }
9.   ])

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164024.77758717939610378484617135312834:50001231000000:2800:E0090FEE0199D43FA14AB4C626DE571CD305B0BD0C2C40D689BDF19378E4057C.png)

## 创建自定义样式的菜单

当默认样式不满足开发需求时，可使用[@Builder](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builder)自定义菜单内容，通过bindMenu接口进行菜单的自定义。

### 使用@Builder自定义菜单内容

1. class Tmp {
2.   // $r('app.media.xxx')需要替换为开发者所需的图像资源文件。
3.   iconStr2: ResourceStr = $r("app.media.view_list_filled");

4.   set(val: Resource) {
5.     this.iconStr2 = val;
6.   }
7. }

8. @Entry
9. @Component
10. struct menuExample {
11.   @State select: boolean = true;
12.   private iconStr: ResourceStr = $r("app.media.view_list_filled");
13.   private iconStr2: ResourceStr = $r("app.media.view_list_filled");

14.   @Builder
15.   SubMenu() {
16.     Menu() {
17.       MenuItem({ content: "复制", labelInfo: "Ctrl+C" })
18.       MenuItem({ content: "粘贴", labelInfo: "Ctrl+V" })
19.     }
20.   }

21.   @Builder
22.   MyMenu() {
23.     Menu() {
24.       MenuItem({ startIcon: $r("app.media.icon"), content: "菜单选项" })
25.       MenuItem({ startIcon: $r("app.media.icon"), content: "菜单选项" }).enabled(false)
26.       MenuItem({
27.         startIcon: this.iconStr,
28.         content: "菜单选项",
29.         endIcon: $r("app.media.arrow_right_filled"),
30.         // 当builder参数进行配置时，表示与menuItem项绑定了子菜单。鼠标hover在该菜单项时，会显示子菜单。
31.         builder: this.SubMenu
32.       })
33.       MenuItemGroup({ header: '小标题' }) {
34.         MenuItem({ content: "菜单选项" })
35.           .selectIcon(true)
36.           .selected(this.select)
37.           .onChange((selected) => {
38.             console.info("menuItem select" + selected);
39.             let Str: Tmp = new Tmp();
40.             Str.set($r("app.media.icon"));
41.           })
42.         MenuItem({
43.           startIcon: $r("app.media.view_list_filled"),
44.           content: "菜单选项",
45.           endIcon: $r("app.media.arrow_right_filled"),
46.           builder: this.SubMenu
47.         })
48.       }

49.       MenuItem({
50.         startIcon: this.iconStr2,
51.         content: "菜单选项",
52.         endIcon: $r("app.media.arrow_right_filled")
53.       })
54.     }
55.   }

56.   build() {
57.     // ...
58.   }
59. }

### 使用bindMenu属性绑定组件

1. Button('click for Menu')
2.   .bindMenu(this.MyMenu)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164024.46606102325250930834168533682495:50001231000000:2800:F7041A04839F772161D4ADF5D2F5A2B1622AFD2838B9995E167B8CFAB9C3AB8E.png)

## 创建支持右键或长按的菜单

通过bindContextMenu接口自定义菜单，设置菜单弹出的触发方式，触发方式为右键或长按。使用bindContextMenu弹出的菜单项是在独立子窗口内的，可显示在应用窗口外部。

- 使用@Builder自定义菜单内容，与上文写法相同。
    
- 确认菜单的弹出方式，并使用bindContextMenu属性绑定组件。示例中为右键弹出菜单。
    
    1. Button('Right-click for Menu')
    2.   .bindContextMenu(this.MyMenu, ResponseType.RightClick)
    

## 菜单弹出时振动效果

菜单从API version 18开始支持振动效果。菜单弹出时，默认不振动。若希望菜单弹出时有振动效果，可以通过[ContextMenuOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#contextmenuoptions10)的hapticFeedbackMode属性，设置菜单弹出时的振动模式。

- 只有一级菜单可配置弹出时振动效果。
    
- 仅当应用具备ohos.permission.VIBRATE权限，且用户启用了触感反馈时才会生效。开启触控反馈时，需要在工程的module.json5中配置[声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions)的requestPermissions字段开启振动权限，配置如下：
    
    1. "requestPermissions": [
    2.   {
    3.     "name": "ohos.permission.VIBRATE",
    4.   }
    5. ]
    

1.   Button('click for Menu')
2.     .bindMenu(this.MyMenu, { hapticFeedbackMode: HapticFeedbackMode.ENABLED })

## 菜单支持避让中轴

从API version 18起，菜单支持中轴避让功能。从API version 20开始，在2in1设备上默认启用（仅在窗口处于瀑布模式时产生避让）。开发者可通过[ContextMenuOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#contextmenuoptions10)中的enableHoverMode属性，控制菜单是否启用中轴避让。

说明

- 如果菜单的点击位置在中轴区域，则菜单不会避让。
- 2in1设备上需同时满足窗口处于瀑布模式才会产生避让。

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = 'Hello World';
5.   // $r('app.media.startIcon')需要替换为开发者所需的图像资源文件。
6.   private iconStr: Resource = $r('app.media.startIcon');
7.   @State index: number = 0;
8.   @State arrayStr: Array<string> = ['上半屏', '中轴', '下半屏'];
9.   @State enableHoverMode: boolean | undefined = true;
10.   @State showInSubwindow: boolean = false;
11.   @State placement: Placement | undefined = undefined;

12.   @Builder
13.   MyMenu1() {
14.     Menu() {
15.       MenuItem({ startIcon: this.iconStr, content: '菜单选项' })
16.       MenuItem({ startIcon: this.iconStr, content: '菜单选项' })
17.       MenuItem({ startIcon: this.iconStr, content: '菜单选项' })
18.       MenuItem({ startIcon: this.iconStr, content: '菜单选项' })
19.     }
20.   }

21.   @State isShow: boolean = false;

22.   build() {
23.     RelativeContainer() {
24.       Column() {
25.         Button('区域:' + this.arrayStr[this.index])
26.           .onClick(() => {
27.             if (this.index < 2) {
28.               this.index++
29.             } else {
30.               this.index = 0
31.             }
32.           })

33.         Button('hoverMode开启:' + this.enableHoverMode)
34.           .onClick(() => {
35.             if (this.enableHoverMode == undefined) {
36.               this.enableHoverMode = true
37.             } else if (this.enableHoverMode == true) {
38.               this.enableHoverMode = false
39.             } else {
40.               this.enableHoverMode = undefined
41.             }
42.           })

43.         Button('MenuPlacement:' + this.placement)
44.           .onClick(() => {
45.             if (this.placement == undefined) {
46.               this.placement = Placement.Bottom
47.             } else if (this.placement == Placement.Bottom) {
48.               this.placement = Placement.Top
49.             } else {
50.               this.placement = undefined
51.             }
52.           })
53.       }

54.       Row() {
55.         Button('Menu')
56.           .fontWeight(FontWeight.Bold)
57.           .bindMenu(this.MyMenu1(), {
58.             enableHoverMode: this.enableHoverMode,
59.             showInSubWindow: this.showInSubwindow,
60.             placement: this.placement
61.           })

62.         Select([{ value: 'text1' }, { value: 'text2' }, { value: 'text3' }, { value: 'text4' }, { value: 'text5' },
63.           { value: 'text6' }, { value: 'text7' }, { value: 'text8' }, { value: 'text9' }, { value: 'text10' }, { value: 'text11' },
64.           { value: 'text12' }])
65.           .value("Select")

66.       }
67.       .alignRules({
68.         center: { anchor: '__container__', align: VerticalAlign.Center },
69.         middle: { anchor: '__container__', align: HorizontalAlign.Center }
70.       })
71.       .margin({
72.         top: this.index == 2 ? 330 : this.index == 1 ? 50 : 0,
73.         bottom: this.index == 0 ? 330 : 0
74.       })
75.     }
76.     .height('100%')
77.     .width('100%')
78.   }
79. }

## 控制子窗菜单的事件透传

当菜单在子窗口中弹出时，默认情况下，菜单周围的事件会传递至所在窗口。从API version 20开始，开发者可通过[ContextMenuOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#contextmenuoptions10)的modalMode属性设置子菜单弹出时的模态模式，以控制菜单周围事件是否传递。将modalMode设置为ModalMode.TARGET_WINDOW时，菜单周围的事件将不再传递，菜单下方的控件也不会响应事件。

1. @Entry
2. @Component
3. struct Index2 {
4.   build() {
5.     Column() {
6.     }
7.     .bindContextMenu(this.contextMenuBuilder, ResponseType.RightClick, {
8.       modalMode: ModalMode.TARGET_WINDOW
9.     })
10.     .onClick(() => {
11.       this.getUIContext().getPromptAction().showToast({
12.         message: 'Clicked!'
13.       })
14.     })
15.     .width('100%')
16.     .height('100%')
17.   }

18.   @Builder
19.   bindMenuBuilder() {
20.     Menu() {
21.       MenuItem({ content: 'bindMenu item' }) {

22.       }
23.     }
24.   }

25.   @Builder
26.   contextMenuBuilder() {
27.     Menu() {
28.       MenuItem({ content: 'contextMenu item' }) {

29.       }
30.     }
31.   }
32. }

## 基于绑定组件指定位置弹出菜单

菜单从API version 20开始支持基于绑定组件在指定位置弹出。通过设置水平与垂直偏移量，控制菜单相对于绑定组件左上角的弹出位置。与单独使用offset接口不同，此方法可使菜单覆盖显示在绑定组件上。需要指定弹出位置时，可使用[ContextMenuOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#contextmenuoptions10)的anchorPosition属性进行设置。

说明

- 当菜单处于预览状态时，设定的定位偏移量将无法生效。
- 预设的[placement](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#contextmenuoptions10)对齐参数将不再生效。
- 叠加[offset](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#contextmenuoptions10)参数的偏移量，最终确定菜单的精确显示位置。
- 当水平与垂直偏移量均设为负值时，菜单以绑定组件左下角为基准点进行显示。
- 当水平或垂直偏移量存在负值时，组件将以绑定组件的左上角为定位基准点，通过叠加偏移量参数实现反向偏移。

1. @Entry
2. @Component
3. struct DirectiveMenuExample {
4.   @Builder
5.   MenuBuilder() {
6.     Column() {
7.       Menu() {
8.         MenuItemGroup() {
9.           // $r('app.media.app_icon')需要替换为开发者所需的图像资源文件。
10.           MenuItem({ startIcon: $r('app.media.app_icon'), content: "Select Mixed Menu 1", labelInfo: "" })
11.           MenuItem({ startIcon: $r('app.media.app_icon'), content: "Select Mixed Menu 2", labelInfo: "" })
12.           MenuItem({ startIcon: $r('app.media.app_icon'), content: "Select Mixed Menu 3", labelInfo: "" })
13.         }
14.       }
15.     }
16.   }

17.   build() {
18.     Column() {
19.       Text()
20.         .borderRadius(10)
21.         .width(200)
22.         .height(150)
23.         .borderWidth(1)
24.         .backgroundColor(Color.White)
25.         .borderColor(Color.Red)
26.         .margin({ top: 200, left: 125 })
27.         .bindContextMenu(this.MenuBuilder, ResponseType.RightClick, {
28.           anchorPosition: { x: 45, y: 50 },
29.         })
30.     }
31.     .alignItems(HorizontalAlign.Start)
32.     .width('100%')
33.     .height('100%')
34.     .backgroundColor('#F5F5F5')
35.   }
36. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.65045736626048973392311778438068:50001231000000:2800:D21AA4B6CB56C1DB4EB8D07DD58F25AC766A79B566799BD6D612B512AFA6F7A1.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-menu-overview "菜单概述")
# 不依赖UI组件的全局菜单 (openMenu)

更新时间: 2025-12-16 16:40

[菜单控制 (Menu)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-menu)在使用时依赖绑定UI组件，否则无法使用。从API version 18开始，可以通过使用全局接口[openMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#openmenu18)的方式，在无UI组件的场景下直接或封装使用，例如在事件回调中使用或封装后对外提供能力。

## 弹出菜单

通过[openMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#openmenu18)可以弹出菜单。

1. promptAction.openMenu(contentNode, { id: targetId }, {
2.   enableArrow: true
3. })
4.   .then(() => {
5.     console.info('openMenu success');
6.   })
7.   .catch((err: BusinessError) => {
8.     console.error('openMenu error: ' + err.code + ' ' + err.message);
9.   })

### 创建ComponentContent

通过调用openMenu接口弹出菜单，需要提供用于定义自定义弹出框的内容[ComponentContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-componentcontent)。其中，wrapBuilder(buildText)封装自定义组件，new Params(this.message)是自定义组件的入参，可以缺省，也可以传入基础数据类型。

1. private contentNode: ComponentContent<Object> = new ComponentContent(uiContext, wrapBuilder(buildText), this.message);

如果在wrapBuilder中包含其他组件（例如：[Popup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-popup)、[Chip](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-chip)组件），则[ComponentContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-componentcontent#componentcontent-1)应采用带有四个参数的构造函数constructor，其中options参数应传递{ nestingBuilderSupported: true }。

1. @Builder
2. export function buildText(params: Params) {
3.   Popup({
4.     // 类型设置图标内容
5.     icon: {
6.       image: $r('app.media.app_icon'),
7.       width: 32,
8.       height: 32,
9.       fillColor: Color.White,
10.       borderRadius: 10
11.     } as PopupIconOptions,
12.     // 设置文字内容
13.     title: {
14.       text: `This is a Popup title 1`,
15.       fontSize: 20,
16.       fontColor: Color.Black,
17.       fontWeight: FontWeight.Normal
18.     } as PopupTextOptions,
19.     // 设置文字内容
20.     message: {
21.       text: `This is a Popup message 1`,
22.       fontSize: 15,
23.       fontColor: Color.Black
24.     } as PopupTextOptions,
25.     // 设置按钮内容
26.     buttons: [{
27.       text: 'confirm',
28.       action: () => {
29.         console.info('confirm button click');
30.       },
31.       fontSize: 15,
32.       fontColor: Color.Black,
33.     },
34.       {
35.         text: 'cancel',
36.         action: () => {
37.           console.info('cancel button click');
38.         },
39.         fontSize: 15,
40.         fontColor: Color.Black
41.       },] as [PopupButtonOptions?, PopupButtonOptions?]
42.   })
43. }

44. private contentNode: ComponentContent<Object> = new ComponentContent(this.uiContext, wrapBuilder(buildText), this.message, { nestingBuilderSupported: true });

### 绑定组件信息

通过调用openMenu接口弹出菜单，需要提供绑定组件的信息[TargetInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-i#targetinfo18)。若未传入有效的target，则无法弹出菜单。

1. let frameNode: FrameNode | null = this.ctx.getFrameNodeByUniqueId(this.getUniqueId());
2. let targetId = frameNode?.getChild(0)?.getUniqueId();

### 设置弹出菜单样式

通过调用openMenu接口弹出菜单，可以设置[MenuOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#menuoptions10)中的属性调整菜单样式。title属性不生效。preview参数仅支持设置[MenuPreviewMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-menu#menupreviewmode11)类型。

1. private options: MenuOptions = { enableArrow: true, placement: Placement.Bottom };

## 更新菜单样式

从API version 18开始，通过[updateMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatemenu18)可以更新菜单的样式。支持全量更新和增量更新其菜单样式，不支持更新showInSubWindow、preview、previewAnimationOptions、transition、onAppear、aboutToAppear、onDisappear、aboutToDisappear、onWillAppear、onDidAppear、onWillDisappear和onDidDisappear。

1. promptAction.updateMenu(contentNode, {
2.   enableArrow: false
3. }, true)
4.   .then(() => {
5.     console.info('updateMenu success');
6.   })
7.   .catch((err: BusinessError) => {
8.     console.error('updateMenu error: ' + err.code + ' ' + err.message);
9.   })

## 关闭菜单

从API version 18开始，通过调用[closeMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#closemenu18)可以关闭菜单。

1. promptAction.closeMenu(contentNode)
2.   .then(() => {
3.     console.info('closeMenu success');
4.   })
5.  .catch((err: BusinessError) => {
6.    console.error('closeMenu error: ' + err.code + ' ' + err.message);
7.  })

说明

由于[updateMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatemenu18)和[closeMenu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#closemenu18)依赖content来更新或者关闭指定的菜单，开发者需自行维护传入的content。

## 在HAR包中使用全局菜单

可以通过[HAR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package)包封装一个Menu，从而对外提供菜单的弹出、更新和关闭能力。

具体调用方式参考[在HAR包中使用全局气泡提示](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-uicontext-popup#%E5%9C%A8har%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E6%B0%94%E6%B3%A1%E6%8F%90%E7%A4%BA)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-menu "菜单控制（Menu）")
# 气泡提示概述

更新时间: 2025-12-16 16:40

气泡提示是一种用于给用户提供提示的弹窗，主要用于屏幕录制、信息弹出提醒等显示状态。

## 使用场景

|接口|使用场景|
|:--|:--|
|[气泡提示 (Popup)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-popup)|用于需要给指定的组件提示时，例如点击一个问号图标弹出一段帮助提示等。|
|[不依赖UI组件的全局气泡提示 (openPopup)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-uicontext-popup)|用于需要在无法直接访问UI组件的场景中给提示时，例如在事件回调中弹出一段帮助提示等。|

## 规格约束

- Popup的弹出需要等待页面全部构建完成才能展示，因此[show](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-popup#bindpopup)不能在页面构建中设置为true，否则会导致popup弹窗显示位置及形状错误。
- openPopup的弹出需要传入有效的[TargetInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-i#targetinfo18)，否则无法弹出气泡。
- 其他规格约束，具体可参考[Popup控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-popup)、[openPopup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#openpopup18) 说明。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-use-popup "气泡提示")
# 气泡提示（Popup）

更新时间: 2025-12-16 16:40

Popup属性可绑定在组件上显示气泡弹窗提示，设置弹窗内容、交互逻辑和显示状态。主要用于屏幕录制、信息弹出提醒等显示状态。

气泡分为两种类型，一种是系统提供的气泡[PopupOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-popup#popupoptions%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E)，一种是开发者可以自定义的气泡[CustomPopupOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-popup#custompopupoptions8%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E)。其中，PopupOptions通过配置primaryButton和secondaryButton来设置带按钮的气泡；CustomPopupOptions通过配置[builder](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builder)来设置自定义的气泡。其中系统提供的气泡PopupOptions，字体的最大放大倍数为2。

气泡可以通过配置[mask](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-popup#popupoptions%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E)来实现模态和非模态窗口，mask为true或者颜色值的时候，气泡为模态窗口，mask为false时，气泡为非模态窗口。

多个气泡同时弹出时，子窗内显示的气泡比主窗内显示的气泡层级高，所处窗口相同时，后面弹出的气泡层级比先弹出的气泡层级高。

## 文本提示气泡

文本提示气泡常用于展示带有文本的信息提示，适用于无交互的场景。Popup属性需绑定组件，当bindPopup属性的参数show为true时，会弹出气泡提示。

在Button组件上绑定Popup属性，每次点击Button按钮时，handlePopup会切换布尔值。当值为true时，触发bindPopup弹出气泡。

1. @Entry
2. @Component
3. struct PopupExample {
4.   @State handlePopup: boolean = false;

5.   build() {
6.     Column() {
7.       Button('PopupOptions')
8.         .onClick(() => {
9.           this.handlePopup = !this.handlePopup;
10.         })
11.         .bindPopup(this.handlePopup, {
12.           message: 'This is a popup with PopupOptions',
13.         })
14.     }.width('100%').padding({ top: 5 })
15.   }
16. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.00952559053577658236234337757750:50001231000000:2800:5F90F6F108418C2BD79832CE38E62894A67736AD110566AA369D1A77D2A32865.png)

## 添加气泡状态变化的事件

通过onStateChange参数为气泡添加状态变化的事件回调，可以判断气泡的当前显示状态。

1. @Entry
2. @Component
3. struct PopupExample {
4.   @State handlePopup: boolean = false;

5.   build() {
6.     Column() {
7.       Button('PopupOptions')
8.         .onClick(() => {
9.           this.handlePopup = !this.handlePopup;
10.         })
11.         .bindPopup(this.handlePopup, {
12.           message: 'This is a popup with PopupOptions',
13.           onStateChange: (e)=> { // 返回当前的气泡状态
14.             if (!e.isVisible) {
15.               this.handlePopup = false;
16.             }
17.           }
18.         })
19.     }.width('100%').padding({ top: 5 })
20.   }
21. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.53671733425389738742310680803531:50001231000000:2800:F482D58A2660251E4FD08A524CE496929DD72361EAF8C2D3DCDB929D4AD75AE4.gif)

## 带按钮的提示气泡

通过primaryButton、secondaryButton属性为气泡最多设置两个Button按钮，通过此按钮进行简单的交互，开发者可以通过配置action参数来设置想要触发的操作。

1. @Entry
2. @Component
3. struct PopupExample22 {
4.   @State handlePopup: boolean = false;

5.   build() {
6.     Column() {
7.       Button('PopupOptions').margin({ top: 200 })
8.         .onClick(() => {
9.           this.handlePopup = !this.handlePopup;
10.         })
11.         .bindPopup(this.handlePopup, {
12.           message: 'This is a popup with PopupOptions',
13.           primaryButton: {
14.             value: 'Confirm',
15.             action: () => {
16.               this.handlePopup = !this.handlePopup;
17.               console.info('confirm Button click');
18.             }
19.           },
20.           secondaryButton: {
21.             value: 'Cancel',
22.             action: () => {
23.               this.handlePopup = !this.handlePopup;
24.             }
25.           },
26.           onStateChange: (e) => {
27.             if (!e.isVisible) {
28.               this.handlePopup = false;
29.             }
30.           }
31.         })
32.     }.width('100%').padding({ top: 5 })
33.   }
34. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.88572437641745144629429527955417:50001231000000:2800:F3D59A535B6281B54BBC6F5C742DBE3C6B05E682D6BB833812A57D21B8898E8E.jpeg)

## 气泡的动画

通过定义transition，可以控制气泡的进场和出场动画效果。

1. // xxx.ets
2. @Entry
3. @Component
4. struct PopupExample {
5.   @State handlePopup: boolean = false;
6.   @State customPopup: boolean = false;

7.   // popup构造器定义弹框内容
8.   @Builder popupBuilder() {
9.     Row() {
10.       Text('Custom Popup with transitionEffect').fontSize(10)
11.     }.height(50).padding(5)
12.   }

13.   build() {
14.     Flex({ direction: FlexDirection.Column }) {
15.       // PopupOptions 类型设置弹框内容
16.       Button('PopupOptions')
17.         .onClick(() => {
18.           this.handlePopup = !this.handlePopup;
19.         })
20.         .bindPopup(this.handlePopup, {
21.           message: 'This is a popup with transitionEffect',
22.           placement: Placement.Top,
23.           showInSubWindow: false,
24.           onStateChange: (e) => {
25.             if (!e.isVisible) {
26.               this.handlePopup = false;
27.             }
28.           },
29.           // 设置弹窗显示动效为透明度动效与平移动效的组合效果，无退出动效
30.           transition:TransitionEffect.asymmetric(
31.             TransitionEffect.OPACITY.animation({ duration: 1000, curve: Curve.Ease }).combine(
32.               TransitionEffect.translate({ x: 50, y: 50 })),
33.             TransitionEffect.IDENTITY)
34.         })
35.         .position({ x: 100, y: 150 })

36.       // CustomPopupOptions 类型设置弹框内容
37.       Button('CustomPopupOptions')
38.         .onClick(() => {
39.           this.customPopup = !this.customPopup;
40.         })
41.         .bindPopup(this.customPopup, {
42.           builder: this.popupBuilder,
43.           placement: Placement.Top,
44.           showInSubWindow: false,
45.           onStateChange: (e) => {
46.             if (!e.isVisible) {
47.               this.customPopup = false;
48.             }
49.           },
50.           // 设置弹窗显示动效与退出动效为缩放动效
51.           transition:TransitionEffect.scale({ x: 1, y: 0 }).animation({ duration: 500, curve: Curve.Ease })
52.         })
53.         .position({ x: 80, y: 300 })
54.     }.width('100%').padding({ top: 5 })
55.   }
56. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.17279504993305001102684687766031:50001231000000:2800:91851DFFD9297B32216A99C847EB9EA7E4556AAC59033D47528CCF56FA2CBB8B.gif)

## 自定义气泡

开发者可以使用CustomPopupOptions的builder创建自定义气泡，@Builder中可以放自定义的内容。除此之外，还可以通过popupColor等参数控制气泡样式。

1. @Entry
2. @Component
3. struct Index {
4.   @State customPopup: boolean = false;
5.   // popup构造器定义弹框内容
6.   @Builder popupBuilder() {
7.     Row({ space: 2 }) {
8.       // $r('app.media.icon')需要替换为开发者所需的图像资源文件。
9.       Image($r("app.media.icon")).width(24).height(24).margin({ left: 5 })
10.       Text('This is Custom Popup').fontSize(15)
11.     }.width(200).height(50).padding(5)
12.   }
13.   build() {
14.     Column() {
15.       Button('CustomPopupOptions')
16.         .position({x:100,y:200})
17.         .onClick(() => {
18.           this.customPopup = !this.customPopup;
19.         })
20.         .bindPopup(this.customPopup, {
21.           builder: this.popupBuilder, // 气泡的内容
22.           placement:Placement.Bottom, // 气泡的弹出位置
23.           popupColor:Color.Pink, // 气泡的背景色
24.           backgroundBlurStyle: BlurStyle.NONE,
25.           onStateChange: (e) => {
26.             if (!e.isVisible) {
27.               this.customPopup = false;
28.             }
29.           }
30.         })
31.     }
32.     .height('100%')
33.   }
34. }

使用者通过配置placement参数将弹出的气泡放到需要提示的位置。弹窗构造器会触发弹出提示信息，来引导使用者完成操作，也让使用者有更好的UI体验。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.76630204641416269281101343102200:50001231000000:2800:E333E7F840E202526FBF8D81C554AEC8785AC8F94E2A304366BFCE398ACEE61F.jpeg)

## 气泡样式

气泡除了可以通过builder实现自定义气泡，还可以通过接口设置气泡的样式和显示效果。

背景颜色：气泡的背景色默认为透明，但是会有一个默认的模糊效果，手机上为COMPONENT_ULTRA_THICK。

蒙层样式：气泡默认有蒙层，且蒙层的颜色为透明。

显示大小：气泡大小由内部的builder大小或者message的长度决定的。

显示位置：气泡默认显示在宿主组件的下方，可以通过Placement接口来配置其显示位置以及对齐方向。

以下示例通过设置popupColor（背景颜色）、mask（蒙层样式）、width（气泡宽度）、placement（显示位置）实现气泡的样式。

1. // xxx.ets

2. @Entry
3. @Component
4. struct PopupExample {
5.   @State handlePopup: boolean = false;

6.   build() {
7.     Column({ space: 100 }) {
8.       Button('PopupOptions')
9.         .onClick(() => {
10.           this.handlePopup = !this.handlePopup;
11.         })
12.         .bindPopup(this.handlePopup, {
13.           width: 200,
14.           message: 'This is a popup.',
15.           popupColor: Color.Red, // 设置气泡的背景色
16.           mask: {
17.             color: '#33d9d9d9'
18.           },
19.           placement: Placement.Top,
20.           backgroundBlurStyle: BlurStyle.NONE // 去除背景模糊效果需要关闭气泡的模糊背景
21.         })
22.     }
23.     .width('100%')
24.   }
25. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.27902200120208001973348240081687:50001231000000:2800:7DD310EFAA5C6BD719A3965CE1ECE2FADC66DED233CFD9CAC5933E243E7AFA16.gif)

## 气泡避让软键盘

当软键盘弹出时，气泡默认不会对其避让，可能导致气泡被软键盘覆盖，从API version 15开始，可以设置keyboardAvoidMode为KeyboardAvoidMode.DEFAULT，来使气泡避让键盘。这时如果当前没有位置放下气泡时，气泡会从预设位置平移覆盖宿主组件。

1. // xxx.ets

2. @Entry
3. @Component
4. struct PopupExample {
5.   @State handlePopup: boolean = false;

6.   @Builder popupBuilder() {
7.     Column({ space: 2 }) {
8.       Text('Custom Popup').fontSize(20)
9.         .borderWidth(2)
10.       TextInput()
11.     }.width(200).padding(5)
12.   }

13.   build() {
14.     Column({ space: 100 }) {
15.       TextInput()
16.       Button('PopupOptions')
17.         .onClick(() => {
18.           this.handlePopup = !this.handlePopup;
19.         })
20.         .bindPopup(this.handlePopup!!, {
21.           width: 200,
22.           builder: this.popupBuilder(),
23.           placement: Placement.Bottom,
24.           mask: false,
25.           autoCancel: false,
26.           keyboardAvoidMode: KeyboardAvoidMode.DEFAULT
27.         })
28.         .position({x: 100, y: 300})
29.     }
30.     .width('100%')
31.   }
32. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.68107634383714571805297772040939:50001231000000:2800:617220D598026059BD43D66C6D10B317CF26FC606FB36D7301106BAA94DFD281.gif)

## 设置气泡内的多态效果

目前使用@Builder自定义气泡内容时，默认不支持多态样式，可以使用@Component新建一个组件实现按下气泡中的内容时背景变色。

1. @Entry
2. @Component
3. struct PopupPage {
4.   private menus: Array<string> = ["扫一扫", "创建群聊", "电子工卡"]

5.   // popup构造器定义弹框内容
6.   @Builder
7.   popupItemBuilder(name: string, action: string) {
8.     PopupItemChild({ childName: name, childAction: action })
9.   }

10.   // popup构造器定义弹框内容
11.   @Builder
12.   popupBuilder() {
13.     Column() {
14.       ForEach(
15.         this.menus,
16.         (item: string, index) => {
17.           this.popupItemBuilder(item, String(index))
18.         },
19.         (item: string, index) => {
20.           return item
21.         })
22.     }
23.     .padding(8)
24.   }

25.   @State customPopup: boolean = false;

26.   build() {
27.     Column() {
28.       Button('click me')
29.         .onClick(() => {
30.           this.customPopup = !this.customPopup
31.         })
32.         .bindPopup(
33.           this.customPopup,
34.           {
35.             builder: this.popupBuilder, // 气泡的内容
36.             placement: Placement.Bottom, // 气泡的弹出位置
37.             popupColor: Color.White, // 气泡的背景色
38.             onStateChange: (event) => {
39.               if (!event.isVisible) {
40.                 this.customPopup = false
41.               }
42.             }
43.           })
44.     }
45.     .width('100%')
46.     .justifyContent(FlexAlign.Center)
47.   }
48. }

49. @Component
50. struct PopupItemChild {
51.   @Prop childName: string = '';
52.   @Prop childAction: string = '';

53.   build() {
54.     Row({ space: 8 }) {
55.       // $r('app.media.startIcon')需要替换为开发者所需的图像资源文件。
56.       Image($r('app.media.startIcon'))
57.         .width(24)
58.         .height(24)
59.       Text(this.childName)
60.         .fontSize(16)
61.     }
62.     .width(130)
63.     .height(50)
64.     .padding(8)
65.     .onClick(() => {
66.       this.getUIContext().getPromptAction().showToast({ message: '选中了' + this.childName })
67.     })
68.     .stateStyles({
69.       normal: {
70.         .backgroundColor(Color.White)
71.       },
72.       pressed: {
73.         .backgroundColor('#1fbb7d')
74.       }
75.     })
76.   }
77. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164025.06014605136354694631824841118086:50001231000000:2800:739B2DD6BF71D4FDD07BEFEBAD90A918845E233A62F6D1489AD48957A2DF7502.gif)

## 气泡支持避让中轴

从API version 18起，气泡支持中轴避让功能。从API version 20开始，在2in1设备上默认启用（仅在窗口处于瀑布模式时产生避让）。开发者可通过[PopupOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-popup#popupoptions%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E)中的enableHoverMode属性，控制气泡是否启用中轴避让。

说明

- 如果气泡的点击位置在中轴区域，则气泡不会避让。
- 2in1设备上需同时满足窗口处于瀑布模式才会产生避让。

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = 'Hello World';
5.   @State index: number = 0;
6.   @State arrayStr: Array<string> = ['上半屏', '中轴', '下半屏'];
7.   @State enableHoverMode: boolean | undefined = true;
8.   @State showInSubwindow: boolean = false;
9.   @State placement: Placement | undefined = undefined;
10.   @State isShow: boolean = false;

11.   build() {
12.     RelativeContainer() {
13.       Column() {
14.         Button('区域:' + this.arrayStr[this.index])
15.           .onClick(() => {
16.             if (this.index < 2) {
17.               this.index++
18.             } else {
19.               this.index = 0
20.             }
21.           })

22.         Button('子窗显示:' + (this.showInSubwindow ? '子窗' : '非子窗'))
23.           .onClick(() => {
24.             this.showInSubwindow = !this.showInSubwindow
25.           })

26.         Button('hoverMode开启:' + this.enableHoverMode)
27.           .onClick(() => {
28.             if (this.enableHoverMode == undefined) {
29.               this.enableHoverMode = true
30.             } else if (this.enableHoverMode == true) {
31.               this.enableHoverMode = false
32.             } else {
33.               this.enableHoverMode = undefined
34.             }
35.           })
36.       }

37.       Row() {
38.         Button('Popup')
39.           .fontWeight(FontWeight.Bold)
40.           .bindPopup(this.isShow, {
41.             message: 'popup',
42.             enableHoverMode: this.enableHoverMode,
43.             showInSubWindow: this.showInSubwindow,
44.           })
45.           .onClick(() => {
46.             this.isShow = !this.isShow
47.           })
48.       }
49.       .alignRules({
50.         center: { anchor: '__container__', align: VerticalAlign.Center },
51.         middle: { anchor: '__container__', align: HorizontalAlign.Center }
52.       })
53.       .margin({
54.         top: this.index == 2 ? 330 : this.index == 1 ? 50 : 0,
55.         bottom: this.index == 0 ? 330 : 0
56.       })
57.     }
58.     .height('100%')
59.     .width('100%')
60.   }
61. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-overview "气泡提示概述")
# 不依赖UI组件的全局气泡提示 (openPopup)

更新时间: 2025-12-16 16:40

[气泡提示（Popup）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-popup)在使用时依赖绑定UI组件，否则无法使用。从API version 18开始，可以通过使用全局接口[openPopup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#openpopup18)的方式，在无UI组件的场景下直接或封装使用，例如在事件回调中使用或封装后对外提供能力。

## 弹出气泡

通过[openPopup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#openpopup18)可以弹出气泡。

1. promptAction.openPopup(contentNode, { id: targetId }, {
2.   enableArrow: true
3. })
4.   .then(() => {
5.     console.info('openPopup success');
6.   })
7.   .catch((err: BusinessError) => {
8.     console.error('openPopup error: ' + err.code + ' ' + err.message);
9.   })

### 创建ComponentContent

通过调用openPopup接口弹出其气泡，需要提供用于定义自定义弹出框的内容[ComponentContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-componentcontent)。其中，wrapBuilder(buildText)封装自定义组件，new Params(this.message)是自定义组件的入参，可以缺省，也可以传入基础数据类型。

1. private contentNode: ComponentContent<Object> = new ComponentContent(uiContext, wrapBuilder(buildText), this.message);

如果在wrapBuilder中包含其他组件（例如：[Popup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-popup)、[Chip](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-arkui-advanced-chip)组件），则[ComponentContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-componentcontent#componentcontent-1)应采用带有四个参数的构造函数constructor，其中options参数应传递{ nestingBuilderSupported: true }。

1. @Builder
2. export function buildText(params: Params) {
3.   Popup({
4.     // 类型设置图标内容
5.     icon: {
6.       image: $r('app.media.app_icon'),
7.       width: 32,
8.       height: 32,
9.       fillColor: Color.White,
10.       borderRadius: 10
11.     } as PopupIconOptions,
12.     // 设置文字内容
13.     title: {
14.       text: `This is a Popup title 1`,
15.       fontSize: 20,
16.       fontColor: Color.Black,
17.       fontWeight: FontWeight.Normal
18.     } as PopupTextOptions,
19.     // 设置文字内容
20.     message: {
21.       text: `This is a Popup message 1`,
22.       fontSize: 15,
23.       fontColor: Color.Black
24.     } as PopupTextOptions,
25.     // 设置按钮内容
26.     buttons: [{
27.       text: 'confirm',
28.       action: () => {
29.         console.info('confirm button click');
30.       },
31.       fontSize: 15,
32.       fontColor: Color.Black,
33.     },
34.       {
35.         text: 'cancel',
36.         action: () => {
37.           console.info('cancel button click');
38.         },
39.         fontSize: 15,
40.         fontColor: Color.Black
41.       },] as [PopupButtonOptions?, PopupButtonOptions?]
42.   })
43. }

44. private contentNode: ComponentContent<Object> = new ComponentContent(this.uiContext, wrapBuilder(buildText), this.message, { nestingBuilderSupported: true });

### 绑定组件信息

通过调用openPopup接口弹出气泡，需要提供绑定组件的信息[TargetInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-i#targetinfo18)。若未传入有效的target，则无法弹出气泡。

1. let frameNode: FrameNode | null = this.ctx.getFrameNodeByUniqueId(this.getUniqueId());
2. let targetId = frameNode?.getChild(0)?.getUniqueId();

### 设置弹出气泡样式

通过调用openPopup接口弹出气泡，可以设置[PopupCommonOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-popup#popupcommonoptions18%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E)属性调整气泡样式。

1. private options: PopupCommonOptions = { enableArrow: true };

## 更新气泡样式

从API version 18开始，通过[updatePopup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatepopup18)可以更新气泡的样式。支持全量更新和增量更新其气泡样式，不支持更新showInSubWindow、focusable、onStateChange、onWillDismiss和transition。

1. promptAction.updatePopup(contentNode, {
2.   enableArrow: false
3. }, true)
4.   .then(() => {
5.     console.info('updatePopup success');
6.   })
7.   .catch((err: BusinessError) => {
8.     console.error('updatePopup error: ' + err.code + ' ' + err.message);
9.   })

## 关闭气泡

从API version 18开始，通过调用[closePopup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#closepopup18)可以关闭气泡。

1. promptAction.closePopup(contentNode)
2.   .then(() => {
3.     console.info('closePopup success');
4.   })
5.   .catch((err: BusinessError) => {
6.     console.error('closePopup error: ' + err.code + ' ' + err.message);
7.   })

说明

由于[updatePopup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#updatepopup18)和[closePopup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-promptaction#closepopup18)依赖content来更新或者关闭指定的气泡，开发者需自行维护传入的content。

## 在HAR包中使用全局气泡提示

以下示例通过[HAR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package)包封装一个Popup，从而对外提供气泡的弹出、更新和关闭能力。

1. // library/src/main/ets/components/MainPage.ets

2. import { BusinessError } from '@kit.BasicServicesKit';
3. import { ComponentContent, TargetInfo, PromptAction } from '@kit.ArkUI';

4. export class PromptActionClass {
5.   private promptAction: PromptAction | null = null;
6.   private contentNode: ComponentContent<Object> | null = null;
7.   private options: PopupCommonOptions | null = null;
8.   private target: TargetInfo | null = null;
9.   private isPartialUpdate: boolean = false;

10.   public setPromptAction(promptAction: PromptAction) {
11.     this.promptAction = promptAction;
12.   }

13.   public setContentNode(node: ComponentContent<Object>) {
14.     this.contentNode = node;
15.   }

16.   public setTarget(target: TargetInfo) {
17.     this.target = target;
18.   }

19.   public setOptions(options: PopupCommonOptions) {
20.     this.options = options;
21.   }

22.   public setIsPartialUpdate(isPartialUpdate: boolean) {
23.     this.isPartialUpdate = isPartialUpdate;
24.   }

25.   public openPopup() {
26.     if (this.promptAction != null) {
27.       this.promptAction.openPopup(this.contentNode, this.target, this.options)
28.         .then(() => {
29.           console.info('openPopup success');
30.         })
31.         .catch((err: BusinessError) => {
32.           console.error('openPopup error: ' + err.code + ' ' + err.message);
33.         })
34.     }
35.   }

36.   public closePopup() {
37.     if (this.promptAction != null) {
38.       this.promptAction.closePopup(this.contentNode)
39.         .then(() => {
40.           console.info('closePopup success');
41.         })
42.         .catch((err: BusinessError) => {
43.           console.error('closePopup error: ' + err.code + ' ' + err.message);
44.         })
45.     }
46.   }

47.   public updatePopup(options: PopupCommonOptions) {
48.     if (this.promptAction != null) {
49.       this.promptAction.updatePopup(this.contentNode, options, this.isPartialUpdate)
50.         .then(() => {
51.           console.info('updatePopup success');
52.         })
53.         .catch((err: BusinessError) => {
54.           console.error('updatePopup error: ' + err.code + ' ' + err.message);
55.         })
56.     }
57.   }
58. }

59. // entry/src/main/ets/pages/Index.ets

60. import { PromptActionClass } from "library";
61. import { ComponentContent, PromptAction } from '@kit.ArkUI';

62. class Params {
63.   text: string = "";
64.   promptActionClass: PromptActionClass = new PromptActionClass();

65.   constructor(text: string, promptActionClass: PromptActionClass) {
66.     this.text = text;
67.     this.promptActionClass = promptActionClass;
68.   }
69. }

70. @Builder
71. function buildText(params: Params) {
72.   Column() {
73.     Text(params.text)
74.       .fontSize(20)
75.       .margin({ top: 10 })
76.     Button('Update')
77.       .margin({ top: 10 })
78.       .width(100)
79.       .onClick(() => {
80.         params.promptActionClass.updatePopup({
81.           enableArrow: false,
82.         });
83.       })
84.     Button('Close')
85.       .margin({ top: 10 })
86.       .width(100)
87.       .onClick(() => {
88.         params.promptActionClass.closePopup();
89.       })
90.   }.width(130).height(150)
91. }

92. @Entry
93. @Component
94. struct Index {
95.   @State message: string = "hello";
96.   private uiContext: UIContext = this.getUIContext();
97.   private promptAction: PromptAction = this.uiContext.getPromptAction();
98.   private promptActionClass: PromptActionClass = new PromptActionClass();
99.   private targetId: number = 0;
100.   private contentNode: ComponentContent<Object> =
101.     new ComponentContent(this.uiContext, wrapBuilder(buildText), new Params(this.message, this.promptActionClass));
102.   private options: PopupCommonOptions = { enableArrow: true };

103.   build() {
104.     Column() {
105.       Button("openPopup")
106.         .margin({ top: 50, left: 100 })
107.         .onClick(() => {
108.           let frameNode: FrameNode | null = this.uiContext.getFrameNodeByUniqueId(this.getUniqueId());
109.           let targetId = frameNode?.getChild(0)?.getUniqueId();
110.           if (targetId == undefined) {
111.             this.targetId = 0;
112.           } else {
113.             this.targetId = targetId;
114.           }
115.           this.promptActionClass.setPromptAction(this.promptAction);
116.           this.promptActionClass.setContentNode(this.contentNode);
117.           this.promptActionClass.setOptions(this.options);
118.           this.promptActionClass.setIsPartialUpdate(false);
119.           this.promptActionClass.setTarget({ id: this.targetId });
120.           this.promptActionClass.openPopup();
121.         })
122.     }
123.   }
124. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164037.58428898993401511873864726290675:50001231000000:2800:9EEFAB4969E6561ECB72410B7C8025C4531E8C5B1A11FFB0D2255731395BA4C7.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-and-menu-components-popup "气泡提示（Popup）")
# 绑定模态页面概述

更新时间: 2025-12-16 16:40

模态页面是一种大面板交互式的弹窗，和其他弹窗组件一样，通常用于在保持当前的上下文环境时，临时展示用户需关注的信息或待处理的操作。相比于其他弹窗组件，模态页面的内容都需要开发者通过自定义组件来填充实现，可展示的视图往往也很大。默认需要用户进行交互才能够退出模态页面。ArkUI当前提供了**半模态**和**全模态**两类模态页面组件。

- **​半模态：​**开发者可以利用此模态页面实现多形态效果。支持不同宽度设备显示不同样式的半模态页面。允许用户通过侧滑，点击蒙层，点击关闭按钮，下拉关闭半模态页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164012.32915115892006093811358193560944:50001231000000:2800:96F8883850238664E307782737AE28B4B84DF581AA773B5D44988285078F10E2.gif)
    
- **全模态：​**开发者可以利用此模态页面实现全屏的模态弹窗效果。默认需要侧滑才能关闭。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164012.52730209391482566577678367948786:50001231000000:2800:7A1F106A0ABC00D6512FC77C0D15CD6241867B752F5161BDFD3008A3643CE97B.gif)
    

## 使用场景

|接口|使用场景|
|:--|:--|
|[bindContentCover](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-contentcover-page)|用于自定义全屏的模态展示界面，结合转场动画和共享元素动画可实现复杂转场动画效果，如缩略图片点击后查看大图。|
|[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sheet-page)|用于半模态展示界面，如分享框。|
|[openBindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#openbindsheet12)/ [updateBindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#updatebindsheet12)/ [closeBindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#closebindsheet12)|用于不依赖UI组件的场景，如全局拉起、更新、关闭。|

## 规格约束

- 建议使用UIContext中的弹窗方法。其他规格约束可参考[openBindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#openbindsheet12)、[updateBindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#updatebindsheet12)、[closeBindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#closebindsheet12)说明。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-bind-modal "绑定模态页面")
# 绑定全模态页面（bindContentCover）

更新时间: 2025-12-16 16:40

[全模态页面（bindContentCover）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-modal-transition#bindcontentcover)是全屏模态形式的弹窗交互页面，完全覆盖底层父视图。适用于查看大图，全屏查看文稿等场景。

## 使用约束

全模态页面本质上是弹窗类组件，其交互层级默认为应用内顶层。

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)导航转场时，新push的页面层级无法超出全模态，其效果仍然显示在模态页面之下。针对此类场景，建议将模态页面的内容迁移至转场页面中实现。例如，在上述情况下，可以使用NavDestination来替代拉起的模态页面，新push的页面层级低于全模态。

## 生命周期

全模态页面提供了生命周期函数，用于通知应用程序该弹窗的生命周期状态。生命周期的触发顺序依次为：onWillAppear -> onAppear -> onWillDisappear -> onDisappear。

|名称|类型|说明|
|:--|:--|:--|
|onWillAppear|() => void|全模态页面显示（动画开始前）回调函数。|
|onAppear|() => void|全模态页面显示（动画结束后）回调函数。|
|onWillDisappear|() => void|全模态页面回退（动画开始前）回调函数。|
|onDisappear|() => void|全模态页面回退（动画结束后）回调函数。|

## 使用bindContentCover构建全屏模态内容覆盖半模态

全模态与半模态之间存在弹窗式的层级交互。后拉起的模态页面能够覆盖先前的模态页面。若开发者期望实现全屏转场，以覆盖半模态，并在全屏页面侧滑退出后，半模态页面仍保持显示，使用bindSheet结合bindContentCover将满足这一场景诉求。

详见[模态转场](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-modal-transition#%E4%BD%BF%E7%94%A8bindcontentcover%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%8F%E6%A8%A1%E6%80%81%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C)章节，了解使用bindContentCover构建全屏模态转场效果。

1. import { curves } from '@kit.ArkUI';

2. interface PersonList {
3.   name: string,
4.   cardNum: string
5. }

6. @Entry
7. @Component
8. struct BindContentCoverDemo {
9.   private personList: Array<PersonList> = [
10.     { name: '王**', cardNum: '1234***********789' },
11.     { name: '宋*', cardNum: '2345***********789' },
12.     { name: '许**', cardNum: '3456***********789' },
13.     { name: '唐*', cardNum: '4567***********789' }
14.   ];
15.   // 半模态转场控制变量
16.   @State isSheetShow: boolean = false;
17.   // 全模态转场控制变量
18.   @State isPresent: boolean = false;

19.   @Builder
20.   MyContentCoverBuilder() {
21.     Column() {
22.       Row() {
23.         Text('选择乘车人')
24.           .fontSize(20)
25.           .fontColor(Color.White)
26.           .width('100%')
27.           .textAlign(TextAlign.Center)
28.           .padding({ top: 30, bottom: 15 })
29.       }
30.       .backgroundColor(0x007dfe)

31.       Row() {
32.         Text('+ 添加乘车人')
33.           .fontSize(16)
34.           .fontColor(0x333333)
35.           .margin({ top: 10 })
36.           .padding({ top: 20, bottom: 20 })
37.           .width('92%')
38.           .borderRadius(10)
39.           .textAlign(TextAlign.Center)
40.           .backgroundColor(Color.White)
41.       }

42.       Column() {
43.         ForEach(this.personList, (item: PersonList, index: number) => {
44.           Row() {
45.             Column() {
46.               if (index % 2 == 0) {
47.                 Column()
48.                   .width(20)
49.                   .height(20)
50.                   .border({ width: 1, color: 0x007dfe })
51.                   .backgroundColor(0x007dfe)
52.               } else {
53.                 Column()
54.                   .width(20)
55.                   .height(20)
56.                   .border({ width: 1, color: 0x007dfe })
57.               }
58.             }
59.             .width('20%')

60.             Column() {
61.               Text(item.name)
62.                 .fontColor(0x333333)
63.                 .fontSize(18)
64.               Text(item.cardNum)
65.                 .fontColor(0x666666)
66.                 .fontSize(14)
67.             }
68.             .width('60%')
69.             .alignItems(HorizontalAlign.Start)

70.             Column() {
71.               Text('编辑')
72.                 .fontColor(0x007dfe)
73.                 .fontSize(16)
74.             }
75.             .width('20%')
76.           }
77.           .padding({ top: 10, bottom: 10 })
78.           .border({ width: { bottom: 1 }, color: 0xf1f1f1 })
79.           .width('92%')
80.           .backgroundColor(Color.White)
81.         })
82.       }
83.       .padding({ top: 20, bottom: 20 })

84.       Text('确认')
85.         .width('90%')
86.         .height(40)
87.         .textAlign(TextAlign.Center)
88.         .borderRadius(10)
89.         .fontColor(Color.White)
90.         .backgroundColor(0x007dfe)
91.         .onClick(() => {
92.           this.isPresent = !this.isPresent;
93.         })
94.     }
95.     .size({ width: '100%', height: '100%' })
96.     .backgroundColor(0xf5f5f5)
97.   }

98.   @Builder
99.   TripInfo() {
100.     Row() {
101.       Column() {
102.         Text('00:25')
103.         Text('始发站')
104.       }
105.       .width('25%')

106.       Column() {
107.         Text('G1234')
108.         Text('8时1分')
109.       }
110.       .width('25%')

111.       Column() {
112.         Text('08:26')
113.         Text('终点站')
114.       }
115.       .width('25%')
116.     }
117.   }

118.   // 第二步：定义半模态展示界面
119.   // 通过@Builder构建模态展示界面
120.   @Builder
121.   MySheetBuilder() {
122.     Column() {
123.       Column() {
124.         this.TripInfo()
125.       }
126.       .width('92%')
127.       .margin(15)
128.       .backgroundColor(Color.White)
129.       .shadow({ radius: 30, color: '#aaaaaa' })
130.       .borderRadius(10)

131.       Column() {
132.         Text('+ 选择乘车人')
133.           .fontSize(18)
134.           .fontColor(Color.Orange)
135.           .fontWeight(FontWeight.Bold)
136.           .padding({ top: 10, bottom: 10 })
137.           .width('60%')
138.           .textAlign(TextAlign.Center)
139.           .borderRadius(15)
140.           .onClick(() => {
141.             // 第三步：通过全模态接口调起全模态展示界面，新拉起的模态面板默认显示在最上层
142.             this.isPresent = !this.isPresent;
143.           })
144.             // 通过全模态接口，绑定模态展示界面MyContentCoverBuilder。transition属性支持自定义转场效果，此处定义了x轴横向入场
145.           .bindContentCover($$this.isPresent, this.MyContentCoverBuilder(), {
146.             transition: TransitionEffect.translate({ x: 500 }).animation({ curve: curves.springMotion(0.6, 0.8) })
147.           })
148.       }
149.       .padding({ top: 60 })
150.     }
151.   }

152.   build() {
153.     Column() {
154.       Row() {
155.         this.TripInfo()
156.         Text('有票')
157.           .fontColor(Color.Blue)
158.           .width('25%')
159.       }
160.       .width('100%')
161.       .margin({top: 200, bottom: 30})
162.       .borderRadius(10)
163.       .backgroundColor(Color.White)
164.       .onClick(()=>{
165.         this.isSheetShow = !this.isSheetShow;
166.       })
167.       // 第一步：定义半模态转场效果
168.       .bindSheet($$this.isSheetShow, this.MySheetBuilder(), {
169.         height: SheetSize.MEDIUM,
170.         title: {title: "确认订单"},
171.       })
172.     }
173.     .width('100%')
174.     .height('100%')
175.     .backgroundColor('#30aaaaaa')
176.   }
177. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164037.87135284281470518948412161422232:50001231000000:2800:AC96A877ADC1656D61F96D25856DD55E905AE48A013C2512C4994B5D2B85B814.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sheet-page "绑定半模态页面（bindSheet）")
# 绑定全模态页面（bindContentCover）

更新时间: 2025-12-16 16:40

[全模态页面（bindContentCover）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-modal-transition#bindcontentcover)是全屏模态形式的弹窗交互页面，完全覆盖底层父视图。适用于查看大图，全屏查看文稿等场景。

## 使用约束

全模态页面本质上是弹窗类组件，其交互层级默认为应用内顶层。

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)导航转场时，新push的页面层级无法超出全模态，其效果仍然显示在模态页面之下。针对此类场景，建议将模态页面的内容迁移至转场页面中实现。例如，在上述情况下，可以使用NavDestination来替代拉起的模态页面，新push的页面层级低于全模态。

## 生命周期

全模态页面提供了生命周期函数，用于通知应用程序该弹窗的生命周期状态。生命周期的触发顺序依次为：onWillAppear -> onAppear -> onWillDisappear -> onDisappear。

|名称|类型|说明|
|:--|:--|:--|
|onWillAppear|() => void|全模态页面显示（动画开始前）回调函数。|
|onAppear|() => void|全模态页面显示（动画结束后）回调函数。|
|onWillDisappear|() => void|全模态页面回退（动画开始前）回调函数。|
|onDisappear|() => void|全模态页面回退（动画结束后）回调函数。|

## 使用bindContentCover构建全屏模态内容覆盖半模态

全模态与半模态之间存在弹窗式的层级交互。后拉起的模态页面能够覆盖先前的模态页面。若开发者期望实现全屏转场，以覆盖半模态，并在全屏页面侧滑退出后，半模态页面仍保持显示，使用bindSheet结合bindContentCover将满足这一场景诉求。

详见[模态转场](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-modal-transition#%E4%BD%BF%E7%94%A8bindcontentcover%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%8F%E6%A8%A1%E6%80%81%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C)章节，了解使用bindContentCover构建全屏模态转场效果。

1. import { curves } from '@kit.ArkUI';

2. interface PersonList {
3.   name: string,
4.   cardNum: string
5. }

6. @Entry
7. @Component
8. struct BindContentCoverDemo {
9.   private personList: Array<PersonList> = [
10.     { name: '王**', cardNum: '1234***********789' },
11.     { name: '宋*', cardNum: '2345***********789' },
12.     { name: '许**', cardNum: '3456***********789' },
13.     { name: '唐*', cardNum: '4567***********789' }
14.   ];
15.   // 半模态转场控制变量
16.   @State isSheetShow: boolean = false;
17.   // 全模态转场控制变量
18.   @State isPresent: boolean = false;

19.   @Builder
20.   MyContentCoverBuilder() {
21.     Column() {
22.       Row() {
23.         Text('选择乘车人')
24.           .fontSize(20)
25.           .fontColor(Color.White)
26.           .width('100%')
27.           .textAlign(TextAlign.Center)
28.           .padding({ top: 30, bottom: 15 })
29.       }
30.       .backgroundColor(0x007dfe)

31.       Row() {
32.         Text('+ 添加乘车人')
33.           .fontSize(16)
34.           .fontColor(0x333333)
35.           .margin({ top: 10 })
36.           .padding({ top: 20, bottom: 20 })
37.           .width('92%')
38.           .borderRadius(10)
39.           .textAlign(TextAlign.Center)
40.           .backgroundColor(Color.White)
41.       }

42.       Column() {
43.         ForEach(this.personList, (item: PersonList, index: number) => {
44.           Row() {
45.             Column() {
46.               if (index % 2 == 0) {
47.                 Column()
48.                   .width(20)
49.                   .height(20)
50.                   .border({ width: 1, color: 0x007dfe })
51.                   .backgroundColor(0x007dfe)
52.               } else {
53.                 Column()
54.                   .width(20)
55.                   .height(20)
56.                   .border({ width: 1, color: 0x007dfe })
57.               }
58.             }
59.             .width('20%')

60.             Column() {
61.               Text(item.name)
62.                 .fontColor(0x333333)
63.                 .fontSize(18)
64.               Text(item.cardNum)
65.                 .fontColor(0x666666)
66.                 .fontSize(14)
67.             }
68.             .width('60%')
69.             .alignItems(HorizontalAlign.Start)

70.             Column() {
71.               Text('编辑')
72.                 .fontColor(0x007dfe)
73.                 .fontSize(16)
74.             }
75.             .width('20%')
76.           }
77.           .padding({ top: 10, bottom: 10 })
78.           .border({ width: { bottom: 1 }, color: 0xf1f1f1 })
79.           .width('92%')
80.           .backgroundColor(Color.White)
81.         })
82.       }
83.       .padding({ top: 20, bottom: 20 })

84.       Text('确认')
85.         .width('90%')
86.         .height(40)
87.         .textAlign(TextAlign.Center)
88.         .borderRadius(10)
89.         .fontColor(Color.White)
90.         .backgroundColor(0x007dfe)
91.         .onClick(() => {
92.           this.isPresent = !this.isPresent;
93.         })
94.     }
95.     .size({ width: '100%', height: '100%' })
96.     .backgroundColor(0xf5f5f5)
97.   }

98.   @Builder
99.   TripInfo() {
100.     Row() {
101.       Column() {
102.         Text('00:25')
103.         Text('始发站')
104.       }
105.       .width('25%')

106.       Column() {
107.         Text('G1234')
108.         Text('8时1分')
109.       }
110.       .width('25%')

111.       Column() {
112.         Text('08:26')
113.         Text('终点站')
114.       }
115.       .width('25%')
116.     }
117.   }

118.   // 第二步：定义半模态展示界面
119.   // 通过@Builder构建模态展示界面
120.   @Builder
121.   MySheetBuilder() {
122.     Column() {
123.       Column() {
124.         this.TripInfo()
125.       }
126.       .width('92%')
127.       .margin(15)
128.       .backgroundColor(Color.White)
129.       .shadow({ radius: 30, color: '#aaaaaa' })
130.       .borderRadius(10)

131.       Column() {
132.         Text('+ 选择乘车人')
133.           .fontSize(18)
134.           .fontColor(Color.Orange)
135.           .fontWeight(FontWeight.Bold)
136.           .padding({ top: 10, bottom: 10 })
137.           .width('60%')
138.           .textAlign(TextAlign.Center)
139.           .borderRadius(15)
140.           .onClick(() => {
141.             // 第三步：通过全模态接口调起全模态展示界面，新拉起的模态面板默认显示在最上层
142.             this.isPresent = !this.isPresent;
143.           })
144.             // 通过全模态接口，绑定模态展示界面MyContentCoverBuilder。transition属性支持自定义转场效果，此处定义了x轴横向入场
145.           .bindContentCover($$this.isPresent, this.MyContentCoverBuilder(), {
146.             transition: TransitionEffect.translate({ x: 500 }).animation({ curve: curves.springMotion(0.6, 0.8) })
147.           })
148.       }
149.       .padding({ top: 60 })
150.     }
151.   }

152.   build() {
153.     Column() {
154.       Row() {
155.         this.TripInfo()
156.         Text('有票')
157.           .fontColor(Color.Blue)
158.           .width('25%')
159.       }
160.       .width('100%')
161.       .margin({top: 200, bottom: 30})
162.       .borderRadius(10)
163.       .backgroundColor(Color.White)
164.       .onClick(()=>{
165.         this.isSheetShow = !this.isSheetShow;
166.       })
167.       // 第一步：定义半模态转场效果
168.       .bindSheet($$this.isSheetShow, this.MySheetBuilder(), {
169.         height: SheetSize.MEDIUM,
170.         title: {title: "确认订单"},
171.       })
172.     }
173.     .width('100%')
174.     .height('100%')
175.     .backgroundColor('#30aaaaaa')
176.   }
177. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164037.87135284281470518948412161422232:50001231000000:2800:AC96A877ADC1656D61F96D25856DD55E905AE48A013C2512C4994B5D2B85B814.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sheet-page "绑定半模态页面（bindSheet）")
# 设置浮层（OverlayManager）

更新时间: 2025-12-16 16:40

浮层（OverlayManager）用于在页面（Page）之上展示自定义的UI内容，位于Dialog、Popup、Menu、BindSheet、BindContentCover和Toast等组件之下，展示范围为当前窗口的安全区内，适用于常驻悬浮等场景。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.07279624071139369509854668534904:50001231000000:2800:8D707EE7E728DA27705D92AB9329407198C38DE308B15723911DDD23B131B522.png)

可以通过使用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中的[getOverlayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getoverlaymanager12)方法获取当前UI上下文关联的[OverlayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager)对象，再通过该对象调用对应方法。

## 规格约束

- OverlayManager上节点的层级在Page页面层级之上，在Dialog、Popup、Menu、BindSheet、BindContentCover和Toast等组件之下。
- OverlayManager添加的节点显示和消失时没有默认动画。
- OverlayManager上节点安全区域内外的绘制方式与Page一致，键盘避让方式与Page一致。
- 推荐使用AppStorage存储与OverlayManager相关的属性，以避免页面切换时属性值变化导致业务错误。
- 当使用API version 19以下版本时，OverlayManager不支持侧滑（左滑/右滑）关闭，需在[onBackPress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#onbackpress)中添加OverlayManager关闭的逻辑。API 19及以上版本可通过配置[OverlayManagerOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-i#overlaymanageroptions15)中的enableBackPressedEvent属性设置OverlayManager是否响应侧滑手势。
- OverlayManager中的事件机制优先被WrappedBuilder装饰的组件接收。若需实现浮层底部接收事件，可通过设置hitTestBehavior为HitTestMode.Transparent将事件传递至底层。

## 设置浮层

在OverlayManager上[新增指定节点（addComponentContent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#addcomponentcontent12)、[删除指定节点（removeComponentContent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#removecomponentcontent12)、[显示所有节点（showAllComponentContents）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#showallcomponentcontents12)和[隐藏所有节点（hideAllComponentContents）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#hideallcomponentcontents12)。

1. import { ComponentContent, OverlayManager } from '@kit.ArkUI';

2. class Params {
3.   text: string = "";
4.   offset: Position;

5.   constructor(text: string, offset: Position) {
6.     this.text = text;
7.     this.offset = offset;
8.   }
9. }

10. @Builder
11. function builderText(params: Params) {
12.   Column() {
13.     Text(params.text)
14.       .fontSize(30)
15.       .fontWeight(FontWeight.Bold)
16.   }.offset(params.offset)
17. }

18. function initOverlayNode(uiContext: UIContext): OverlayManager {
19.   uiContext.setOverlayManagerOptions({
20.     enableBackPressedEvent: true
21.   });
22.   return uiContext.getOverlayManager();
23. }

24. @Entry
25. @Component
26. struct OverlayExample {
27.   @State message: string = 'ComponentContent';
28.   private uiContext: UIContext = this.getUIContext();
29.   private overlayNode: OverlayManager = this.uiContext.getOverlayManager();
30.   @StorageLink('contentArray') contentArray: ComponentContent<Params>[] = [];
31.   @StorageLink('componentContentIndex') componentContentIndex: number = 0;
32.   @StorageLink('arrayIndex') arrayIndex: number = 0;
33.   @StorageLink("componentOffset") componentOffset: Position = { x: 0, y: 30 };

34.   build() {
35.     Column({ space: 10 }) {
36.       Button("递增componentContentIndex: " + this.componentContentIndex).onClick(() => {
37.         ++this.componentContentIndex;
38.       })
39.       Button("递减componentContentIndex: " + this.componentContentIndex).onClick(() => {
40.         --this.componentContentIndex;
41.       })
42.       Button("增加ComponentContent" + this.contentArray.length).onClick(() => {
43.         let componentContent = new ComponentContent(
44.           this.uiContext, wrapBuilder<[Params]>(builderText),
45.           new Params(this.message + (this.contentArray.length), this.componentOffset)
46.         );
47.         this.contentArray.push(componentContent);
48.         this.overlayNode.addComponentContent(componentContent, this.componentContentIndex);
49.       })
50.       Button("递增arrayIndex: " + this.arrayIndex).onClick(() => {
51.         ++this.arrayIndex;
52.       })
53.       Button("递减arrayIndex: " + this.arrayIndex).onClick(() => {
54.         --this.arrayIndex;
55.       })
56.       Button("删除ComponentContent" + this.arrayIndex).onClick(() => {
57.         if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
58.           let componentContent = this.contentArray.splice(this.arrayIndex, 1);
59.           this.overlayNode.removeComponentContent(componentContent.pop());
60.         } else {
61.           console.info("arrayIndex有误");
62.         }
63.       })
64.       Button("显示ComponentContent" + this.arrayIndex).onClick(() => {
65.         if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
66.           let componentContent = this.contentArray[this.arrayIndex];
67.           this.overlayNode.showComponentContent(componentContent);
68.         } else {
69.           console.info("arrayIndex有误");
70.         }
71.       })
72.       Button("隐藏ComponentContent" + this.arrayIndex).onClick(() => {
73.         if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
74.           let componentContent = this.contentArray[this.arrayIndex];
75.           this.overlayNode.hideComponentContent(componentContent);
76.         } else {
77.           console.info("arrayIndex有误");
78.         }
79.       })
80.       Button("显示所有ComponentContent").onClick(() => {
81.         this.overlayNode.showAllComponentContents();
82.       })
83.       Button("隐藏所有ComponentContent").onClick(() => {
84.         this.overlayNode.hideAllComponentContents();
85.       })

86.       Button("跳转页面").onClick(() => {
87.         this.getUIContext().getRouter().pushUrl({
88.           url: 'pages/Second'
89.         })
90.       })
91.     }
92.     .width('100%')
93.     .height('100%')
94.   }
95. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.73537004238958734951257423879307:50001231000000:2800:EBF46998703E9C6BA86D2C639353BD3E216EBA927F0378CB5AFF629AD79BCDB7.gif)

显示一个始终在屏幕左侧的悬浮球，点击可以弹出alertDialog弹窗。

1. import { ComponentContent, OverlayManager } from '@kit.ArkUI';

2. class Params {
3.   context: UIContext;
4.   offset: Position;
5.   constructor(context: UIContext, offset: Position) {
6.     this.context = context;
7.     this.offset = offset;
8.   }
9. }
10. @Builder
11. function builderOverlay(params: Params) {
12.   Column() {
13.     Stack(){
14.     }.width(50).height(50).backgroundColor(Color.Yellow).position(params.offset).borderRadius(50)
15.     .onClick(() => {
16.       params.context.showAlertDialog(
17.         {
18.           title: 'title',
19.           message: 'Text',
20.           autoCancel: true,
21.           alignment: DialogAlignment.Center,
22.           gridCount: 3,
23.           confirm: {
24.             value: 'Button',
25.             action: () => {}
26.           },
27.           cancel: () => {}
28.         }
29.       )
30.     })
31.   }.focusable(false).width('100%').height('100%').hitTestBehavior(HitTestMode.Transparent)
32. }

33. @Entry
34. @Component
35. struct OverlayExample {
36.   private uiContext: UIContext = this.getUIContext();
37.   private overlayNode: OverlayManager = this.uiContext.getOverlayManager();
38.   private overlayContent:ComponentContent<Params>[] = [];
39.   controller: TextInputController = new TextInputController();

40.   aboutToAppear(): void {
41.     let uiContext = this.getUIContext();
42.     let componentContent = new ComponentContent(
43.       this.uiContext, wrapBuilder<[Params]>(builderOverlay),
44.       new Params(uiContext, {x:0, y: 100})
45.     );
46.     this.overlayNode.addComponentContent(componentContent, 0);
47.     this.overlayContent.push(componentContent);
48.   }

49.   aboutToDisappear(): void {
50.     let componentContent = this.overlayContent.pop();
51.     this.overlayNode.removeComponentContent(componentContent);
52.   }

53.   build() {
54.     Column() {

55.     }
56.     .width('100%')
57.     .height('100%')
58.   }
59. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.40100393529718495279484301010563:50001231000000:2800:1A3C63C491240AD1E6589F4FAD65661AB8F1BC2C131676B7DDBE573E8F0FFF93.gif)

从API version 18开始，可以通过调用UIContext中getOverlayManager方法获取OverlayManager对象，并利用该对象在指定层级上新增指定节点（[addComponentContentWithOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#addcomponentcontentwithorder18)），层次高的浮层会覆盖在层级低的浮层之上。

1. import { ComponentContent, LevelOrder, OverlayManager } from '@kit.ArkUI';

2. class Params {
3.   text: string = "";
4.   offset: Position;
5.   constructor(text: string, offset: Position) {
6.     this.text = text;
7.     this.offset = offset;
8.   }
9. }

10. @Builder
11. function builderTopText(params: Params) {
12.   Column() {
13.     Stack(){
14.       Text(params.text)
15.         .fontSize(30)
16.         .fontWeight(FontWeight.Bold)
17.     }.width(300).height(200).padding(5).backgroundColor('#F7F7F7').alignContent(Alignment.Top)
18.   }.offset(params.offset)
19. }

20. @Builder
21. function builderNormalText(params: Params) {
22.   Column() {
23.     Stack(){
24.       Text(params.text)
25.         .fontSize(30)
26.         .fontWeight(FontWeight.Bold)
27.     }.width(300).height(400).padding(5).backgroundColor('#D5D5D5').alignContent(Alignment.Top)
28.   }.offset(params.offset)
29. }

30. @Entry
31. @Component
32. struct Index {
33.   private ctx: UIContext = this.getUIContext();
34.   private overlayManager: OverlayManager = this.ctx.getOverlayManager();
35.   @StorageLink('contentArray') contentArray: ComponentContent<Params>[] = [];
36.   @StorageLink('componentContentIndex') componentContentIndex: number = 0;
37.   @StorageLink('arrayIndex') arrayIndex: number = 0;
38.   @StorageLink('componentOffset') componentOffset: Position = {x: 0, y: 80};

39.   build() {
40.     Row() {
41.       Column({ space: 5 }) {
42.         Button('点击打开置顶弹窗')
43.           .onClick(() => {
44.             let componentContent = new ComponentContent(
45.               this.ctx, wrapBuilder<[Params]>(builderTopText),
46.               new Params('我是置顶弹窗', this.componentOffset)
47.             );
48.             this.contentArray.push(componentContent);
49.             this.overlayManager.addComponentContentWithOrder(componentContent, LevelOrder.clamp(100000));
50.           })
51.         Button('点击打开普通弹窗')
52.           .onClick(() => {
53.             let componentContent = new ComponentContent(
54.               this.ctx, wrapBuilder<[Params]>(builderNormalText),
55.               new Params('我是普通弹窗', this.componentOffset)
56.             );
57.             this.contentArray.push(componentContent);
58.             this.overlayManager.addComponentContentWithOrder(componentContent, LevelOrder.clamp(0));
59.           })
60.         Button("点击移除弹窗").onClick(()=>{
61.           if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
62.             let componentContent = this.contentArray.splice(this.arrayIndex, 1);
63.             this.overlayManager.removeComponentContent(componentContent.pop());
64.           } else {
65.             console.info("arrayIndex有误");
66.           }
67.         })
68.       }.width('100%')
69.     }
70.   }
71. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.23912736393424627868738863582248:50001231000000:2800:B07A573E81B7C826183F0350AFD318BD1FF52BE4BD524BBDCE411D9E8FCF8F05.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-toast "即时反馈（Toast）")
# 设置浮层（OverlayManager）

更新时间: 2025-12-16 16:40

浮层（OverlayManager）用于在页面（Page）之上展示自定义的UI内容，位于Dialog、Popup、Menu、BindSheet、BindContentCover和Toast等组件之下，展示范围为当前窗口的安全区内，适用于常驻悬浮等场景。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.07279624071139369509854668534904:50001231000000:2800:8D707EE7E728DA27705D92AB9329407198C38DE308B15723911DDD23B131B522.png)

可以通过使用[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext)中的[getOverlayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#getoverlaymanager12)方法获取当前UI上下文关联的[OverlayManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager)对象，再通过该对象调用对应方法。

## 规格约束

- OverlayManager上节点的层级在Page页面层级之上，在Dialog、Popup、Menu、BindSheet、BindContentCover和Toast等组件之下。
- OverlayManager添加的节点显示和消失时没有默认动画。
- OverlayManager上节点安全区域内外的绘制方式与Page一致，键盘避让方式与Page一致。
- 推荐使用AppStorage存储与OverlayManager相关的属性，以避免页面切换时属性值变化导致业务错误。
- 当使用API version 19以下版本时，OverlayManager不支持侧滑（左滑/右滑）关闭，需在[onBackPress](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#onbackpress)中添加OverlayManager关闭的逻辑。API 19及以上版本可通过配置[OverlayManagerOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-i#overlaymanageroptions15)中的enableBackPressedEvent属性设置OverlayManager是否响应侧滑手势。
- OverlayManager中的事件机制优先被WrappedBuilder装饰的组件接收。若需实现浮层底部接收事件，可通过设置hitTestBehavior为HitTestMode.Transparent将事件传递至底层。

## 设置浮层

在OverlayManager上[新增指定节点（addComponentContent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#addcomponentcontent12)、[删除指定节点（removeComponentContent）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#removecomponentcontent12)、[显示所有节点（showAllComponentContents）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#showallcomponentcontents12)和[隐藏所有节点（hideAllComponentContents）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#hideallcomponentcontents12)。

1. import { ComponentContent, OverlayManager } from '@kit.ArkUI';

2. class Params {
3.   text: string = "";
4.   offset: Position;

5.   constructor(text: string, offset: Position) {
6.     this.text = text;
7.     this.offset = offset;
8.   }
9. }

10. @Builder
11. function builderText(params: Params) {
12.   Column() {
13.     Text(params.text)
14.       .fontSize(30)
15.       .fontWeight(FontWeight.Bold)
16.   }.offset(params.offset)
17. }

18. function initOverlayNode(uiContext: UIContext): OverlayManager {
19.   uiContext.setOverlayManagerOptions({
20.     enableBackPressedEvent: true
21.   });
22.   return uiContext.getOverlayManager();
23. }

24. @Entry
25. @Component
26. struct OverlayExample {
27.   @State message: string = 'ComponentContent';
28.   private uiContext: UIContext = this.getUIContext();
29.   private overlayNode: OverlayManager = this.uiContext.getOverlayManager();
30.   @StorageLink('contentArray') contentArray: ComponentContent<Params>[] = [];
31.   @StorageLink('componentContentIndex') componentContentIndex: number = 0;
32.   @StorageLink('arrayIndex') arrayIndex: number = 0;
33.   @StorageLink("componentOffset") componentOffset: Position = { x: 0, y: 30 };

34.   build() {
35.     Column({ space: 10 }) {
36.       Button("递增componentContentIndex: " + this.componentContentIndex).onClick(() => {
37.         ++this.componentContentIndex;
38.       })
39.       Button("递减componentContentIndex: " + this.componentContentIndex).onClick(() => {
40.         --this.componentContentIndex;
41.       })
42.       Button("增加ComponentContent" + this.contentArray.length).onClick(() => {
43.         let componentContent = new ComponentContent(
44.           this.uiContext, wrapBuilder<[Params]>(builderText),
45.           new Params(this.message + (this.contentArray.length), this.componentOffset)
46.         );
47.         this.contentArray.push(componentContent);
48.         this.overlayNode.addComponentContent(componentContent, this.componentContentIndex);
49.       })
50.       Button("递增arrayIndex: " + this.arrayIndex).onClick(() => {
51.         ++this.arrayIndex;
52.       })
53.       Button("递减arrayIndex: " + this.arrayIndex).onClick(() => {
54.         --this.arrayIndex;
55.       })
56.       Button("删除ComponentContent" + this.arrayIndex).onClick(() => {
57.         if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
58.           let componentContent = this.contentArray.splice(this.arrayIndex, 1);
59.           this.overlayNode.removeComponentContent(componentContent.pop());
60.         } else {
61.           console.info("arrayIndex有误");
62.         }
63.       })
64.       Button("显示ComponentContent" + this.arrayIndex).onClick(() => {
65.         if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
66.           let componentContent = this.contentArray[this.arrayIndex];
67.           this.overlayNode.showComponentContent(componentContent);
68.         } else {
69.           console.info("arrayIndex有误");
70.         }
71.       })
72.       Button("隐藏ComponentContent" + this.arrayIndex).onClick(() => {
73.         if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
74.           let componentContent = this.contentArray[this.arrayIndex];
75.           this.overlayNode.hideComponentContent(componentContent);
76.         } else {
77.           console.info("arrayIndex有误");
78.         }
79.       })
80.       Button("显示所有ComponentContent").onClick(() => {
81.         this.overlayNode.showAllComponentContents();
82.       })
83.       Button("隐藏所有ComponentContent").onClick(() => {
84.         this.overlayNode.hideAllComponentContents();
85.       })

86.       Button("跳转页面").onClick(() => {
87.         this.getUIContext().getRouter().pushUrl({
88.           url: 'pages/Second'
89.         })
90.       })
91.     }
92.     .width('100%')
93.     .height('100%')
94.   }
95. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.73537004238958734951257423879307:50001231000000:2800:EBF46998703E9C6BA86D2C639353BD3E216EBA927F0378CB5AFF629AD79BCDB7.gif)

显示一个始终在屏幕左侧的悬浮球，点击可以弹出alertDialog弹窗。

1. import { ComponentContent, OverlayManager } from '@kit.ArkUI';

2. class Params {
3.   context: UIContext;
4.   offset: Position;
5.   constructor(context: UIContext, offset: Position) {
6.     this.context = context;
7.     this.offset = offset;
8.   }
9. }
10. @Builder
11. function builderOverlay(params: Params) {
12.   Column() {
13.     Stack(){
14.     }.width(50).height(50).backgroundColor(Color.Yellow).position(params.offset).borderRadius(50)
15.     .onClick(() => {
16.       params.context.showAlertDialog(
17.         {
18.           title: 'title',
19.           message: 'Text',
20.           autoCancel: true,
21.           alignment: DialogAlignment.Center,
22.           gridCount: 3,
23.           confirm: {
24.             value: 'Button',
25.             action: () => {}
26.           },
27.           cancel: () => {}
28.         }
29.       )
30.     })
31.   }.focusable(false).width('100%').height('100%').hitTestBehavior(HitTestMode.Transparent)
32. }

33. @Entry
34. @Component
35. struct OverlayExample {
36.   private uiContext: UIContext = this.getUIContext();
37.   private overlayNode: OverlayManager = this.uiContext.getOverlayManager();
38.   private overlayContent:ComponentContent<Params>[] = [];
39.   controller: TextInputController = new TextInputController();

40.   aboutToAppear(): void {
41.     let uiContext = this.getUIContext();
42.     let componentContent = new ComponentContent(
43.       this.uiContext, wrapBuilder<[Params]>(builderOverlay),
44.       new Params(uiContext, {x:0, y: 100})
45.     );
46.     this.overlayNode.addComponentContent(componentContent, 0);
47.     this.overlayContent.push(componentContent);
48.   }

49.   aboutToDisappear(): void {
50.     let componentContent = this.overlayContent.pop();
51.     this.overlayNode.removeComponentContent(componentContent);
52.   }

53.   build() {
54.     Column() {

55.     }
56.     .width('100%')
57.     .height('100%')
58.   }
59. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.40100393529718495279484301010563:50001231000000:2800:1A3C63C491240AD1E6589F4FAD65661AB8F1BC2C131676B7DDBE573E8F0FFF93.gif)

从API version 18开始，可以通过调用UIContext中getOverlayManager方法获取OverlayManager对象，并利用该对象在指定层级上新增指定节点（[addComponentContentWithOrder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-overlaymanager#addcomponentcontentwithorder18)），层次高的浮层会覆盖在层级低的浮层之上。

1. import { ComponentContent, LevelOrder, OverlayManager } from '@kit.ArkUI';

2. class Params {
3.   text: string = "";
4.   offset: Position;
5.   constructor(text: string, offset: Position) {
6.     this.text = text;
7.     this.offset = offset;
8.   }
9. }

10. @Builder
11. function builderTopText(params: Params) {
12.   Column() {
13.     Stack(){
14.       Text(params.text)
15.         .fontSize(30)
16.         .fontWeight(FontWeight.Bold)
17.     }.width(300).height(200).padding(5).backgroundColor('#F7F7F7').alignContent(Alignment.Top)
18.   }.offset(params.offset)
19. }

20. @Builder
21. function builderNormalText(params: Params) {
22.   Column() {
23.     Stack(){
24.       Text(params.text)
25.         .fontSize(30)
26.         .fontWeight(FontWeight.Bold)
27.     }.width(300).height(400).padding(5).backgroundColor('#D5D5D5').alignContent(Alignment.Top)
28.   }.offset(params.offset)
29. }

30. @Entry
31. @Component
32. struct Index {
33.   private ctx: UIContext = this.getUIContext();
34.   private overlayManager: OverlayManager = this.ctx.getOverlayManager();
35.   @StorageLink('contentArray') contentArray: ComponentContent<Params>[] = [];
36.   @StorageLink('componentContentIndex') componentContentIndex: number = 0;
37.   @StorageLink('arrayIndex') arrayIndex: number = 0;
38.   @StorageLink('componentOffset') componentOffset: Position = {x: 0, y: 80};

39.   build() {
40.     Row() {
41.       Column({ space: 5 }) {
42.         Button('点击打开置顶弹窗')
43.           .onClick(() => {
44.             let componentContent = new ComponentContent(
45.               this.ctx, wrapBuilder<[Params]>(builderTopText),
46.               new Params('我是置顶弹窗', this.componentOffset)
47.             );
48.             this.contentArray.push(componentContent);
49.             this.overlayManager.addComponentContentWithOrder(componentContent, LevelOrder.clamp(100000));
50.           })
51.         Button('点击打开普通弹窗')
52.           .onClick(() => {
53.             let componentContent = new ComponentContent(
54.               this.ctx, wrapBuilder<[Params]>(builderNormalText),
55.               new Params('我是普通弹窗', this.componentOffset)
56.             );
57.             this.contentArray.push(componentContent);
58.             this.overlayManager.addComponentContentWithOrder(componentContent, LevelOrder.clamp(0));
59.           })
60.         Button("点击移除弹窗").onClick(()=>{
61.           if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
62.             let componentContent = this.contentArray.splice(this.arrayIndex, 1);
63.             this.overlayManager.removeComponentContent(componentContent.pop());
64.           } else {
65.             console.info("arrayIndex有误");
66.           }
67.         })
68.       }.width('100%')
69.     }
70.   }
71. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.23912736393424627868738863582248:50001231000000:2800:B07A573E81B7C826183F0350AFD318BD1FF52BE4BD524BBDCE411D9E8FCF8F05.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-toast "即时反馈（Toast）")
# 形状裁剪（clipShape）

更新时间: 2025-12-16 16:39

可利用[clipShape](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sharp-clipping#clipshape12)接口将组件裁剪为所需的形状。调用该接口后，可以保留该形状覆盖的组件部分，同时移除组件的其余部分。裁剪形状本身是不可见的。

说明

不同的形状支持的属性范围不同，路径是一种形状，除此之外还有椭圆、矩形等形状。

路径的形状不支持设置宽度和高度，具体形状支持的属性参考具体[形状](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-shape)的文档。

形状中的[fill](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-shape#fill)属性对clipShape接口不生效。

## 裁剪圆形

通过设置CircleShape，将图片裁剪为圆形。

1. // xxx.ets
2. import { CircleShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       // 用一个280px直径的圆对图片进行裁剪
9.       Image($r('app.media.background'))
10.         .clipShape(new CircleShape({ width: '280px', height: '280px' }))
11.         .width('500px').height('280px')

12.       // 用一个350px直径的圆对图片进行裁剪
13.       Image($r('app.media.background'))
14.         .clipShape(new CircleShape({ width: '350px', height: '350px' }))
15.         .width('500px').height('370px')
16.     }
17.     .width('100%')
18.     .margin({ top: 15 })
19.   }
20. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.03890277170452978146036547282191:50001231000000:2800:8FBD63A5997D6D81749CD01ED81C1104DC99D399243527D9E67FDD684A59EE15.png)

## 裁剪椭圆形

通过设置EllipseShape，将图片裁剪为椭圆形。

1. // xxx.ets
2. import { EllipseShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       Image($r('app.media.background'))
9.         .clipShape(new EllipseShape({ width: '280px', height: '200px' }))
10.         .width('500px').height('400px')

11.       Image($r('app.media.background'))
12.         .clipShape(new EllipseShape({ width: '380px', height: '280px' }))
13.         .width('500px').height('400px')
14.     }
15.     .width('100%')
16.     .margin({ top: 15 })
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.26645364561418244814994501752365:50001231000000:2800:0FDE46E3FEE6803BA771D5541180F103869212499CBF83315D1895A93E134519.png)

## 裁剪矩形

通过设置RectShape，将图片裁剪为矩形。

1. // xxx.ets
2. import { RectShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       Image($r('app.media.background'))
9.         .clipShape(new RectShape({ width: '200px', height: '200px' }))
10.         .width('500px').height('400px')

11.       Image($r('app.media.background'))
12.         .clipShape(new RectShape({ width: '380px', height: '280px' }))
13.         .width('500px').height('400px')
14.     }
15.     .width('100%')
16.     .margin({ top: 15 })
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.31668104931408886654024951362005:50001231000000:2800:2D758F18E57E19C1B5E3D084FE9B4ABA7C9CC9992EB3F9C95F9C4E472B94B753.png)

## 裁剪不规则形状

通过设置PathShape，将图片裁剪为不规则形状。

1. // xxx.ets
2. import { PathShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       Row() {
9.         Image($r('app.media.background'))
10.           .clipShape(new PathShape({ commands: 'M0 0 H400 V200 H0 Z' }))
11.           .width('500px').height('300px')
12.       }
13.       .clip(true)
14.       .borderRadius(20)
15.     }
16.     .width('100%')
17.     .margin({ top: 15 })
18.   }
19. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.36444403032658649971973016160159:50001231000000:2800:F56F045CDB4D63C4229575F0C42FF49C2CC212701814725170BA489C7DD09EAA.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-geometric-shape-drawing "绘制几何图形 (Shape)")
# 形状裁剪（clipShape）

更新时间: 2025-12-16 16:39

可利用[clipShape](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sharp-clipping#clipshape12)接口将组件裁剪为所需的形状。调用该接口后，可以保留该形状覆盖的组件部分，同时移除组件的其余部分。裁剪形状本身是不可见的。

说明

不同的形状支持的属性范围不同，路径是一种形状，除此之外还有椭圆、矩形等形状。

路径的形状不支持设置宽度和高度，具体形状支持的属性参考具体[形状](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-shape)的文档。

形状中的[fill](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-shape#fill)属性对clipShape接口不生效。

## 裁剪圆形

通过设置CircleShape，将图片裁剪为圆形。

1. // xxx.ets
2. import { CircleShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       // 用一个280px直径的圆对图片进行裁剪
9.       Image($r('app.media.background'))
10.         .clipShape(new CircleShape({ width: '280px', height: '280px' }))
11.         .width('500px').height('280px')

12.       // 用一个350px直径的圆对图片进行裁剪
13.       Image($r('app.media.background'))
14.         .clipShape(new CircleShape({ width: '350px', height: '350px' }))
15.         .width('500px').height('370px')
16.     }
17.     .width('100%')
18.     .margin({ top: 15 })
19.   }
20. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.03890277170452978146036547282191:50001231000000:2800:8FBD63A5997D6D81749CD01ED81C1104DC99D399243527D9E67FDD684A59EE15.png)

## 裁剪椭圆形

通过设置EllipseShape，将图片裁剪为椭圆形。

1. // xxx.ets
2. import { EllipseShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       Image($r('app.media.background'))
9.         .clipShape(new EllipseShape({ width: '280px', height: '200px' }))
10.         .width('500px').height('400px')

11.       Image($r('app.media.background'))
12.         .clipShape(new EllipseShape({ width: '380px', height: '280px' }))
13.         .width('500px').height('400px')
14.     }
15.     .width('100%')
16.     .margin({ top: 15 })
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.26645364561418244814994501752365:50001231000000:2800:0FDE46E3FEE6803BA771D5541180F103869212499CBF83315D1895A93E134519.png)

## 裁剪矩形

通过设置RectShape，将图片裁剪为矩形。

1. // xxx.ets
2. import { RectShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       Image($r('app.media.background'))
9.         .clipShape(new RectShape({ width: '200px', height: '200px' }))
10.         .width('500px').height('400px')

11.       Image($r('app.media.background'))
12.         .clipShape(new RectShape({ width: '380px', height: '280px' }))
13.         .width('500px').height('400px')
14.     }
15.     .width('100%')
16.     .margin({ top: 15 })
17.   }
18. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.31668104931408886654024951362005:50001231000000:2800:2D758F18E57E19C1B5E3D084FE9B4ABA7C9CC9992EB3F9C95F9C4E472B94B753.png)

## 裁剪不规则形状

通过设置PathShape，将图片裁剪为不规则形状。

1. // xxx.ets
2. import { PathShape } from '@kit.ArkUI';

3. @Entry
4. @Component
5. struct ClipShapeExample {
6.   build() {
7.     Column({ space: 15 }) {
8.       Row() {
9.         Image($r('app.media.background'))
10.           .clipShape(new PathShape({ commands: 'M0 0 H400 V200 H0 Z' }))
11.           .width('500px').height('300px')
12.       }
13.       .clip(true)
14.       .borderRadius(20)
15.     }
16.     .width('100%')
17.     .margin({ top: 15 })
18.   }
19. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163942.36444403032658649971973016160159:50001231000000:2800:F56F045CDB4D63C4229575F0C42FF49C2CC212701814725170BA489C7DD09EAA.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-geometric-shape-drawing "绘制几何图形 (Shape)")
