# Web组件嵌套滚动

更新时间: 2025-12-16 16:38

Web组件嵌套滚动的典型应用场景为，在页面中，多个独立区域需进行滚动，当用户滚动Web区域内容时，可联动其他滚动区域，实现上下左右全方位滑动页面的嵌套滚动体验。内嵌于可滚动容器（[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)、[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)、[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll)、[Swiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper)、[Tabs](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs)、[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)、[Refresh](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-refresh)、[bindSheet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sheet-transition#bindsheet)）中的Web组件，接收到滑动手势事件后，需要设置ArkUI的[NestedScrollMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#nestedscrollmode10)枚举属性，实现Web组件与ArkUI可滚动容器的嵌套滚动。

Web组件嵌套滚动可通过[方案1：使用nestedScroll属性实现嵌套滚动](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-nested-scrolling#%E4%BD%BF%E7%94%A8nestedscroll%E5%B1%9E%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%B5%8C%E5%A5%97%E6%BB%9A%E5%8A%A8)或[方案2：滚动偏移量由滚动父组件统一派发](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-nested-scrolling#%E6%BB%9A%E5%8A%A8%E5%81%8F%E7%A7%BB%E9%87%8F%E7%94%B1%E6%BB%9A%E5%8A%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%9F%E4%B8%80%E6%B4%BE%E5%8F%91)两个方案实现，方案的选择应取决于应用嵌套滚动的具体业务场景。如果只是简单的Web组件与其他父组件联动滚动建议通过方案1实现；如果应用需要自定义控制Web组件和其他滚动组件滚动，以及一些复杂场景建议使用方案2。

说明

如果Web组件用到了全量展开的场景（layoutMode为WebLayoutMode.FIT_CONTENT），需要显式指明渲染模式(RenderMode.SYNC_RENDER)，详见[layoutMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#layoutmode11)。

## 使用nestedScroll属性实现嵌套滚动

使用Web组件[nestedScroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#nestedscroll11)属性来设置上下左右四个方向，或者设置向前、向后两个方向的嵌套滚动模式，实现与父组件的滚动联动，同时也允许在过程中动态改变嵌套滚动的模式。

**完整代码**

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @ComponentV2
5. struct NestedScroll {
6.   private scrollerForScroll: Scroller = new Scroller()
7.   private listScroller: Scroller = new Scroller()
8.   controller: webview.WebviewController = new webview.WebviewController();
9.   @Local arr: Array<number> = []

10.   aboutToAppear(): void {
11.     for (let i = 0; i < 10; i++) {
12.       this.arr.push(i)
13.     }
14.   }

15.   build() {
16.     Scroll(this.scrollerForScroll) {
17.       Column() {
18.         Web({ src: $rawfile("index.html"), controller: this.controller })
19.           .nestedScroll({
20.             scrollUp: NestedScrollMode.PARENT_FIRST,//向上滚动父组件优先
21.             scrollDown: NestedScrollMode.SELF_FIRST,//向下滚动子组件优先
22.           }).height("100%")
23.         Repeat<number>(this.arr)
24.           .each((item: RepeatItem<number>) => {
25.             Text("Scroll Area")
26.               .width("100%")
27.               .height("40%")
28.               .backgroundColor(0X330000FF)
29.               .fontSize(16)
30.               .textAlign(TextAlign.Center)
31.           })
32.       }
33.     }
34.   }
35. }

加载的html文件。

1. <!-- index.html -->
2. <!DOCTYPE html>
3. <html>
4. <head>
5.     <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1.0">
6.     <style>
7.         .blue {
8.           background-color: lightblue;
9.         }
10.         .green {
11.           background-color: lightgreen;
12.         }
13.         .blue, .green {
14.          font-size:16px;
15.          height:200px;
16.          text-align: center;       /* 水平居中 */
17.          line-height: 200px;       /* 垂直居中（值等于容器高度） */
18.         }
19.     </style>
20. </head>
21. <body>
22. <div class="blue" >webArea</div>
23. <div class="green">webArea</div>
24. <div class="blue">webArea</div>
25. <div class="green">webArea</div>
26. <div class="blue">webArea</div>
27. <div class="green">webArea</div>
28. <div class="blue">webArea</div>
29. </body>
30. </html>

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.30306954501521552657679920908106:50001231000000:2800:22CF7F0F017E30BE2AB83AFF5D367271D1ED6CA31D5B8F1730B29FDE5B6CCE03.gif)

## 滚动偏移量由滚动父组件统一派发

**实现思路**

1. 手指向上滑动：
    
    (1) 如果Web页面没有滚动到底部，Scroll组件将滚动偏移量派发给Web，Scroll组件自身不滚动。
    
    (2) 如果Web页面滚动至底部，而Scroll组件尚未滚动至底部，则仅Scroll组件自身滚动，不向Web组件和List组件传递滚动位移。
    
    (3) 如果Scroll组件滚动到底部，则滚动偏移量派发给List组件，Scroll组件自身不滚动。
    
2. 手指向下滑动：
    
    (1) 如果List组件没有滚动到顶部，则Scroll组件将滚动偏移量派发给List组件，Scroll组件自身不滚动。
    
    (2) 当List组件滚动至顶部，而Scroll组件未到达顶部时，Scroll组件将自行滚动，滚动偏移量不会派发给List组件和Web组件。
    
    (3) 如果Scroll组件滚动到顶部，则滚动偏移量派发给Web，Scroll组件自身不滚动。
    

**关键实现**

1. 如何禁用Web组件滚动手势。
    
    (1) 首先调用Web组件滚动控制器方法，设置Web禁用触摸（[setScrollable](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#setscrollable12)）的滚动。
    
    1. this.webController.setScrollable(false, webview.ScrollType.EVENT);
    
    (2) 再使用[onGestureRecognizerJudgeBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin13)方法，禁止Web组件自带的滑动手势触发。
    
    2. .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, otherArray<GestureRecognizer>) => {
    3.   if (current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
    4.     return GestureJudgeResult.REJECT;
    5.   }
    6.   return GestureJudgeResult.CONTINUE;
    7. })
    
2. 如何禁止[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)组件的手势。
    
    1.   .enableScrollInteraction(false)
    
3. 如何检测List组件、Scroll组件是否滚动到边界。
    
    (1) 滚动到上边界：scroller.currentOffset().yOffset <= 0;
    
    (2) 滚动到下边界：scroller.isAtEnd() == true;
    
4. 如何检测Web组件是否滚动到边界。
    
    (1) 获取Web组件自身高度、内容高度和当前滚动偏移量来判定。
    
    (2) 判断Web组件是否滚动到顶部：webController.getPageOffset().y == 0;
    
    (3) 判断Web组件是否滚动到底部：webController.getPageOffset().y + this.webHeight >= webController.getPageHeight();
    
    (4) 获取Web组件自身高度：webController.[getPageHeight()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#getpageheight);
    
    (5) 获取Web组件窗口高度：webController?.[runJavaScriptExt](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#runjavascriptext10)('window. innerHeight');
    
    (6) 获取Web组件的滚动偏移量：webController.[getPageOffset()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#getpageoffset20);
    
5. 如何让Scroll组件不滚动。
    
    Scroll组件绑定[onScrollFrameBegin](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll#onscrollframebegin9)事件，将剩余滚动偏移量返回0，scroll组件就不滚动，也不会停止惯性滚动动画。
    
6. 滚动偏移量如何派发给List。
    
    1.   this.listScroller.scrollBy(0, offset)
    
7. 滚动偏移量如何派发给Web。
    
    1.   this.webController.scrollBy(0, offset)
    
8. 设置Web组件[bypassVsyncCondition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#bypassvsynccondition20)为WebBypassVsyncCondition.SCROLLBY_FROM_ZERO_OFFSET，加快Web组件首帧滚动绘制。
    
    1.   .bypassVsyncCondition(WebBypassVsyncCondition.SCROLLBY_FROM_ZERO_OFFSET)
    

**完整代码**

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @ComponentV2
5. struct Index {
6.   private scroller:Scroller = new Scroller()
7.   private listScroller:Scroller = new Scroller()
8.   private webController: webview.WebviewController = new webview.WebviewController()
9.   private isWebAtEnd:boolean = false
10.   private webHeight:number = 0
11.   @Local arr: Array<number> = []

12.   aboutToAppear(): void {
13.     for (let i = 0; i < 10; i++) {
14.       this.arr.push(i)
15.     }
16.   }

17.   getWebHeight() {
18.     try {
19.       this.webController?.runJavaScriptExt('window.innerHeight',
20.         (error, result) => {
21.           if (error || !result) {
22.             return;
23.           }
24.           if (result.getType() === webview.JsMessageType.NUMBER) {
25.             this.webHeight = result.getNumber()
26.           }
27.         })
28.     } catch (error) {
29.     }
30.   }

31.   checkScrollBottom() {
32.       this.isWebAtEnd = false;
33.       if (this.webController.getPageOffset().y + this.webHeight >= this.webController.getPageHeight()) {
34.         this.isWebAtEnd = true;
35.       }
36.   }

37.   build() {
38.     Scroll(this.scroller) {
39.       Column() {
40.         Web({
41.           src: $rawfile("index.html"),
42.           controller: this.webController,
43.         }).height("100%")
44.           .bypassVsyncCondition(WebBypassVsyncCondition.SCROLLBY_FROM_ZERO_OFFSET)
45.           .onPageEnd(() => {
46.             this.webController.setScrollable(false, webview.ScrollType.EVENT);
47.             this.getWebHeight();
48.           })
49.             // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
50.           .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>) => {
51.             if (current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
52.               return GestureJudgeResult.REJECT;
53.             }
54.             return GestureJudgeResult.CONTINUE;
55.           })
56.         List({ scroller: this.listScroller }) {
57.           Repeat<number>(this.arr)
58.             .each((item: RepeatItem<number>) => {
59.               ListItem() {
60.                 Text("Scroll Area")
61.                   .width("100%")
62.                   .height("40%")
63.                   .backgroundColor(0X330000FF)
64.                   .fontSize(16)
65.                   .textAlign(TextAlign.Center)
66.               }
67.             })
68.         }.height("100%")
69.         .maintainVisibleContentPosition(true)
70.         .enableScrollInteraction(false)
71.       }
72.     }
73.     .onScrollFrameBegin((offset: number, state: ScrollState)=>{
74.       this.checkScrollBottom();
75.       if (offset > 0) {
76.         if (!this.isWebAtEnd) {
77.           this.webController.scrollBy(0, offset)
78.           return {offsetRemain:0}
79.         } else if (this.scroller.isAtEnd()) {
80.           this.listScroller.scrollBy(0, offset)
81.           return {offsetRemain:0}
82.         }
83.       } else if (offset < 0) {
84.         if (this.listScroller.currentOffset().yOffset > 0) {
85.           this.listScroller.scrollBy(0, offset)
86.           return {offsetRemain:0}
87.         } else if (this.scroller.currentOffset().yOffset <= 0) {
88.           this.webController.scrollBy(0, offset)
89.           return {offsetRemain:0}
90.         }
91.       }
92.       return {offsetRemain:offset}
93.     })
94.   }
95. }

加载的html文件。

1. <!-- index.html -->
2. <!DOCTYPE html>
3. <html>
4. <head>
5.     <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1.0">
6.     <style>
7.         .blue {
8.           background-color: lightblue;
9.         }
10.         .green {
11.           background-color: lightgreen;
12.         }
13.         .blue, .green {
14.          font-size:16px;
15.          height:200px;
16.          text-align: center;       /* 水平居中 */
17.          line-height: 200px;       /* 垂直居中（值等于容器高度） */
18.         }
19.     </style>
20. </head>
21. <body>
22. <div class="blue" >webArea</div>
23. <div class="green">webArea</div>
24. <div class="blue">webArea</div>
25. <div class="green">webArea</div>
26. <div class="blue">webArea</div>
27. <div class="green">webArea</div>
28. <div class="blue">webArea</div>
29. </body>
30. </html>

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.33561163488343677995706375830943:50001231000000:2800:776BE430EFE52FFB1F2EA195DA35A92B9220B3612664BEB467E9B6F0A8920C8B.gif)

## 示例代码

- [Web组件嵌套滑动](https://gitcode.com/harmonyos_samples/web-scroller)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-manage-page-interaction "管理网页交互")
# Web页面显示内容滚动

更新时间: 2025-12-16 16:38

当Web页面的内容高度或宽度超过可视区域时，页面才能滚动。Web页面滚动有多种方式，包括使用外接设备、ArkTS侧接口调用和js侧接口调用。

## 使用外接设备控制Web页面滚动

可以使用以下方式，通过触屏、触摸板和鼠标滚动控制Web页面滚动。

- 通过触屏控制Web页面滚动：支持在触摸屏上单指上下左右滑动可以控制页面滚动。
- 通过触摸板控制Web页面滚动：支持在笔记本触摸板或者外接触摸板双指上下左右滑动，可以控制页面滚动。
- 通过鼠标滚轮控制Web页面滚动：支持用鼠标滚轮上下滑动来控制页面滚动

## 调用ArkTS侧接口控制Web页面滚动

- [scrollTo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#scrollto)：在指定时间内，将页面滚动到指定的绝对位置。
    
    返回页面顶部。
    
    1. this.controller.scrollTo(0, 0);
    
- [scrollBy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#scrollby)：在指定时间内将页面滚动指定的偏移量。
    
    可以作为Web组件嵌套滚动中，控制Web组件滚动的接口，详见[滚动偏移量由滚动父组件统一派发](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-nested-scrolling#%E6%BB%9A%E5%8A%A8%E5%81%8F%E7%A7%BB%E9%87%8F%E7%94%B1%E6%BB%9A%E5%8A%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%9F%E4%B8%80%E6%B4%BE%E5%8F%91)。
    
- [pageUp](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#pageup)：将Webview的内容向上滚动半个视框大小或者跳转到页面最顶部，通过top入参控制。
    
- [pageDown](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#pagedown)：将Webview的内容向下滚动半个视框大小或者跳转到页面最底部，通过bottom入参控制。
    

## 调用js侧接口控制Web页面滚动

- scrollBy：相对当前滚动位置滚动一定距离（正数向下/右，负数向上/左）。
    
    1. window.scrollBy(deltaX, deltaY);//deltaX是元素要在横轴上滚动的距离，deltaY是元素要在纵轴上滚动的距离。
    
    渐进式滚动（如“阅读更多”按钮）。
    
    2. document.getElementById("read-more").addEventListener("click", ()=>{
    3.   window.scrollBy(0, 300);
    4. })
    
- scrollTo：将页面滚动到绝对坐标位置。
    
    1. window.scrollTo(x, y);//X是你想要显示在左上角的元素沿水平轴的像素，Y是你想要显示在左上角的元素沿垂直轴的像素。
    
    (1) 返回页面顶部。
    
    2. window.scrollTo(0, 0);
    
    (2) 跳转到页面特定位置。
    
    3. window.scrollTo(0, 500); //滚动到某个固定像素位置（如：500px)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-nested-scrolling "Web组件嵌套滚动")
# Web组件对接软键盘

更新时间: 2025-12-16 16:38

开发者能够通过Web组件对接软键盘，来处理系统软键盘的显示与交互问题，同时实现软键盘的自定义功能。主要有以下场景：

- 拉起系统软键盘输入文字：点击网页输入框时，屏幕下方将弹出系统默认的软键盘。开发者可以通过软键盘输入文字，输入的内容会显示在输入框中。
- 自定义系统软键盘的回车键类型：设置不同的回车键类型，例如：确认、下一个和提交。
- 软键盘避让：在移动设备上，由于输入法通常显示在屏幕下方区域，应用可设置不同的Web页面软键盘避让模式，来避让软键盘。例如：平移、调整大小和不避让。
- 自定义软键盘输入：在移动设备上，可以使用自绘制输入法在Web页面输入，以此替代系统软键盘。

## Web页面输入框输入与软键盘交互的W3C标准支持

为支持Web页面与系统软键盘、自定义软键盘等的良好交互，ArkWeb遵循并实现了W3C规范中的以下输入控制属性：

- type属性
    
    type属性定义了input元素的类型，影响输入的验证、显示方式和键盘类型。常见的type值包括：
    
    |type值|描述|
    |:--|:--|
    |text|默认值。普通文本输入|
    |number|数字输入|
    |email|电子邮件地址输入|
    |password|密码输入|
    |tel|电话号码输入|
    |url|URL输入|
    |date|日期选择器|
    |time|时间选择器|
    |checkbox|复选框|
    |radio|单选按钮|
    |file|文件上传|
    |submit|提交按钮|
    |reset|重置按钮|
    |button|普通按钮|
    
- inputmode属性
    
    inputmode属性用于配置输入法类型，默认值：text。
    
    |inputmode|描述|
    |:--|:--|
    |decimal|只显示数字键盘，通常还有一个逗号键。|
    |email|文本键盘，键通常用于电子邮件地址，如[@]。|
    |none|不应出现键盘。|
    |numeric|只显示数字键盘。|
    |search|文本键盘，[enter]键通常显示为[go]。|
    |tel|只显示数字键盘，通常还有[+]、[*]和[#]键。|
    |text|默认文本键盘。|
    |url|文本键盘，键通常用于网址，如[.]和[/]，以及特殊的[.com]键，或者其他通常用于本地设置的域名结束符。|
    
- enterkeyhint属性
    
    enterkeyhint属性用于指定移动设备虚拟键盘上回车键的显示方式。
    
    |enterkeyhint值|描述|
    |:--|:--|
    |enter|显示默认的回车键|
    |done|表示输入完成|
    |go|表示跳转或执行|
    |next|进入下一个输入字段|
    |previous|返回上一个输入字段|
    |search|执行搜索|
    |send|发送信息|
    

说明

点击网页输入框时，屏幕下方将弹出系统默认的软键盘，用户可以进行文字输入。

type属性影响键盘显示、输入验证和元素外观。

inputmode优化移动设备键盘输入体验，不影响基本行为或验证。

## 软键盘自动弹出

为提升用户体验，可以在页面完成加载后，输入框自动获焦并弹出软键盘。通过调用[showTextInput()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inputmethod#showtextinput10)设置软键盘自动弹出功能。

1. <!-- index.html -->
2. <!DOCTYPE html>
3. <html>
4.   <head>
5.     <title>测试网页</title>
6.   </head>
7.   <body>
8.     <h1>DEMO</h1>
9.     <input type="text" id="input_a">
10.   </body>
11. </html>

12. //Index.ets
13. import { webview } from '@kit.ArkWeb';
14. import { inputMethod } from '@kit.IMEKit';

15. @Entry
16. @Component
17. struct WebComponent {
18.   controller: webview.WebviewController = new webview.WebviewController();
19.   build() {
20.     Column() {
21.       Web({ src: $rawfile("index.html"), controller: this.controller})
22.         .onPageEnd(() => {
23.           this.controller.runJavaScript(`document.getElementById('input_a').focus()`).then(() => {
24.             setTimeout(() => {
25.               inputMethod.getController().showTextInput();
26.             }, 10);
27.           });
28.         });
29.     }
30.   }
31. }

## 设置软键盘避让模式

在移动设备上，支持设置Web页面的软键盘避让模式。

1. 在应用代码中设置UIContext的软键盘避让模式[setKeyboardAvoidMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#setkeyboardavoidmode11)。ArkWeb组件支持Resize和Offset两种模式。

- Resize模式下，应用窗口高度可缩小避开软键盘，ArkWeb组件跟随ArkUI重新布局。
- Offset模式下（以及默认模式），应用窗口高度不变，ArkWeb组件根据自身的避让模式进行避让。

（1）设置UIContext的软键盘避让模式。

1. // EntryAbility.ets
2. import { KeyboardAvoidMode } from '@kit.ArkUI';
3. import { hilog } from '@kit.PerformanceAnalysisKit';

4. onWindowStageCreate(windowStage: window.WindowStage) {
5.   hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

6.   windowStage.loadContent('pages/Index', (err, data) => {
7.     let keyboardAvoidMode = windowStage.getMainWindowSync().getUIContext().getKeyboardAvoidMode();
8.     // 设置虚拟键盘抬起时压缩页面大小为减去键盘的高度
9.   windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE);
10.     if (err.code) {
11.       hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
12.       return;
13.     }
14.     hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
15.   });
16. }

（2）在Web组件中调起软键盘。

1. <!-- index.html -->
2. <!DOCTYPE html>
3. <html>
4.   <head>
5.     <title>测试网页</title>
6.   </head>
7.   <body>
8.     <h1>DEMO</h1>
9.     <input type="text" id="input_a">
10.   </body>
11. </html>

12. //Index.ets
13. import { webview } from '@kit.ArkWeb';

14. @Entry
15. @Component
16. struct KeyboardAvoidExample {
17.   controller: webview.WebviewController = new webview.WebviewController();
18.   build() {
19.     Column() {
20.       Row().height("50%").width("100%").backgroundColor(Color.Gray)
21.       Web({ src: $rawfile("index.html"),controller: this.controller})
22.       Text("I can see the bottom of the page").width("100%").textAlign(TextAlign.Center).backgroundColor(Color.Pink).layoutWeight(1)
23.     }.width('100%').height("100%")
24.   }
25. }

ArkWeb组件将跟随ArkUI重新布局，效果如图1和图2所示。

**图1** Web组件网页默认软键盘避让模式

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163839.51055063672727513641575057730881:50001231000000:2800:0B4E64ABBA5D08EE346413F0A1C1AFE13FB4BCE7A35158AB08FBC2FE4EFE37E6.png)

**图2** Web组件网页跟随Arkui软键盘避让模式

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163839.85925924570694714330101505874714:50001231000000:2800:D2464A20939099C74647718B0753971573DEAB0C7D32DA6098921A27D837D000.png)

2.在UIContext的键盘避让模式为Offset模式时，应用可通过[WebKeyboardAvoidMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-e#webkeyboardavoidmode12)设置ArkWeb组件的键盘避让模式。Web组件的[WebKeyboardAvoidMode()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-e#webkeyboardavoidmode12)接口优先级高于W3C侧virtualKeyboard.overlayContens。

- RESIZE_VISUAL：仅调整可视视口的大小，而不调整布局视口的大小。
- RESIZE_CONTENT：调整视觉视口和布局视口的大小。
- OVERLAYS_CONTENT：不调整任何视口的大小，获焦input元素没有滚动到可视区域的行为。

说明

可视视口指用户正在看到的网站的区域，该区域的宽度等于移动设备的浏览器窗口的宽度。

布局视口指网页本身的宽度。

在应用代码中设置ArkWeb的软键盘避让模式。

1. // Index.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct KeyboardAvoidExample {
6.   controller: webview.WebviewController = new webview.WebviewController();
7.   build() {
8.     Column() {
9.       Row().height("50%").width("100%").backgroundColor(Color.Gray)
10.       Web({ src: $rawfile("index.html"),controller: this.controller})
11.         .keyboardAvoidMode(WebKeyboardAvoidMode.OVERLAYS_CONTENT) //此时ArkWeb组件不会调整任何视口的大小。
12.       Text("I can see the bottom of the page").width("100%").textAlign(TextAlign.Center).backgroundColor(Color.Pink).layoutWeight(1)
13.     }.width('100%').height("100%")
14.   }
15. }

ArkWeb组件根据避让模式进行避让，效果见图3。

**图3** Web组件网页自身软键盘避让模式

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163839.25337426735543321535589599818651:50001231000000:2800:4CDD11810D7F31C9F1ECC2D170C01E20D6BEBDAB2B592F6A78CDD85E901385E3.png)

3.在软键盘弹出时，为使Web组件不发生避让行为，可通过调用[expandSafeArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea)设置Web组件扩展安全区域。更多详细示例可参考[网页中安全区域计算和避让适配](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-safe-area-insets)。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct WebComponent {
6.   controller: webview.WebviewController = new webview.WebviewController();

7.   build() {
8.     Column() {
9.       Web({ src: 'www.example.com', controller: this.controller })
10.         .width('100%').height('100%')
11.         .expandSafeArea([SafeAreaType.KEYBOARD, SafeAreaType.SYSTEM])
12.     }
13.   }
14. }

与其他Web组件行为的交互场景：

|交叉场景|规格|
|:--|:--|
|同层渲染|同层Web：软键盘避让方式与普通场景相同。<br><br>同层系统组件：由ArkUI负责软键盘避让模式。|
|离屏创建组件|默认使用与非离屏创建一致的软键盘避让模式，在添加至组件树前设置其他避让模式即可生效。|
|customDialog|customDialog自身避让。|
|折叠屏|软键盘避让行为与普通场景行为一致。屏幕软键盘将根据屏幕开合状态进行调整。|
|软键盘托管|软键盘避让行为与普通场景行为一致。|
|Web嵌套滚动|在嵌套滚动场景下，建议不要使用Web软键盘避让，包括RESIZE_VISUAL和RESIZE_CONTENT。|

## 拦截系统软键盘与自定义软键盘输入

应用可以通过监听[onInterceptKeyboardAttach](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-events#oninterceptkeyboardattach12)回调，在软键盘拉起前，控制软键盘的显示，包括系统默认软键盘、带有特定Enter键的软键盘，或完全自定义软键盘。借助这一功能，开发者能够实现对软键盘的灵活管理。

- 使用系统默认软键盘
- 使用带有定制Enter键的系统软键盘
- 使用完全由应用程序自定义的软键盘

1.   // Index.ets
2.   import { webview } from '@kit.ArkWeb';
3.   import { inputMethodEngine } from '@kit.IMEKit';

4.   @Entry
5.   @Component
6.   struct WebComponent {
7.     controller: webview.WebviewController = new webview.WebviewController();
8.     webKeyboardController: WebKeyboardController = new WebKeyboardController();
9.     inputAttributeMap: Map<string, number> = new Map([
10.         ['UNSPECIFIED', inputMethodEngine.ENTER_KEY_TYPE_UNSPECIFIED],
11.         ['GO', inputMethodEngine.ENTER_KEY_TYPE_GO],
12.         ['SEARCH', inputMethodEngine.ENTER_KEY_TYPE_SEARCH],
13.         ['SEND', inputMethodEngine.ENTER_KEY_TYPE_SEND],
14.         ['NEXT', inputMethodEngine.ENTER_KEY_TYPE_NEXT],
15.         ['DONE', inputMethodEngine.ENTER_KEY_TYPE_DONE],
16.         ['PREVIOUS', inputMethodEngine.ENTER_KEY_TYPE_PREVIOUS]
17.       ])

18.       /**
19.        * 自定义键盘组件Builder
20.        */
21.       @Builder
22.       customKeyboardBuilder() {
23.           // 这里实现自定义键盘组件，对接WebKeyboardController实现输入、删除、关闭等操作。
24.         Row() {
25.           Text("完成")
26.             .fontSize(20)
27.             .fontColor(Color.Blue)
28.             .onClick(() => {
29.               this.webKeyboardController.close();
30.             })
31.           // 插入字符。
32.           Button("insertText").onClick(() => {
33.             this.webKeyboardController.insertText('insert ');
34.           }).margin({
35.             bottom: 200,
36.           })
37.           // 从后往前删除length参数指定长度的字符。
38.           Button("deleteForward").onClick(() => {
39.             this.webKeyboardController.deleteForward(1);
40.           }).margin({
41.             bottom: 200,
42.           })
43.           // 从前往后删除length参数指定长度的字符。
44.           Button("deleteBackward").onClick(() => {
45.             this.webKeyboardController.deleteBackward(1);
46.           }).margin({
47.             left: -220,
48.           })
49.           // 插入功能按键。
50.           Button("sendFunctionKey").onClick(() => {
51.             this.webKeyboardController.sendFunctionKey(6);
52.           })
53.         }
54.       }

55.     build() {
56.       Column() {
57.         Web({ src: $rawfile('index.html'), controller: this.controller })
58.         .onInterceptKeyboardAttach((KeyboardCallbackInfo) => {
59.           // option初始化，默认使用系统默认键盘
60.           let option: WebKeyboardOptions = {
61.             useSystemKeyboard: true,
62.           };
63.           if (!KeyboardCallbackInfo) {
64.             return option;
65.           }

66.           // 保存WebKeyboardController，使用自定义键盘时候，需要使用该handler控制输入、删除、软键盘关闭等行为
67.           this.webKeyboardController = KeyboardCallbackInfo.controller;
68.           let attributes: Record<string, string> = KeyboardCallbackInfo.attributes;
69.           // 遍历attributes
70.           let attributeKeys = Object.keys(attributes);
71.           for (let i = 0; i < attributeKeys.length; i++) {
72.             console.info('WebCustomKeyboard key = ' + attributeKeys[i] + ', value = ' + attributes[attributeKeys[i]]);
73.           }

74.           if (attributes) {
75.             if (attributes['data-keyboard'] == 'customKeyboard') {
76.               // 根据html可编辑元素的属性，判断使用不同的软键盘，例如这里如果属性包含有data-keyboard，且值为customKeyboard，则使用自定义键盘
77.               console.info('WebCustomKeyboard use custom keyboard');
78.               option.useSystemKeyboard = false;
79.               // 设置自定义键盘builder
80.               option.customKeyboard = () => {
81.                 this.customKeyboardBuilder()
82.               }
83.               return option;
84.             }

85.             if (attributes['keyboard-return'] != undefined) {
86.               // 根据html可编辑元素的属性，判断使用不同的软键盘，例如这里如果属性包含有keyboard-return，使用系统键盘，并且指定系统软键盘enterKey类型
87.               option.useSystemKeyboard = true;
88.               let enterKeyType: number | undefined = this.inputAttributeMap.get(attributes['keyboard-return']);
89.               if (enterKeyType != undefined) {
90.                 option.enterKeyType = enterKeyType;
91.               }
92.               return option;
93.             }
94.           }

95.           return option;
96.         })
97.       }
98.     }
99.   }

100. <!-- index.html -->
101.     <!DOCTYPE html>
102.     <html>

103.     <head>
104.         <meta charset="utf-8">
105.         <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0">
106.     </head>

107.     <body>

108.     <p style="font-size:12px">input标签，原有默认行为：</p>
109.     <input type="text" style="width: 300px; height: 20px"><br>
110.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

111.     <p style="font-size:12px">input标签，系统键盘自定义enterKeyType属性 enter key UNSPECIFIED：</p>
112.     <input type="text" keyboard-return="UNSPECIFIED" style="width: 300px; height: 20px"><br>
113.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

114.     <p style="font-size:12px">input标签，系统键盘自定义enterKeyType属性 enter key GO：</p>
115.     <input type="text" keyboard-return="GO" style="width: 300px; height: 20px"><br>
116.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

117.     <p style="font-size:12px">input标签，系统键盘自定义enterKeyType属性 enter key SEARCH：</p>
118.     <input type="text" keyboard-return="SEARCH" style="width: 300px; height: 20px"><br>
119.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

120.     <p style="font-size:12px">input标签，系统键盘自定义enterKeyType属性 enter key SEND：</p>
121.     <input type="text" keyboard-return="SEND" style="width: 300px; height: 20px"><br>
122.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

123.     <p style="font-size:12px">input标签，系统键盘自定义enterKeyType属性 enter key NEXT：</p>
124.     <input type="text" keyboard-return="NEXT" style="width: 300px; height: 20px"><br>
125.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

126.     <p style="font-size:12px">input标签，系统键盘自定义enterKeyType属性 enter key DONE：</p>
127.     <input type="text" keyboard-return="DONE" style="width: 300px; height: 20px"><br>
128.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

129.     <p style="font-size:12px">input标签，系统键盘自定义enterKeyType属性 enter key PREVIOUS：</p>
130.     <input type="text" keyboard-return="PREVIOUS" style="width: 300px; height: 20px"><br>
131.     <hr style="height:2px;border-width:0;color:gray;background-color:gray">

132.     <p style="font-size:12px">input标签，应用自定义键盘：</p>
133.     <input type="text" data-keyboard="customKeyboard" style="width: 300px; height: 20px"><br>

134.     </body>

135.     </html>

ArkWeb自定义键盘的示例效果如图4、图5和图6所示。

**图4** ArkWeb自定义键盘数字键盘

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163839.88003839767006764208131875759687:50001231000000:2800:67AFFDE658CD227175DA4A91C227CD3518D69E130B567C9909D75788B6BE9CFF.png)

**图5** ArkWeb自定义键盘字母键盘

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163839.17773897538159135772737724238093:50001231000000:2800:D687D654C0468727540E11ED8644A2C72D1321680BFA787EA971E6C4B333387D.png)

**图6** ArkWeb自定义键盘符号键盘

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163839.38013318385536666263785628752284:50001231000000:2800:B92260F54F7970498F2CD0969DE2750EBCDB0EEB8063716F70EE5F4D413F1A27.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-content-scrolling "Web页面显示内容滚动")
# Web组件焦点管理

更新时间: 2025-12-16 16:38

开发者可利用Web组件的焦点管理功能，有效管理Web组件的聚焦与失焦，同时利用H5侧的W3C标准接口，管理网页界面上唯一可交互的元素聚焦与失焦。

- Web组件与ArkUI组件焦点控制的常用接口及其使用场景：
    
    1. 通过requestFocus主动请求Web组件获焦：当应用内有多个组件时，开发者可通过Web组件的[requestFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#requestfocus)接口，主动将焦点转移到Web组件。
    2. 根据焦点情况更改Web组件样式：组件监听焦点事件上报，为组件修改样式，例如边框、背景色等，以提供视觉和交互反馈。
- Web组件内H5元素焦点控制的常用接口及其使用场景：
    
    1. 通过tabindex属性管理元素焦点：定义Web组件内元素的焦点顺序。可以通过将元素的tabindex设置为"-1"，使其能够通过脚本进行聚焦，同时在CSS中对元素的可见性进行控制。
    2. 键盘事件更新焦点位置：监听键盘事件，例如Tab键，依据用户的操作更新Web内元素焦点位置。
    3. 根据焦点情况更改Web组件内元素样式：为焦点元素添加样式，例如边框、背景色等，以提供视觉和交互反馈。

## 基础概念

Web组件焦点、焦点链和走焦的详情说明请参考[ArkUI焦点基础概念](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)。

- 焦点：
    - 组件焦点：指当前应用界面上唯一的一个可交互元素。
    - 网页内元素焦点：指当前网页界面上唯一的一个可交互元素。
- 走焦：
    - 组件走焦：指焦点在应用内的组件之间转移的行为。这一过程对用户是透明的，开发者可以通过监听onFocus（焦点获取）和onBlur（焦点失去）事件来捕捉这些变化。
    - 网页内元素走焦：指焦点在网页内的元素之间转移的行为。该行为遵循W3C标准，开发者可以通过监听focus（在元素获取焦点时触发）和blur（在元素失去焦点时触发）事件来捕捉这些变化。

## Web组件走焦规范

根据走焦的触发方式，可以分为主动走焦和被动走焦，Web组件走焦规范详情参考[ArkUI走焦规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event#%E8%B5%B0%E7%84%A6%E8%A7%84%E8%8C%83)。

### 主动走焦

指开发者或用户主观行为导致的焦点移动。包括：使用requestFocus申请焦点、外接键盘的按键走焦（Tab键/Shift+Tab键）、点击申请焦点（手势/鼠标/触摸板）等导致的焦点转移。

- requestFocus
    
    详见[Web组件与ArkUI组件焦点控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-focus#web%E7%BB%84%E4%BB%B6%E4%B8%8Earkui%E7%BB%84%E4%BB%B6%E7%84%A6%E7%82%B9%E6%8E%A7%E5%88%B6)，可以主动将焦点转移到Web组件上。
    
- 按键走焦
    
    - 支持ArkWeb与其他组件通过Tab键、Shift+Tab键走焦。
    - 支持ArkWeb内部网页元素通过Tab键、Shift+Tab键走焦，网页元素走焦完成后，抛回ArkUI继续框架侧走焦。
- 点击申请获焦
    
    开发者或用户可通过手势、鼠标或触摸板点击Web组件，使其主动获得焦点。当具体点击到Web组件内的某个元素时，该元素能够获得焦点，例如：点击网页内的输入框，可使其从不可编辑状态转变为可编辑状态，并激活输入法。
    

### 被动走焦

被动走焦指焦点因系统或其他操作而转移，无需开发者直接干预，是焦点系统的默认行为。

被动走焦的场景有：

- 组件删除：当焦点所在的Web组件被移除时，系统会按照先向后再向前的原则，将焦点转移至相邻的同级组件。若所有同级组件均不可获焦，则焦点将被释放，并通知其父级组件进行焦点处理。
    
- 属性变更：若将处于焦点状态的组件的focusable或enabled属性设置为false，或者将visibility属性设置为不可见，系统将自动转移焦点至其他可获焦组件，转移方式同组件删除。
    
- Web组件不可见：ArkWeb获焦后，应用前后台切换、页面切换、Navigation导航等场景，ArkWeb会失焦再获焦。
    
- Web组件加载网页：ArkWeb通过src、loadUrl、loadData加载网页，默认会获取焦点，但若此时web组件为不可获焦状态则会获焦失败（常见的不可获焦状态原因有：过场动画过程中父组件不可获焦、应用侧设置了web组件或其父组件不可获焦属性等），应用侧可以调用主动申请获焦接口[requestFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#requestfocus)再次尝试使web组件获焦。当获焦成功后，应用侧onFocus、W3C focus事件均会上报。
    
- autofocus样式：设置了autofocus样式的元素网页完成加载时默认获焦。若该元素支持文本输入，则输入框会有光标闪烁，但不会弹出软键盘。如需自动弹出软键盘，可参考[软键盘自动弹出](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-docking-softkeyboard#%E8%BD%AF%E9%94%AE%E7%9B%98%E8%87%AA%E5%8A%A8%E5%BC%B9%E5%87%BA)。
    
- 菜单弹出：ArkUI的overlay属性类型组件默认抢焦，在与此类组件结合的ArkWeb场景中（[menu](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-menu)、[datepicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-datepicker)、[timepicker](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-timepicker)、下拉框、弹窗等），ArkWeb均会失焦。
    

## Web组件与ArkUI组件焦点控制

- 应用侧通用获焦回调接口[onFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-focus-event#onfocus)，获焦事件回调，绑定该接口的组件获焦时，回调响应。
- 应用侧通用失焦回调接口[onBlur](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-focus-event#onblur)，失焦事件回调，绑定该接口的组件失焦时，回调响应。
- 应用侧主动申请获焦接口[requestFocus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#requestfocus)，组件主动申请获焦。
- 设置组件是否可获焦：应用可以通过设置[focusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focusable)属性，控制Web组件是否能够获取焦点。Web组件默认可获焦。

**示例：**

1. requestFocus接口允许应用开发者主动控制让Web组件获焦。
2. onFocus和onBlur两个接口通常成对使用，来监听组件的焦点变化。

3. // xxx.ets
4. import { webview } from '@kit.ArkWeb';
5. import { BusinessError } from '@kit.BasicServicesKit';

6. @Entry
7. @Component
8. struct WebComponent {
9.   controller: webview.WebviewController = new webview.WebviewController();
10.   controller2: webview.WebviewController = new webview.WebviewController();
11.   @State webBorderColor: Color = Color.Red;
12.   @State webBorderColor2: Color = Color.Red;

13.   build() {
14.     Column() {
15.       Row() {
16.         Button('web1 requestFocus')
17.           .onClick(() => {
18.             try {
19.               this.controller.requestFocus();
20.             } catch (error) {
21.               console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
22.             }
23.           });
24.         Button('web2 requestFocus')
25.           .onClick(() => {
26.             try {
27.               this.controller2.requestFocus();
28.             } catch (error) {
29.               console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
30.             }
31.           });
32.       }
33.       Web({ src: 'www.example.com', controller: this.controller })
34.         .onFocus(() => {
35.           this.webBorderColor = Color.Green;
36.         })
37.         .onBlur(() => {
38.           this.webBorderColor = Color.Red;
39.         })
40.         .margin(3)
41.         .borderWidth(10)
42.         .borderColor(this.webBorderColor)
43.         .height("45%")

44.       Web({ src: 'www.example.com', controller: this.controller2 })
45.         .onFocus(() => {
46.           this.webBorderColor2 = Color.Green;
47.         })
48.         .onBlur(() => {
49.           this.webBorderColor2 = Color.Red;
50.         })
51.         .margin(3)
52.         .borderWidth(10)
53.         .borderColor(this.webBorderColor2)
54.         .height("45%")
55.     }
56.   }
57. }

**示例图1** 组件焦点获焦/失焦事件

通过requestFocus接口主动请求获焦，并监听通用接口onFocus和onBlur事件，改变Web组件边框颜色。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163844.15455213579426938349478954673786:50001231000000:2800:A8F9A4CCC16F963D37A5800F3F93CEF3B4F535570F775F43215B8DB5C74C6563.gif)

## Web组件内H5元素焦点控制

- W3C标准事件focus，前端感知网页获焦

1. addEventListener("focus", (event) => {});

2. onfocus = (event) => {};

- W3C标准事件blur，前端感知网页失焦

1. addEventListener("blur", (event) => {});

2. onblur = (event) => {};

- W3C autofocus，表示元素应在页面加载时或其所属的 dialog 显示时被聚焦

1. <input name="q" autofocus />

在文档或对话框中，最多只能有一个元素具有 autofocus 属性。若应用于多个元素，第一个元素将获得焦点。

**示例：**

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();

8.   build() {
9.     Column() {
10.       Web({ src: $rawfile("test.html"), controller: this.controller })
11.     }
12.   }
13. }

14. // test.html
15. <!DOCTYPE html>
16. <html>
17. <head>
18. <meta charset="utf-8">
19. <title>test</title>
20. </head>
21. <body>
22.   <form id="form">
23.     <input type="text" placeholder="text input" />
24.     <input type="password" placeholder="password" />
25.   </form>
26. </body>
27. <script>
28. const form = document.getElementById("form");

29. form.addEventListener(
30.   "focus",
31.   (event) => {
32.     event.target.style.background = "pink";
33.   },
34.   true,
35. );

36. form.addEventListener(
37.   "blur",
38.   (event) => {
39.     event.target.style.background = "";
40.   },
41.   true,
42. );
43. </script>
44. </html>

**示例图2** Web组件内元素焦点获焦/失焦事件

通过监听W3C接口focus和blur事件，改变输入背景色。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163844.22904667473926379889080277924814:50001231000000:2800:37FC829768743D918EFE72B9623F727E153BF4E26A32F124FC3A51601E38134C.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-docking-softkeyboard "Web组件对接软键盘")
# 使用Web组件的手势与应用交互

更新时间: 2025-12-16 16:38

在移动端或支持触控的Web应用中，用户通过触摸屏与页面交互，Web组件支持了常见的手势识别，例如长按、滑动、点击等，以支持丰富的用户交互体验。

## ArkWeb手势识别

ArkWeb接收ArkUI的[触摸事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-development-guide-touch-screen#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6)，并识别出手势（触摸事件的分发策略详见[交互基础机制说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-basic-principles)）。ArkWeb手势符合W3C标准：Touch Events、UI Events、Pointer Events。

常见事件识别说明：

|手势事件|触发条件|
|:--|:--|
|Tap|按下并抬起时触发，且间隔较短未触发长按。|
|LongPress|按下且不移动，经过一段延迟后触发。|
|ScrollBegin|滚动开始时触发。|
|ScrollUpdate|滚动时触发，包括抛滑和拖滑。手指未离开屏幕时的滚动为拖滑；若手指离开屏幕时带有速度，离手后页面继续滚动，被称为抛滑。|
|ScrollEnd|滚动结束时触发。|
|FlingStart|滚动过程中手指抬起，且抬手速度足够快，触发了抛滑。|
|FlingCancel|取消抛滑时触发。|
|PinchBegin|捏合开始时触发。|
|PinchUpdate|捏合过程中触发。|
|PinchEnd|捏合结束时触发。|

## ArkWeb手势与ArkUI手势

ArkUI提供了[手势绑定](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-binding)，Web组件有独立的手势识别，因此需要区分两种手势：

- ArkWeb手势：Web组件接收触摸事件自动生成的手势，这些手势作用于网页上。
- ArkUI手势：Web组件作为通用组件会接收ArkUI手势，ArkUI手势并不直接作用于网页，而作用于Web组件上。

以缩放为例说明两种手势的区别：

- 在Web上使用双指捏合时，Web组件中的内容将会缩放。这是由于ArkWeb识别了Pinch事件并将其作用于网页上。
- 使用三指捏合，Web组件本身会进行缩放。这是因为ArkWeb接收到ArkUI识别出的[PinchGesture](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-single-gesture#%E6%8D%8F%E5%90%88%E6%89%8B%E5%8A%BFpinchgesture)，执行绑定的回调函数。同时，ArkWeb支持scale方法，能够调整Web组件的缩放比例。

说明

该示例仅用于说明ArkUI手势和ArkWeb手势的区别，不建议使用此方法进行Web组件的缩放。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct Index {
6.   @State scaleValue: number = 1;
7.   @State pinchValue: number = 1;
8.   controller: webview.WebviewController = new webview.WebviewController();

9.   build() {
10.     Column() {
11.       Web({ src: 'www.example.com', controller: this.controller })
12.       // 在组件上绑定缩放比例，可以通过修改缩放比例来实现组件的缩小或者放大
13.       .scale({ x: this.scaleValue, y: this.scaleValue, z: 1 })
14.       .zoomAccess(true)
15.       .gesture(
16.         // 在组件上绑定三指触发的捏合手势
17.         PinchGesture({ fingers: 3 })
18.           .onActionStart((event: GestureEvent|undefined) => {
19.             console.info('Pinch start');
20.           })
21.             // 当捏合手势触发时，可以通过回调函数获取缩放比例，从而修改组件的缩放比例
22.           .onActionUpdate((event: GestureEvent|undefined) => {
23.             if(event){
24.               this.scaleValue = this.pinchValue * event.scale;
25.               console.info('Pinch update');
26.             }
27.           })
28.           .onActionEnd(() => {
29.             this.pinchValue = this.scaleValue;
30.             console.info('Pinch end');
31.           })
32.       )
33.     }
34.   }
35. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163847.93384959105639476070896073485509:50001231000000:2800:FFCD77D0DACA3E5C814AFB39EF6E8DFB0F481D16B69E6A95573F168B76DBDCC8.gif)

## Web组件的手势拦截

- ArkUI手势
    
    ArkWeb会消费部分ArkUI手势，例如[滑动手势](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-single-gesture#%E6%BB%91%E5%8A%A8%E6%89%8B%E5%8A%BFpangesture)，若希望自行处理这些手势而非由ArkWeb消费，可以参考ArkUI的[手势冲突处理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-gesture-judge)。
    
- ArkWeb手势
    
    ArkWeb手势的生成需要Web组件接收触摸事件，有两种拦截方案：
    
    1. 完全禁止触摸事件发送给Web组件，详见[触摸测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-basic-principles#%E8%A7%A6%E6%91%B8%E6%B5%8B%E8%AF%95)。
    2. 发送TouchCancel触摸事件给Web组件，详见[OH_ArkUI_TouchRecognizer_CancelTouch](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-gesture-h#%E5%87%BD%E6%95%B0)。

## 常见问题

### 如何禁用缩放手势

Web组件提供了接口[zoomAccess](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#zoomaccess)，控制是否可以缩放。网页上有user-scalable属性也会影响缩放。详见[使用Web组件管理网页缩放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-scale-zoom)。

### Web组件中如何通过手势滑动返回上一个Web页面

**解决措施**

通过重写onBackPress函数来自定义返回逻辑，使用WebviewController判断是否返回上一个Web页面。

**示例代码**

1. import { webview } from '@kit.ArkWeb';

2. @Entry
3. @Component
4. struct Index {
5.   controller: webview.WebviewController = new webview.WebviewController();

6.   build() {
7.     Column() {
8.       Web({ src: 'https://www.example.com', controller: this.controller })//需要手动替换为真实网站
9.     }
10.   }

11.   onBackPress() {
12.     // 当前页面是否可前进或者后退给定的step步(-1),正数代表前进，负数代表后退
13.     if (this.controller.accessStep(-1)) {
14.       this.controller.backward(); // 返回上一个web页
15.       // 执行用户自定义返回逻辑
16.       return true
17.     } else {
18.       // 执行系统默认返回逻辑，返回上一个page页
19.       return false
20.     }
21.   }
22. }

### 为什么Web加载后网页无法交互？

网页可能基于其他平台的User-Agent进行判断。为解决此问题，可以在Web组件中设置自定义User-Agent，例如：

1. import { webview } from '@kit.ArkWeb'

2. @Entry
3. @Component
4. struct Index {
5.     private webController: webview.WebviewController = new webview.WebviewController()
6.     build(){
7.       Column() {
8.         Web({
9.           src: 'https://www.example.com',
10.           controller: this.webController,
11.         }).onControllerAttached(() => {
12.           // 自定义User-Agent
13.           let customUA = 'Mozilla/5.0 (Phone; Android; HarmonyOS 5.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Mobile Safari/537.36'
14.           this.webController.setCustomUserAgent(customUA)
15.         })
16.       }
17.     }
18. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-focus "Web组件焦点管理")
# 使用Web组件管理网页缩放

更新时间: 2025-12-16 16:38

Web组件支持手势缩放、鼠标滚轮、键盘缩放，以方便用户调整到舒适的显示大小。并对应用提供监听、控制页面缩放比例的功能，以便应用实现个性化的视觉效果。

## 启用/禁用网页缩放

### 启用/禁用网页手势缩放

通过属性[zoomAccess](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#zoomaccess)控制网页缩放功能，当设置为false时，网页不允许手势缩放行为。

当html网页设置<meta name="viewport" id="viewport" content="user-scalable=no">时，网页不允许手势缩放。

仅当zoomAccess和viewport标签都设置为允许缩放时，才允许手势缩放。

说明

在PC/2in1设备上，viewport标签不生效，仅能通过设置zoomAccess为false来禁用手势缩放。

以上方法仅能控制缩放功能的开关，但如果网页在viewport标签中设置了minimum-scale和maximum-scale，那么缩放的范围也会受到这两个属性的限制，当最大、最小值相等时，网页也是不能缩放的。

另外，网页的内容宽度也会限制缩小的比例。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct WebComponent {
6.   controller: webview.WebviewController = new webview.WebviewController();

7.   build() {
8.     Column() {
9.       Web({ src: 'www.example.com', controller: this.controller })
10.         .zoomAccess(false)
11.     }
12.   }
13. }

### 启用/禁用手势强制缩放

通过属性[forceEnableZoom](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#forceenablezoom21)控制网页强制缩放功能，当设置为true时，手势缩放行为不受minimum-scale和maximum-scale以及user-scalable=no的限制。

### 启用/禁用网页键盘鼠标缩放

ArkWeb默认支持通过Ctrl+按键'-'/'+' 或者 Ctrl+鼠标滚轮进行缩放。应用可以通过拦截键盘事件来阻止按键缩放，当前暂未支持拦截Ctrl+鼠标滚轮缩放。

通过拦截键盘事件来阻止按键缩放：

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { KeyCode } from '@kit.InputKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();

8.   build() {
9.     Column() {
10.       Web({ src: 'www.example.com', controller: this.controller })
11.         .zoomAccess(true)
12.         .onKeyPreIme((event) => {
13.           if (event.type == KeyType.Down &&
14.               event.getModifierKeyState &&
15.               event.getModifierKeyState(['Ctrl']) &&
16.               (event.keyCode == KeyCode.KEYCODE_MINUS || event.keyCode == KeyCode.KEYCODE_EQUALS ||
17.                event.keyCode == KeyCode.KEYCODE_NUMPAD_SUBTRACT || event.keyCode == KeyCode.KEYCODE_NUMPAD_ADD)) {
18.             return true;
19.           }
20.           return false;
21.         })
22.     }
23.   }
24. }

## 监听页面缩放比例变化

应用可以通过[onScaleChange](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-events#onscalechange9)接口监听页面缩放比例的变化。

该接口事件对应手势事件(双指缩放)，event.newScale对应网页属性visualViewport.scale。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct WebComponent {
6.   controller: webview.WebviewController = new webview.WebviewController();

7.   build() {
8.     Column() {
9.       Web({ src: 'www.example.com', controller: this.controller })
10.         .onScaleChange((event) => {
11.           console.info('onScaleChange changed from ' + event.oldScale + ' to ' + event.newScale);
12.         })
13.     }
14.   }
15. }

## 控制网页的缩放比例

应用可以通过设置[initialScale](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#initialscale9)属性设置页面初始缩放比例。

应用可以通过[zoom](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#zoom)、[zoomIn](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#zoomin)、[zoomOut](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#zoomout)接口控制页面缩放。

说明

使用以上接口控制页面缩放时，必须设置属性zoomAccess为true。zoomAccess为false时，zoom类接口会抛出异常17100004。

### 以固定比例缩放页面

zoomIn将当前网页进行放大，比例为25%；zoomOut将当前网页进行缩小，比例为20%。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();
8.   build() {
9.     Column() {
10.       Button('zoomIn')
11.         .onClick(() => {
12.           try {
13.             this.controller.zoomIn();
14.           } catch (error) {
15.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
16.           }
17.         })
18.       Button('zoomOut')
19.         .onClick(() => {
20.           try {
21.             this.controller.zoomOut();
22.           } catch (error) {
23.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
24.           }
25.         })
26.       Web({ src: 'www.example.com', controller: this.controller })
27.         .zoomAccess(true)
28.     }
29.   }
30. }

### 根据输入值控制页面缩放比例:

zoom基于当前网页比例进行缩放，入参要求大于0，当入参为1时为默认加载网页的缩放比例，入参小于1为缩小，入参大于1为放大。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();
8.   @State factor: number = 1;

9.   build() {
10.     Column() {
11.       TextInput()
12.         .type(InputType.NUMBER_DECIMAL)
13.         .onChange((value)=>{
14.             this.factor = Number(value);
15.         })
16.       Button('zoom')
17.         .onClick(() => {
18.           try {
19.             this.controller.zoom(this.factor);
20.           } catch (error) {
21.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
22.           }
23.         })
24.       Web({ src: 'www.example.com', controller: this.controller })
25.         .zoomAccess(true)
26.     }
27.   }
28. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163849.86048765312705066066301216960798:50001231000000:2800:9BE16B20D6646845B651B7359699AEA40B0839B479A1AB0E2A427E6C4B84CB28.gif)

### 缩放页面到目标比例:

通过onScaleChange接口，应用可以得知当前网页的缩放比例，配合zoom接口即可实现将页面缩放至指定比例的功能。根据当前页面缩放比例pageFactor和目标比例targetFactor计算zoom入参的公式为：

1. factor = 100 * targetFactor / pageFactor

2. // xxx.ets
3. import { webview } from '@kit.ArkWeb';
4. import { BusinessError } from '@kit.BasicServicesKit';

5. @Entry
6. @Component
7. struct WebComponent {
8.   controller: webview.WebviewController = new webview.WebviewController();
9.   @State targetFactor: number = 1;
10.   @State pageFactor: number = 100;

11.   build() {
12.     Column() {
13.       TextInput()
14.         .type(InputType.NUMBER_DECIMAL)
15.         .onChange((value)=>{
16.           this.targetFactor = Number(value);
17.         })
18.       Button('zoom')
19.         .onClick(() => {
20.           try {
21.             let factor = this.targetFactor * 100 / this.pageFactor;
22.             this.controller.zoom(factor);
23.           } catch (error) {
24.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
25.           }
26.         })
27.       Web({ src: 'www.example.com', controller: this.controller })
28.         .zoomAccess(true)
29.         .onScaleChange((event) => {
30.           console.info('onScaleChange changed from ' + event.oldScale + ' to ' + event.newScale);
31.           this.pageFactor = event.newScale;
32.         })
33.     }
34.   }
35. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163849.22577323650404128758106513240980:50001231000000:2800:7E8294CA50D53914E121EF7D2442C905F870CBFE21D4F66080DBEFA8CD891CF4.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-gesture "使用Web组件的手势与应用交互")
# 使用Web组件的拖拽功能与网页交互

更新时间: 2025-12-16 16:38

ArkWeb的拖拽功能使应用能够在网页中实现元素的拖放，用户可以长按可拖拽的元素，将其拖至可放置的元素上，然后松手完成放置。ArkWeb在网页内容中的拖拽功能满足H5标准。

## 将网页内容拖拽至其他应用

ArkWeb目前支持以下四种数据格式。应用按照 H5 标准设置这些格式的拖拽数据，即可将内容拖拽到其他应用中。

|数据格式|说明|
|:--|:--|
|text/plain|文本|
|text/uri-list|链接|
|text/html|HTML格式|
|Files|文件|

## 拖拽事件通知

ArkWeb拖拽不同于ArkUI的组件级拖拽，主要针对网页内容的拖拽，因此仅支持部分拖拽事件的监听方法。

|监听方法|说明|
|:--|:--|
|[onDragStart](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragstart)|不建议使用此方法，否则会影响Web组件的拖拽行为，造成拖拽逻辑不符合预期，如无法触发html拖拽事件监听，预览图无法创建或预览图错误，拖拽数据无法预置等。|
|[onDragEnter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragenter)|拖拽的元素进入Web区域。|
|[onDragMove](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragmove)|拖拽的元素在Web区域移动。|
|[onDragLeave](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragleave)|拖拽的元素离开Web区域。|
|[onDragEnd](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragend10)|由Web发起的拖拽元素结束拖拽。|

## 在ArkTS侧实现拖拽相关逻辑

在多数情况下，应用在H5端实现的拖拽功能能够满足需求。如有需要，请参考以下案例，实现在ArkTS端进行拖拽数据读取等操作。

1. [建立应用侧与前端页面数据通道](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-app-page-data-channel)。
2. 在onDrop方法中，做简单逻辑，例如暂存一些关键数据。
3. 在ArkTS侧接受消息的方法中，添加应用处理逻辑，可以进行耗时任务。

由于ArkTS侧的onDrop方法会早于H5中放置事件的处理方法（html示例中的droppable.addEventListener('drop')）执行，若在onDrop方法中进行页面跳转等操作，将导致H5中的drop方法无法正确执行，产生不符合预期的结果。因此，应建立双向通信机制，在H5中的drop方法执行完毕后，通知ArkTS侧执行相应的业务逻辑，以确保业务逻辑的预期执行。

1. import { webview } from '@kit.ArkWeb'
2. import { unifiedDataChannel, uniformTypeDescriptor } from '@kit.ArkData';

3. @Entry
4. @Component
5. struct DragDrop {
6.   private controller: webview.WebviewController = new webview.WebviewController()
7.   @State ports: Array<webview.WebMessagePort> = []
8.   @State dragData: Array<unifiedDataChannel.UnifiedRecord> = []

9.   build() {
10.     Column() {
11.       Web({
12.         src: $rawfile("drag.html"),
13.         controller: this.controller,
14.       }).onPageEnd((event) => {
15.         //注册通信端口
16.         this.ports = this.controller.createWebMessagePorts();
17.         this.ports[1].onMessageEvent((result: webview.WebMessage) => {
18.           //ArkTS收到html传来的数据后的处理，可以先打日志确认下消息，双端的消息格式可以自己约定，能唯一识别就行
19.           console.info("ETS receive Message: typeof (result) = " + typeof (result) + ";" + result);
20.           //这里添加result中消息接收到后的处理,可进行耗时任务
21.         });
22.         console.info("ETS postMessage set h5port ");
23.         //完成通信端口注册后，向前端发送注册完成消息，完成双向的端口绑定
24.         this.controller.postMessage('__init_port__', [this.ports[0]], '*');
25.       })// onDrop 可做简单逻辑，例如暂存一些关键数据
26.         .onDrop((DragEvent: DragEvent) => {
27.           console.info("ETS onDrop!")
28.           let data: UnifiedData = DragEvent.getData();
29.           if(!data) {
30.             return false;
31.           }
32.           let uriArr: Array<unifiedDataChannel.UnifiedRecord> = data.getRecords();
33.           if (!uriArr || uriArr.length <= 0) {
34.             return false;
35.           }
36.           // 可以遍历records取数据暂存，或者以其他方式暂存数据
37.           for (let i = 0; i < uriArr.length; ++i) {
38.             if (uriArr[i].getType() === uniformTypeDescriptor.UniformDataType.PLAIN_TEXT) {
39.               let plainText = uriArr[i] as unifiedDataChannel.PlainText;
40.               if (plainText.textContent) {
41.                 console.info("plainText.textContent: ", plainText.textContent);
42.               }
43.             }
44.           }
45.           return true
46.         })
47.     }

48.   }
49. }

html示例:

1. <html lang="zh-CN">
2. <head>
3.     <meta charset="UTF-8">
4.     <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
5.     <title>H5 拖拽 Demo</title>
6. </head>
7. <style>
8.     body {
9.       font-family: Arial, sans-serif;
10.       padding: 20px;
11.     }

12.     .draggable {
13.       width: 100px;
14.       height: 100px;
15.       background-color: #4CAF50;
16.       color: white;
17.       text-align: center;
18.       line-height: 100px;
19.       margin-bottom: 20px;
20.       cursor: grab;
21.     }

22.     .droppable {
23.       width: 300px;
24.       height: 150px;
25.       border: 2px dashed #999;
26.       background-color: #f0f0f0;
27.       text-align: center;
28.       line-height: 150px;
29.       font-size: 16px;
30.     }

31.     .success {
32.       background-color: #4CAF50;
33.       color: white;
34.     }
35. </style>
36. <body>

37. <h2>H5 拖拽 Demo</h2>

38. <div id="draggable" class="draggable" draggable="true">可拖拽元素</div>

39. <div id="droppable" class="droppable">请将方块拖到这里</div>

40. <script>
41.     const draggable = document.getElementById('draggable');
42.     const droppable = document.getElementById('droppable');

43.     // 拖拽开始事件
44.     draggable.addEventListener('dragstart', function (e) {
45.       e.dataTransfer.setData('text/plain', this.id);
46.       this.style.opacity = '0.4';
47.     });

48.     // 拖拽结束事件
49.     draggable.addEventListener('dragend', function (e) {
50.       this.style.opacity = '1';
51.     });

52.     // 拖入目标区域时触发
53.     droppable.addEventListener('dragover', function (e) {
54.       e.preventDefault(); // 必须调用，否则无法触发 drop 事件
55.     });

56.     // 放置事件
57.     droppable.addEventListener('drop', function (e) {
58.       e.preventDefault();
59.       const data = e.dataTransfer.getData('text/plain');
60.       // 传入ArkTS
61.       PostMsgToArkTS(data);
62.       const draggableEl = document.getElementById(data);
63.       this.appendChild(draggableEl);
64.       this.classList.add('success');
65.       this.textContent = "放置成功！";
66.     });

67.     //     scriptproxy端口在js侧设置
68.     var h5Port;
69.     window.addEventListener('message', function (event) {
70.     console.info("H5 receive settingPort message");
71.         if (event.data == '__init_port__') {
72.             if (event.ports[0] != null) {
73.                 console.info("H5 set h5Port " + event.ports[0]);
74.                 h5Port = event.ports[0];
75.             }
76.         }
77.     });

78.     // 通过scriptproxy方式,发送数据到ArkTS侧的实现
79.     function PostMsgToArkTS(data) {
80.         console.info("H5 PostMsgToArkTS, h5Port " + h5Port);
81.         if (h5Port) {
82.           h5Port.postMessage(data);
83.         } else {
84.           console.error("h5Port is null, Please initialize first");
85.         }
86.     }
87. </script>

88. </body>
89. </html>

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163852.15954491537821756324725343796439:50001231000000:2800:8FC22AC88DCA8809CF5BDFEB09155D2101880BB87EB0C3C847B6E036306D8942.gif)

日志打印：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163852.22826312479865232248946714854527:50001231000000:2800:0E94400B22AA86EA9E11924E1592F655C7E2869ADB12C2771082BCE94ED63719.png)

## 常见问题

### 为什么H5设置的拖拽事件没有触发？

请检查相关CSS资源是否正常设置，因为有些网页UA做了判断，针对特定设备的UA才会进行CSS样式设置。可以考虑在Web组件设置自定义UA解决这种问题，例如：

1. import { webview } from '@kit.ArkWeb'

2. @Entry
3. @Component
4. struct Index {
5.     private webController: webview.WebviewController = new webview.WebviewController()
6.     build(){
7.       Column() {
8.         Web({
9.           src: "example.com",
10.           controller: this.webController,
11.         }).onControllerAttached(() => {
12.           // 特定UA
13.           let customUA = 'android'
14.           this.webController.setCustomUserAgent(this.webController.getUserAgent() + customUA)
15.         })
16.       }
17.     }
18. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-dialog "使用Web组件显示网页弹框")
# 使用Web组件的拖拽功能与网页交互

更新时间: 2025-12-16 16:38

ArkWeb的拖拽功能使应用能够在网页中实现元素的拖放，用户可以长按可拖拽的元素，将其拖至可放置的元素上，然后松手完成放置。ArkWeb在网页内容中的拖拽功能满足H5标准。

## 将网页内容拖拽至其他应用

ArkWeb目前支持以下四种数据格式。应用按照 H5 标准设置这些格式的拖拽数据，即可将内容拖拽到其他应用中。

|数据格式|说明|
|:--|:--|
|text/plain|文本|
|text/uri-list|链接|
|text/html|HTML格式|
|Files|文件|

## 拖拽事件通知

ArkWeb拖拽不同于ArkUI的组件级拖拽，主要针对网页内容的拖拽，因此仅支持部分拖拽事件的监听方法。

|监听方法|说明|
|:--|:--|
|[onDragStart](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragstart)|不建议使用此方法，否则会影响Web组件的拖拽行为，造成拖拽逻辑不符合预期，如无法触发html拖拽事件监听，预览图无法创建或预览图错误，拖拽数据无法预置等。|
|[onDragEnter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragenter)|拖拽的元素进入Web区域。|
|[onDragMove](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragmove)|拖拽的元素在Web区域移动。|
|[onDragLeave](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragleave)|拖拽的元素离开Web区域。|
|[onDragEnd](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragend10)|由Web发起的拖拽元素结束拖拽。|

## 在ArkTS侧实现拖拽相关逻辑

在多数情况下，应用在H5端实现的拖拽功能能够满足需求。如有需要，请参考以下案例，实现在ArkTS端进行拖拽数据读取等操作。

1. [建立应用侧与前端页面数据通道](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-app-page-data-channel)。
2. 在onDrop方法中，做简单逻辑，例如暂存一些关键数据。
3. 在ArkTS侧接受消息的方法中，添加应用处理逻辑，可以进行耗时任务。

由于ArkTS侧的onDrop方法会早于H5中放置事件的处理方法（html示例中的droppable.addEventListener('drop')）执行，若在onDrop方法中进行页面跳转等操作，将导致H5中的drop方法无法正确执行，产生不符合预期的结果。因此，应建立双向通信机制，在H5中的drop方法执行完毕后，通知ArkTS侧执行相应的业务逻辑，以确保业务逻辑的预期执行。

1. import { webview } from '@kit.ArkWeb'
2. import { unifiedDataChannel, uniformTypeDescriptor } from '@kit.ArkData';

3. @Entry
4. @Component
5. struct DragDrop {
6.   private controller: webview.WebviewController = new webview.WebviewController()
7.   @State ports: Array<webview.WebMessagePort> = []
8.   @State dragData: Array<unifiedDataChannel.UnifiedRecord> = []

9.   build() {
10.     Column() {
11.       Web({
12.         src: $rawfile("drag.html"),
13.         controller: this.controller,
14.       }).onPageEnd((event) => {
15.         //注册通信端口
16.         this.ports = this.controller.createWebMessagePorts();
17.         this.ports[1].onMessageEvent((result: webview.WebMessage) => {
18.           //ArkTS收到html传来的数据后的处理，可以先打日志确认下消息，双端的消息格式可以自己约定，能唯一识别就行
19.           console.info("ETS receive Message: typeof (result) = " + typeof (result) + ";" + result);
20.           //这里添加result中消息接收到后的处理,可进行耗时任务
21.         });
22.         console.info("ETS postMessage set h5port ");
23.         //完成通信端口注册后，向前端发送注册完成消息，完成双向的端口绑定
24.         this.controller.postMessage('__init_port__', [this.ports[0]], '*');
25.       })// onDrop 可做简单逻辑，例如暂存一些关键数据
26.         .onDrop((DragEvent: DragEvent) => {
27.           console.info("ETS onDrop!")
28.           let data: UnifiedData = DragEvent.getData();
29.           if(!data) {
30.             return false;
31.           }
32.           let uriArr: Array<unifiedDataChannel.UnifiedRecord> = data.getRecords();
33.           if (!uriArr || uriArr.length <= 0) {
34.             return false;
35.           }
36.           // 可以遍历records取数据暂存，或者以其他方式暂存数据
37.           for (let i = 0; i < uriArr.length; ++i) {
38.             if (uriArr[i].getType() === uniformTypeDescriptor.UniformDataType.PLAIN_TEXT) {
39.               let plainText = uriArr[i] as unifiedDataChannel.PlainText;
40.               if (plainText.textContent) {
41.                 console.info("plainText.textContent: ", plainText.textContent);
42.               }
43.             }
44.           }
45.           return true
46.         })
47.     }

48.   }
49. }

html示例:

1. <html lang="zh-CN">
2. <head>
3.     <meta charset="UTF-8">
4.     <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
5.     <title>H5 拖拽 Demo</title>
6. </head>
7. <style>
8.     body {
9.       font-family: Arial, sans-serif;
10.       padding: 20px;
11.     }

12.     .draggable {
13.       width: 100px;
14.       height: 100px;
15.       background-color: #4CAF50;
16.       color: white;
17.       text-align: center;
18.       line-height: 100px;
19.       margin-bottom: 20px;
20.       cursor: grab;
21.     }

22.     .droppable {
23.       width: 300px;
24.       height: 150px;
25.       border: 2px dashed #999;
26.       background-color: #f0f0f0;
27.       text-align: center;
28.       line-height: 150px;
29.       font-size: 16px;
30.     }

31.     .success {
32.       background-color: #4CAF50;
33.       color: white;
34.     }
35. </style>
36. <body>

37. <h2>H5 拖拽 Demo</h2>

38. <div id="draggable" class="draggable" draggable="true">可拖拽元素</div>

39. <div id="droppable" class="droppable">请将方块拖到这里</div>

40. <script>
41.     const draggable = document.getElementById('draggable');
42.     const droppable = document.getElementById('droppable');

43.     // 拖拽开始事件
44.     draggable.addEventListener('dragstart', function (e) {
45.       e.dataTransfer.setData('text/plain', this.id);
46.       this.style.opacity = '0.4';
47.     });

48.     // 拖拽结束事件
49.     draggable.addEventListener('dragend', function (e) {
50.       this.style.opacity = '1';
51.     });

52.     // 拖入目标区域时触发
53.     droppable.addEventListener('dragover', function (e) {
54.       e.preventDefault(); // 必须调用，否则无法触发 drop 事件
55.     });

56.     // 放置事件
57.     droppable.addEventListener('drop', function (e) {
58.       e.preventDefault();
59.       const data = e.dataTransfer.getData('text/plain');
60.       // 传入ArkTS
61.       PostMsgToArkTS(data);
62.       const draggableEl = document.getElementById(data);
63.       this.appendChild(draggableEl);
64.       this.classList.add('success');
65.       this.textContent = "放置成功！";
66.     });

67.     //     scriptproxy端口在js侧设置
68.     var h5Port;
69.     window.addEventListener('message', function (event) {
70.     console.info("H5 receive settingPort message");
71.         if (event.data == '__init_port__') {
72.             if (event.ports[0] != null) {
73.                 console.info("H5 set h5Port " + event.ports[0]);
74.                 h5Port = event.ports[0];
75.             }
76.         }
77.     });

78.     // 通过scriptproxy方式,发送数据到ArkTS侧的实现
79.     function PostMsgToArkTS(data) {
80.         console.info("H5 PostMsgToArkTS, h5Port " + h5Port);
81.         if (h5Port) {
82.           h5Port.postMessage(data);
83.         } else {
84.           console.error("h5Port is null, Please initialize first");
85.         }
86.     }
87. </script>

88. </body>
89. </html>

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163852.15954491537821756324725343796439:50001231000000:2800:8FC22AC88DCA8809CF5BDFEB09155D2101880BB87EB0C3C847B6E036306D8942.gif)

日志打印：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163852.22826312479865232248946714854527:50001231000000:2800:0E94400B22AA86EA9E11924E1592F655C7E2869ADB12C2771082BCE94ED63719.png)

## 常见问题

### 为什么H5设置的拖拽事件没有触发？

请检查相关CSS资源是否正常设置，因为有些网页UA做了判断，针对特定设备的UA才会进行CSS样式设置。可以考虑在Web组件设置自定义UA解决这种问题，例如：

1. import { webview } from '@kit.ArkWeb'

2. @Entry
3. @Component
4. struct Index {
5.     private webController: webview.WebviewController = new webview.WebviewController()
6.     build(){
7.       Column() {
8.         Web({
9.           src: "example.com",
10.           controller: this.webController,
11.         }).onControllerAttached(() => {
12.           // 特定UA
13.           let customUA = 'android'
14.           this.webController.setCustomUserAgent(this.webController.getUserAgent() + customUA)
15.         })
16.       }
17.     }
18. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-dialog "使用Web组件显示网页弹框")
# 使用智能防跟踪功能

更新时间: 2025-12-16 16:38

Web组件支持智能防跟踪功能，即当跟踪型网站作为第三方插入到其他网页时，其发送的网络请求将禁止携带cookie。

- 通过调用[enableIntelligentTrackingPrevention](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#enableintelligenttrackingprevention12)接口启用或关闭Web组件的智能防跟踪功能。默认情况下，该功能未启用。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('enableIntelligentTrackingPrevention')
    11.         .onClick(() => {
    12.           try {
    13.             this.controller.enableIntelligentTrackingPrevention(true);
    14.             console.info("enableIntelligentTrackingPrevention: true");
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 调用[isIntelligentTrackingPreventionEnabled](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#isintelligenttrackingpreventionenabled12)接口，判断Web组件是否开启了智能防跟踪功能。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('isIntelligentTrackingPreventionEnabled')
    11.         .onClick(() => {
    12.           try {
    13.             let result = this.controller.isIntelligentTrackingPreventionEnabled();
    14.             console.info("result: " + result);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 通过[onIntelligentTrackingPreventionResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-events#onintelligenttrackingpreventionresult12)接口将被拦截的跟踪型域名及其触发网站的域名回调给应用。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       // 需要打开智能防跟踪功能，才会触发onIntelligentTrackingPreventionResult回调
    11.       Button('enableIntelligentTrackingPrevention')
    12.         .onClick(() => {
    13.           try {
    14.             this.controller.enableIntelligentTrackingPrevention(true);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code}, Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.         .onIntelligentTrackingPreventionResult((details) => {
    21.           console.info("onIntelligentTrackingPreventionResult: [websiteHost]= " + details.host +
    22.             ", [trackerHost]=" + details.trackerHost);
    23.         })
    24.     }
    25.   }
    26. }
    

智能防跟踪功能提供了一组接口，用于设置绕过该功能的域名列表。这些接口设置的域名列表适用于整个应用，而非特定的Web组件。

- 调用[addIntelligentTrackingPreventionBypassingList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#addintelligenttrackingpreventionbypassinglist12)接口设置绕过域名列表。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('addIntelligentTrackingPreventionBypassingList')
    11.         .onClick(() => {
    12.           try {
    13.             let hostList = ["www.test1.com", "www.test2.com", "www.test3.com"];
    14.             webview.WebviewController.addIntelligentTrackingPreventionBypassingList(hostList);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 调用[removeIntelligentTrackingPreventionBypassingList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#removeintelligenttrackingpreventionbypassinglist12)接口删除部分绕过域名列表。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('removeIntelligentTrackingPreventionBypassingList')
    11.         .onClick(() => {
    12.           try {
    13.             let hostList = [ "www.test1.com", "www.test2.com" ];
    14.             webview.WebviewController.removeIntelligentTrackingPreventionBypassingList(hostList);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 调用[clearIntelligentTrackingPreventionBypassingList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#clearintelligenttrackingpreventionbypassinglist12)接口清除所有绕过域名列表。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    
    3. @Entry
    4. @Component
    5. struct WebComponent {
    6.   controller: webview.WebviewController = new webview.WebviewController();
    
    7.   build() {
    8.     Column() {
    9.       Button('clearIntelligentTrackingPreventionBypassingList')
    10.         .onClick(() => {
    11.           webview.WebviewController.clearIntelligentTrackingPreventionBypassingList();
    12.         })
    13.       Web({ src: 'www.example.com', controller: this.controller })
    14.     }
    15.   }
    16. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-cross-origin "解决Web组件本地资源跨域问题")
# 使用智能防跟踪功能

更新时间: 2025-12-16 16:38

Web组件支持智能防跟踪功能，即当跟踪型网站作为第三方插入到其他网页时，其发送的网络请求将禁止携带cookie。

- 通过调用[enableIntelligentTrackingPrevention](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#enableintelligenttrackingprevention12)接口启用或关闭Web组件的智能防跟踪功能。默认情况下，该功能未启用。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('enableIntelligentTrackingPrevention')
    11.         .onClick(() => {
    12.           try {
    13.             this.controller.enableIntelligentTrackingPrevention(true);
    14.             console.info("enableIntelligentTrackingPrevention: true");
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 调用[isIntelligentTrackingPreventionEnabled](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#isintelligenttrackingpreventionenabled12)接口，判断Web组件是否开启了智能防跟踪功能。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('isIntelligentTrackingPreventionEnabled')
    11.         .onClick(() => {
    12.           try {
    13.             let result = this.controller.isIntelligentTrackingPreventionEnabled();
    14.             console.info("result: " + result);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 通过[onIntelligentTrackingPreventionResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-events#onintelligenttrackingpreventionresult12)接口将被拦截的跟踪型域名及其触发网站的域名回调给应用。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       // 需要打开智能防跟踪功能，才会触发onIntelligentTrackingPreventionResult回调
    11.       Button('enableIntelligentTrackingPrevention')
    12.         .onClick(() => {
    13.           try {
    14.             this.controller.enableIntelligentTrackingPrevention(true);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code}, Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.         .onIntelligentTrackingPreventionResult((details) => {
    21.           console.info("onIntelligentTrackingPreventionResult: [websiteHost]= " + details.host +
    22.             ", [trackerHost]=" + details.trackerHost);
    23.         })
    24.     }
    25.   }
    26. }
    

智能防跟踪功能提供了一组接口，用于设置绕过该功能的域名列表。这些接口设置的域名列表适用于整个应用，而非特定的Web组件。

- 调用[addIntelligentTrackingPreventionBypassingList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#addintelligenttrackingpreventionbypassinglist12)接口设置绕过域名列表。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('addIntelligentTrackingPreventionBypassingList')
    11.         .onClick(() => {
    12.           try {
    13.             let hostList = ["www.test1.com", "www.test2.com", "www.test3.com"];
    14.             webview.WebviewController.addIntelligentTrackingPreventionBypassingList(hostList);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 调用[removeIntelligentTrackingPreventionBypassingList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#removeintelligenttrackingpreventionbypassinglist12)接口删除部分绕过域名列表。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('removeIntelligentTrackingPreventionBypassingList')
    11.         .onClick(() => {
    12.           try {
    13.             let hostList = [ "www.test1.com", "www.test2.com" ];
    14.             webview.WebviewController.removeIntelligentTrackingPreventionBypassingList(hostList);
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       Web({ src: 'www.example.com', controller: this.controller })
    20.     }
    21.   }
    22. }
    
- 调用[clearIntelligentTrackingPreventionBypassingList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#clearintelligenttrackingpreventionbypassinglist12)接口清除所有绕过域名列表。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    
    3. @Entry
    4. @Component
    5. struct WebComponent {
    6.   controller: webview.WebviewController = new webview.WebviewController();
    
    7.   build() {
    8.     Column() {
    9.       Button('clearIntelligentTrackingPreventionBypassingList')
    10.         .onClick(() => {
    11.           webview.WebviewController.clearIntelligentTrackingPreventionBypassingList();
    12.         })
    13.       Web({ src: 'www.example.com', controller: this.controller })
    14.     }
    15.   }
    16. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-cross-origin "解决Web组件本地资源跨域问题")
# 使用Web组件的广告过滤功能

更新时间: 2025-12-16 16:38

ArkWeb为应用提供广告过滤功能，支持通过云端推送默认的easylist规则，或允许应用通过接口设定自定义规则文件。它在网络层拦截广告资源的下载，或在网页中注入CSS规则以隐藏特定的广告元素。

当前配置文件格式为[easylist规则](https://easylist-downloads.adblockplus.org/easylist.txt)。

## 常用easylist语法规则

|规则类别|说明|示例|
|:--|:--|:--|
|URL拦截规则|拦截所有网站中url能匹配"example.com/js/*_tv.js"的子资源请求。用于定义域名过滤规则，匹配特定的域名及其所有子域名。|\|example.com/js/*_tv.js|
|URL拦截规则|拦截非alimama.com、非taobao.com域名网站中的url匹配"alimama.cn"的第三方资源。$third_party是一种options语法，表示匹配第三方资源；域名前使用'~'表示不包括该域名。|\|alimama.cn^$third-party,domain=alimama.com\|\taobao.com|
|例外规则|关闭example.com网页内的广告过滤。@@是例外规则的语法关键字，表示不过滤。|@@\|example.com^$document|
|例外规则|在域名为litv.tv的网页中，不过滤能匹配上".adserver."的子资源。|@@.adserver.$domain=litv.tv|
|元素隐藏规则|隐藏myabandonware.com和myware.com域名中所有class="i528"的元素。##用于表示元素隐藏。|myabandonware.com, myware.com##.i528|
|元素隐藏例外规则|不隐藏sdf-event.sakura.ne.jp网站中id="ad_1"的元素。|sdf-event.sakura.ne.jp#@##ad_1|

例外规则，通常是与普通规则配合使用的，在某些特定场景下使普通规则不适用，单独应用例外规则是没有意义的。

例如先配置了一条过滤所有网站的拦截规则：||abc.com/js/123.js，如果某些网站出现误拦截或不能拦截的情况，可以针对这些网站配置新的例外规则。

## 约束与限制

- 在[WebviewController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller)类中，增加开启/关闭广告过滤特性的接口[enableAdsBlock()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#enableadsblock12)，支持Web实例级的特性开关。
    
- 新增[AdsBlockManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager)全局单例类，提供自定义广告过滤配置、控制网站级特性开关的能力。
    
- Web实例上提供了[onAdsBlocked()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#onadsblocked12)回调通知方法，支持将拦截信息通知到上层应用。
    
- [AdsBlockManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager)接口[setAdsBlockRules()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#setadsblockrules12)接口仅能设置一份自定义配置，此配置会持久化，应用冷启动无需重新配置，可避免每次冷启动配置规则都触发广告过滤配置的编译解析。
    
- [AdsBlockManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager)接口[addAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockdisallowedlist12)、[removeAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#removeadsblockdisallowedlist12)、[clearAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#clearadsblockdisallowedlist12)、[addAdsBlockAllowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockallowedlist12)、[removeAdsBlockAllowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#removeadsblockallowedlist12)、[clearAdsBlockAllowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#clearadsblockallowedlist12)操作的数据不会持久化，应用冷启动需要重新设置。
    
- 如果1个Web实例启用了广告过滤特性，但未调用[AdsBlockManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager)接口[addAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockdisallowedlist12)、[removeAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#removeadsblockdisallowedlist12)、[clearAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#clearadsblockdisallowedlist12)、[addAdsBlockAllowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockallowedlist12)、[removeAdsBlockAllowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#removeadsblockallowedlist12)、[clearAdsBlockAllowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#clearadsblockallowedlist12)配置disallowlist和allowlist数据，则默认所有网站均启用广告过滤。
    
- allowlist和disallowlist数据共同使用时，allowlist的优先级高于disallowlist，即先使用allowlist匹配，如果匹配成功就不再使用disallowlist匹配，该网站会启用广告过滤特性。
    
- 如果应用未启用广告过滤特性，那么Web组件不会向服务器请求默认的内置easylist规则。
    
- disallowlist和allowlist数据采用后缀匹配，例如应用的设置的域名"xxyy.com"，可以匹配上url为"wwsstt.xxyy.com"的网站。
    

## 使用场景

### 开启广告过滤

应用可以通过AdsBlockManager提供的[setAdsBlockRules()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#setadsblockrules12)接口设置自定义的easylist过滤规则，并通过Web组件的[enableAdsBlock()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#enableadsblock12)接口使能广告过滤特性。

在下面的示例中，演示了一个应用通过文件选择器选择easylist规则文件，并开启广告过滤功能。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { picker, fileUri } from '@kit.CoreFileKit';

4. // 演示点击按钮，通过filepicker打开一个easylist规则文件并设置到Web组件中
5. @Entry
6. @Component
7. struct WebComponent {
8.   main_url: string = 'https://www.example.com';
9.   controller: webview.WebviewController = new webview.WebviewController();

10.   @State input_text: string = 'https://www.example.com';

11.   build() {
12.     Column() {
13.       Row() {
14.         Flex() {
15.           Button({type: ButtonType.Capsule}) {
16.             Text("setAdsBlockRules")
17.           }
18.           .onClick(() => {
19.             try {
20.               let documentSelectionOptions: ESObject = new picker.DocumentSelectOptions();
21.               let documentPicker: ESObject = new picker.DocumentViewPicker();
22.               documentPicker.select(documentSelectionOptions).then((documentSelectResult: ESObject) => {
23.                 if (documentSelectResult && documentSelectResult.length > 0) {
24.                   let fileRealPath = new fileUri.FileUri(documentSelectResult[0]);
25.                   console.info('DocumentViewPicker.select successfully, uri: ' + fileRealPath);
26.                   webview.AdsBlockManager.setAdsBlockRules(fileRealPath.path, true);
27.                 }
28.               })
29.             } catch (err) {
30.               console.error('DocumentViewPicker.select failed with err:' + err);
31.             }
32.           })
33.         }
34.       }
35.       Web({ src: this.main_url, controller: this.controller })
36.         .onControllerAttached(()=>{
37.           this.controller.enableAdsBlock(true);
38.         })
39.     }
40.   }
41. }

如果存在内置的easylist规则文件，[setAdsBlockRules()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#setadsblockrules12)接口的replace参数可用于设置规则文件的使用策略，replace为true表示不使用内置的easylist规则文件，replace为false表示自定义规则和内置的规则将会同时工作，如果发现内置规则与自定义规则冲突，可使用replace=true禁用内置规则效果。

设置的自定义规则文件在应用进程内对所有的Web组件生效，是一个应用级全局配置文件，并将持久化，应用重启后可继续工作。

### 关闭特定域名页面的广告过滤

在Web组件的广告过滤开关开启后，应用有时候会期望关闭一些特定页面的广告过滤功能，除了可以使用自定义的easylist规则，AdsBlockManager还提供了[addAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockdisallowedlist12)接口完成此功能。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. // 演示通过一个按钮的点击向Web组件设置广告过滤的域名策略
4. @Entry
5. @Component
6. struct WebComponent {
7.   main_url: string = 'https://www.example.com';
8.   text_input_controller: TextInputController = new TextInputController();
9.   controller: webview.WebviewController = new webview.WebviewController();

10.   @State input_text: string = 'https://www.example.com';

11.   build() {
12.     Column() {
13.       Row() {
14.         Flex() {
15.           TextInput({ text: this.input_text, placeholder: this.main_url, controller: this.text_input_controller})
16.             .id("input_url")
17.             .height(40)
18.             .margin(5)
19.             .borderColor(Color.Blue)
20.             .onChange((value: string) => {
21.               this.input_text = value;
22.             })

23.           Button({type: ButtonType.Capsule}) { Text("Go") }
24.           .onClick(() => {
25.             this.controller.loadUrl(this.input_text);
26.           })

27.           Button({type: ButtonType.Capsule}) { Text("addAdsBlockDisallowedList") }
28.           .onClick(() => {
29.             let arrDomainSuffixes = new Array<string>();
30.             arrDomainSuffixes.push('example.com');
31.             arrDomainSuffixes.push('abcdefg.cn');
32.             webview.AdsBlockManager.addAdsBlockDisallowedList(arrDomainSuffixes);
33.           })
34.         }
35.       }
36.       Web({ src: this.main_url, controller: this.controller })
37.         .onControllerAttached(()=>{
38.           this.controller.enableAdsBlock(true);
39.         })
40.     }
41.   }
42. }

[addAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockdisallowedlist12)接口将域名设置到AdsBlockManager的DisallowedList中，下次页面加载时会使用网页url和DisallowedList中的域名进行后缀匹配，匹配成功则不会对此页面进行广告过滤。此外，还提供了[addAdsBlockAllowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockallowedlist12)接口配合DisallowedList进行域名设置，控制是否开启广告过滤。

AdsBlockManager中缓存有2组域名列表，分别为DisallowedList和AllowList，其中DisallowedList用于禁用网页的广告过滤，而AllowList用于重新开启被DisallowedList关闭的广告过滤开关，其中AllowList优先级更高。页面加载时会先使用网页url和AllowList进行匹配，匹配成功的网页广告过滤将保持开启，否则将会继续使用DisallowedList进行匹配，匹配成功将关闭网页的广告过滤。如果访问的网页不在AllowList和DisallowedList中，那么默认网页的广告过滤会保持开启状态。

例如，应用想要开启域名为'news.example.com'和'sport.example.com'的广告过滤，但需要关闭'example.com'的其他域名下网页的广告过滤，就可以先使用addAdsBlockDisallowedList()接口添加'example.com'域名到DisallowedList，再使用[addAdsBlockDisallowedList()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-adsblockmanager#addadsblockdisallowedlist12)接口添加'news.example.com'和'sport.example.com'域名。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. // 演示addAdsBlockAllowedList和addAdsBlockAllowedList配套使用，设置网页级的广告过滤开关。
4. @Entry
5. @Component
6. struct WebComponent {
7.   main_url: string = 'https://www.example.com';
8.   text_input_controller: TextInputController = new TextInputController();
9.   controller: webview.WebviewController = new webview.WebviewController();

10.   @State input_text: string = 'https://www.example.com';

11.   build() {
12.     Column() {
13.       Row() {
14.         Flex() {
15.           TextInput({ text: this.input_text, placeholder: this.main_url, controller: this.text_input_controller})
16.             .id("input_url")
17.             .height(40)
18.             .margin(5)
19.             .borderColor(Color.Blue)
20.             .onChange((value: string) => {
21.               this.input_text = value;
22.             })

23.           Button({type: ButtonType.Capsule}) { Text("Go") }
24.           .onClick(() => {
25.             this.controller.loadUrl(this.input_text);
26.           })

27.           Button({type: ButtonType.Capsule}) { Text("addAdsBlockAllowedList") }
28.           .onClick(() => {
29.             let arrDisallowDomainSuffixes = new Array<string>();
30.             arrDisallowDomainSuffixes.push('example.com');
31.             webview.AdsBlockManager.addAdsBlockDisallowedList(arrDisallowDomainSuffixes);

32.             let arrAllowedDomainSuffixes = new Array<string>();
33.             arrAllowedDomainSuffixes.push('news.example.com');
34.             arrAllowedDomainSuffixes.push('sport.example.com');
35.             webview.AdsBlockManager.addAdsBlockAllowedList(arrAllowedDomainSuffixes);
36.           })
37.         }
38.       }
39.       Web({ src: this.main_url, controller: this.controller })
40.         .onControllerAttached(()=>{
41.           this.controller.enableAdsBlock(true);
42.         })
43.     }
44.   }
45. }

需要注意的是，AdsBlockManager的DisallowedList和AllowedList列表不会持久化，因此重启应用后会重置为空。

如果Web组件未通过[enableAdsBlock()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#enableadsblock12)接口开启广告过滤功能，上述接口设置在此Web组件中将不起作用。

### 收集广告过滤的信息

在Web组件的广告过滤开关开启后，访问的网页如果发生了广告过滤，会通过Web组件的[onAdsBlocked()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#onadsblocked12)回调接口通知到应用，应用可根据需要进行过滤信息的收集和统计。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct WebComponent {
6.   @State totalAdsBlockCounts: number = 0;
7.   controller: webview.WebviewController = new webview.WebviewController();

8.   build() {
9.     Column() {
10.       Web({ src: 'https://www.example.com', controller: this.controller })
11.         .onAdsBlocked((details: AdsBlockedDetails) => {
12.           if (details) {
13.             console.info(' Blocked ' + details.adsBlocked.length + ' in ' + details.url);
14.             let adList: Array<string> = Array.from(new Set(details.adsBlocked));
15.             this.totalAdsBlockCounts += adList.length;
16.             console.info('Total blocked counts :' + this.totalAdsBlockCounts);
17.           }
18.         })
19.     }
20.   }
21. }

由于页面可能随时发生变化并不断产生网络请求，为了减少通知频次、降低对页面加载过程的影响，仅在页面加载完成时进行首次通知，此后发生的过滤将间隔1秒钟上报，无广告过滤则无通知。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-intelligent-tracking-prevention "使用智能防跟踪功能")
# 使用Web组件加载页面

更新时间: 2025-12-16 16:38

页面加载是Web组件的基本功能。根据页面加载数据来源可以分为三种常用场景，包括加载网络页面、加载本地页面、加载HTML格式的富文本数据。

页面加载过程中，若涉及网络资源获取，请在module.json5中配置网络访问权限，添加方法请参考[在配置文件中声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions#%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A3%B0%E6%98%8E%E6%9D%83%E9%99%90)。

1. "requestPermissions":[
2.     {
3.       "name" : "ohos.permission.INTERNET"
4.     }
5.   ]

## 加载网络页面

开发者可以在Web组件创建时，指定默认加载的网络页面。在默认页面加载完成后，如果需要变更此Web组件显示的网络页面，可以通过调用[loadUrl()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loadurl)接口加载指定的网页。[Web组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web)的第一个参数变量src不能通过状态变量（例如：@State）动态更改地址，如需更改，请通过[loadUrl()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loadurl)重新加载。

在下面的示例中，在Web组件加载完“www.example.com”页面后，开发者可通过loadUrl接口将此Web组件显示页面变更为“www.example1.com”。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();

8.   build() {
9.     Column() {
10.       Button('loadUrl')
11.         .onClick(() => {
12.           try {
13.             // 点击按钮时，通过loadUrl，跳转到www.example1.com
14.             this.controller.loadUrl('www.example1.com');
15.           } catch (error) {
16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
17.           }
18.         })
19.       // 组件创建时，加载www.example.com
20.       Web({ src: 'www.example.com', controller: this.controller })
21.     }
22.   }
23. }

## 加载本地页面

为了在启动、跳转、弱网等场景下减少用户等待感知，同时为动态内容加载争取时间，可以加载本地页面优化用户体验。

在下面的示例中展示加载本地页面文件的方法：

将本地页面文件放在应用的rawfile目录下，开发者可以在Web组件创建的时候指定默认加载的本地页面，并且加载完成后可通过调用[loadUrl()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loadurl)接口变更当前Web组件的页面。

加载本地html文件时引用本地css样式文件可以通过以下方法实现。

1. <link rel="stylesheet" href="resource://rawfile/xxx.css">
2. <link rel="stylesheet" href="file:///data/storage/el2/base/haps/entry/cache/xxx.css">// 加载沙箱路径下的本地css文件。

- 将资源文件放置在应用的resources/rawfile目录下。
    
    **图1** 资源文件路径
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.70508290826519965898917409953022:50001231000000:2800:FAC5BBB00BF8F0031FBAE1AC1A058744A6BF3EB8809FAD0E2464004661E012F7.png)
    
- 应用侧代码。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('loadUrl')
    11.         .onClick(() => {
    12.           try {
    13.             // 点击按钮时，通过loadUrl，跳转到local1.html
    14.             this.controller.loadUrl($rawfile("local1.html"));
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       // 组件创建时，通过$rawfile加载本地文件local.html
    20.       Web({ src: $rawfile("local.html"), controller: this.controller })
    21.     }
    22.   }
    23. }
    
- local.html页面代码。
    
    1. <!-- local.html -->
    2. <!DOCTYPE html>
    3. <html>
    4.   <body>
    5.     <p>Hello World</p>
    6.   </body>
    7. </html>
    
- local1.html页面代码。
    
    1. <!-- local1.html -->
    2. <!DOCTYPE html>
    3. <html>
    4.   <body>
    5.     <p>This is local1 page</p>
    6.   </body>
    7. </html>
    

加载沙箱路径下的本地页面文件。

1. 通过构造的单例对象GlobalContext获取沙箱路径。需要开启应用中文件系统的访问[fileAccess](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#fileaccess)权限。
    
    1. // GlobalContext.ets
    2. export class GlobalContext {
    3.   private constructor() {}
    4.   private static instance: GlobalContext;
    5.   private _objects = new Map<string, Object>();
    
    6.   public static getContext(): GlobalContext {
    7.     if (!GlobalContext.instance) {
    8.       GlobalContext.instance = new GlobalContext();
    9.     }
    10.     return GlobalContext.instance;
    11.   }
    
    12.   getObject(value: string): Object | undefined {
    13.     return this._objects.get(value);
    14.   }
    
    15.   setObject(key: string, objectClass: Object): void {
    16.     this._objects.set(key, objectClass);
    17.   }
    18. }
    
    19. // xxx.ets
    20. import { webview } from '@kit.ArkWeb';
    21. import { GlobalContext } from '../GlobalContext';
    
    22. let url = 'file://' + GlobalContext.getContext().getObject("filesDir") + '/index.html';
    
    23. @Entry
    24. @Component
    25. struct WebComponent {
    26.   controller: webview.WebviewController = new webview.WebviewController();
    
    27.   build() {
    28.     Column() {
    29.       // 加载沙箱路径文件。
    30.       Web({ src: url, controller: this.controller })
    31.       .fileAccess(true)
    32.     }
    33.   }
    34. }
    
2. 修改EntryAbility.ets文件。
    
    以filesDir为例，获取沙箱路径。若想获取其他路径，请参考[应用文件路径](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-context-stage#%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84)。
    
    1. // xxx.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { webview } from '@kit.ArkWeb';
    4. import { GlobalContext } from '../GlobalContext';
    
    5. export default class EntryAbility extends UIAbility {
    6.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
    7.     // 通过在GlobalContext对象上绑定filesDir，可以实现UIAbility组件与UI之间的数据同步。
    8.     GlobalContext.getContext().setObject("filesDir", this.context.filesDir);
    9.     console.info("Sandbox path is " + GlobalContext.getContext().getObject("filesDir"));
    10.   }
    11. }
    
    加载的html文件。
    
    12. <!-- index.html -->
    13. <!DOCTYPE html>
    14. <html>
    15.     <body>
    16.         <p>Hello World</p>
    17.     </body>
    18. </html>
    

## 加载HTML格式的文本数据

Web组件可以通过[loadData()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loaddata)接口实现加载HTML格式的文本数据。当开发者不需要加载整个页面，只需要显示一些页面片段时，可通过此功能来快速加载页面，当加载大量html文件时，需设置第四个参数baseUrl为"data"。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();

8.   build() {
9.     Column() {
10.       Button('loadData')
11.         .onClick(() => {
12.           try {
13.             // 点击按钮时，通过loadData，加载HTML格式的文本数据
14.             this.controller.loadData(
15.               "<html><body bgcolor=\"white\">Source:<pre>source</pre></body></html>",
16.               "text/html",
17.               "UTF-8"
18.             );
19.           } catch (error) {
20.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
21.           }
22.         })
23.       // 组件创建时，加载www.example.com
24.       Web({ src: 'www.example.com', controller: this.controller })
25.     }
26.   }
27. }

Web组件可以通过data url方式直接加载HTML字符串。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();
8.   htmlStr: string = "data:text/html, <html><body bgcolor=\"white\">Source:<pre>source</pre></body></html>";

9.   build() {
10.     Column() {
11.       // 组件创建时，加载htmlStr
12.       Web({ src: this.htmlStr, controller: this.controller })
13.     }
14.   }
15. }

## resource协议加载本地资源

resource协议允许访问应用资源目录中的文件。

1. import { webview } from '@kit.ArkWeb';

2. @Entry
3. @Component
4. struct ResourceWebComponent {
5.   controller: webview.WebviewController = new webview.WebviewController();

6.   build() {
7.     Column() {
8.       Button('加载Resource资源')
9.         .onClick(() => {
10.           try {
11.             // 通过resource加载resources/rawfile目录下的index1.html文件
12.             this.controller.loadUrl('resource://rawfile/index1.html');
13.           } catch (error) {
14.             console.error(`ErrorCode: ${error.code}, Message: ${error.message}`);
15.           }
16.         })

17.       // 组件创建时直接使用resource协议加载资源
18.       Web({
19.         src: 'resource://rawfile/index.html', controller: this.controller})
20.     }
21.   }
22. }

在“src\main\resources\rawfile”文件夹下创建index.html：

1. <!-- index.html -->
2. <!DOCTYPE html>
3. <html>
4.   <body>
5.     <p>Hello World</p>
6.   </body>
7. </html>

在“src\main\resources\rawfile”文件夹下创建index1.html：

1. <!-- index1.html -->
2. <!DOCTYPE html>
3. <html>
4.   <body>
5.     <p>Hello World Again</p>
6.   </body>
7. </html>

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-manage-loading-browsing "管理网页加载与浏览记录")
# 使用Web组件加载页面

更新时间: 2025-12-16 16:38

页面加载是Web组件的基本功能。根据页面加载数据来源可以分为三种常用场景，包括加载网络页面、加载本地页面、加载HTML格式的富文本数据。

页面加载过程中，若涉及网络资源获取，请在module.json5中配置网络访问权限，添加方法请参考[在配置文件中声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions#%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A3%B0%E6%98%8E%E6%9D%83%E9%99%90)。

1. "requestPermissions":[
2.     {
3.       "name" : "ohos.permission.INTERNET"
4.     }
5.   ]

## 加载网络页面

开发者可以在Web组件创建时，指定默认加载的网络页面。在默认页面加载完成后，如果需要变更此Web组件显示的网络页面，可以通过调用[loadUrl()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loadurl)接口加载指定的网页。[Web组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web)的第一个参数变量src不能通过状态变量（例如：@State）动态更改地址，如需更改，请通过[loadUrl()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loadurl)重新加载。

在下面的示例中，在Web组件加载完“www.example.com”页面后，开发者可通过loadUrl接口将此Web组件显示页面变更为“www.example1.com”。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();

8.   build() {
9.     Column() {
10.       Button('loadUrl')
11.         .onClick(() => {
12.           try {
13.             // 点击按钮时，通过loadUrl，跳转到www.example1.com
14.             this.controller.loadUrl('www.example1.com');
15.           } catch (error) {
16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
17.           }
18.         })
19.       // 组件创建时，加载www.example.com
20.       Web({ src: 'www.example.com', controller: this.controller })
21.     }
22.   }
23. }

## 加载本地页面

为了在启动、跳转、弱网等场景下减少用户等待感知，同时为动态内容加载争取时间，可以加载本地页面优化用户体验。

在下面的示例中展示加载本地页面文件的方法：

将本地页面文件放在应用的rawfile目录下，开发者可以在Web组件创建的时候指定默认加载的本地页面，并且加载完成后可通过调用[loadUrl()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loadurl)接口变更当前Web组件的页面。

加载本地html文件时引用本地css样式文件可以通过以下方法实现。

1. <link rel="stylesheet" href="resource://rawfile/xxx.css">
2. <link rel="stylesheet" href="file:///data/storage/el2/base/haps/entry/cache/xxx.css">// 加载沙箱路径下的本地css文件。

- 将资源文件放置在应用的resources/rawfile目录下。
    
    **图1** 资源文件路径
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163827.70508290826519965898917409953022:50001231000000:2800:FAC5BBB00BF8F0031FBAE1AC1A058744A6BF3EB8809FAD0E2464004661E012F7.png)
    
- 应用侧代码。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   controller: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Button('loadUrl')
    11.         .onClick(() => {
    12.           try {
    13.             // 点击按钮时，通过loadUrl，跳转到local1.html
    14.             this.controller.loadUrl($rawfile("local1.html"));
    15.           } catch (error) {
    16.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
    17.           }
    18.         })
    19.       // 组件创建时，通过$rawfile加载本地文件local.html
    20.       Web({ src: $rawfile("local.html"), controller: this.controller })
    21.     }
    22.   }
    23. }
    
- local.html页面代码。
    
    1. <!-- local.html -->
    2. <!DOCTYPE html>
    3. <html>
    4.   <body>
    5.     <p>Hello World</p>
    6.   </body>
    7. </html>
    
- local1.html页面代码。
    
    1. <!-- local1.html -->
    2. <!DOCTYPE html>
    3. <html>
    4.   <body>
    5.     <p>This is local1 page</p>
    6.   </body>
    7. </html>
    

加载沙箱路径下的本地页面文件。

1. 通过构造的单例对象GlobalContext获取沙箱路径。需要开启应用中文件系统的访问[fileAccess](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-attributes#fileaccess)权限。
    
    1. // GlobalContext.ets
    2. export class GlobalContext {
    3.   private constructor() {}
    4.   private static instance: GlobalContext;
    5.   private _objects = new Map<string, Object>();
    
    6.   public static getContext(): GlobalContext {
    7.     if (!GlobalContext.instance) {
    8.       GlobalContext.instance = new GlobalContext();
    9.     }
    10.     return GlobalContext.instance;
    11.   }
    
    12.   getObject(value: string): Object | undefined {
    13.     return this._objects.get(value);
    14.   }
    
    15.   setObject(key: string, objectClass: Object): void {
    16.     this._objects.set(key, objectClass);
    17.   }
    18. }
    
    19. // xxx.ets
    20. import { webview } from '@kit.ArkWeb';
    21. import { GlobalContext } from '../GlobalContext';
    
    22. let url = 'file://' + GlobalContext.getContext().getObject("filesDir") + '/index.html';
    
    23. @Entry
    24. @Component
    25. struct WebComponent {
    26.   controller: webview.WebviewController = new webview.WebviewController();
    
    27.   build() {
    28.     Column() {
    29.       // 加载沙箱路径文件。
    30.       Web({ src: url, controller: this.controller })
    31.       .fileAccess(true)
    32.     }
    33.   }
    34. }
    
2. 修改EntryAbility.ets文件。
    
    以filesDir为例，获取沙箱路径。若想获取其他路径，请参考[应用文件路径](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-context-stage#%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84)。
    
    1. // xxx.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { webview } from '@kit.ArkWeb';
    4. import { GlobalContext } from '../GlobalContext';
    
    5. export default class EntryAbility extends UIAbility {
    6.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
    7.     // 通过在GlobalContext对象上绑定filesDir，可以实现UIAbility组件与UI之间的数据同步。
    8.     GlobalContext.getContext().setObject("filesDir", this.context.filesDir);
    9.     console.info("Sandbox path is " + GlobalContext.getContext().getObject("filesDir"));
    10.   }
    11. }
    
    加载的html文件。
    
    12. <!-- index.html -->
    13. <!DOCTYPE html>
    14. <html>
    15.     <body>
    16.         <p>Hello World</p>
    17.     </body>
    18. </html>
    

## 加载HTML格式的文本数据

Web组件可以通过[loadData()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#loaddata)接口实现加载HTML格式的文本数据。当开发者不需要加载整个页面，只需要显示一些页面片段时，可通过此功能来快速加载页面，当加载大量html文件时，需设置第四个参数baseUrl为"data"。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();

8.   build() {
9.     Column() {
10.       Button('loadData')
11.         .onClick(() => {
12.           try {
13.             // 点击按钮时，通过loadData，加载HTML格式的文本数据
14.             this.controller.loadData(
15.               "<html><body bgcolor=\"white\">Source:<pre>source</pre></body></html>",
16.               "text/html",
17.               "UTF-8"
18.             );
19.           } catch (error) {
20.             console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as BusinessError).message}`);
21.           }
22.         })
23.       // 组件创建时，加载www.example.com
24.       Web({ src: 'www.example.com', controller: this.controller })
25.     }
26.   }
27. }

Web组件可以通过data url方式直接加载HTML字符串。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';
3. import { BusinessError } from '@kit.BasicServicesKit';

4. @Entry
5. @Component
6. struct WebComponent {
7.   controller: webview.WebviewController = new webview.WebviewController();
8.   htmlStr: string = "data:text/html, <html><body bgcolor=\"white\">Source:<pre>source</pre></body></html>";

9.   build() {
10.     Column() {
11.       // 组件创建时，加载htmlStr
12.       Web({ src: this.htmlStr, controller: this.controller })
13.     }
14.   }
15. }

## resource协议加载本地资源

resource协议允许访问应用资源目录中的文件。

1. import { webview } from '@kit.ArkWeb';

2. @Entry
3. @Component
4. struct ResourceWebComponent {
5.   controller: webview.WebviewController = new webview.WebviewController();

6.   build() {
7.     Column() {
8.       Button('加载Resource资源')
9.         .onClick(() => {
10.           try {
11.             // 通过resource加载resources/rawfile目录下的index1.html文件
12.             this.controller.loadUrl('resource://rawfile/index1.html');
13.           } catch (error) {
14.             console.error(`ErrorCode: ${error.code}, Message: ${error.message}`);
15.           }
16.         })

17.       // 组件创建时直接使用resource协议加载资源
18.       Web({
19.         src: 'resource://rawfile/index.html', controller: this.controller})
20.     }
21.   }
22. }

在“src\main\resources\rawfile”文件夹下创建index.html：

1. <!-- index.html -->
2. <!DOCTYPE html>
3. <html>
4.   <body>
5.     <p>Hello World</p>
6.   </body>
7. </html>

在“src\main\resources\rawfile”文件夹下创建index1.html：

1. <!-- index1.html -->
2. <!DOCTYPE html>
3. <html>
4.   <body>
5.     <p>Hello World Again</p>
6.   </body>
7. </html>

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-manage-loading-browsing "管理网页加载与浏览记录")
# 管理页面跳转及浏览记录导航

更新时间: 2025-12-16 16:38

为了提高页面访问速度，浏览记录导航允许用户通过“前进”和“后退”按钮在历史记录的页面之间切换。Web组件允许用户能够跳转到应用内其他页面或者进行跨应用跳转。

## 历史记录导航

在前端页面点击网页中的链接时，Web组件默认会自动打开并加载目标网址。当前端页面替换为新的加载链接时，会自动记录已经访问的网页地址。可以通过[forward()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#forward)和[backward()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#backward)接口向前/向后浏览上一个/下一个历史记录。

页面加载涉及网络资源时，需在module.json5中配置网络访问权限，添加方法请参考[在配置文件中声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions#%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A3%B0%E6%98%8E%E6%9D%83%E9%99%90)。

1. "requestPermissions":[
2.     {
3.       "name" : "ohos.permission.INTERNET"
4.     }
5.   ]

在以下示例中，通过点击应用按钮来触发前端页面的后退操作。

1. // xxx.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct WebComponent {
6.   webviewController: webview.WebviewController = new webview.WebviewController();

7.   build() {
8.     Column() {
9.       Button('loadData')
10.         .onClick(() => {
11.           if (this.webviewController.accessBackward()) {
12.             this.webviewController.backward();
13.           }
14.         })
15.       Web({ src: 'https://www.example.com/cn/', controller: this.webviewController })
16.     }
17.   }
18. }

如果存在历史记录，[accessBackward()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#accessbackward)接口将返回true。同样，开发者可以使用[accessForward()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#accessforward)接口检查是否存在前进的历史记录。如果未执行检查，当用户浏览到历史记录的末尾时，调用[forward()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#forward)和[backward()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#backward)接口将不会执行任何操作。

## 页面跳转

当点击页面中的链接需要跳转到应用内其他页面时，可以通过使用Web组件的[onLoadIntercept()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-events#onloadintercept10)接口来实现。

在下面的示例中，应用首页Index.ets加载前端页面route.html，在route.html页面点击'个人中心'超链接，可跳转到应用的ProfilePage.ets页面。

- 应用首页Index.ets页面代码。
    
    1. // index.ets
    2. import { webview } from '@kit.ArkWeb';
    
    3. @Entry
    4. @Component
    5. struct WebComponent {
    6.   webviewController: webview.WebviewController = new webview.WebviewController();
    
    7.   build() {
    8.     Column() {
    9.       // 资源文件route.html存放路径src/main/resources/rawfile
    10.       Web({ src: $rawfile('route.html'), controller: this.webviewController })
    11.         .onLoadIntercept((event) => {
    12.           if (event) {
    13.             let url: string = event.data.getRequestUrl();
    14.             if (url.indexOf('native://') === 0) {
    15.               // 跳转其他界面
    16.               this.getUIContext().getRouter().pushUrl({ url: url.substring(9) });
    17.               return true;
    18.             }
    19.           }
    20.           return false;
    21.         })
    22.     }
    23.   }
    24. }
    
- route.html前端页面代码。
    
    1. <!-- route.html -->
    2. <!DOCTYPE html>
    3. <html>
    4. <body>
    5.   <div>
    6.       <a href="native://pages/ProfilePage">个人中心</a>
    7.    </div>
    8. </body>
    9. </html>
    
- 跳转页面ProfilePage.ets代码。
    
    1. @Entry
    2. @Component
    3. struct ProfilePage {
    4.   @State message: string = 'Hello World';
    
    5.   build() {
    6.     Column() {
    7.       Text(this.message)
    8.         .fontSize(20)
    9.     }
    10.   }
    11. }
    

## 跨应用跳转

Web组件可以实现点击前端页面超链接跳转到其他应用。

在下面的示例代码中，点击call.html前端页面中的超链接，可以跳转到电话应用的拨号界面。

- 应用侧代码。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    3. import { call } from '@kit.TelephonyKit';
    
    4. @Entry
    5. @Component
    6. struct WebComponent {
    7.   webviewController: webview.WebviewController = new webview.WebviewController();
    
    8.   build() {
    9.     Column() {
    10.       Web({ src: $rawfile('call.html'), controller: this.webviewController })
    11.         .onLoadIntercept((event) => {
    12.           if (event) {
    13.             let url: string = event.data.getRequestUrl();
    14.             // 判断链接是否为拨号链接
    15.             if (url.indexOf('tel://') === 0) {
    16.               // 跳转拨号界面
    17.               call.makeCall(url.substring(6), (err) => {
    18.                 if (!err) {
    19.                   console.info('make call succeeded.');
    20.                 } else {
    21.                   console.info('make call fail, err is:' + JSON.stringify(err));
    22.                 }
    23.               });
    24.               return true;
    25.             }
    26.           }
    27.           return false;
    28.         })
    29.     }
    30.   }
    31. }
    
- 前端页面call.html代码。
    
    1. <!-- call.html -->
    2. <!DOCTYPE html>
    3. <html>
    4. <body>
    5.   <div>
    6.     <a href="tel://***********">拨打电话</a>
    7.   </div>
    8. </body>
    9. </html>
    

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163835.64863855406089619851938682141721:50001231000000:2800:F2F5AA87BAA7FC93DDD1847C61BA85D2E6F9912F12F514797F51752D3FB5C75A.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-page-loading-with-web-components "使用Web组件加载页面")
# 自定义页面请求响应

更新时间: 2025-12-16 16:38

Web组件支持在应用拦截到页面请求后自定义响应请求能力。开发者通过[onInterceptRequest()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-events#oninterceptrequest9)接口来实现自定义资源请求响应 。自定义请求能力可以用于开发者自定义Web页面响应、自定义文件资源响应等场景。

Web网页上发起资源加载请求，应用层收到资源请求信息。应用层构造本地资源响应信息发送给Web内核。Web内核解析应用层响应信息，根据此响应信息进行页面资源加载。

在下面的示例中，Web组件通过拦截页面请求“https://www.example.com/test.html”， 在应用侧代码构建响应资源，实现自定义页面响应场景。

- 前端页面index.html代码。
    
    1. <!DOCTYPE html>
    2. <html>
    3. <head>
    4.     <meta charset="utf-8">
    5. </head>
    6. <body>
    7. <!-- 页面资源请求 -->
    8. <a href="https://www.example.com/test.html">intercept test!</a>
    9. </body>
    10. </html>
    
- 应用侧代码。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    
    3. @Entry
    4. @Component
    5. struct WebComponent {
    6.   controller: webview.WebviewController = new webview.WebviewController();
    7.   responseResource: WebResourceResponse = new WebResourceResponse();
    8.   // 开发者自定义响应数据
    9.   @State webData: string = '<!DOCTYPE html>\n' +
    10.     '<html>\n' +
    11.     '<head>\n' +
    12.     '<title>intercept test</title>\n' +
    13.     '</head>\n' +
    14.     '<body>\n' +
    15.     '<h1>intercept ok</h1>\n' +
    16.     '</body>\n' +
    17.     '</html>'
    
    18.   build() {
    19.     Column() {
    20.       Web({ src: $rawfile('index.html'), controller: this.controller })
    21.         .onInterceptRequest((event) => {
    22.           if (event) {
    23.             console.info('url:' + event.request.getRequestUrl());
    24.             // 拦截页面请求
    25.             if (event.request.getRequestUrl() !== 'https://www.example.com/test.html') {
    26.               return null;
    27.             }
    28.           }
    29.           // 构造响应数据
    30.           this.responseResource.setResponseData(this.webData);
    31.           this.responseResource.setResponseEncoding('utf-8');
    32.           this.responseResource.setResponseMimeType('text/html');
    33.           this.responseResource.setResponseCode(200);
    34.           this.responseResource.setReasonMessage('OK');
    35.           return this.responseResource;
    36.         })
    37.     }
    38.   }
    39. }
    
- 被拦截后的页面
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163844.29846892203777812137917333698518:50001231000000:2800:D316096630200A64C7B89A66DF1618C17BA6C4EA1C0C5DA1F323BB1465F20E8E.png)
    

为自定义的JavaScript请求响应生成 CodeCache：自定义请求响应的资源类型如果是JavaScript脚本，可以在响应头中添加“ResponseDataID”字段，Web内核读取到该字段后会在为该JS资源生成CodeCache，加速JS执行，并且ResponseData如果有更新时必须更新该字段。不添加“ResponseDataID”字段的情况下默认不生成CodeCache。

在下面的示例中，Web组件通过拦截页面请求“https://www.example.com/test.js”， 应用侧代码构建响应资源，在响应头中添加“ResponseDataID”字段，开启生成CodeCache的功能。

- 前端页面index.html代码。
    
    1. <!DOCTYPE html>
    2. <html>
    3. <head>
    4.     <meta charset="utf-8">
    5. </head>
    6. <body>
    
    7. <div id="div-1">this is a test div</div>
    8. <div id="div-2">this is a test div</div>
    9. <div id="div-3">this is a test div</div>
    10. <div id="div-4">this is a test div</div>
    11. <div id="div-5">this is a test div</div>
    12. <div id="div-6">this is a test div</div>
    13. <div id="div-7">this is a test div</div>
    14. <div id="div-8">this is a test div</div>
    15. <div id="div-9">this is a test div</div>
    16. <div id="div-10">this is a test div</div>
    17. <div id="div-11">this is a test div</div>
    
    18. <script src="https://www.example.com/test.js"></script>
    19. </body>
    20. </html>
    
- 应用侧代码。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    
    3. @Entry
    4. @Component
    5. struct WebComponent {
    6.   controller: webview.WebviewController = new webview.WebviewController();
    7.   responseResource: WebResourceResponse = new WebResourceResponse();
    8.   // 开发者自定义响应数据（响应数据长度需大于等于1024才会生成codecache）
    9.   @State jsData: string = 'let text_msg = "the modified content:version 0000000000001";\n' +
    10.     'let element1 = window.document.getElementById("div-1");\n' +
    11.     'let element2 = window.document.getElementById("div-2");\n' +
    12.     'let element3 = window.document.getElementById("div-3");\n' +
    13.     'let element4 = window.document.getElementById("div-4");\n' +
    14.     'let element5 = window.document.getElementById("div-5");\n' +
    15.     'let element6 = window.document.getElementById("div-6");\n' +
    16.     'let element7 = window.document.getElementById("div-7");\n' +
    17.     'let element8 = window.document.getElementById("div-8");\n' +
    18.     'let element9 = window.document.getElementById("div-9");\n' +
    19.     'let element10 = window.document.getElementById("div-10");\n' +
    20.     'let element11 = window.document.getElementById("div-11");\n' +
    21.     'element1.innerHTML = text_msg;\n' +
    22.     'element2.innerHTML = text_msg;\n' +
    23.     'element3.innerHTML = text_msg;\n' +
    24.     'element4.innerHTML = text_msg;\n' +
    25.     'element5.innerHTML = text_msg;\n' +
    26.     'element6.innerHTML = text_msg;\n' +
    27.     'element7.innerHTML = text_msg;\n' +
    28.     'element8.innerHTML = text_msg;\n' +
    29.     'element9.innerHTML = text_msg;\n' +
    30.     'element10.innerHTML = text_msg;\n' +
    31.     'element11.innerHTML = text_msg;\n';
    
    32.   build() {
    33.     Column() {
    34.       Web({ src: $rawfile('index.html'), controller: this.controller })
    35.         .onInterceptRequest((event) => {
    36.           // 拦截页面请求
    37.           if (event?.request.getRequestUrl() == 'https://www.example.com/test.js') {
    38.             // 构造响应数据
    39.             this.responseResource.setResponseHeader([
    40.               {
    41.                 // 格式：不超过13位纯数字。js识别码，Js有更新时必须更新该字段
    42.                 headerKey: "ResponseDataID",
    43.                 headerValue: "0000000000001"
    44.               }]);
    45.             this.responseResource.setResponseData(this.jsData);
    46.             this.responseResource.setResponseEncoding('utf-8');
    47.             this.responseResource.setResponseMimeType('application/javascript');
    48.             this.responseResource.setResponseCode(200);
    49.             this.responseResource.setReasonMessage('OK');
    50.             return this.responseResource;
    51.           }
    52.           return null;
    53.         })
    54.     }
    55.   }
    56. }
    
- 被拦截后的页面
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163844.07987935820632823342657877706221:50001231000000:2800:9E4F13E5136771DBE1A13DA403060A2B7A87084DEF022A53252FD37CC7F4C5C9.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-scheme-handler "拦截Web组件发起的网络请求")
# 自定义页面请求响应

更新时间: 2025-12-16 16:38

Web组件支持在应用拦截到页面请求后自定义响应请求能力。开发者通过[onInterceptRequest()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-basic-components-web-events#oninterceptrequest9)接口来实现自定义资源请求响应 。自定义请求能力可以用于开发者自定义Web页面响应、自定义文件资源响应等场景。

Web网页上发起资源加载请求，应用层收到资源请求信息。应用层构造本地资源响应信息发送给Web内核。Web内核解析应用层响应信息，根据此响应信息进行页面资源加载。

在下面的示例中，Web组件通过拦截页面请求“https://www.example.com/test.html”， 在应用侧代码构建响应资源，实现自定义页面响应场景。

- 前端页面index.html代码。
    
    1. <!DOCTYPE html>
    2. <html>
    3. <head>
    4.     <meta charset="utf-8">
    5. </head>
    6. <body>
    7. <!-- 页面资源请求 -->
    8. <a href="https://www.example.com/test.html">intercept test!</a>
    9. </body>
    10. </html>
    
- 应用侧代码。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    
    3. @Entry
    4. @Component
    5. struct WebComponent {
    6.   controller: webview.WebviewController = new webview.WebviewController();
    7.   responseResource: WebResourceResponse = new WebResourceResponse();
    8.   // 开发者自定义响应数据
    9.   @State webData: string = '<!DOCTYPE html>\n' +
    10.     '<html>\n' +
    11.     '<head>\n' +
    12.     '<title>intercept test</title>\n' +
    13.     '</head>\n' +
    14.     '<body>\n' +
    15.     '<h1>intercept ok</h1>\n' +
    16.     '</body>\n' +
    17.     '</html>'
    
    18.   build() {
    19.     Column() {
    20.       Web({ src: $rawfile('index.html'), controller: this.controller })
    21.         .onInterceptRequest((event) => {
    22.           if (event) {
    23.             console.info('url:' + event.request.getRequestUrl());
    24.             // 拦截页面请求
    25.             if (event.request.getRequestUrl() !== 'https://www.example.com/test.html') {
    26.               return null;
    27.             }
    28.           }
    29.           // 构造响应数据
    30.           this.responseResource.setResponseData(this.webData);
    31.           this.responseResource.setResponseEncoding('utf-8');
    32.           this.responseResource.setResponseMimeType('text/html');
    33.           this.responseResource.setResponseCode(200);
    34.           this.responseResource.setReasonMessage('OK');
    35.           return this.responseResource;
    36.         })
    37.     }
    38.   }
    39. }
    
- 被拦截后的页面
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163844.29846892203777812137917333698518:50001231000000:2800:D316096630200A64C7B89A66DF1618C17BA6C4EA1C0C5DA1F323BB1465F20E8E.png)
    

为自定义的JavaScript请求响应生成 CodeCache：自定义请求响应的资源类型如果是JavaScript脚本，可以在响应头中添加“ResponseDataID”字段，Web内核读取到该字段后会在为该JS资源生成CodeCache，加速JS执行，并且ResponseData如果有更新时必须更新该字段。不添加“ResponseDataID”字段的情况下默认不生成CodeCache。

在下面的示例中，Web组件通过拦截页面请求“https://www.example.com/test.js”， 应用侧代码构建响应资源，在响应头中添加“ResponseDataID”字段，开启生成CodeCache的功能。

- 前端页面index.html代码。
    
    1. <!DOCTYPE html>
    2. <html>
    3. <head>
    4.     <meta charset="utf-8">
    5. </head>
    6. <body>
    
    7. <div id="div-1">this is a test div</div>
    8. <div id="div-2">this is a test div</div>
    9. <div id="div-3">this is a test div</div>
    10. <div id="div-4">this is a test div</div>
    11. <div id="div-5">this is a test div</div>
    12. <div id="div-6">this is a test div</div>
    13. <div id="div-7">this is a test div</div>
    14. <div id="div-8">this is a test div</div>
    15. <div id="div-9">this is a test div</div>
    16. <div id="div-10">this is a test div</div>
    17. <div id="div-11">this is a test div</div>
    
    18. <script src="https://www.example.com/test.js"></script>
    19. </body>
    20. </html>
    
- 应用侧代码。
    
    1. // xxx.ets
    2. import { webview } from '@kit.ArkWeb';
    
    3. @Entry
    4. @Component
    5. struct WebComponent {
    6.   controller: webview.WebviewController = new webview.WebviewController();
    7.   responseResource: WebResourceResponse = new WebResourceResponse();
    8.   // 开发者自定义响应数据（响应数据长度需大于等于1024才会生成codecache）
    9.   @State jsData: string = 'let text_msg = "the modified content:version 0000000000001";\n' +
    10.     'let element1 = window.document.getElementById("div-1");\n' +
    11.     'let element2 = window.document.getElementById("div-2");\n' +
    12.     'let element3 = window.document.getElementById("div-3");\n' +
    13.     'let element4 = window.document.getElementById("div-4");\n' +
    14.     'let element5 = window.document.getElementById("div-5");\n' +
    15.     'let element6 = window.document.getElementById("div-6");\n' +
    16.     'let element7 = window.document.getElementById("div-7");\n' +
    17.     'let element8 = window.document.getElementById("div-8");\n' +
    18.     'let element9 = window.document.getElementById("div-9");\n' +
    19.     'let element10 = window.document.getElementById("div-10");\n' +
    20.     'let element11 = window.document.getElementById("div-11");\n' +
    21.     'element1.innerHTML = text_msg;\n' +
    22.     'element2.innerHTML = text_msg;\n' +
    23.     'element3.innerHTML = text_msg;\n' +
    24.     'element4.innerHTML = text_msg;\n' +
    25.     'element5.innerHTML = text_msg;\n' +
    26.     'element6.innerHTML = text_msg;\n' +
    27.     'element7.innerHTML = text_msg;\n' +
    28.     'element8.innerHTML = text_msg;\n' +
    29.     'element9.innerHTML = text_msg;\n' +
    30.     'element10.innerHTML = text_msg;\n' +
    31.     'element11.innerHTML = text_msg;\n';
    
    32.   build() {
    33.     Column() {
    34.       Web({ src: $rawfile('index.html'), controller: this.controller })
    35.         .onInterceptRequest((event) => {
    36.           // 拦截页面请求
    37.           if (event?.request.getRequestUrl() == 'https://www.example.com/test.js') {
    38.             // 构造响应数据
    39.             this.responseResource.setResponseHeader([
    40.               {
    41.                 // 格式：不超过13位纯数字。js识别码，Js有更新时必须更新该字段
    42.                 headerKey: "ResponseDataID",
    43.                 headerValue: "0000000000001"
    44.               }]);
    45.             this.responseResource.setResponseData(this.jsData);
    46.             this.responseResource.setResponseEncoding('utf-8');
    47.             this.responseResource.setResponseMimeType('application/javascript');
    48.             this.responseResource.setResponseCode(200);
    49.             this.responseResource.setReasonMessage('OK');
    50.             return this.responseResource;
    51.           }
    52.           return null;
    53.         })
    54.     }
    55.   }
    56. }
    
- 被拦截后的页面
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163844.07987935820632823342657877706221:50001231000000:2800:9E4F13E5136771DBE1A13DA403060A2B7A87084DEF022A53252FD37CC7F4C5C9.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-scheme-handler "拦截Web组件发起的网络请求")
# 设置Web组件前进后退缓存

更新时间: 2025-12-16 16:38

Web组件为开发者提供了启用和配置前进后退缓存（以下简称BFCache）的功能。启用此功能后，能够显著提升用户返回至先前浏览网页的速度，尤其对于网络条件不佳的用户，可提供更为流畅的浏览体验。

BFCache功能启用后，Web组件会在用户离开当前页面时在内存中保存该页面的快照。当用户在短期内通过Web组件的前进或后退功能重新访问同一页面时，能够迅速恢复页面状态，避免重复发起HTTP请求。

## Web组件开启BFCache

开发者需要在调用[initializeWebEngine()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#initializewebengine)初始化ArkWeb内核之前调用[enableBackForwardCache()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#enablebackforwardcache12)来开启BFCache。enableBackForwardCache可以接收一个[BackForwardCacheSupportedFeatures](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/kts-apis-webview-backforwardcachesupportedfeatures)参数，用于控制是否允许具备同层渲染特性和视频托管特性的页面进入BFCache。

1. // EntryAbility.ets
2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
3. import { hilog } from '@kit.PerformanceAnalysisKit';
4. import { window } from '@kit.ArkUI';
5. import { webview } from '@kit.ArkWeb';

6. export default class EntryAbility extends UIAbility {
7.     onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
8.         let features = new webview.BackForwardCacheSupportedFeatures();
9.         features.nativeEmbed = true;
10.         features.mediaTakeOver = true;
11.         webview.WebviewController.enableBackForwardCache(features);
12.         webview.WebviewController.initializeWebEngine();
13.         AppStorage.setOrCreate("abilityWant", want);
14.     }
15. }

## 设置缓存的页面数量和页面留存的时间

启用BFCache后仅能存储一个页面，Web组件默认进入BFCache的页面可保持存活状态600秒。开发者可通过调用[setBackForwardCacheOptions()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller#setbackforwardcacheoptions12)设置每个Web实例的前进后退缓存策略。包括调整缓存中页面的最大数量，使BFCache能够容纳更多页面，从而在用户连续进行前进后退操作时，提供更快的加载速度。同时，开发者还能修改每个页面在缓存中的停留时间，延长页面在BFCache中的驻留期限，进而优化用户的浏览体验。

在下面的示例中，设置Web组件可以缓存的最大数量为10，每个页面在缓存中停留300s。

1. // Index.ets
2. import { webview } from '@kit.ArkWeb';

3. @Entry
4. @Component
5. struct Index {
6.   controller: webview.WebviewController = new webview.WebviewController();

7.   build() {
8.     Column() {
9.       Row() {
10.         Button("Add options").onClick((event: ClickEvent) => {
11.           let options = new webview.BackForwardCacheOptions();
12.           options.size = 10;
13.           options.timeToLive = 300;
14.           this.controller.setBackForwardCacheOptions(options);
15.         })
16.         Button("Backward").onClick((event: ClickEvent) => {
17.           this.controller.backward();
18.         })
19.         Button("Forward").onClick((event: ClickEvent) => {
20.           this.controller.forward();
21.         })
22.       }
23.       Web({ src: "https://www.example.com", controller: this.controller })
24.     }
25.     .height('100%')
26.     .width('100%')
27.   }
28. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-predictor "加速Web页面的访问")
# Web组件在不同的窗口间迁移

更新时间: 2025-12-16 16:38

Web组件能够实现在不同窗口的组件树上进行挂载或移除操作，这一能力使得开发者可以将同一个Web组件在不同窗口间迁移。例如，将浏览器的Tab页拖出成独立窗口，或拖入浏览器的另一个窗口。

Web组件在不同窗口间迁移，是基于[自定义节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-node)能力实现的。实现的基本原理是：通过[BuilderNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-arktsnode-buildernode)，开发者可创建Web组件的离线节点，并结合[自定义占位节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-place-holder)控制Web节点的挂载与移除。当从一个窗口上移除Web节点，并挂载到另一个窗口中，即完成Web组件在窗口间的迁移。

在以下示例中，主窗Ability启动时，通过命令式的方式创建了一个Web组件。开发者可以利用common.ets中提供的方法和类，实现Web组件的挂载和移除。Index.ets则提供了一种挂载和移除Web组件的实现方法。通过这种方式，开发者能够实现Web组件在不同窗口中页面的挂载与移除，即实现了Web组件在不同窗口间的迁移。下图是展示了这一迁移过程的示意图。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163850.92574847167675142092357627798661:50001231000000:2800:7463D5F69388421FC60F2B7D352915FA4F09183FA8BE8D8D4D646F6EA705A7BA.png)

说明

不要将一个Web组件同时挂载在两个父节点下，这会导致非预期行为。

1. // 主窗Ability
2. // EntryAbility.ets
3. import { createNWeb, defaultUrl } from '../pages/common'

4. // ...

5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

7.     windowStage.loadContent('pages/Index', (err) => {
8.       if (err && err.code) {
9.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
10.         return;
11.       }
12.       // 创建Web动态组件（需传入UIContext），loadContent之后的任意时机均可创建，应用仅创建一个Web组件
13.       createNWeb(defaultUrl, windowStage.getMainWindowSync().getUIContext());
14.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
15.     });
16.   }

17. // ...

18. // 提供动态挂载Web组件能力
19. // pages/common.ets
20. import { UIContext, NodeController, BuilderNode, FrameNode } from '@kit.ArkUI';
21. import { webview } from '@kit.ArkWeb';
22. import { hilog } from '@kit.PerformanceAnalysisKit';

23. export const defaultUrl : string = 'https://www.example.com';

24. // Data为入参封装类
25. class Data{
26.   url: string = '';
27.   webController: webview.WebviewController | null = null;

28.   constructor(url: string, webController: webview.WebviewController) {
29.     this.url = url;
30.     this.webController = webController;
31.   }
32. }

33. // @Builder中为动态组件的具体组件内容
34. @Builder
35. function WebBuilder(data:Data) {
36.   Web({ src: data.url, controller: data.webController })
37.     .width("100%")
38.     .height("100%")
39.     .borderStyle(BorderStyle.Dashed)
40.     .borderWidth(2)
41. }

42. let wrap = wrapBuilder<[Data]>(WebBuilder);

43. // 用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用
44. export class MyNodeController extends NodeController {
45.   private builderNode: BuilderNode<[Data]> | null | undefined = null;
46.   private webController : webview.WebviewController | null | undefined = null;
47.   private rootNode : FrameNode | null = null;

48.   constructor(builderNode : BuilderNode<[Data]> | undefined, webController : webview.WebviewController | undefined) {
49.     super();
50.     this.builderNode = builderNode;
51.     this.webController = webController;
52.   }

53.   // 必须要重写的方法，用于构建节点数、返回节点挂载在对应NodeContainer中
54.   // 在对应NodeContainer创建的时候调用或者通过rebuild方法调用刷新
55.   makeNode(uiContext: UIContext): FrameNode | null {
56.     // 该节点会被挂载在NodeContainer的父节点下
57.     return this.rootNode;
58.   }

59.   // 挂载Webview
60.   attachWeb() : void {
61.     if (this.builderNode) {
62.       let frameNode : FrameNode | null = this.builderNode.getFrameNode();
63.       if (frameNode?.getParent() != null) {
64.         // 挂载自定义节点前判断该节点是否已经被挂载
65.         hilog.error(0x0000, 'testTag', '%{public}s', 'The frameNode is already attached');
66.         return;
67.       }
68.       this.rootNode = this.builderNode.getFrameNode();
69.     }
70.   }

71.   // 卸载Webview
72.   detachWeb() : void {
73.     this.rootNode = null;
74.   }

75.   getWebController() : webview.WebviewController | null | undefined {
76.     return this.webController;
77.   }
78. }

79. // 创建Map保存所需要的BuilderNode
80. let builderNodeMap : Map<string, BuilderNode<[Data]> | undefined> = new Map();
81. // 创建Map保存所需要的webview.WebviewController
82. let webControllerMap : Map<string, webview.WebviewController | undefined> = new Map();

83. // 初始化需要UIContext对象，UIContext对象可通过窗口或自定义组件的getUIContext方法获取
84. export const createNWeb = (url: string, uiContext: UIContext) => {
85.   // 创建WebviewController
86.   let webController = new webview.WebviewController() ;
87.   // 创建BuilderNode
88.   let builderNode : BuilderNode<[Data]> = new BuilderNode(uiContext);
89.   // 创建动态Web组件
90.   builderNode.build(wrap, new Data(url, webController));

91.   // 保存BuilderNode
92.   builderNodeMap.set(url, builderNode);
93.   // 保存WebviewController
94.   webControllerMap.set(url, webController);
95. }

96. // 自定义获取BuilderNode的接口
97. export const getBuilderNode = (url : string) : BuilderNode<[Data]> | undefined => {
98.   return builderNodeMap.get(url);
99. }
100. // 自定义获取WebviewController的接口
101. export const getWebviewController = (url : string) : webview.WebviewController | undefined => {
102.   return webControllerMap.get(url);
103. }

104. // 使用NodeController的Page页
105. // pages/Index.ets
106. import { getBuilderNode, MyNodeController, defaultUrl, getWebviewController } from "./common"

107. @Entry
108. @Component
109. struct Index {
110.   private nodeController : MyNodeController =
111.     new MyNodeController(getBuilderNode(defaultUrl), getWebviewController(defaultUrl));

112.   build() {
113.     Row() {
114.       Column() {
115.         Button("Attach Webview")
116.           .onClick(() => {
117.             // 注意不要将同一个节点同时挂载在不同的页面上！
118.             this.nodeController.attachWeb();
119.             this.nodeController.rebuild();
120.           })
121.         Button("Detach Webview")
122.           .onClick(() => {
123.             this.nodeController.detachWeb();
124.             this.nodeController.rebuild();
125.           })
126.         // NodeContainer用于与NodeController节点绑定，rebuild会触发makeNode
127.         // Page页通过NodeContainer接口绑定NodeController，实现动态组件页面显示
128.         NodeContainer(this.nodeController)
129.           .height("80%")
130.           .width("80%")
131.       }
132.       .width('100%')
133.     }
134.     .height('100%')
135.   }
136. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-set-back-forward-cache "设置Web组件前进后退缓存")
# Web组件在不同的窗口间迁移

更新时间: 2025-12-16 16:38

Web组件能够实现在不同窗口的组件树上进行挂载或移除操作，这一能力使得开发者可以将同一个Web组件在不同窗口间迁移。例如，将浏览器的Tab页拖出成独立窗口，或拖入浏览器的另一个窗口。

Web组件在不同窗口间迁移，是基于[自定义节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-node)能力实现的。实现的基本原理是：通过[BuilderNode](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-arktsnode-buildernode)，开发者可创建Web组件的离线节点，并结合[自定义占位节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-place-holder)控制Web节点的挂载与移除。当从一个窗口上移除Web节点，并挂载到另一个窗口中，即完成Web组件在窗口间的迁移。

在以下示例中，主窗Ability启动时，通过命令式的方式创建了一个Web组件。开发者可以利用common.ets中提供的方法和类，实现Web组件的挂载和移除。Index.ets则提供了一种挂载和移除Web组件的实现方法。通过这种方式，开发者能够实现Web组件在不同窗口中页面的挂载与移除，即实现了Web组件在不同窗口间的迁移。下图是展示了这一迁移过程的示意图。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163850.92574847167675142092357627798661:50001231000000:2800:7463D5F69388421FC60F2B7D352915FA4F09183FA8BE8D8D4D646F6EA705A7BA.png)

说明

不要将一个Web组件同时挂载在两个父节点下，这会导致非预期行为。

1. // 主窗Ability
2. // EntryAbility.ets
3. import { createNWeb, defaultUrl } from '../pages/common'

4. // ...

5.   onWindowStageCreate(windowStage: window.WindowStage): void {
6.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

7.     windowStage.loadContent('pages/Index', (err) => {
8.       if (err && err.code) {
9.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
10.         return;
11.       }
12.       // 创建Web动态组件（需传入UIContext），loadContent之后的任意时机均可创建，应用仅创建一个Web组件
13.       createNWeb(defaultUrl, windowStage.getMainWindowSync().getUIContext());
14.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
15.     });
16.   }

17. // ...

18. // 提供动态挂载Web组件能力
19. // pages/common.ets
20. import { UIContext, NodeController, BuilderNode, FrameNode } from '@kit.ArkUI';
21. import { webview } from '@kit.ArkWeb';
22. import { hilog } from '@kit.PerformanceAnalysisKit';

23. export const defaultUrl : string = 'https://www.example.com';

24. // Data为入参封装类
25. class Data{
26.   url: string = '';
27.   webController: webview.WebviewController | null = null;

28.   constructor(url: string, webController: webview.WebviewController) {
29.     this.url = url;
30.     this.webController = webController;
31.   }
32. }

33. // @Builder中为动态组件的具体组件内容
34. @Builder
35. function WebBuilder(data:Data) {
36.   Web({ src: data.url, controller: data.webController })
37.     .width("100%")
38.     .height("100%")
39.     .borderStyle(BorderStyle.Dashed)
40.     .borderWidth(2)
41. }

42. let wrap = wrapBuilder<[Data]>(WebBuilder);

43. // 用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用
44. export class MyNodeController extends NodeController {
45.   private builderNode: BuilderNode<[Data]> | null | undefined = null;
46.   private webController : webview.WebviewController | null | undefined = null;
47.   private rootNode : FrameNode | null = null;

48.   constructor(builderNode : BuilderNode<[Data]> | undefined, webController : webview.WebviewController | undefined) {
49.     super();
50.     this.builderNode = builderNode;
51.     this.webController = webController;
52.   }

53.   // 必须要重写的方法，用于构建节点数、返回节点挂载在对应NodeContainer中
54.   // 在对应NodeContainer创建的时候调用或者通过rebuild方法调用刷新
55.   makeNode(uiContext: UIContext): FrameNode | null {
56.     // 该节点会被挂载在NodeContainer的父节点下
57.     return this.rootNode;
58.   }

59.   // 挂载Webview
60.   attachWeb() : void {
61.     if (this.builderNode) {
62.       let frameNode : FrameNode | null = this.builderNode.getFrameNode();
63.       if (frameNode?.getParent() != null) {
64.         // 挂载自定义节点前判断该节点是否已经被挂载
65.         hilog.error(0x0000, 'testTag', '%{public}s', 'The frameNode is already attached');
66.         return;
67.       }
68.       this.rootNode = this.builderNode.getFrameNode();
69.     }
70.   }

71.   // 卸载Webview
72.   detachWeb() : void {
73.     this.rootNode = null;
74.   }

75.   getWebController() : webview.WebviewController | null | undefined {
76.     return this.webController;
77.   }
78. }

79. // 创建Map保存所需要的BuilderNode
80. let builderNodeMap : Map<string, BuilderNode<[Data]> | undefined> = new Map();
81. // 创建Map保存所需要的webview.WebviewController
82. let webControllerMap : Map<string, webview.WebviewController | undefined> = new Map();

83. // 初始化需要UIContext对象，UIContext对象可通过窗口或自定义组件的getUIContext方法获取
84. export const createNWeb = (url: string, uiContext: UIContext) => {
85.   // 创建WebviewController
86.   let webController = new webview.WebviewController() ;
87.   // 创建BuilderNode
88.   let builderNode : BuilderNode<[Data]> = new BuilderNode(uiContext);
89.   // 创建动态Web组件
90.   builderNode.build(wrap, new Data(url, webController));

91.   // 保存BuilderNode
92.   builderNodeMap.set(url, builderNode);
93.   // 保存WebviewController
94.   webControllerMap.set(url, webController);
95. }

96. // 自定义获取BuilderNode的接口
97. export const getBuilderNode = (url : string) : BuilderNode<[Data]> | undefined => {
98.   return builderNodeMap.get(url);
99. }
100. // 自定义获取WebviewController的接口
101. export const getWebviewController = (url : string) : webview.WebviewController | undefined => {
102.   return webControllerMap.get(url);
103. }

104. // 使用NodeController的Page页
105. // pages/Index.ets
106. import { getBuilderNode, MyNodeController, defaultUrl, getWebviewController } from "./common"

107. @Entry
108. @Component
109. struct Index {
110.   private nodeController : MyNodeController =
111.     new MyNodeController(getBuilderNode(defaultUrl), getWebviewController(defaultUrl));

112.   build() {
113.     Row() {
114.       Column() {
115.         Button("Attach Webview")
116.           .onClick(() => {
117.             // 注意不要将同一个节点同时挂载在不同的页面上！
118.             this.nodeController.attachWeb();
119.             this.nodeController.rebuild();
120.           })
121.         Button("Detach Webview")
122.           .onClick(() => {
123.             this.nodeController.detachWeb();
124.             this.nodeController.rebuild();
125.           })
126.         // NodeContainer用于与NodeController节点绑定，rebuild会触发makeNode
127.         // Page页通过NodeContainer接口绑定NodeController，实现动态组件页面显示
128.         NodeContainer(this.nodeController)
129.           .height("80%")
130.           .width("80%")
131.       }
132.       .width('100%')
133.     }
134.     .height('100%')
135.   }
136. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-set-back-forward-cache "设置Web组件前进后退缓存")