# 适配指导案例

更新时间: 2025-12-16 16:34

本文通过具体应用场景中的案例，提供在ArkTS语法规则下将TS代码适配成ArkTS代码的建议。各章以ArkTS语法规则的英文名称命名，每个案例展示适配前的TS代码和适配后的ArkTS代码。

## arkts-identifiers-as-prop-names

当属性名是有效的标识符（即不包含特殊字符、空格等，并且不以数字开头），可以直接使用而无需引号。

**应用代码**

1. interface W {
2.   bundleName: string
3.   action: string
4.   entities: string[]
5. }

6. let wantInfo: W = {
7.   'bundleName': 'com.huawei.hmos.browser',
8.   'action': 'ohos.want.action.viewData',
9.   'entities': ['entity.system.browsable']
10. }

**建议改法**

1. interface W {
2.   bundleName: string
3.   action: string
4.   entities: string[]
5. }

6. let wantInfo: W = {
7.   bundleName: 'com.huawei.hmos.browser',
8.   action: 'ohos.want.action.viewData',
9.   entities: ['entity.system.browsable']
10. }

## arkts-no-any-unknown

### 按照业务逻辑，将代码中的any, unknown改为具体的类型

1. function printObj(obj: any) {
2.   console.info(obj);
3. }

4. printObj('abc'); // abc

**建议改法**

1. function printObj(obj: string) {
2.   console.info(obj);
3. }

4. printObj('abc'); // abc

### 标注JSON.parse返回值类型

**应用代码**

1. class A {
2.   v: number = 0
3.   s: string = ''

4.   foo(str: string) {
5.     let tmpStr = JSON.parse(str);
6.     if (tmpStr.add != undefined) {
7.       this.v = tmpStr.v;
8.       this.s = tmpStr.s;
9.     }
10.   }
11. }

**建议改法**

1. class A {
2.   v: number = 0
3.   s: string = ''

4.   foo(str: string) {
5.     let tmpStr: Record<string, Object> = JSON.parse(str);
6.     if (tmpStr.add != undefined) {
7.       this.v = tmpStr.v as number;
8.       this.s = tmpStr.s as string;
9.     }
10.   }
11. }

### 使用Record类型

**应用代码**

1. function printProperties(obj: any) {
2.   console.info(obj.name);
3.   console.info(obj.value);
4. }

**建议改法**

1. function printProperties(obj: Record<string, Object>) {
2.   console.info(obj.name as string);
3.   console.info(obj.value as string);
4. }

## arkts-no-call-signature

使用函数类型进行替代。

**应用代码**

1. interface I {
2.   (value: string): void;
3. }

4. function foo(fn: I) {
5.   fn('abc');
6. }

7. foo((value: string) => {
8.   console.info(value);
9. })

**建议改法**

1. type I = (value: string) => void

2. function foo(fn: I) {
3.   fn('abc');
4. }

5. foo((value: string) => {
6.   console.info(value);
7. })

## arkts-no-ctor-signatures-type

使用工厂函数（() => Instance）替代构造函数签名。

**应用代码**

1. class Controller {
2.   value: string = ''

3.   constructor(value: string) {
4.     this.value = value;
5.   }
6. }

7. type ControllerConstructor = {
8.   new (value: string): Controller;
9. }

10. class testMenu {
11.   controller: ControllerConstructor = Controller
12.   createController() {
13.     if (this.controller) {
14.       return new this.controller('123');
15.     }
16.     return null;
17.   }
18. }

19. let t = new testMenu();
20. console.info(t.createController()!.value);

**建议改法**

1. class Controller {
2.   value: string = ''

3.   constructor(value: string) {
4.     this.value = value;
5.   }
6. }

7. type ControllerConstructor = () => Controller;

8. class testMenu {
9.   controller: ControllerConstructor = () => {
10.     return new Controller('abc');
11.   }

12.   createController() {
13.     if (this.controller) {
14.       return this.controller();
15.     }
16.     return null;
17.   }
18. }

19. let t: testMenu = new testMenu();
20. console.info(t.createController()!.value);

## arkts-no-indexed-signatures

使用Record类型进行替代。

**应用代码**

1. function foo(data: { [key: string]: string }) {
2.   data['a'] = 'a';
3.   data['b'] = 'b';
4.   data['c'] = 'c';
5. }

**建议改法**

1. function foo(data: Record<string, string>) {
2.   data['a'] = 'a';
3.   data['b'] = 'b';
4.   data['c'] = 'c';
5. }

## arkts-no-typing-with-this

使用具体类型替代this。

**应用代码**

1. class C {
2.   getInstance(): this {
3.     return this;
4.   }
5. }

**建议改法**

1. class C {
2.   getInstance(): C {
3.     return this;
4.   }
5. }

## arkts-no-ctor-prop-decls

显式声明类属性，并在构造函数中手动赋值。

**应用代码**

1. class Person {
2.   constructor(readonly name: string) {}

3.   getName(): string {
4.     return this.name;
5.   }
6. }

**建议改法**

1. class Person {
2.   name: string
3.   constructor(name: string) {
4.     this.name = name;
5.   }

6.   getName(): string {
7.     return this.name;
8.   }
9. }

## arkts-no-ctor-signatures-iface

使用type定义工厂函数或普通函数类型。

**应用代码**

1. class Controller {
2.   value: string = ''

3.   constructor(value: string) {
4.     this.value = value;
5.   }
6. }

7. interface ControllerConstructor {
8.   new (value: string): Controller;
9. }

10. class testMenu {
11.   controller: ControllerConstructor = Controller
12.   createController() {
13.     if (this.controller) {
14.       return new this.controller('abc');
15.     }
16.     return null;
17.   }
18. }

19. let t = new testMenu();
20. console.info(t.createController()!.value);

**建议改法**

1. class Controller {
2.   value: string = ''

3.   constructor(value: string) {
4.     this.value = value;
5.   }
6. }

7. type ControllerConstructor = () => Controller;

8. class testMenu {
9.   controller: ControllerConstructor = () => {
10.     return new Controller('abc');
11.   }

12.   createController() {
13.     if (this.controller) {
14.       return this.controller();
15.     }
16.     return null;
17.   }
18. }

19. let t: testMenu = new testMenu();
20. console.info(t.createController()!.value);

## arkts-no-props-by-index

可以将对象转换为Record类型，以便访问其属性。

**应用代码**

1. function foo(params: Object) {
2.     let funNum: number = params['funNum'];
3.     let target: string = params['target'];
4. }

**建议改法**

1. function foo(params: Record<string, string | number>) {
2.     let funNum: number = params['funNum'] as number;
3.     let target: string = params['target'] as string;
4. }

## arkts-no-inferred-generic-params

所有泛型调用都应显式标注泛型参数类型，如 Map<string, T>、.map<T>()。

**应用代码**

1. class A {
2.   str: string = ''
3. }
4. class B extends A {}
5. class C extends A {}

6. let arr: Array<A> = [];

7. let originMenusMap:Map<string, C> = new Map(arr.map(item => [item.str, (item instanceof C) ? item: null]));

**建议改法**

1. class A {
2.   str: string = ''
3. }
4. class B extends A {}
5. class C extends A {}

6. let arr: Array<A> = [];

7. let originMenusMap: Map<string, C | null> = new Map<string, C | null>(arr.map<[string, C | null]>(item => [item.str, (item instanceof C) ? item: null]));

**原因**

(item instanceof C) ? item: null 需要声明类型为C | null，由于编译器无法推导出map的泛型类型参数，需要显式标注。

## arkts-no-regexp-literals

使用new RegExp(pattern, flags) 构造函数替代RegExp字面量。

**应用代码**

1. let regex: RegExp = /\s*/g;

**建议改法**

1. let regexp: RegExp = new RegExp('\\s*','g');

**原因**

如果正则表达式中使用了标志符，需要将其作为new RegExp()的参数。

## arkts-no-untyped-obj-literals

### 从SDK中导入类型，标注object literal类型

**应用代码**

1. const area = { // 没有写明类型 不方便维护
2.   pixels: new ArrayBuffer(8),
3.   offset: 0,
4.   stride: 8,
5.   region: { size: { height: 1,width:2 }, x: 0, y: 0 }
6. }

**建议改法**

1. import { image } from '@kit.ImageKit';

2. const area: image.PositionArea = { // 写明具体类型
3.   pixels: new ArrayBuffer(8),
4.   offset: 0,
5.   stride: 8,
6.   region: { size: { height: 1, width: 2 }, x: 0, y: 0 }
7. }

### 用class为object literal标注类型，要求class的构造函数无参数

**应用代码**

1. class Test {
2.   value: number = 1
3.   // 有构造函数
4.   constructor(value: number) {
5.     this.value = value;
6.   }
7. }

8. let t: Test = { value: 2 };

**建议改法1**

1. // 去除构造函数
2. class Test {
3.   value: number = 1
4. }

5. let t: Test = { value: 2 };

**建议改法2**

1. // 使用new
2. class Test {
3.   value: number = 1

4.   constructor(value: number) {
5.     this.value = value;
6.   }
7. }

8. let t: Test = new Test(2);

**原因**

1. class C {
2.   value: number = 1

3.   constructor(n: number) {
4.     if (n < 0) {
5.       throw new Error('Negative');
6.     }
7.     this.value = n;
8.   }
9. }

10. let s: C = new C(-2);     //抛出异常
11. let t: C = { value: -2 };    //ArkTS不支持

如果允许使用C来标注object literal的类型，变量t会导致行为的二义性。ArkTS禁止通过object literal绕过这一行为。

### 用class/interface为object literal标注类型，要求使用identifier作为object literal的key

**应用代码**

1. class Test {
2.   value: number = 0
3. }

4. let arr: Test[] = [
5.   {
6.     'value': 1
7.   },
8.   {
9.     'value': 2
10.   },
11.   {
12.     'value': 3
13.   }
14. ]

**建议改法**

1. class Test {
2.   value: number = 0
3. }
4. let arr: Test[] = [
5.   {
6.     value: 1
7.   },
8.   {
9.     value: 2
10.   },
11.   {
12.     value: 3
13.   }
14. ]

### 使用Record类型为object literal标注类型，要求使用字符串作为object literal的key

**应用代码**

1. let obj: Record<string, number | string> = {
2.   value: 123,
3.   name: 'abc'
4. }

**建议改法**

1. let obj: Record<string, number | string> = {
2.   'value': 123,
3.   'name': 'abc'
4. }

### 函数参数类型包含index signature

**应用代码**

1. function foo(obj: { [key: string]: string}): string {
2.   if (obj != undefined && obj != null) {
3.     return obj.value1 + obj.value2;
4.   }
5.   return '';
6. }

**建议改法**

1. function foo(obj: Record<string, string>): string {
2.   if (obj != undefined && obj != null) {
3.     return obj.value1 + obj.value2;
4.   }
5.   return '';
6. }

### 函数实参使用了object literal

**应用代码**

1. (fn) => {
2.   fn({ value: 123, name:'' });
3. }

**建议改法**

1. class T {
2.   value: number = 0
3.   name: string = ''
4. }

5. (fn: (v: T) => void) => {
6.   fn({ value: 123, name: '' });
7. }

### class/interface 中包含方法

**应用代码**

1. interface T {
2.   foo(value: number): number
3. }

4. let t:T = { foo: (value) => { return value } };

**建议改法1**

1. interface T {
2.   foo: (value: number) => number
3. }

4. let t:T = { foo: (value) => { return value } };

**建议改法2**

1. class T {
2.   foo: (value: number) => number = (value: number) => {
3.     return value;
4.   }
5. }

6. let t:T = new T();

**原因**

class/interface中声明的方法应被所有实例共享。ArkTS不支持通过object literal改写实例方法。ArkTS支持函数类型的属性。

### export default对象

**应用代码**

1. export default {
2.   onCreate() {
3.     // ...
4.   },
5.   onDestroy() {
6.     // ...
7.   }
8. }

**建议改法**

1. class Test {
2.   onCreate() {
3.     // ...
4.   }
5.   onDestroy() {
6.     // ...
7.   }
8. }

9. export default new Test()

### 通过导入namespace获取类型

**应用代码**

1. // test.d.ets
2. declare namespace test {
3.   interface I {
4.     id: string;
5.     type: number;
6.   }

7.   function foo(name: string, option: I): void;
8. }

9. export default test;

10. // app.ets
11. import test from 'test';

12. let option = { id: '', type: 0 };
13. test.foo('', option);

**建议改法**

1. // test.d.ets
2. declare namespace test {
3.   interface I {
4.     id: string;
5.     type: number;
6.   }

7.   function foo(name: string, option: I): void;
8. }

9. export default test;

10. // app.ets
11. import test from 'test';

12. let option: test.I = { id: '', type: 0 };
13. test.foo('', option);

**原因**

对象字面量缺少类型，根据test.foo分析可以得知，option的类型来源于声明文件，那么只需要将类型导入即可。

在test.d.ets中，I定义在namespace中。在ets文件中，先导入namespace，再通过名称获取相应的类型。

### object literal传参给Object类型

**应用代码**

1. function emit(event: string, ...args: Object[]): void {}

2. emit('', {
3.   'action': 11,
4.   'outers': false
5. });

**建议改法**

1. function emit(event: string, ...args: Object[]): void {}

2. let emitArg: Record<string, number | boolean> = {
3.    'action': 11,
4.    'outers': false
5. }

6. emit('', emitArg);

## arkts-no-obj-literals-as-types

使用interface显式定义结构类型。

**应用代码**

1. type Person = { name: string, age: number }

**建议改法**

1. interface Person {
2.   name: string,
3.   age: number
4. }

## arkts-no-noninferrable-arr-literals

显式声明数组元素的类型（使用interface或class），并为数组变量添加类型注解。

**应用代码**

1. let permissionList = [
2.   { name: '设备信息', value: '用于分析设备的续航、通话、上网、SIM卡故障等' },
3.   { name: '麦克风', value: '用于反馈问题单时增加语音' },
4.   { name: '存储', value: '用于反馈问题单时增加本地文件附件' }
5. ]

**建议改法**

为对象字面量声明类型。

1. class PermissionItem {
2.   name?: string
3.   value?: string
4. }

5. let permissionList: PermissionItem[] = [
6.   { name: '设备信息', value: '用于分析设备的续航、通话、上网、SIM卡故障等' },
7.   { name: '麦克风', value: '用于反馈问题单时增加语音' },
8.   { name: '存储', value: '用于反馈问题单时增加本地文件附件' }
9. ]

## arkts-no-method-reassignment

使用函数类型的类字段（class field）代替原型方法。

**应用代码**

1. class C {
2.   add(left: number, right: number): number {
3.     return left + right;
4.   }
5. }

6. function sub(left: number, right: number): number {
7.   return left - right;
8. }

9. let c1 = new C();
10. c1.add = sub;

**建议改法**

1. class C {
2.   add: (left: number, right: number) => number =
3.     (left: number, right: number) => {
4.       return left + right;
5.     }
6. }

7. function sub(left: number, right: number): number {
8.   return left - right;
9. }

10. let c1 = new C();
11. c1.add = sub;

## arkts-no-polymorphic-unops

使用 Number.parseInt()、new Number() 等显式转换函数。

**应用代码**

1. let a = +'5'; // 使用操作符隐式转换
2. let b = -'5';
3. let c = ~'5';
4. let d = +'string';

**建议改法**

1. let a = Number.parseInt('5'); // 使用Number.parseInt显示转换
2. let b = -Number.parseInt('5');
3. let c = ~Number.parseInt('5');
4. let d = new Number('123');

## arkts-no-type-query

使用类、接口或类型别名替代typeof，避免依赖变量做类型推导。

**应用代码**

1. // module1.ts
2. class C {
3.   value: number = 0
4. }

5. export let c = new C()

6. // module2.ts
7. import { c } from './module1'
8. let t: typeof c = { value: 123 };

**建议改法**

1. // module1.ts
2. class C {
3.   value: number = 0
4. }

5. export { C }

6. // module2.ts
7. import { C } from './module1'
8. let t: C = { value: 123 };

## arkts-no-in

### 使用Object.keys判断属性是否存在

**应用代码**

1. function test(str: string, obj: Record<string, Object>) {
2.   return str in obj;
3. }

**建议改法**

1. function test(str: string, obj: Record<string, Object>) {
2.   for (let i of Object.keys(obj)) {
3.     if (i == str) {
4.       return true;
5.     }
6.   }
7.   return false;
8. }

## arkts-no-destruct-assignment

使用索引访问元素或手动赋值代替解构赋值。

**应用代码**

1. let map = new Map<string, string>([['a', 'a'], ['b', 'b']]);
2. for (let [key, value] of map) {
3.   console.info(key);
4.   console.info(value);
5. }

**建议改法**

使用数组。

1. let map = new Map<string, string>([['a', 'a'], ['b', 'b']]);
2. for (let arr of map) {
3.   let key = arr[0];
4.   let value = arr[1];
5.   console.info(key);
6.   console.info(value);
7. }

## arkts-no-types-in-catch

使用无类型 catch (error)，然后通过类型断言处理。

**应用代码**

1. import { BusinessError } from '@kit.BasicServicesKit'

2. try {
3.   // ...
4. } catch (e: BusinessError) {
5.   console.error(e.message, e.code);
6. }

**建议改法**

1. import { BusinessError } from '@kit.BasicServicesKit'

2. try {
3.   // ...
4. } catch (error) {
5.   let e: BusinessError = error as BusinessError;
6.   console.error(e.message, e.code);
7. }

## arkts-no-for-in

使用 Object.entries(obj) + for of 替代 for in。

**应用代码**

1. interface Person {
2.   [name: string]: string
3. }
4. let p: Person = {
5.   name: 'tom',
6.   age: '18'
7. };

8. for (let t in p) {
9.   console.info(p[t]);  // info: "tom", "18"
10. }

**建议改法**

1. let p: Record<string, string> = {
2.   'name': 'tom',
3.   'age': '18'
4. };

5. for (let ele of Object.entries(p)) {
6.   console.info(ele[1]);  // info: "tom", "18"
7. }

## arkts-no-mapped-types

使用 Record<K, T> 替代映射类型。

**应用代码**

1. class C {
2.   a: number = 0
3.   b: number = 0
4.   c: number = 0
5. }
6. type OptionsFlags = {
7.   [Property in keyof C]: string
8. }

**建议改法**

1. class C {
2.   a: number = 0
3.   b: number = 0
4.   c: number = 0
5. }

6. type OptionsFlags = Record<keyof C, string>

## arkts-limited-throw

将对象转换为Error，或创建新的Error实例抛出。

**应用代码**

1. import { BusinessError } from '@kit.BasicServicesKit'

2. function ThrowError(error: BusinessError) {
3.   throw error;
4. }

**建议改法**

1. import { BusinessError } from '@kit.BasicServicesKit'

2. function ThrowError(error: BusinessError) {
3.   throw error as Error;
4. }

**原因**

throw语句中值的类型必须为Error或者其继承类，如果继承类是一个泛型，会有编译期报错。建议使用as将类型转换为Error。

## arkts-no-standalone-this

### 函数内使用this

**应用代码**

1. function foo() {
2.   console.info(this.value);
3. }

4. let obj = { value: 'abc' };
5. foo.apply(obj);

**建议改法1**

使用类的方法实现,如果该方法被多个类使用,可以考虑采用继承的机制。

1. class Test {
2.   value: string = ''
3.   constructor (value: string) {
4.     this.value = value
5.   }

6.   foo() {
7.     console.info(this.value);
8.   }
9. }

10. let obj: Test = new Test('abc');
11. obj.foo();

**建议改法2**

将this作为参数传入。

1. function foo(obj: Test) {
2.   console.info(obj.value);
3. }

4. class Test {
5.   value: string = ''
6. }

7. let obj: Test = { value: 'abc' };
8. foo(obj);

**建议改法3**

将属性作为参数传入。

1. function foo(value: string) {
2.   console.info(value);
3. }

4. class Test {
5.   value: string = ''
6. }

7. let obj: Test = { value: 'abc' };
8. foo(obj.value);

### class的静态方法内使用this

**应用代码**

1. class Test {
2.   static value: number = 123
3.   static foo(): number {
4.     return this.value
5.   }
6. }

**建议改法**

1. class Test {
2.   static value: number = 123
3.   static foo(): number {
4.     return Test.value
5.   }
6. }

## arkts-no-spread

使用Object.assign()、手动赋值或数组方法替代扩展运算符。

**应用代码**

1. // test.d.ets
2. declare namespace test {
3.   interface I {
4.     id: string;
5.     type: number;
6.   }

7.   function foo(): I;
8. }

9. export default test

10. // app.ets
11. import test from 'test';

12. let t: test.I = {
13.   ...test.foo(),
14.   type: 0
15. }

**建议改法**

1. // test.d.ets
2. declare namespace test {
3.   interface I {
4.     id: string;
5.     type: number;
6.   }

7.   function foo(): I;
8. }

9. export default test

10. // app.ets
11. import test from 'test';

12. let t: test.I = test.foo();
13. t.type = 0;

**原因**

ArkTS中，对象布局在编译期是确定的。如果需要将一个对象的所有属性展开赋值给另一个对象可以通过逐个属性赋值语句完成。在本例中，需要展开的对象和赋值的目标对象类型恰好相同，可以通过改变该对象属性的方式重构代码。

## arkts-no-ctor-signatures-funcs

在class内声明属性，而不是在构造函数上。

**应用代码**

1. class Controller {
2.   value: string = ''
3.   constructor(value: string) {
4.     this.value = value
5.   }
6. }

7. type ControllerConstructor = new (value: string) => Controller;

8. class testMenu {
9.   controller: ControllerConstructor = Controller
10.   createController() {
11.     if (this.controller) {
12.       return new this.controller('abc');
13.     }
14.     return null;
15.   }
16. }

17. let t = new testMenu()
18. console.info(t.createController()!.value)

**建议改法**

1. class Controller {
2.   value: string = ''
3.   constructor(value: string) {
4.     this.value = value;
5.   }
6. }

7. type ControllerConstructor = () => Controller;

8. class testMenu {
9.   controller: ControllerConstructor = () => { return new Controller('abc') }
10.   createController() {
11.     if (this.controller) {
12.       return this.controller();
13.     }
14.     return null;
15.   }
16. }

17. let t: testMenu = new testMenu();
18. console.info(t.createController()!.value);

## arkts-no-globalthis

ArkTS不支持globalThis。一方面无法为globalThis添加静态类型，只能通过查找方式访问其属性，导致额外性能开销。另一方面，无法为globalThis的属性标记类型，无法保证操作的安全性和高性能。

1. 建议按照业务逻辑根据import/export语法实现数据在不同模块的传递。
    
2. 必要情况下，可以通过构造的**单例对象**来实现全局对象的功能。(**说明：** 不能在har中定义单例对象，har在打包时会在不同的hap中打包两份，无法实现单例。)
    

**构造单例对象**

1. // 构造单例对象
2. export class GlobalContext {
3.   private constructor() {}
4.   private static instance: GlobalContext;
5.   private _objects = new Map<string, Object>();

6.   public static getContext(): GlobalContext {
7.     if (!GlobalContext.instance) {
8.       GlobalContext.instance = new GlobalContext();
9.     }
10.     return GlobalContext.instance;
11.   }

12.   getObject(value: string): Object | undefined {
13.     return this._objects.get(value);
14.   }

15.   setObject(key: string, objectClass: Object): void {
16.     this._objects.set(key, objectClass);
17.   }
18. }

**应用代码**

1. // file1.ts

2. export class Test {
3.   value: string = '';
4.   foo(): void {
5.     globalThis.value = this.value;
6.   }
7. }

8. // file2.ts

9. globalThis.value;

**建议改法**

1. // file1.ts

2. import { GlobalContext } from '../GlobalContext'

3. export class Test {
4.   value: string = '';
5.   foo(): void {
6.     GlobalContext.getContext().setObject('value', this.value);
7.   }
8. }

9. // file2.ts

10. import { GlobalContext } from '../GlobalContext'

11. GlobalContext.getContext().getObject('value');

## arkts-no-func-apply-bind-call

### 使用标准库中接口

**应用代码**

1. let arr: number[] = [1, 2, 3, 4];
2. let str = String.fromCharCode.apply(null, Array.from(arr));

**建议改法**

1. let arr: number[] = [1, 2, 3, 4];
2. let str = String.fromCharCode(...Array.from(arr));

### bind定义方法

**应用代码**

1. class A {
2.   value: string = ''
3.   foo: Function = () => {}
4. }

5. class Test {
6.   value: string = '1234'
7.   obj: A = {
8.     value: this.value,
9.     foo: this.foo.bind(this)
10.   }

11.   foo() {
12.     console.info(this.value);
13.   }
14. }

**建议改法1**

1. class A {
2.   value: string = ''
3.   foo: Function = () => {}
4. }

5. class Test {
6.   value: string = '1234'
7.   obj: A = {
8.     value: this.value,
9.     foo: (): void => this.foo()
10.   }

11.   foo() {
12.     console.info(this.value);
13.   }
14. }

**建议改法2**

1. class A {
2.   value: string = ''
3.   foo: Function = () => {}
4. }

5. class Test {
6.   value: string = '1234'
7.   foo: () => void = () => {
8.     console.info(this.value);
9.   }
10.   obj: A = {
11.     value: this.value,
12.     foo: this.foo
13.   }
14. }

### 使用apply

**应用代码**

1. class A {
2.   value: string;
3.   constructor (value: string) {
4.     this.value = value;
5.   }

6.   foo() {
7.     console.info(this.value);
8.   }
9. }

10. let a1 = new A('1');
11. let a2 = new A('2');

12. a1.foo();
13. a1.foo.apply(a2);

**建议改法**

1. class A {
2.   value: string;
3.   constructor (value: string) {
4.     this.value = value;
5.   }

6.   foo() {
7.     this.fooApply(this);
8.   }

9.   fooApply(a: A) {
10.     console.info(a.value);
11.   }
12. }

13. let a1 = new A('1');
14. let a2 = new A('2');

15. a1.foo();
16. a1.fooApply(a2);

## arkts-limited-stdlib

### Object.fromEntries()

**应用代码**

1. let entries = new Map([
2.   ['foo', 123],
3.   ['bar', 456]
4. ]);

5. let obj = Object.fromEntries(entries);

**建议改法**

1. let entries = new Map([
2.   ['foo', 123],
3.   ['bar', 456]
4. ]);

5. let obj: Record<string, Object> = {};
6. entries.forEach((key, value) => {
7.   if (key != undefined && key != null) {
8.     obj[key] = value;
9.   }
10. })

## 严格模式检查(StrictModeError)

### strictPropertyInitialization

**应用代码**

1. interface I {
2.   name:string
3. }

4. class A {}

5. class Test {
6.   a: number;
7.   b: string;
8.   c: boolean;
9.   d: I;
10.   e: A;
11. }

**建议改法**

1. interface I {
2.   name:string
3. }

4. class A {}

5. class Test {
6.   a: number;
7.   b: string;
8.   c: boolean;
9.   d: I = { name:'abc' };
10.   e: A | null = null;
11.   constructor(a:number, b:string, c:boolean) {
12.     this.a = a;
13.     this.b = b;
14.     this.c = c;
15.   }
16. }

### Type *** | null is not assignable to type ***

**应用代码**

1. class A {
2.   bar() {}
3. }
4. function foo(n: number) {
5.   if (n === 0) {
6.     return null;
7.   }
8.   return new A();
9. }
10. function getNumber() {
11.   return 5;
12. }
13. let a:A = foo(getNumber());
14. a.bar();

**建议改法**

1. class A {
2.   bar() {}
3. }
4. function foo(n: number) {
5.   if (n === 0) {
6.     return null;
7.   }
8.   return new A();
9. }
10. function getNumber() {
11.   return 5;
12. }

13. let a: A | null = foo(getNumber());
14. a?.bar();

### 严格属性初始化检查

在class中，如果一个属性没有初始化，且没有在构造函数中被赋值，ArkTS将报错。

**建议改法**

1.一般情况下，**建议按照业务逻辑**在声明时初始化属性，或者在构造函数中为属性赋值。如：

1. //code with error
2. class Test {
3.   value: number
4.   flag: boolean
5. }

6. //方式一，在声明时初始化
7. class Test {
8.   value: number = 0
9.   flag: boolean = false
10. }

11. //方式二，在构造函数中赋值
12. class Test {
13.   value: number
14.   flag: boolean
15.   constructor(value: number, flag: boolean) {
16.     this.value = value;
17.     this.flag = flag;
18.   }
19. }

2.对于对象类型（包括函数类型）A，如果不确定如何初始化，建议按照以下方式之一进行初始化：

​ 方式(i) prop: A | null = null

​ 方式(ii) prop?: A

​ 方式三(iii) prop： A | undefined = undefined

- 从性能角度看，null类型仅用于编译期的类型检查，不会影响虚拟机性能。而undefined | A被视为联合类型，运行时可能产生额外开销。
- 从代码可读性、简洁性的角度来说，prop?:A是prop： A | undefined = undefined的语法糖，**推荐使用可选属性的写法**。

### 严格函数类型检查

**应用代码**

1. function foo(fn: (value?: string) => void, value: string): void {}

2. foo((value: string) => {}, ''); //error

**建议改法**

1. function foo(fn: (value?: string) => void, value: string): void {}

2. foo((value?: string) => {}, '');

**原因**

例如，在以下的例子中，如果编译期不开启严格函数类型的检查，那么该段代码可以编译通过，但是在运行时会产生非预期的行为。具体来看，在foo的函数体中，一个undefined被传入fn（这是可以的，因为fn可以接受undefined），但是在代码第6行foo的调用点，传入的(value: string) => { console.info(value.toUpperCase()) }的函数实现中，始终将参数value当做string类型，允许其调用toUpperCase方法。如果不开启严格函数类型的检查，那么这段代码在运行时，会出现在undefined上无法找到属性的错误。

1. function foo(fn: (value?: string) => void, value: string): void {
2.   let v: string | undefined = undefined;
3.   fn(v);
4. }

5. foo((value: string) => { console.info(value.toUpperCase()) }, ''); // Cannot read properties of undefined (reading 'toUpperCase')

为了避免运行时的非预期行为，开启严格类型检查时，这段代码将无法编译通过，需要提醒开发者修改代码，确保程序安全。

### 严格空值检查

**应用代码**

1. class Test {
2.   private value?: string;

3.   public printValue () {
4.     console.info(this.value.toLowerCase());
5.   }
6. }

7. let t = new Test();
8. t.printValue();

**应用代码运行时错误原因**

编译期不开启严格空值检查，应用代码可以通过编译，但是在运行时会报错。

因为t的属性value为undefined，在调用printValue方法时，由于在该方法内未对this.value的值进行空值检查，直接按照string类型访问其属性，导致了运行时的错误。

**建议改法**

在编写代码时，建议减少可空类型的使用。如果对变量、属性标记了可空类型，那么在使用它们之前，需要进行空值的判断，根据是否为空值处理不同的逻辑。

1. class Test {
2.   private value?: string;

3.   public printValue () {
4.     if (this.value) {
5.       console.info(this.value.toLowerCase());
6.     }
7.   }
8. }

9. let t = new Test();
10. t.printValue();

### 函数返回类型不匹配

**应用代码**

1. class Test {
2.   handleClick: (action: string, externInfo?: string) => void | null = null;
3. }

**建议改法**

在这种写法下，函数返回类型被解析为 void | undefined，需要添加括号用来区分union类型。

1. class Test {
2.   handleClick: ((action: string, externInfo?: string) => void) | null = null;
3. }

### Type '*** | null' is not assignable to type '***'

**应用代码**

1. class A {
2.   value: number
3.   constructor(value: number) {
4.     this.value = value;
5.   }
6. }

7. function foo(v: number): A | null {
8.   if (v > 0) {
9.     return new A(v);
10.   }
11.   return null;
12. }

13. let a: A = foo();

**建议改法1**

修改变量a的类型：let a: A | null = foo()。

1. class A {
2.   value: number
3.   constructor(value: number) {
4.     this.value = value;
5.   }
6. }

7. function foo(v: number): A | null {
8.   if (v > 0) {
9.     return new A(v);
10.   }
11.   return null;
12. }

13. let a: A | null = foo(123);

14. if (a != null) {
15.   // 非空分支
16. } else {
17.   // 处理null
18. }

**建议改法2**

如果确定此处调用foo一定返回非空值，可以使用非空断言!。

1. class A {
2.   value: number
3.   constructor(value: number) {
4.     this.value = value;
5.   }
6. }

7. function foo(v: number): A | null {
8.   if (v > 0) {
9.     return new A(v);
10.   }
11.   return null;
12. }

13. let a: A = foo(123)!;

### Cannot invoke an object which is possibly 'undefined'

**应用代码**

1. interface A {
2.   foo?: () => void
3. }

4. let a:A = { foo: () => {} };
5. a.foo();

**建议改法1**

1. interface A {
2.   foo: () => void
3. }
4. let a: A = { foo: () => {} };
5. a.foo();

**建议改法2**

1. interface A {
2.   foo?: () => void
3. }

4. let a: A = { foo: () => {} };
5. if (a.foo) {
6.   a.foo();
7. }

**原因**

在原先代码的定义中，foo是可选属性，可能为undefined，对undefined的调用会导致报错。建议根据业务逻辑判断是否需要将foo设为可选属性。如果确实需要，那么在访问该属性后需要进行空值检查。

### Variable '***' is used before being assigned

**应用代码**

1. class Test {
2.   value: number = 0
3. }

4. let a: Test
5. try {
6.   a = { value: 1};
7. } catch (e) {
8.   a.value;
9. }
10. a.value;

**建议改法**

1. class Test {
2.   value: number = 0
3. }

4. let a: Test | null = null;
5. try {
6.   a = { value:1 };
7. } catch (e) {
8.   if (a) {
9.     a.value;
10.   }
11. }

12. if (a) {
13.   a.value;
14. }

**原因**

对于primitive types，可以根据业务逻辑赋值，例如0，''，false。

对于对象类型，可以将其类型修改为与null的联合类型，并赋值为null。使用时需要进行非空检查。

### Function lacks ending return statement and return type does not include 'undefined'.

**应用代码**

1. function foo(a: number): number {
2.   if (a > 0) {
3.     return a;
4.   }
5. }

**建议改法1**

根据业务逻辑，在else分支中返回合适的数值。

**建议改法2**

1. function foo(a: number): number | undefined {
2.   if (a > 0) {
3.     return a;
4.   }
5.   return
6. }

## arkts-strict-typing-required

删除忽略注释，为所有变量显式声明类型。

**应用代码**

1. // @ts-ignore
2. var a: any = 123;

**建议改法**

1. let a: number = 123;

**原因**

ArkTS不支持通过注释的方式绕过严格类型检查。首先将注释（// @ts-nocheck或者// @ts-ignore）删去，再根据报错信息修改其他代码。

## Importing ArkTS files to JS and TS files is not allowed

## arkts-no-tsdeps

不允许.ts、.js文件import.ets文件源码。

**建议改法**

方式1.将.ts文件的后缀修改为ets，并按ArkTS语法规则适配代码。

方式2.将.ets文件中被.ts文件依赖的代码单独抽取到.ts文件中。

## arkts-no-special-imports

改为使用普通import { ... } from '...' 导入类型。

**应用代码**

1. import type {A, B, C, D } from '***'

**建议改法**

1. import {A, B, C, D } from '***'

## arkts-no-classes-as-obj

### 使用class构造实例

**应用代码**

1. class Controller {
2.   value: string = ''
3.   constructor(value: string) {
4.     this.value = value
5.   }
6. }

7. interface ControllerConstructor {
8.   new (value: string): Controller;
9. }

10. class TestMenu {
11.   controller: ControllerConstructor = Controller
12.   createController() {
13.     if (this.controller) {
14.       return new this.controller('abc');
15.     }
16.     return null;
17.   }
18. }

19. let t = new TestMenu();
20. console.info(t.createController()!.value);

**建议改法**

1. class Controller {
2.   value: string = ''

3.   constructor(value: string) {
4.     this.value = value;
5.   }
6. }

7. type ControllerConstructor = () => Controller;

8. class TestMenu {
9.   controller: ControllerConstructor = () => {
10.     return new Controller('abc');
11.   }

12.   createController() {
13.     if (this.controller) {
14.       return this.controller();
15.     }
16.     return null;
17.   }
18. }

19. let t: TestMenu = new TestMenu();
20. console.info(t.createController()!.value);

### 访问静态属性

**应用代码**

1. class C1 {
2.   static value: string = 'abc'
3. }

4. class C2 {
5.   static value: string = 'def'
6. }

7. function getValue(obj: any) {
8.   return obj['value'];
9. }

10. console.info(getValue(C1));
11. console.info(getValue(C2));

**建议改法**

1. class C1 {
2.   static value: string = 'abc'
3. }

4. class C2 {
5.   static value: string = 'def'
6. }

7. function getC1Value(): string {
8.   return C1.value;
9. }

10. function getC2Value(): string {
11.   return C2.value;
12. }

13. console.info(getC1Value());
14. console.info(getC2Value());

## arkts-no-side-effects-imports

改用动态import。

**应用代码**

1. import 'module'

**建议改法**

1. import('module')

## arkts-no-func-props

使用class来组织多个相关函数。

**应用代码**

1. function foo(value: number): void {
2.   console.info(value.toString());
3. }

4. foo.add = (left: number, right: number) => {
5.   return left + right;
6. }

7. foo.sub = (left: number, right: number) => {
8.   return left - right;
9. }

**建议改法**

1. class Foo {
2.   static foo(value: number): void {
3.     console.info(value.toString());
4.   }

5.   static add(left: number, right: number): number {
6.     return left + right;
7.   }

8.   static sub(left: number, right: number): number {
9.     return left - right;
10.   }
11. }

## arkts-limited-esobj

使用具体类型（如number, string）或接口代替不明确的ESObject。

**应用代码**

1. // testa.ts
2. export function foo(): any {
3.   return null;
4. }

5. // main.ets
6. import {foo} from './testa'
7. let e0: ESObject = foo();

8. function f() {
9.   let e1 = foo();
10.   let e2: ESObject = 1;
11.   let e3: ESObject = {};
12.   let e4: ESObject = '';
13. }

**建议改法**

1. // testa.ts
2. export function foo(): any {
3.   return null;
4. }

5. // main.ets
6. import {foo} from './testa'
7. interface I {}

8. function f() {
9.   let e0: ESObject = foo();
10.   let e1: ESObject = foo();
11.   let e2: number = 1;
12.   let e3: I = {};
13.   let e4: string = '';
14. }

## 拷贝

### 浅拷贝

**TypeScript**

1. function shallowCopy(obj: object): object {
2.   let newObj = {};
3.   Object.assign(newObj, obj);
4.   return newObj;
5. }

**ArkTS**

1. function shallowCopy(obj: object): object {
2.   let newObj: Record<string, Object> = {};
3.   for (let key of Object.keys(obj)) {
4.     newObj[key] = obj[key];
5.   }
6.   return newObj;
7. }

### 深拷贝

**TypeScript**

1. function deepCopy(obj: object): object {
2.   let newObj = Array.isArray(obj) ? [] : {};
3.   for (let key in obj) {
4.     if (typeof obj[key] === 'object') {
5.       newObj[key] = deepCopy(obj[key]);
6.     } else {
7.       newObj[key] = obj[key];
8.     }
9.   }
10.   return newObj;
11. }

**ArkTS**

1. function deepCopy(obj: object): object {
2.   let newObj: Record<string, Object> | Object[] = Array.isArray(obj) ? [] : {};
3.   for (let key of Object.keys(obj)) {
4.     if (typeof obj[key] === 'object') {
5.       newObj[key] = deepCopy(obj[key]);
6.     } else {
7.       newObj[key] = obj[key];
8.     }
9.   }
10.   return newObj;
11. }

## 状态管理使用典型场景

### Struct组件外使用状态变量

由于struct和class的不同，不建议将this作为参数传递到struct外部使用，以避免实例引用无法释放，导致内存泄露。建议传递状态变量对象到struct外部使用，通过修改对象的属性来触发UI刷新。

**不推荐用法**

1. export class MyComponentController {
2.   item: MyComponent = null;

3.   setItem(item: MyComponent) {
4.     this.item = item;
5.   }

6.   changeText(value: string) {
7.     this.item.value = value;
8.   }
9. }

10. @Component
11. export default struct MyComponent {
12.   public controller: MyComponentController = null;
13.   @State value: string = 'Hello World';

14.   build() {
15.     Column() {
16.       Text(this.value)
17.         .fontSize(50)
18.     }
19.   }

20.   aboutToAppear() {
21.     if (this.controller)
22.       this.controller.setItem(this); // 不建议把this作为参数传递到struct外部使用
23.   }
24. }

25. @Entry
26. @Component
27. struct ObjThisOldPage {
28.   controller = new MyComponentController();

29.   build() {
30.     Column() {
31.       MyComponent({ controller: this.controller })
32.       Button('change value').onClick(() => {
33.         this.controller.changeText('Text');
34.       })
35.     }
36.   }
37. }

**推荐用法**

1. class CC {
2.   value: string = '1';

3.   constructor(value: string) {
4.     this.value = value;
5.   }
6. }

7. export class MyComponentController {
8.   item: CC = new CC('1');

9.   setItem(item: CC) {
10.     this.item = item;
11.   }

12.   changeText(value: string) {
13.     this.item.value = value;
14.   }
15. }

16. @Component
17. export default struct MyComponent {
18.   public controller: MyComponentController | null = null;
19.   @State value: CC = new CC('Hello World');

20.   build() {
21.     Column() {
22.       Text(`${this.value.value}`)
23.         .fontSize(50)
24.     }
25.   }

26.   aboutToAppear() {
27.     if (this.controller)
28.       this.controller.setItem(this.value);
29.   }
30. }

31. @Entry
32. @Component
33. struct StyleExample {
34.   controller: MyComponentController = new MyComponentController();

35.   build() {
36.     Column() {
37.       MyComponent({ controller: this.controller })
38.       Button('change value').onClick(() => {
39.         this.controller.changeText('Text');
40.       })
41.     }
42.   }
43. }

### Struct支持联合类型的方案

下面这段代码有arkts-no-any-unknown的报错，由于struct不支持泛型，建议使用联合类型，实现自定义组件类似泛型的功能。

**不推荐用法**

1. class Data {
2.   aa: number = 11;
3. }

4. @Entry
5. @Component
6. struct DatauionOldPage {
7.   @State array: Data[] = [new Data(), new Data(), new Data()];

8.   @Builder
9.   componentCloser(data: Data) {
10.     Text(data.aa + '').fontSize(50)
11.   }

12.   build() {
13.     Row() {
14.       Column() {
15.         ForEachCom({ arrayList: this.array, closer: this.componentCloser })
16.       }
17.       .width('100%')
18.     }
19.     .height('100%')
20.   }
21. }

22. @Component
23. export struct ForEachCom {
24.   arrayList: any[]; // struct不支持泛型，有arkts-no-any-unknown报错
25.   @BuilderParam closer: (data: any) => void = this.componentCloser; // struct不支持泛型，有arkts-no-any-unknown报错

26.   @Builder
27.   componentCloser() {
28.   }

29.   build() {
30.     Column() {
31.       ForEach(this.arrayList, (item: any) => { // struct不支持泛型，有arkts-no-any-unknown报错
32.         Row() {
33.           this.closer(item)
34.         }.width('100%').height(200).backgroundColor('#eee')
35.       })
36.     }
37.   }
38. }

**推荐用法**

1. class Data {
2.   aa: number = 11;
3. }

4. class Model {
5.   aa: string = '11';
6. }

7. type UnionData = Data | Model;

8. @Entry
9. @Component
10. struct DatauionPage {
11.   array: UnionData[] = [new Data(), new Data(), new Data()];

12.   @Builder
13.   componentCloser(data: UnionData) {
14.     if (data instanceof Data) {
15.       Text(data.aa + '').fontSize(50)
16.     }
17.   }

18.   build() {
19.     Row() {
20.       Column() {
21.         ForEachCom({ arrayList: this.array, closer: this.componentCloser })
22.       }
23.       .width('100%')
24.     }
25.     .height('100%')
26.   }
27. }

28. @Component
29. export struct ForEachCom {
30.   arrayList: UnionData[] = [new Data(), new Data(), new Data()];
31.   @BuilderParam closer: (data: UnionData) => void = this.componentCloser;

32.   @Builder
33.   componentCloser() {
34.   }

35.   build() {
36.     Column() {
37.       ForEach(this.arrayList, (item: UnionData) => {
38.         Row() {
39.           this.closer(item)
40.         }.width('100%').height(200).backgroundColor('#eee')
41.       })
42.     }
43.   }
44. }
# ArkTS高性能编程实践

更新时间: 2025-12-16 16:34

## 概述

本文提供应用性能敏感场景下的高性能编程建议，帮助开发者编写高性能应用。高性能编程实践是在开发过程中总结的一些高性能写法和建议。在实现业务功能时，应同步思考并理解高性能写法的原理，并将其应用于代码逻辑中。关于ArkTS编程规范，请参考[ArkTS编程规范](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-coding-style-guide)。

## 声明与表达式

### 使用const声明不变的变量

不变的变量推荐使用const声明。

1. const index = 10000; // 该变量在后续过程中未发生改变，建议声明成常量

### number类型变量避免整型和浮点型混用

针对number类型，运行时在优化时会区分整型和浮点型数据。建议避免在初始化后改变数据类型。

1. let intNum = 1;
2. intNum = 1.1;  // 该变量在声明时为整型数据，建议后续不要赋值浮点型数据

3. let doubleNum = 1.1;
4. doubleNum = 1;  // 该变量在声明时为浮点型数据，建议后续不要赋值整型数据

### 数值计算避免溢出

常见的可能导致溢出的数值计算包括如下场景，溢出之后，会导致引擎走入慢速的溢出逻辑分支处理，影响后续的性能。

- 针对加法、减法、乘法、指数运算等运算操作，应避免数值大于INT32_MAX（2147483647）或小于INT32_MIN（-2147483648）。
    
- 针对&（and）、>>>（无符号右移）等运算操作，应避免数值大于INT32_MAX。
    

### 循环中常量提取，减少属性访问次数

如果常量在循环中不会改变，可以将其提取到循环外部，减少访问次数。

1. class Time {
2.   static start: number = 0;
3.   static info: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
4. }

5. function getNum(num: number): number {
6.   let total: number = 348;
7.   for (let index: number = 0x8000; index > 0x8; index >>= 1) {
8.     // 此处会多次对Time的info及start进行查找，并且每次查找出来的值是相同的
9.     total += ((Time.info[num - Time.start] & index) !== 0) ? 1 : 0;
10.   }
11.   return total;
12. }

优化后的代码如下，可以将Time.info[num - Time.start]提取为常量，这样可以显著减少属性访问次数，提升性能。

1. class Time {
2.   static start: number = 0;
3.   static info: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
4. }

5. function getNum(num: number): number {
6.   let total: number = 348;
7.   const info = Time.info[num - Time.start];  // 从循环中提取不变量
8.   for (let index: number = 0x8000; index > 0x8; index >>= 1) {
9.     if ((info & index) != 0) {
10.       total++;
11.     }
12.   }
13.   return total;
14. }

## 函数

### 建议使用参数传递函数外的变量

使用闭包会造成额外的开销。在性能敏感场景中，建议使用参数传递函数外的变量替代。

1. let arr = [0, 1, 2];

2. function foo(): number {
3.   return arr[0] + arr[1];
4. }

5. foo();

建议使用参数传递函数外部的变量，以替代使用闭包。

1. let arr = [0, 1, 2];

2. function foo(array: number[]): number {
3.   return array[0] + array[1];
4. }

5. foo(arr);

### 避免使用可选参数

函数的可选参数表示参数可能为undefined，在函数内部使用该参数时，需要进行非空值的判断，造成额外的开销。

1. function add(left?: number, right?: number): number | undefined {
2.   if (left != undefined && right != undefined) {
3.     return left + right;
4.   }
5.   return undefined;
6. }

根据业务需求，将函数参数声明为必选参数。考虑使用默认参数。

1. function add(left: number = 0, right: number = 0): number {
2.   return left + right;
3. }

## 数组

### 数值数组推荐使用TypedArray

涉及纯数值计算时，推荐使用TypedArray数据结构。

优化前的代码示例：

1. const arr1 = new Array<number>(1, 2, 3);
2. const arr2 = new Array<number>(4, 5, 6);
3. let res = new Array<number>(3);
4. for (let i = 0; i < 3; i++) {
5.   res[i] = arr1[i] + arr2[i];
6. }

优化后的代码示例：

1. const typedArray1 = Int8Array.from([1, 2, 3]);
2. const typedArray2 = Int8Array.from([4, 5, 6]);
3. let res = new Int8Array(3);
4. for (let i = 0; i < 3; i++) {
5.   res[i] = typedArray1[i] + typedArray2[i];
6. }

### 避免使用稀疏数组

运行时在分配超过1024大小的数组或稀疏数组时，会采用hash表来存储元素。在该模式下，访问数组元素速度较慢。代码开发时应避免数组变成稀疏数组。

1. // 直接分配100000大小的数组，运行时会处理成用hash表来存储元素
2. let count = 100000;
3. let result: number[] = new Array(count);

4. // 创建数组后，直接在9999处赋值，会变成稀疏数组
5. let result: number[] = new Array();
6. result[9999] = 0;

### 避免使用联合类型数组

避免使用联合类型数组。避免在数值数组中混合使用整型数据和浮点型数据。

1. let arrNum: number[] = [1, 1.1, 2];  // 数值数组中混合使用整型数据和浮点型数据

2. let arrUnion: (number | string)[] = [1, 'hello'];  // 联合类型数组

根据业务需求，将相同类型的数据放在同一数组中。

1. let arrInt: number[] = [1, 2, 3];
2. let arrDouble: number[] = [0.1, 0.2, 0.3];
3. let arrString: string[] = ['hello', 'world'];

## 异常

### 避免频繁抛出异常

创建异常时会构造异常的栈帧，造成性能损耗。在性能敏感场景下，如for循环语句中，应避免频繁抛出异常。

优化前的代码示例：

1. function div(a: number, b: number): number {
2.   if (a <= 0 || b <= 0) {
3.     throw new Error('Invalid numbers.');
4.   }
5.   return a / b;
6. }

7. function sum(num: number): number {
8.   let sum = 0;
9.   try {
10.     for (let t = 1; t < 100; t++) {
11.       sum += div(t, num);
12.     }
13.   } catch (e) {
14.     console.info(e.message);
15.   }
16.   return sum;
17. }

优化后的代码示例：

1. function div(a: number, b: number): number {
2.   if (a <= 0 || b <= 0) {
3.     return NaN;
4.   }
5.   return a / b;
6. }

7. function sum(num: number): number {
8.   let sum = 0;
9.   for (let t = 1; t < 100; t++) {
10.     // 直接拦截异常场景，避免频繁抛出异常
11.     if (num <= 0) {
12.       console.info('Invalid numbers.');
13.     }
14.     sum += div(t, num);
15.   }
16.   return sum;
17. }
# 从Java到ArkTS的迁移指导

更新时间: 2025-12-16 16:34

对于熟悉Java的开发者而言，ArkTS作为新的开发语言，带来了全新的开发体验与机遇。ArkTS在语法和编程范式上不仅继承了现代语言的特性，还针对生态进行了深度优化。理解Java与ArkTS的差异和共性，能够帮助开发者快速上手应用开发，避开常见的编程误区。

本文档基于Java语言对ArkTS语言进行对比和介绍。如需更详细的了解，可参考[ArkTS语言介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/introduction-to-arkts)。

## 探索Java与ArkTS的差异

本文档将帮助Java开发者梳理在转向ArkTS开发过程中会遇到的误解和陷阱。ArkTS的语法、类型系统以及应用开发模式与Java存在差异，在学习过程中需特别注意这些关键区别。建议先掌握ArkTS的基础语法和运行时行为，再重点对比其与Java的不同之处。

## 基础语法

### 变量声明

**ArkTS示例：**

1. // 类型注解（类似Java）。
2. let age: number = 20;
3. const program: string = 'ArkTS';

4. // 类型推断（类似Java的局部变量类型推断）。
5. let version = 5.0;

### 基础数据类型

|Java类型|ArkTS类型|示例代码|核心差异说明|
|:--|:--|:--|:--|
|boolean|boolean|let isDone: boolean = false;|定义方式相似，均用于逻辑判断，无运行时装箱拆箱操作。|
|byte|number|let b: number = 100;|Java中的byte为8位整数。<br><br>ArkTS统一用number表示小整数类型。|
|short|number|let s: number = 300;|Java中的short为16位整数。<br><br>ArkTS统一用number表示小整数类型。|
|int|number|let count: number = 10;|Java的int为32位整数。<br><br>ArkTS的number是双精度浮点型，可存储整数和浮点数。|
|long|number|let largeNum: number = 9007199254740991;|Java需加L后缀（如9007199254740991L）。<br><br>ArkTS用同一类型表示。|
|float|number|let pi: number = 3.14;|Java需加f后缀（如3.14f）。<br><br>ArkTS直接使用number，无需特殊标识。|
|double|number|let e: number = 2.71828;|Java区分float和double。<br><br>ArkTS统一用number表示所有数值类型。|
|char|string|let c: string = 'a';|ArkTS无char类型，单字符场景使用string。|
|String|string|let message: string = 'Hello';|定义方式类似，但ArkTS字符串支持模板字面量（如${name}）和更灵活的操作。|

### 复杂数据类型

|Java类型体系|ArkTS类型体系|ArkTS示例代码|核心差异说明|
|:--|:--|:--|:--|
|**数组**：int[] arr = new int[5];|**Array**：let arr: Array<number> = [1, 2, 3];|// 固定长度初始化（类似Java）<br><br>let fixedArr: number[] = new Array<number>(5);<br><br>// 动态长度语法糖<br><br>let dynamicArr = [4, 5, 6];|Java数组长度固定。<br><br>ArkTS的Array是动态数组，支持push/pop等操作；可直接用[]简化初始化。数组不会越界，当数组下标超过数组长度时会得到undefined。|
|**集合 - List**：List<String> list = new ArrayList<>();|**Array**：let strList: Array<string> = ['a', 'b'];|strList.push('c'); // 向数组末尾添加元素<br><br>let firstItem = strList[0]; // 索引访问|Java集合通过接口（如List）与实现类（如ArrayList）分离。<br><br>ArkTS数组兼具基础类型与集合特性，语法更简洁。|
|**集合 - Map**：Map<String, Integer> map = new HashMap<>();|**Map**：let map: Map<string, number> = new Map();|map.set('key', 1); // 添加键值对<br><br>let value = map.get('key'); // 获取值<br><br>map.has('key'); // 检查键是否存在|Java的Map需显式声明泛型类型。<br><br>ArkTS的Map操作更直接，支持链式调用（如map.set('a', 1).set('b', 2)）。|
|**接口**：interface Shape { double area(); }|**interface**：interface Shapes { area(): number; }|class Rectangles implements Shapes {<br><br>public width: number = 0;<br><br>public height: number = 0;<br><br>area(): number { return this.width * this.height; }<br><br>}|语法结构相似，但ArkTS接口实现无需显式修饰符（如Java的public），且支持可选属性（如name?: string）。|
|**类**：class Circle implements Shape { /* 类定义 */ }|**class**：class Circles implements Shape { /* 类定义 */ }|class Circles {<br><br>radius: number;<br><br>constructor(radius: number = 10) { // 支持参数默认值<br><br>this.radius = radius;<br><br>}<br><br>}|ArkTS类支持属性默认值、可选参数，构造函数参数可直接声明为类属性（如constructor(public name: string)），语法更简洁。|
|**枚举**：enum Color { RED, GREEN, BLUE; }|**enum**：enum Colors { Red, Green, Blue }|enum Colors { Red = 1, Green, Blue };<br><br>let color = Colors.Green; // 值为2（自动递增）|基本概念一致，但ArkTS枚举不支持Java中的自定义构造函数和方法，仅支持简单的数值或字符串枚举。|

### 函数

**ArkTS示例：**

1. // 常规函数定义。
2. function add(x: number, y: number): number {
3.     return x + y;
4. }

5. // 简洁的箭头函数形式。
6. const multiply = (a: number, b: number): number => a * b;

### 函数重载

Java在编译时多态，允许同一类中存在多个同名方法，通过参数列表（数量、类型、顺序）来进行区分。

- 通过多个具体方法实现重载，每个重载方法有独立的方法体。
    
- 参数列表（类型、数量、顺序）必须不同，返回值类型可以相同或不同。
    
- 编译时根据参数类型选择具体方法。
    

**Java示例：** Java函数重载

1. class Example {
2.     // 方法1：接受int参数。
3.     void print(int value) {
4.         System.out.println("Integer: " + value);
5.     }

6.     // 方法2：接受String参数。
7.     void print(String value) {
8.         System.out.println("String: " + value);
9.     }
10. }

ArkTS提供类型声明层面的多态，仅用于类型检查和文档提示，实际只有一个实现函数。

- 通过类型声明重载签名，但仅有一个实现函数。
    
- 实现函数需兼容所有重载签名，通常需要在函数体内手动判断参数类型。
    
- 类型检查器根据调用时的参数匹配声明，但运行时只有单一函数。
    

**ArkTS示例：** ArkTS函数重载

1. function foo(x: number): void;            /* 第一个函数定义 */
2. function foo(x: string): void;            /* 第二个函数定义 */
3. function foo(x: number | string): void {  /* 函数实现 */
4. }

5. foo(123);     //  OK，使用第一个定义。
6. foo('aa'); // OK，使用第二个定义。

### 基础类库

ArkTS基础类库和容器类库增强了语言的基础功能，包括高精度浮点运算、二进制Buffer、XML生成解析转换和多种容器库等能力，协助开发者简化开发工作，提升开发效率。详细介绍可见[ArkTS基础类库概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-utils-overview)。

## 语言结构

Java是一种典型的面向对象的编程语言，即一切围绕类和对象展开。

ArkTS采用更为灵活的语言结构，融合了面向对象编程和函数式编程等多种范式。

### 模块与包管理

在Java中，开发者使用包（package）来组织代码，通过import语句引入其他包中的类。ArkTS也有自己的模块和包管理机制，同样通过import语句引入其他模块中的功能。

**ArkTS示例：**

1. // 引入ArkTS标准库中的ArkTS容器集。

2. import { collections } from '@kit.ArkTS';

由于ArkTS的模块系统更注重模块化开发和代码复用，能够更便捷地管理不同功能模块之间的依赖关系，所以在使用方式上，与Java的包管理会有所区别。

### 类与命名空间特性

ArkTS的类系统在语法层面与Java相似，但在高阶特性上展现出更现代的设计理念。

|特性|Java实现方式|ArkTS实现方式|说明|
|:--|:--|:--|:--|
|命名空间组织|静态嵌套类/内部类|namespace关键字或模块文件结构。|支持显式命名空间与模块化组织的混合模式。|
|类继承机制|基于类的继承体系|基于原型链的继承机制。|语法相似但底层机制不同。|
|类成员可见性|public/private/protected|同Java，但支持[模块级](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-principle)可见性控制。|增加了模块导出控制的维度。|

**命名空间管理**

ArkTS支持显式命名空间（namespace）和模块化组织。

**ArkTS示例：**

1. namespace Models {
2.     export class User {
3.         // 实现细节。
4.     }

5.     export interface Repository {
6.         // 接口定义。
7.     }
8. }

相比Java的package+static class组合，ArkTS的命名空间能更直观地实现代码分层。

### 异步编程模型

**单线程vs多线程**

Java依赖多线程和Future/CompletableFuture实现并发。

ArkTS基于事件循环，使用Promise/async/await处理异步，避免阻塞主线程。

**错误处理**

Java的同步代码通过try/catch捕获异常，异步异常需特殊处理（如Future.get()）。

ArkTS中未捕获的Promise错误可能导致静默失败，需显式使用try/catch或.catch。

### this的绑定

Java的this始终指向当前类的实例对象，由代码结构在编译时确定。在方法中，this指向调用该方法的对象实例，无法通过调用方式改变this的指向。

**Java示例：**

1. class MyClass {
2.   void method() {
3.     System.out.println(this); // 始终指向MyClass的实例。
4.   }
5. }

ArkTS的this指向取决于函数调用时的上下文。

**ArkTS示例：**

1. class A {
2.   bar: string = 'I am A';

3.   foo() {
4.     console.info(this.bar);
5.   }
6. }

7. class B {
8.   bar: string = 'I am B';

9.   callFunction(fn: () => void) {
10.     fn();
11.   }
12. }

13. function callFunction(fn: () => void) {
14.   fn();
15. }

16. let a: A = new A();
17. let b: B = new B();

18. callFunction(a.foo); // 程序crash。this的上下文发生了变化。
19. b.callFunction(a.foo); // 程序crash。this的上下文发生了变化。
20. b.callFunction(a.foo.bind(b)) // 输出'I am B'。

## 类型系统

ArkTS与Java的类型系统也存在差异。

### 类型推断与可选类型

相较于Java需要显式类型声明和严格的null检查，ArkTS的类型系统提供了更灵活的表达方式。

ArkTS具有强大的类型推断能力，编译器能够根据上下文自动推断出变量的类型，所以很多时候不需要显式声明变量的类型。

**ArkTS示例：**

1. let num = 10; // 编译器自动推断num为number类型。

同时，ArkTS支持可选类型，通过在类型后面添加问号（?）来表示该变量可以为null或undefined。

**ArkTS示例：**

1. interface Person {
2.   name: string;
3.   age?: number;  // age 是可选属性。
4. }

5. const person: Person = {
6.   name: "Alice",
7. };

### 联合类型

联合类型这种类型组合能力为复杂场景提供了更强的表达力，是ArkTS类型系统的重要创新点。

ArkTS支持联合类型（|）。联合类型表示一个值可以是多种类型中的一种。

**ArkTS示例：**

1. // 联合类型示例。

2. let value: string | number;
3. value = 'hello';
4. value = 123;
# XML概述

更新时间: 2025-12-16 16:38

XML（可扩展标记语言）是一种用于描述数据的标记语言，提供通用的数据传输和存储方式。XML不预定义标记，因此更加灵活，适用于广泛的应用领域。

XML文档由元素（element）、属性（attribute）和内容（content）组成。

- 元素指的是标记对，包含文本、属性或其他元素。
    
- 属性提供了有关元素的其他信息。
    
- 内容则是元素包含的数据或子元素。
    

XML使用XML Schema或DTD（文档类型定义）定义文档结构，开发人员可以利用这些机制创建自定义规则，以验证XML文档的格式是否符合预期规范。

XML支持命名空间、实体引用、注释和处理指令，灵活适应各种数据需求。

语言基础类库提供了XML相关的基础能力，包括：[XML的生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/xml-generation)、[XML的解析](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/xml-parsing)和[XML的转换](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/xml-conversion)。

以下是一个简单的XML样例及对应说明，更多XML的接口和具体使用，请见[@ohos.xml](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-xml)。

1. <!-- 声明 -->
2. <?xml version="1.0" encoding="utf-8"?>
3. <!-- 处理指令 -->
4. <?xml-stylesheet type="text/css" href="style.css"?>
5. <!-- 元素、属性及属性值 -->
6. <note importance="high">
7.     <title>Happy</title>
8.     <!-- 实体引用 -->
9.     <todo>&amp;</todo>
10.     <!-- 命名空间的声明及统一资源标识符 -->
11.     <h:table xmlns:h="http://www.w3.org/TR/html4/">
12.         <h:tr>
13.             <h:td>Apples</h:td>
14.             <h:td>Bananas</h:td>
15.         </h:tr>
16.     </h:table>
17. </note>

# XML生成

更新时间: 2025-12-16 16:39

XML可以作为数据交换格式，被各种系统和应用程序支持。例如Web服务，可以将结构化数据以XML格式进行传递。

XML还可以作为消息传递格式，用于分布式系统中不同节点的通信。

## 注意事项

- XML标签必须成对出现，生成开始标签就要生成结束标签。
    
- XML标签对大小写敏感，开始标签与结束标签大小写要一致。
    

## 开发步骤

XML模块提供XmlSerializer及XmlDynamicSerializer类来生成XML数据，使用XmlSerializer需传入固定长度的ArrayBuffer或DataView对象作为输出缓冲区，用于存储序列化后的XML数据。

XmlDynamicSerializer类动态扩容，程序根据实际生成的数据大小自动创建ArrayBuffer。

调用不同的方法写入不同的内容，如startElement(name: string)写入元素开始标记，setText(text: string)写入标签值。

XML模块的API接口可以参考[@ohos.xml](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-xml)的详细描述，按需求调用相应的函数可以生成一份完整的XML数据。

使用XmlSerializer生成XML示例如下：

1. 引入模块。
    
    1. import { xml, util } from '@kit.ArkTS';
    
2. 创建缓冲区，构造XmlSerializer对象。可以基于ArrayBuffer构造XmlSerializer对象，也可以基于DataView构造XmlSerializer对象。
    
    方式1：基于ArrayBuffer构造XmlSerializer对象
    
    1. let arrayBuffer: ArrayBuffer = new ArrayBuffer(2048); // 创建一个2048字节的缓冲区
    2. let serializer: xml.XmlSerializer = new xml.XmlSerializer(arrayBuffer); // 基于ArrayBuffer构造XmlSerializer对象
    
    方式2：基于DataView构造XmlSerializer对象
    
    1. let arrayBuffer: ArrayBuffer = new ArrayBuffer(2048); // 创建一个2048字节的缓冲区
    2. let dataView: DataView = new DataView(arrayBuffer); // 创建一个DataView
    3. let serializer: xml.XmlSerializer = new xml.XmlSerializer(dataView); // 基于DataView构造XmlSerializer对象
    
3. 调用XML元素生成函数。
    
    1. serializer.setDeclaration(); // 写入XML的声明
    2. serializer.startElement('bookstore'); // 写入元素开始标记
    3. serializer.startElement('book'); // 嵌套元素开始标记
    4. serializer.setAttributes('category', 'COOKING'); // 写入属性及其属性值
    5. serializer.startElement('title');
    6. serializer.setAttributes('lang', 'en');
    7. serializer.setText('Everyday'); // 写入标签值
    8. serializer.endElement(); // 写入结束标记
    9. serializer.startElement('author');
    10. serializer.setText('Giana');
    11. serializer.endElement();
    12. serializer.startElement('year');
    13. serializer.setText('2005');
    14. serializer.endElement();
    15. serializer.endElement();
    16. serializer.endElement();
    
4. 使用Uint8Array操作ArrayBuffer，并调用TextDecoder对Uint8Array解码后输出。
    
    1. let uint8Array: Uint8Array = new Uint8Array(arrayBuffer); // 使用Uint8Array读取arrayBuffer的数据
    2. let textDecoder: util.TextDecoder = util.TextDecoder.create(); // 调用util模块的TextDecoder类
    3. let result: string = textDecoder.decodeToString(uint8Array); // 对uint8Array解码
    4. console.info(result);
    
    输出结果如下：
    
    1. <?xml version="1.0" encoding="utf-8"?><bookstore>
    2.   <book category="COOKING">
    3.     <title lang="en">Everyday</title>
    4.     <author>Giana</author>
    5.     <year>2005</year>
    6.   </book>
    7. </bookstore>
    

使用XmlDynamicSerializer生成XML示例如下：

1. 引入模块。
    
    1. import { xml, util } from '@kit.ArkTS';
    
2. 调用XML元素生成函数。
    
    1. let DySerializer = new xml.XmlDynamicSerializer('utf-8');
    2. DySerializer.setDeclaration(); // 写入XML的声明
    3. DySerializer.startElement('bookstore'); // 写入元素开始标记
    4. DySerializer.startElement('book'); // 嵌套元素开始标记
    5. DySerializer.setAttributes('category', 'COOKING'); // 写入属性及其属性值
    6. DySerializer.startElement('title');
    7. DySerializer.setAttributes('lang', 'en');
    8. DySerializer.setText('Everyday'); // 写入标签值
    9. DySerializer.endElement(); // 写入结束标记
    10. DySerializer.startElement('author');
    11. DySerializer.setText('Giana');
    12. DySerializer.endElement();
    13. DySerializer.startElement('year');
    14. DySerializer.setText('2005');
    15. DySerializer.endElement();
    16. DySerializer.endElement();
    17. DySerializer.endElement();
    18. let arrayBuffer = DySerializer.getOutput();
    
3. 使用Uint8Array操作ArrayBuffer，并调用TextDecoder对Uint8Array解码后输出。
    
    1. let uint8Array: Uint8Array = new Uint8Array(arrayBuffer);
    2. let result: string = util.TextDecoder.create().decodeToString(uint8Array);
    3. console.info(result);
    
    输出结果如下：
    
    4. <?xml version="1.0" encoding="utf-8"?>
    5. <bookstore>
    6.   <book category="COOKING">
    7.     <title lang="en">Everyday</title>
    8.     <author>Giana</author>
    9.     <year>2005</year>
    10.   </book>
    11. </bookstore>
    # XML解析

更新时间: 2025-12-16 16:39

对于以XML作为载体传递的数据，实际使用中需要对相关的元素进行解析，一般包括[解析XML标签和标签值](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/xml-parsing#%E8%A7%A3%E6%9E%90xml%E6%A0%87%E7%AD%BE%E5%92%8C%E6%A0%87%E7%AD%BE%E5%80%BC)、[解析XML属性和属性值](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/xml-parsing#%E8%A7%A3%E6%9E%90xml%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%80%BC)、[解析XML事件类型和元素信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/xml-parsing#%E8%A7%A3%E6%9E%90xml%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%83%E7%B4%A0%E4%BF%A1%E6%81%AF)三类操作。如在Web服务中，XML是SOAP（Simple Object Access Protocol）协议的基础，SOAP消息通常以XML格式封装，包含请求和响应参数，通过解析这些XML消息，Web服务可以处理来自客户端的请求并生成相应的响应。

XML模块提供XmlPullParser类用于解析XML文本，输入为包含XML数据的ArrayBuffer或DataView，输出为结构化的解析结果。

**表1** XML解析选项，其详细介绍请参见[ParseOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-xml#parseoptions)。

|名称|类型|必填|说明|
|:--|:--|:--|:--|
|supportDoctype|boolean|否|是否解析文档类型，false表示不解析文档类型，true表示解析文档类型，默认false。|
|ignoreNameSpace|boolean|否|是否忽略命名空间，忽略命名空间后，将不会对其进行解析。true表示忽略命名空间，false表示不忽略命名空间，默认false。|
|tagValueCallbackFunction|(name: string, value: string) => boolean|否|获取tagValue回调函数，打印XML标签及标签值。默认为undefined，表示不解析XML标签和标签值。|
|attributeValueCallbackFunction|(name: string, value: string) => boolean|否|获取attributeValue回调函数，打印XML属性及属性值。默认为undefined，表示不解析XML属性和属性值。|
|tokenValueCallbackFunction|(eventType: EventType, value: ParseInfo) => boolean|否|获取tokenValue回调函数，打印XML事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。|

## 注意事项

- 确保传入的XML数据符合标准格式。
    
- 目前不支持解析指定节点的值。
    

## 解析XML标签和标签值

1. 引入模块。
    
    1. import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文本编码
    
2. 对XML文本编码后调用XmlPullParser。
    
    可以基于ArrayBuffer创建XmlPullParser对象，也可以基于DataView创建XmlPullParser对象（两种创建方式返回结果无区别）。
    
    1. let strXml: string =
    2. '<?xml version="1.0" encoding="utf-8"?>' +
    3.   '<note importance="high" logged="true">' +
    4.   '<title>Play</title>' +
    5.   '<lens>Work</lens>' +
    6.   '</note>';
    7. let textEncoder: util.TextEncoder = new util.TextEncoder();
    8. let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据进行编码，防止中文字符乱码
    9. // 方式1：基于ArrayBuffer构造XmlPullParser对象
    10. let xmlParser: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');
    
    11. // 方式2：基于DataView构造XmlPullParser对象
    12. // let dataView: DataView = new DataView(arrBuffer.buffer as object as ArrayBuffer);
    13. // let xmlParser: xml.XmlPullParser = new xml.XmlPullParser(dataView, 'UTF-8');
    
3. 自定义回调函数，本例直接打印出标签及标签值。
    
    1. function func(name: string, value: string): boolean {
    2.   if (name == 'note') {
    3.     console.info(name);
    4.   }
    5.   if (value == 'Play' || value == 'Work') {
    6.     console.info('    ' + value);
    7.   }
    8.   if (name == 'title' || name == 'lens') {
    9.     console.info('  ' + name);
    10.   }
    11.   return true; //true:继续解析 false:停止解析
    12. }
    
4. 设置解析选项，调用parseXml函数。
    
    1. let options: xml.ParseOptions = {supportDoctype:true, ignoreNameSpace:true, tagValueCallbackFunction:func};
    2. xmlParser.parseXml(options);
    
    输出结果如下所示：
    
    1. note
    2.   title
    3.     Play
    4.   title
    5.   lens
    6.     Work
    7.   lens
    8. note
    

## 解析XML属性和属性值

1. 引入模块。
    
    1. import { xml, util } from '@kit.ArkTS'; // 使用util模块对文本编码
    
2. 对XML文本编码后调用XmlPullParser。
    
    1. let strXml: string =
    2.   '<?xml version="1.0" encoding="utf-8"?>' +
    3.     '<note importance="high" logged="true">' +
    4.     '    <title>Play</title>' +
    5.     '    <title>Happy</title>' +
    6.     '    <lens>Work</lens>' +
    7.     '</note>';
    8. let textEncoder: util.TextEncoder = new util.TextEncoder();
    9. let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据进行编码，防止中文字符乱码
    10. let xmlParser: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');
    
3. 自定义回调函数，示例直接打印出属性及属性值。
    
    1. let str: string = '';
    2. function func(name: string, value: string): boolean {
    3.   str += name + ' ' + value + ' ';
    4.   return true; // true:继续解析 false:停止解析
    5. }
    
4. 设置解析选项，调用parseXml函数。
    
    1. let options: xml.ParseOptions = {supportDoctype:true, ignoreNameSpace:true, attributeValueCallbackFunction:func};
    2. xmlParser.parseXml(options);
    3. console.info(str); // 打印所有属性及其值
    
    输出结果如下所示：
    
    4. importance high logged true // note节点的属性及属性值
    

## 解析XML事件类型和元素信息

1. 引入模块。
    
    1. import { xml, util } from '@kit.ArkTS'; // 使用util模块函数对文本编码
    
2. 对XML文本编码后调用XmlPullParser。
    
    1. let strXml: string =
    2.   '<?xml version="1.0" encoding="utf-8"?>' +
    3.   '<note importance="high" logged="true">' +
    4.   '<title>Play</title>' +
    5.   '</note>';
    6. let textEncoder: util.TextEncoder = new util.TextEncoder();
    7. let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据进行编码，防止中文字符乱码
    8. let xmlParser: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');
    
3. 自定义回调函数，示例直接打印元素事件类型及元素深度。
    
    1. let str: string = '';
    2. function func(name: xml.EventType, value: xml.ParseInfo): boolean {
    3.   str = name + ' ' + value.getDepth(); // getDepth 获取元素在XML文档中的当前深度
    4.   console.info(str);
    5.   return true; // true:继续解析 false:停止解析
    6. }
    
4. 设置解析选项，调用parseXml函数。
    
    1. let options: xml.ParseOptions = {supportDoctype:true, ignoreNameSpace:true, tokenValueCallbackFunction:func};
    2. xmlParser.parseXml(options);
    
    输出结果如下所示：
    
    1.  0 0 // 0：<?xml version="1.0" encoding="utf-8"?> 对应事件类型START_DOCUMENT值为0  0：起始深度为0
    2.  2 1 // 2：<note importance="high" logged="true"> 对应事件类型START_TAG值为2  1：深度为1
    3.  2 2 // 2：<title>对应事件类型START_TAG值为2  2：深度为2
    4.  4 2 // 4：Play对应事件类型TEXT值为4  2：深度为2
    5.  3 2 // 3：</title>对应事件类型END_TAG值为3  2：深度为2
    6.  3 1 // 3：</note>对应事件类型END_TAG值为3  1：深度为1（与<note对应>）
    7.  1 0 // 1：对应事件类型END_DOCUMENT值为1  0：深度为0
    

## 场景示例

此处以调用所有解析选项为例，提供解析XML标签、属性和事件类型的开发示例。

1. import { xml, util } from '@kit.ArkTS';

2. let strXml: string =
3.   '<?xml version="1.0" encoding="UTF-8"?>' +
4.     '<book category="COOKING">' +
5.     '<title lang="en">Everyday</title>' +
6.     '<author>Giana</author>' +
7.     '</book>';
8. let textEncoder: util.TextEncoder = new util.TextEncoder();
9. let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml);
10. let xmlParser: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');
11. let str: string = '';

12. function tagFunc(name: string, value: string): boolean {
13.   str = name + value;
14.   console.info('tag-' + str);
15.   return true;
16. }

17. function attFunc(name: string, value: string): boolean {
18.   str = name + ' ' + value;
19.   console.info('attri-' + str);
20.   return true;
21. }

22. function tokenFunc(name: xml.EventType, value: xml.ParseInfo): boolean {
23.   str = name + ' ' + value.getDepth();
24.   console.info('token-' + str);
25.   return true;
26. }

27. let options: xml.ParseOptions = {
28.   supportDoctype: true,
29.   ignoreNameSpace: true,
30.   tagValueCallbackFunction: tagFunc,
31.   attributeValueCallbackFunction: attFunc,
32.   tokenValueCallbackFunction: tokenFunc
33. };
34. xmlParser.parseXml(options);

输出结果如下所示：

1. tag-
2. token-0 0
3. tag-book
4. token-2 1
5. attri-category COOKING
6. tag-title
7. token-2 2
8. attri-lang en
9. tag-Everyday
10. token-4 2
11. tag-title
12. token-3 2
13. tag-author
14. token-2 2
15. tag-Giana
16. token-4 2
17. tag-author
18. token-3 2
19. tag-book
20. token-3 1
21. tag-
22. token-1 0
# XML转换

更新时间: 2025-12-16 16:39

将XML文本转换为JavaScript对象，便于处理和操作数据，适用于JavaScript应用程序。

语言基础类库提供ConvertXML类，将XML文本转换为JavaScript对象，输入为待转换的XML字符串及转换选项，输出为转换后的JavaScript对象。具体转换选项可见[API参考@ohos.convertxml](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-convertxml)。

## 注意事项

XML解析及转换需要确保传入的XML数据符合XML标准格式。

## 开发步骤

以XML转换为JavaScript对象为例，说明如何获取标签值。

1. 引入所需的模块。
    
    1. import { convertxml } from '@kit.ArkTS';
    
2. 输入待转换的XML，设置转换选项。支持的转换选项及含义，请参见[ConvertOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-convertxml#convertoptions)。
    
    说明
    
    请确保传入的XML文本符合标准格式，若包含“&”字符，请使用实体引用“&amp;”替换。
    
    1. let xml: string =
    2.  '<?xml version="1.0" encoding="utf-8"?>' +
    3.  '<note importance="high" logged="true">' +
    4.  '    <title>Happy</title>' +
    5.  '    <todo>Work</todo>' +
    6.  '    <todo>Play</todo>' +
    7.  '</note>';
    8. let options: convertxml.ConvertOptions = {
    9.   // trim: false 转换后是否删除文本前后的空格，否
    10.   // declarationKey: "_declaration" 转换后文件声明使用_declaration来标识
    11.   // instructionKey: "_instruction" 转换后指令使用_instruction标识
    12.   // attributesKey: "_attributes" 转换后属性使用_attributes标识
    13.   // textKey: "_text" 转换后标签值使用_text标识
    14.   // cdataKey: "_cdata" 转换后未解析数据使用_cdata标识
    15.   // docTypeKey: "_doctype" 转换后文档类型使用_doctype标识
    16.   // commentKey: "_comment" 转换后注释使用_comment标识
    17.   // parentKey: "_parent" 转换后父类使用_parent标识
    18.   // typeKey: "_type" 转换后元素类型使用_type标识
    19.   // nameKey: "_name" 转换后标签名称使用_name标识
    20.   // elementsKey: "_elements" 转换后元素使用_elements标识
    21.   trim: false,
    22.   declarationKey: "_declaration",
    23.   instructionKey: "_instruction",
    24.   attributesKey: "_attributes",
    25.   textKey: "_text",
    26.   cdataKey: "_cdata",
    27.   doctypeKey: "_doctype",
    28.   commentKey: "_comment",
    29.   parentKey: "_parent",
    30.   typeKey: "_type",
    31.   nameKey: "_name",
    32.   elementsKey: "_elements"
    33. }
    
3. 调用fastConvertToJSObject函数并打印结果。
    
    1. let conv: convertxml.ConvertXML = new convertxml.ConvertXML();
    2. let result: object = conv.fastConvertToJSObject(xml, options);
    3. let strRes: string = JSON.stringify(result); // 将js对象转换为json字符串，用于显式输出
    4. console.info(strRes);
    
    输出结果如下所示：
    
    1. strRes:
    2. {"_declaration":{"_attributes":{"version":"1.0","encoding":"utf-8"}},"_elements":[{"_type":"element","_name":"note",
    3.  "_attributes":{"importance":"high","logged":"true"},"_elements":[{"_type":"element","_name":"title","_parent":"note",
    4.  "_elements":[{"_type":"text","_text":"Happy"}]},{"_type":"element","_name":"todo","_parent":"note","_elements":
    5.  [{"_type":"text","_text":"Work"}]},{"_type":"element","_name":"todo","_parent":"note","_elements":[{"_type":"text",
    6.  "_text":"Play"}]}]}]}
    # JSON扩展库

更新时间: 2025-12-16 16:38

## 场景介绍

该库扩展了原生JSON功能，提供了额外的错误处理、循环引用检测、BigInt处理以及对不同输入类型的严格检查。代码中底层依赖于原生JSON.parse和JSON.stringify，但在此基础上加入了多种自定义逻辑并提供额外的has和remove接口，具体可见[@arkts.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-json)。

JSON扩展库主要适用于以下场景：

- 需要处理BigInt的JSON解析或序列化。
    
- 需要更严格的参数校验和错误处理。
    
- 需要在序列化对象时检测循环引用。
    
- 需要安全的对象操作（has/remove）。
    

该库适用于需要增强JSON功能的场景，特别是在处理BigInt和严格的参数校验时。

## JSON扩展说明

### parse

parse(text: string, reviver?: Transformer, options?: ParseOptions): Object | null

解析JSON字符串，支持BigInt模式。

**与原生的区别：**

|特性|原生parse|本库parse|
|:--|:--|:--|
|BigInt支持|不支持（抛出TypeError）|支持（通过parseBigInt扩展）|
|参数校验|弱校验|强校验（抛出BusinessError）|
|错误信息|原生错误（如SyntaxError）|自定义BusinessError|
|reviver参数|支持|支持，但强制类型检查|

### stringify

stringify(value: Object, replacer?: (number | string)[] | null, space?: string | number): string

将对象转换为JSON字符串，支持BigInt模式。

**与原生的区别：**

|特性|原生stringify|本库stringify|
|:--|:--|:--|
|BigInt支持|不支持（抛出TypeError）|支持（通过stringifyBigInt扩展）|
|循环引用检测|抛出TypeError|检测并抛出BusinessError|
|参数校验|弱校验|强校验（replacer必须是函数或数组）|
|错误信息|原生错误|自定义BusinessError|

### has

has(obj: object, property: string): boolean

检查对象是否包含指定的属性，确保传入的值是一个对象，并且属性键是有效的字符串。

**与原生的区别：**

|特性|原生方式（obj.hasOwnProperty）|本库has|
|:--|:--|:--|
|参数校验|无校验（可能误用）|强制检查obj是普通对象，property是非空字符串|
|错误处理|可能静默失败|抛出BusinessError|

### remove

remove(obj: object, property: string): void

从对象中删除指定的属性。

|特性|原生方式（delete obj.key）|本库remove|
|:--|:--|:--|
|参数校验|无校验（可能误删）|强制检查obj是普通对象，property是非空字符串|
|错误处理|可能静默失败|抛出BusinessError|

### 总结

|功能|原生JSON|本库|
|:--|:--|:--|
|严格参数校验|不支持|支持|
|循环引用检测|不支持|支持|
|BigInt处理|不支持|支持|
|增强的错误处理（BusinessError）|不支持|支持|
|额外方法（has/remove）|不支持|支持|

## 开发场景

### 解析包含嵌套引号的JSON字符串场景

JSON字符串中的嵌套引号会破坏其结构，将导致解析失败。

1. // 比如以下JSON字符串，由于嵌套引号导致结构破坏，执行JSON.parse将会抛异常。
2. // let jsonStr = `{"info": "{"name": "zhangsan", "age": 18}"}`;

以下提供两种方式解决该场景问题：

方式1：避免出现嵌套引号的操作。

1. import { JSON } from '@kit.ArkTS';

2. interface Info {
3.   name: string;
4.   age: number;
5. }

6. interface TestObj {
7.   info: Info;
8. }

9. interface TestStr {
10.   info: string;
11. }

12. /*
13.  * 将原始JSON字符串`{"info": "{"name": "zhangsan", "age": 18}"}`
14.  * 修改为`{"info": {"name": "zhangsan", "age": 18}}`。
15.  * */
16. let jsonStr = `{"info": {"name": "zhangsan", "age": 18}}`;
17. let obj1  = JSON.parse(jsonStr) as TestObj;
18. console.info(JSON.stringify(obj1));    //{"info":{"name":"zhangsan","age":18}}
19. // 获取JSON字符串中的name信息
20. console.info(obj1.info.name); // zhangsan

方式2：将JSON字符串中嵌套的引号进行双重转义，恢复JSON的正常结构。

1. import { JSON } from '@kit.ArkTS';

2. interface Info {
3.   name: string;
4.   age: number;
5. }

6. interface TestObj {
7.   info: Info;
8. }

9. interface TestStr {
10.   info: string;
11. }

12. /*
13.  * 将原始JSON字符串`{"info": "{"name": "zhangsan", "age": 18}"}`进行双重转义，
14.  * 修改为`{"info": "{\\"name\\": \\"zhangsan\\", \\"age\\": 18}"}`。
15.  * */
16. let jsonStr = `{"info": "{\\"name\\": \\"zhangsan\\", \\"age\\": 18}"}`;
17. let obj2 = JSON.parse(jsonStr) as TestStr;
18. console.info(JSON.stringify(obj2));    // {"info":"{\"name\": \"zhangsan\", \"age\": 18}"}
19. // 获取JSON字符串中的name信息
20. let obj3 = JSON.parse(obj2.info) as Info;
21. console.info(obj3.name); // zhangsan

### 解析包含大整数的JSON字符串场景

当JSON字符串中存在小于-(2^53-1)或大于(2^53-1)的整数时，解析后数据会出现精度丢失或不正确的情况。该解析场景需要指定BigIntMode，将大整数解析为BigInt。

1. import { JSON } from '@kit.ArkTS';

2. let numberText = '{"number": 10, "largeNumber": 112233445566778899}';

3. let numberObj1 = JSON.parse(numberText) as Object;
4. console.info((numberObj1 as object)?.["largeNumber"]);    // 112233445566778900

5. // 使用PARSE_AS_BIGINT的BigInt模式进行解析，避免出现大整数解析错误。
6. let options: JSON.ParseOptions = {
7.   bigIntMode: JSON.BigIntMode.PARSE_AS_BIGINT,
8. }

9. let numberObj2 = JSON.parse(numberText, null, options) as Object;

10. console.info(typeof (numberObj2 as object)?.["number"]);   // number
11. console.info((numberObj2 as object)?.["number"]);    // 10

12. console.info(typeof (numberObj2 as object)?.["largeNumber"]);    // bigint
13. console.info((numberObj2 as object)?.["largeNumber"]);    // 112233445566778899

### 序列化BigInt对象场景

为弥补原生JSON无法序列化BigInt对象的缺陷，本库提供以下两种JSON序列化方式：

方式1：不使用自定义转换函数，直接序列化BigInt对象。

1. import { JSON } from '@kit.ArkTS';

2. let bigIntObject = BigInt(112233445566778899n)

3. console.info(JSON.stringify(bigIntObject)); // 112233445566778899

方式2：使用自定义转换函数，需预处理BigInt对象进行序列化操作。

1. import { JSON } from '@kit.ArkTS';

2. let bigIntObject = BigInt(112233445566778899n)

3. // 错误序列化用法：自定义函数中直接返回BigInt对象
4. // JSON.stringify(bigIntObject, (key: string, value: Object): Object =>{ return value; });

5. // 正确序列化用法：自定义函数中将BigInt对象预处理为string对象
6. let result: string = JSON.stringify(bigIntObject, (key: string, value: Object): Object => {
7.   if (typeof value === 'bigint') {
8.     return value.toString();
9.   }
10.   return value;
11. });
12. console.info("result:", result); // result: "112233445566778899"

### 序列化浮点数number场景

在JSON序列化中，浮点数处理存在一个特殊行为：当小数部分为零时，为保持数值的简洁表示，序列化结果会自动省略小数部分。这可能导致精度信息丢失，影响需要精确表示浮点数的场景（如金融金额、科学计量）。以下示例提供解决该场景的方法：

1. import { JSON } from '@kit.ArkTS';

2. // 序列化小数部分不为零的浮点数，可以正常序列化。
3. let floatNumber1 = 10.12345;
4. console.info(JSON.stringify(floatNumber1)); // 10.12345

5. // 序列化小数部分为零的浮点数，为保持数值的简洁表示，会丢失小数部分的精度。
6. let floatNumber2 = 10.00;
7. console.info(JSON.stringify(floatNumber2)); // 10

8. // 以下是防止浮点数精度丢失的方法：
9. let result = JSON.stringify(floatNumber2, (key: string, value: Object): Object => {
10.   if (typeof value === 'number') {
11.     // 按照业务场景需要，定制所需的固定精度。
12.     return value.toFixed(2);
13.   }
14.   return value;
15. });
16. console.info(result); // "10.00"
# 线性容器

更新时间: 2025-12-16 16:39

线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue和Stack。

线性容器优化了数据访问速度，运行时（Runtime）通过一条字节码指令即可完成增、删、改、查等操作。

## 各线性容器类型特征对比

|类名|特征及建议使用场景|
|:--|:--|
|ArrayList|动态数组，占用一片连续的内存空间。需要频繁读取元素时推荐使用。|
|List|单向链表，占用的空间可以不连续。推荐在需要频繁插入和删除元素，且需要使用单向链表时使用。|
|LinkedList|双向链表，占用的空间可以不连续。推荐在需要频繁插入和删除元素，且需要使用双向链表时使用。|
|Deque|双端队列，支持从头尾两端进行元素的插入和删除操作，占用连续的内存空间。推荐在需要频繁访问和操作头尾元素时使用。|
|Queue|队列，是一种从尾部插入元素、从头部移除元素的数据结构，占用连续的内存空间，适用于先进先出的场景。|
|Stack|栈，只能从一端进行插入和删除操作，占用连续的内存空间。适用于先进后出的场景。|
|Vector|动态数组，占用连续的内存空间。已不再维护，推荐使用ArrayList。|

## ArrayList

[ArrayList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist)即动态数组，可用来构造全局的数组对象。需要频繁读取集合元素时，推荐使用ArrayList。

ArrayList依据泛型定义，存储位置为连续的内存空间，初始容量为10，支持动态扩容，每次扩容为原始容量的1.5倍。

ArrayList支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(element: T)|在数组尾部增加一个元素。|
|增加元素|insert(element: T, index: number)|在指定位置插入一个元素。|
|访问元素|arr[index: number]|获取指定index对应的value值。|
|访问元素|forEach(callbackFn: (value: T, index?: number, arrlist?: ArrayList<T>) => void, thisArg?: Object)|访问整个ArrayList容器的元素，其中callbackFn是forEach方法中用于处理每个元素的回调函数，它接收当前元素、索引和原列表作为参数。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|修改元素|arr[index] = xxx|修改指定index位置对应的value值。|
|删除元素|remove(element: T)|删除第一个匹配到的元素。|
|删除元素|removeByRange(fromIndex: number, toIndex:number)|删除指定范围内的元素。|

## List

[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-list)可用来构造一个单向链表对象，若需要查找List中某一个元素，只能从头结点开始遍历。List依据泛型定义，存储的元素在内存中的存储位置可以不连续。

List和[LinkedList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-linkedlist)相比，LinkedList是双向链表，支持在头部和尾部快速增删操作。List则是单向链表，不支持双向操作。

当需要频繁插入和删除元素，并且使用单向链表时，推荐使用List进行高效操作。

可以通过get/set等接口修改存储的元素，List支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(element: T)|在数组尾部增加一个元素。|
|增加元素|insert(element: T, index: number)|在指定位置增加一个元素。|
|访问元素|get(index: number)|获取指定index位置对应的元素。|
|访问元素|list[index: number]|获取指定索引位置的元素。若索引超出数组范围（index < 0 或 index >= list.length），或者数组是稀疏数组（存在未赋值的索引），则返回undefined。|
|访问元素|getFirst()|获取第一个元素。|
|访问元素|getLast()|获取最后一个元素。|
|访问元素|getIndexOf(element: T)|获取第一个匹配指定元素的位置。|
|访问元素|getLastIndexOf(element: T)|获取最后一个匹配指定元素的位置。|
|访问元素|forEach(callbackfn: (value:T, index?: number, list?: List<T>)=> void,thisArg?: Object)|遍历访问整个List容器中的每个元素，并执行指定的回调函数。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|修改元素|set(index:number, element: T)|修改指定index位置的元素值为element。|
|修改元素|list[index] = element|修改指定index位置的元素值为element时，不会对链表中的实际节点进行任何更改，仅会在对象上添加一个属性，这将导致程序状态与链表实际内容不一致，从而产生未定义行为。|
|修改元素|replaceAllElements(callbackFn:(value: T,index?: number,list?: List<T>)=>T,thisArg?: Object)|对List内元素进行逐个替换。|
|删除元素|remove(element: T)|通过 === 运算符逐个比对链表中的元素，删除第一个匹配成功的节点。对于对象类型，只有当传入的对象与链表中某节点的引用完全一致时才会被删除。|
|删除元素|removeByIndex(index:number)|删除index位置对应的元素，如果index超出范围，则会报out of range错误。|

## LinkedList

[LinkedList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-linkedlist)可用于构造双向链表对象，支持在任意节点向前或向后遍历LinkedList。LinkedList依据泛型定义，其元素在内存中的存储位置可以不连续。

LinkedList和[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-list)相比，LinkedList是双向链表，支持快速的头尾增删操作。List是单向链表，不支持双向操作。

LinkedList和[ArrayList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist)相比，LinkedList插入数据的效率高于ArrayList，ArrayList查询效率高于LinkedList。

需要频繁插入删除元素且使用双向链表时，推荐使用LinkedList。

可以通过get/set等接口修改存储的元素。LinkedList支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(element: T)|在数组尾部增加一个元素。|
|增加元素|insert(element: T, index: number)|在指定位置插入一个元素。|
|访问元素|get(index: number)|获取指定index位置对应的元素。|
|访问元素|list[index: number]|获取指定index位置对应的元素，若索引超出数组范围（index < 0 或 index >= list.length），或者数组是稀疏数组（存在未赋值的索引），则返回undefined。|
|访问元素|getFirst()|获取第一个元素。|
|访问元素|getLast()|获取最后一个元素。|
|访问元素|getIndexOf(element: T)|获取第一个匹配指定元素的位置。|
|访问元素|getLastIndexOf(element: T)|获取最后一个匹配指定元素的位置。|
|访问元素|forEach(callbackFn: (value: T, index?: number, list?: LinkedList<T>) => void, thisArg?: Object)|遍历访问整个LinkedList容器的每个元素，并执行指定的回调函数。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|修改元素|set(index:number, element: T)|修改指定index位置的元素值为element。|
|修改元素|list[index] = element|修改指定index位置的元素值为element，若索引超出数组范围（index < 0 或 index >= list.length），或者数组是稀疏数组（存在未赋值的索引），则可能导致未定义行为。|
|删除元素|remove(element: T)|删除第一个匹配到的元素。|
|删除元素|removeByIndex(index:number)|删除index位置对应的元素。|

## Deque

[Deque](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-deque)可用来构造双端队列对象，存储元素遵循先进先出以及先进后出的规则，双端队列可以分别从队头或者队尾进行访问。

Deque依据泛型定义，要求存储位置为连续的内存空间，初始容量为8，支持动态扩容，每次扩容为原容量的2倍。Deque底层采用循环队列实现，入队和出队操作效率高。

Deque和[Queue](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-queue)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。

Deque和[Vector](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-vector)相比，都支持在两端增删元素，但Deque不支持中间插入。Deque在头部插入和删除元素的效率高于Vector，而Vector访问元素的效率高于Deque。

需要频繁在两端增删元素时，推荐使用Deque。

Deque支持增、删、改、查操作。常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|insertFront(element: T)|在头部增加一个元素。|
|增加元素|insertEnd(element: T)|在尾部增加一个元素。|
|访问元素|getFirst()|获取第一个元素，不进行出队操作。|
|访问元素|getLast()|获取最后一个元素，不进行出队操作。|
|访问元素|forEach(callbackFn:(value: T, index?: number, deque?: Deque<T>) => void, thisArg?: Object)|遍历访问整个Deque容器的每个元素，并执行指定的回调函数。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|删除元素|popFirst()|将队首元素作为返回值进行返回，并将其出队，如果队列为空，则返回undefined。|
|删除元素|popLast()|将队尾元素作为返回值进行返回，并将其出队，如果队列为空，则返回undefined。|

## Queue

[Queue](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-queue)可用来构造队列对象，存储元素遵循先进先出的规则。

Queue基于泛型定义，存储位置为连续的内存空间，初始容量为8，支持动态扩容，每次扩容容量翻倍。

Queue底层采用循环队列实现，入队和出队操作效率高。

Queue和[Deque](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-deque)相比，Queue仅支持在头部删除元素，尾部增加元素，而Deque支持在两端进行元素的增删操作。

符合先进先出的场景可以使用Queue。

Queue支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(element: T)|在尾部增加一个元素。|
|访问元素|getFirst()|获取队首元素，不进行出队操作。|
|访问元素|forEach(callbackFn: (value: T, index?: number, queue?: Queue<T>) => void,thisArg?: Object)|遍历访问整个Queue容器的每个元素，并执行指定的回调函数。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|删除元素|pop()|将队首元素作为返回值进行返回，并将其移除。|

## Stack

[Stack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-stack)可用来构造栈对象，存储元素遵循先进后出的规则。

Stack基于泛型定义，要求使用连续的内存空间存储元素，初始容量为8，并支持动态扩容，每次扩容为原容量的1.5倍。Stack底层使用数组实现，入栈和出栈操作均在数组的一端进行。

Stack和[Queue](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-queue)相比，Queue基于循环队列实现，仅支持在头部删除元素，尾部增加元素，而Stack都在一端进行操作。

符合先进后出的场景可以使用Stack。

Stack支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|push(item: T)|在栈顶增加一个元素。|
|访问元素|peek()|获取栈顶元素，不进行出队操作。|
|访问元素|locate(element: T)|获取元素对应的位置。|
|访问元素|forEach(callbackFn: (value: T, index?: number, stack?: Stack<T>) => void, thisArg?: Object)|遍历访问整个Stack容器的每个元素，并执行指定的回调函数。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|删除元素|pop()|将栈顶元素作为返回值进行返回，并将其移除。|

## Vector

说明

API version 9开始，该接口不再维护，推荐使用[ArrayList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist)。

[Vector](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-vector)是一种连续存储结构，用于创建全局数组对象。它基于泛型定义，要求存储在连续的内存空间中。Vector的初始容量为10，支持动态扩容，每次扩容时容量增加为原来的两倍。

Vector和[ArrayList](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist)相似，都基于数组实现，但Vector提供了更多操作数组的接口，支持操作符访问，增加get/set接口，提供更完善的校验和容错机制，满足不同的场景需求。

Vector支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(element: T)|在数组尾部增加一个元素。|
|增加元素|insert(element: T, index: number)|在指定位置插入一个元素。|
|访问元素|get(index: number)|获取指定index位置对应的元素。|
|访问元素|vec[index: number]|获取指定index位置对应的元素，通过指令获取保证访问速度。|
|访问元素|getFirst()|获取第一个元素。|
|访问元素|getLastElement()|获取最后一个元素。|
|访问元素|getIndexOf(element: T)|获取第一个匹配指定元素的位置。|
|访问元素|getLastIndexOf(element: T)|获取最后一个匹配指定元素的位置。|
|访问元素|forEach(callbackFn: (value: T, index?: number, Vector?: Vector<T>) => void, thisArg?: Object)|遍历访问整个Vector容器的每个元素，并执行指定的回调函数。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|修改元素|set(index:number, element: T)|修改指定index位置的元素值为element。|
|修改元素|vec[index] = element|修改指定index位置的元素值为element。|
|修改元素|replaceAllElements(callbackFn: (value: T, index?: number, vector?: Vector<T>) => T, thisArg?: Object)|逐个替换Vector内的元素。|
|修改元素|setLength(newSize:number)|设置Vector的长度大小。|
|删除元素|remove(element: T)|删除第一个匹配到的元素。|
|删除元素|removeByIndex(index:number)|删除index位置对应的元素。|
|删除元素|removeByRange(fromIndex:number,toIndex:number)|删除指定范围内的元素。|

## 线性容器的使用

此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、添加元素、访问元素及修改等操作。示例代码如下所示：

1. // ArrayList
2. import { ArrayList } from '@kit.ArkTS'; // 导入ArrayList模块

3. let arrayList1: ArrayList<string> = new ArrayList();
4. arrayList1.add('a'); // 增加一个值为'a'的元素
5. let arrayList2: ArrayList<number> = new ArrayList();
6. arrayList2.add(1); // 增加一个值为1的元素
7. console.info(`result: ${arrayList2[0]}`); // 访问索引为0的元素。输出：result: 1
8. arrayList1[0] = 'one'; // 修改索引为0的元素
9. console.info(`result: ${arrayList1[0]}`); // 输出：result: one

10. // Deque
11. import { Deque } from '@kit.ArkTS'; // 导入Deque模块

12. let deque1: Deque<string> = new Deque();
13. deque1.insertFront('a'); // 头部增加一个值为'a'的元素
14. let deque2: Deque<number> = new Deque();
15. deque2.insertFront(1); // 头部增加一个值为1的元素
16. console.info(`result: ${deque2.getFirst()}`); // 访问队列首部的元素。输出：result: 1
17. deque1.insertEnd('one'); // 尾部增加一个值为'one'的元素
18. console.info(`result: ${deque1.getLast()}`); // 访问队列尾部的元素。输出：result: one

19. // Stack
20. import { Stack } from '@kit.ArkTS'; // 导入Stack模块

21. let stack1: Stack<string> = new Stack();
22. stack1.push('a'); // 向栈里增加一个值为'a'的元素
23. let stack2: Stack<number> = new Stack();
24. stack2.push(1); // 向栈里增加一个值为1的元素
25. console.info(`result: ${stack1.peek()}`); // 访问栈顶元素。输出：result: a
26. console.info(`result: ${stack2.pop()}`); // 删除栈顶元素并返回该删除元素。输出：result: 1
27. console.info(`result: ${stack2.length}`); // 输出：result: 0

28. // List
29. import { List } from '@kit.ArkTS'; // 导入List模块

30. let list1: List<string> = new List();
31. list1.add('a'); // 增加一个值为'a'的元素
32. let list2: List<number> = new List();
33. list2.insert(0, 0); // 在0号位置插入（增加）一个值为0的元素
34. let list3: List<Array<number>> = new List();
35. let b2 = [1, 2, 3];
36. list3.add(b2); // 增加一个Array类型的元素
37. console.info(`result: ${list1[0]}`); // 访问索引为0的元素。输出：result: a
38. console.info(`result: ${list3.get(0)}`); // 访问索引为0的元素。输出：result: 1,2,3

# 非线性容器

更新时间: 2025-12-16 16:39

非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。

## 各非线性容器类型特征对比

|类名|特征及建议使用场景|
|:--|:--|
|HashMap|存储具有关联关系的键值对集合。键唯一，依据键的hash值确定存储位置。访问速度快，但不能自定义排序。推荐用于需要快速存取、插入删除键值对数据时使用。|
|HashSet|存储一系列值的集合。值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。适用于不重复的集合或去重某个集合。|
|TreeMap|存储具有关联关系的键值对集合。键唯一，允许用户自定义排序方法。适用于按序存储键值对的场景。|
|TreeSet|存储一系列值的集合。值唯一，允许用户自定义排序方法，但不建议放入null值。适用于按序存储集合的场景。|
|LightWeightMap|存储具有关联关系的键值对集合。键唯一，底层采用轻量级结构，空间占用小。推荐用于存取键值对数据且内存不充足时。|
|LightWeightSet|存储一系列值的集合。值唯一，底层采用轻量级结构，空间占用小。适用于不重复的集合或去重某个集合。|
|PlainArray|存储具有关联关系的键值对集合。键唯一，底层与LightWeightMap一样采用轻量级结构，键固定为number类型。适用于存储键为number类型键值对的场景。|

## HashMap

[HashMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。

HashMap通过泛型定义，利用键的哈希值确定存储位置，实现快速查找。初始容量为16，支持动态扩容，每次扩容为原容量的两倍。底层基于哈希表实现，冲突处理采用链地址法。

HashMap和[TreeMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treemap)相比，HashMap依据键的hashCode存取数据，访问速度较快。TreeMap则按顺序存取，效率较低。

[HashSet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。

需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。

HashMap支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|set(key: K, value: V)|增加一个键值对。|
|访问元素|get(key: K)|获取key对应的value值。|
|访问元素|keys()|返回一个迭代器对象，包含map中的所有key值。|
|访问元素|values()|返回一个迭代器对象，包含map中的所有value值。|
|访问元素|entries()|返回一个迭代器对象，包含map中的所有键值对。|
|访问元素|forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object)|遍历访问整个map的元素。|
|访问元素|[Symbol.iterator]():IterableIterator<[K,V]>|创建迭代器以访问数据。|
|修改元素|replace(key: K, newValue: V)|修改指定key对应的value值。|
|修改元素|forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object)|遍历并修改整个map的元素。|
|删除元素|remove(key: K)|删除map中匹配到的键值对。|
|删除元素|clear()|清空整个map。|

## HashSet

[HashSet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset)可用来存储一系列值的集合，存储元素中value是唯一的。

HashSet基于泛型定义，集合中通过value的hash值确定存储位置，从而快速找到该值。初始容量为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型需满足ECMA标准。HashSet基于[HashMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap)实现，只处理value对象，底层数据结构与HashMap一致。

HashSet和[TreeSet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treeset)相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。

可以利用HashSet的不重复特性，在需要去重或确保集合元素唯一性时使用。

HashSet支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(value: T)|增加一个值。|
|访问元素|values()|返回一个迭代器对象，包含set中的所有value。|
|访问元素|entries()|返回一个迭代器对象，包含类似键值对的数组，键值都是value。|
|访问元素|forEach(callbackFn: (value?: T, key?: T, set?: HashSet<T>) => void, thisArg?: Object)|遍历访问整个set的元素。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|修改元素|forEach(callbackFn: (value?: T, key?: T, set?: HashSet<T>) => void, thisArg?: Object)|通过遍历对set中的元素进行操作，可能包括但不限于修改元素。|
|删除元素|remove(value: T)|删除指定的元素。|
|删除元素|clear()|清空整个set。|

## TreeMap

[TreeMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treemap)用于存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key对应一个value值。

TreeMap的key按照泛型定义有序存储，基于红黑树实现，支持快速插入和删除，key的类型需满足ECMA标准。

TreeMap和[HashMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。

一般需要存储有序键值对的场景，可以使用TreeMap。

TreeMap支持增、删、改、查操作，常用 API 如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|set(key: K, value: V)|增加一个键值对。|
|访问元素|get(key: K)|获取key对应的value值。|
|访问元素|getFirstKey()|获取map中排在首位的key值。|
|访问元素|getLastKey()|获取map中排在末位的key值。|
|访问元素|keys()|返回一个迭代器对象，包含map中的所有key值。|
|访问元素|values()|返回一个迭代器对象，包含map中的所有value值。|
|访问元素|entries()|返回一个迭代器对象，包含map中的所有键值对。|
|访问元素|forEach(callbackFn: (value?: V, key?: K, map?: TreeMap<K, V>) => void, thisArg?: Object)|遍历访问整个map的元素。|
|访问元素|[Symbol.iterator]():IterableIterator<[K,V]>|创建迭代器以进行数据访问。|
|修改元素|replace(key: K, newValue: V)|修改指定key对应的value值。|
|修改元素|forEach(callbackFn: (value?: V, key?: K, map?: TreeMap<K, V>) => void, thisArg?: Object)|通过遍历对map中的元素进行操作，可能包括但不限于修改元素。|
|删除元素|remove(key: K)|删除map中匹配到的键值对。|
|删除元素|clear()|清空整个map。|

## TreeSet

[TreeSet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treeset)可用来存储一系列值的集合，存储元素中value是唯一的。

TreeSet根据泛型定义有序存储值，底层实现基于红黑树，支持快速插入和删除。value的类型符合ECMA标准。

TreeSet基于[TreeMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treemap)实现，仅处理value对象，用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。

TreeSet和[HashSet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset)相比，HashSet无序存放数据，TreeSet有序存放数据。两者元素均不允许重复，HashSet允许null值，但TreeSet不建议存放null值，可能影响排序。

在需要存储有序集合的场景中，可以使用TreeSet。

TreeSet支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(value: T)|增加一个值。|
|访问元素|values()|返回一个迭代器对象，包含set中的所有value值。|
|访问元素|entries()|返回一个迭代器对象，包含类似键值对的数组，键值都是value。|
|访问元素|getFirstValue()|获取set中排在首位的value值。|
|访问元素|getLastValue()|获取set中排在末位的value值。|
|访问元素|forEach(callbackFn: (value?: T, key?: T, set?: TreeSet<T>) => void, thisArg?: Object)|遍历访问整个set的元素。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|修改元素|forEach(callbackFn: (value?: T, key?: T, set?: TreeSet<T>) => void, thisArg?: Object)|通过遍历对set中的元素进行操作，可能包括但不限于修改元素。|
|删除元素|remove(value: T)|删除指定的元素。|
|删除元素|clear()|清空整个set。|

## LightWeightMap

[LightWeightMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-lightweightmap)用于存储具有唯一键的键值对集合，存储元素中key是唯一的，每个key会对应一个value值。LightWeightMap依据泛型定义，采用轻量级结构，底层通过hash实现唯一key，冲突策略为线性探测。集合中的key值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的key值以及value值，key的类型满足ECMA标准。

初始默认容量为8，每次扩容为原容量的2倍。

LightWeightMap和[HashMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap)都是用来存储具有关联关系的key-value键值对集合，但LightWeightMap占用内存更小。

当需要存储具有关联关系的key-value键值对集合时，推荐使用占用内存更小的LightWeightMap。

LightWeightMap支持增、删、改、查操作，常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|set(key: K, value: V)|增加一个键值对。|
|访问元素|get(key: K)|获取key对应的value值。|
|访问元素|getIndexOfKey(key: K)|获取map中指定key的index。|
|访问元素|getIndexOfValue(value: V)|获取map中指定value出现的第一个的index。|
|访问元素|keys()|返回一个迭代器对象，包含map中的所有key值。|
|访问元素|values()|返回一个迭代器对象，包含map中的所有value值。|
|访问元素|entries()|返回一个迭代器对象，包含map中的所有键值对。|
|访问元素|getKeyAt(index: number)|获取指定index对应的key值。|
|访问元素|getValueAt(index: number)|获取指定index对应的value值。|
|访问元素|forEach(callbackFn: (value?: V, key?: K, map?: LightWeightMap<K, V>) => void, thisArg?: Object)|遍历访问整个map的元素。|
|访问元素|[Symbol.iterator]():IterableIterator<[K,V]>|创建迭代器以进行数据访问。|
|修改元素|setValueAt(index: number, newValue: V)|修改指定index对应的value值。|
|修改元素|forEach(callbackFn: (value?: V, key?: K, map?: LightWeightMap<K, V>) => void, thisArg?: Object)|通过遍历对map中的元素进行操作，可能包括但不限于修改元素。|
|删除元素|remove(key: K)|删除map中指定key匹配到的键值对。|
|删除元素|removeAt(index: number)|删除map中指定index对应的键值对。|
|删除元素|clear()|清空整个map。|

## LightWeightSet

[LightWeightSet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-lightweightset)可用来存储一系列值的集合，存储元素中value是唯一的。

LightWeightSet依据泛型定义，采用更加轻量级的结构，初始默认容量为8，每次扩容为原始容量的2倍。集合中的value值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的value值，value的类型满足ECMA标准。

LightWeightSet底层通过hash表结构实现value的唯一性，冲突策略采用线性探测法，查找策略基于二分查找法。

LightWeightSet和[HashSet](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset)都是用来存储键值的集合，但LightWeightSet的占用内存更小。

当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。

LightWeightSet支持增、删、改、查操作。常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(obj: T)|增加一个值。|
|访问元素|getIndexOf(key: T)|获取对应的index值。|
|访问元素|getValueAt(index: number)|获取指定index对应的value值。|
|访问元素|values()|返回一个迭代器对象，包含set中的所有value值。|
|访问元素|entries()|返回一个迭代器对象，包含类似键值对的数组，键值都是value。|
|访问元素|forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet<T>) => void, thisArg?: Object)|遍历访问整个set的元素。|
|访问元素|[Symbol.iterator]():IterableIterator<T>|创建迭代器以进行数据访问。|
|修改元素|forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet<T>) => void, thisArg?: Object)|通过遍历对set中的元素进行操作，可能包括但不限于修改元素。|
|删除元素|remove(key: K)|删除指定的元素。|
|删除元素|removeAt(index: number)|删除set中指定index对应的值。|
|删除元素|clear()|清空整个set。|

## PlainArray

[PlainArray](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-plainarray)可用来存储具有关联关系的键值对集合，存储元素中key是唯一的，并且对于PlainArray来说，其key的类型为number类型。每个key会对应一个value值，类型依据泛型的定义，PlainArray采用轻量级的结构，集合中的key值的查找依赖于二分查找算法，然后映射到其他数组中的value值。

初始默认容量为16，每次扩容为原始容量的2倍。

PlainArray和[LightWeightMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-lightweightmap)都用于存储键值对，且采用轻量级结构。不过，PlainArray的键值类型仅限于number。

当需要存储键为number类型的键值对时，可以使用PlainArray。

PlainArray支持增、删、改、查操作。常用API如下：

|操作|方法|描述|
|:--|:--|:--|
|增加元素|add(key: number,value: T)|增加一个键值对。|
|访问元素|get(key: number)|获取key对应的value值。|
|访问元素|getIndexOfKey(key: number)|获取PlainArray中指定key的index。|
|访问元素|getIndexOfValue(value: T)|获取PlainArray中指定value出现的第一个的index。|
|访问元素|getKeyAt(index: number)|获取指定index对应的key值。|
|访问元素|getValueAt(index: number)|获取指定index对应的value值。|
|访问元素|forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray<T>) => void, thisArg?: Object)|遍历访问整个PlainArray的元素。|
|访问元素|[Symbol.iterator]():IterableIterator<[number, T]>|创建迭代器以进行数据访问。|
|修改元素|setValueAt(index:number, value: T)|修改指定index对应的value值。|
|修改元素|forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray<T>) => void, thisArg?: Object)|通过遍历对PlainArray中的元素进行操作，可能包括但不限于修改元素。|
|删除元素|remove(key: number)|删除PlainArray中指定key匹配到的键值对。|
|删除元素|removeAt(index: number)|删除PlainArray中指定index对应的键值对。|
|删除元素|removeRangeFrom(index: number, size: number)|删除PlainArray中指定范围内的元素。|
|删除元素|clear()|清空整个PlainArray。|

## 非线性容器的使用

此处列举常用的非线性容器HashMap、TreeMap、LightWeightMap、PlainArray的使用示例，包括导入模块、增加元素、访问元素及修改等操作，示例代码如下所示：

1. // HashMap
2. import { HashMap } from '@kit.ArkTS'; // 导入HashMap模块

3. let hashMap1: HashMap<string, number> = new HashMap();
4. hashMap1.set('a', 123); // 增加一个键为'a'，值为123的元素
5. let hashMap2: HashMap<number, number> = new HashMap();
6. hashMap2.set(4, 123); // 增加一个键为4，值为123的元素
7. console.info(`result: ${hashMap2.hasKey(4)}`); // 判断是否含有键为4的元素。输出：result: true
8. console.info(`result: ${hashMap1.get('a')}`); // 访问键为'a'的元素。输出：result: 123

9. // TreeMap
10. import { TreeMap } from '@kit.ArkTS'; // 导入TreeMap模块

11. let treeMap: TreeMap<string, number> = new TreeMap();
12. treeMap.set('a', 123); // 增加一个键为'a'，值为123的元素
13. treeMap.set('6', 356); // 增加一个键为'6'，值为356的元素
14. console.info(`result: ${treeMap.get('a')}`); // 访问键为'a'的元素。输出：result: 123
15. console.info(`result: ${treeMap.getFirstKey()}`); // 访问首元素。输出：result: 6
16. console.info(`result: ${treeMap.getLastKey()}`); // 访问尾元素。输出：result: a

17. // LightWeightMap
18. import { LightWeightMap } from '@kit.ArkTS'; // 导入LightWeightMap模块

19. let lightWeightMap: LightWeightMap<string, number> = new LightWeightMap();
20. lightWeightMap.set('x', 123); // 增加一个键为'x'，值为123的元素
21. lightWeightMap.set('8', 356); // 增加一个键为'8'，值为356的元素
22. console.info(`result: ${lightWeightMap.get('a')}`); // 访问键为'a'的元素。输出：result: undefined
23. console.info(`result: ${lightWeightMap.get('x')}`); // 访问键为'x'的元素，获取其值。输出：result: 123
24. console.info(`result: ${lightWeightMap.getIndexOfKey('8')}`); // 访问键为'8'的元素，获取其索引。输出：result: 0

25. // PlainArray
26. import { PlainArray } from '@kit.ArkTS'; // 导入PlainArray模块

27. let plainArray: PlainArray<string> = new PlainArray();
28. plainArray.add(1, 'sdd'); // 增加一个键为1，值为'sdd'的元素
29. plainArray.add(2, 'sff'); // 增加一个键为2，值为'sff'的元素
30. console.info(`result: ${plainArray.get(1)}`); // 访问键为1的元素，获取值。输出：result: sdd
31. console.info(`result: ${plainArray.getKeyAt(1)}`); // 访问索引为1的元素，获取键。输出：result: 2

# # UI开发（ArkTS声明式开发范式）概述

更新时间: 2025-12-16 16:38

基于ArkTS的声明式开发范式的方舟开发框架是一套开发极简、高性能、支持跨设备的UI开发框架，提供了构建应用UI所必需的能力，主要包括：

- **ArkTS**
    
    ArkTS是优选的主力应用开发语言，围绕应用开发在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了进一步扩展。扩展能力包含声明式UI描述、自定义组件、动态扩展UI元素、状态管理和渲染控制。状态管理作为基于ArkTS的声明式开发范式的特色，通过功能不同的装饰器给开发者提供了清晰的页面更新渲染流程和管道。状态管理包括UI组件状态和应用程序状态，两者协作可以使开发者完整地构建整个应用的数据更新和UI渲染。ArkTS语言的基础知识请参考[初识ArkTS语言](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-get-started)。
    
- **布局**
    
    布局是UI的必要元素，它定义了组件在界面中的位置。ArkUI框架提供了多种布局方式，除了基础的线性布局、层叠布局、弹性布局、相对布局、栅格布局外，也提供了相对复杂的列表、宫格、轮播。
    
- **组件**
    
    组件是UI的必要元素，形成了在界面中的样子，由框架直接提供的称为**系统组件**，由开发者定义的称为**自定义组件**。系统组件包括按钮、单选框、进度条、文本等。开发者可以通过链式调用的方式设置系统组件的渲染效果。开发者可以将系统组件组合为自定义组件，通过这种方式将页面组件化为一个个独立的UI单元，实现页面不同单元的独立创建、开发和复用，具有更强的工程性。
    
- **页面路由和组件导航**
    
    开发者可以将应用的用户界面设计为多个功能页面[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)，页面通过栈结构管理，并通过导航容器[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)完成页面间的调度管理如跳转、回退等操作，以实现应用内的功能解耦。
    
- **图形**
    
    方舟开发框架提供了多种类型图片的显示能力和多种自定义绘制的能力，以满足开发者的自定义绘图需求，支持绘制形状、填充颜色、绘制文本、变形与裁剪、嵌入图片等。
    
- **动画**
    
    动画是UI的重要元素之一。优秀的动画设计能够极大地提升用户体验，框架提供了丰富的动画能力，除了组件内置动画效果外，还包括属性动画、显式动画、自定义转场动画以及动画API等，开发者可以通过封装的物理模型或者调用动画能力API来实现自定义动画轨迹。
    
- **交互事件**
    
    交互事件是UI和用户交互的必要元素。方舟开发框架提供了多种交互事件，除了触摸事件、鼠标事件、键盘按键事件、焦点事件等通用事件外，还包括基于通用事件进行进一步识别的手势事件。手势事件有单一手势如点击手势、长按手势、拖动手势、捏合手势、旋转手势、滑动手势，以及通过单一手势事件进行组合的组合手势事件。
    
- **自定义能力**
    
    自定义能力是UI开发框架提供给开发者对UI界面进行开发和定制化的能力。包括：自定义组合、自定义扩展、自定义节点和自定义渲染。
    

## 特点

- 开发效率高，开发体验好
    
    - 代码简洁：通过接近自然语义的方式描述UI，不必关心框架如何实现UI绘制和渲染。
    - 数据驱动UI变化：让开发者更专注自身业务逻辑的处理。当UI发生变化时，开发者无需编写在不同的UI之间进行切换的UI代码， 开发人员仅需要编写引起界面变化的数据，具体UI如何变化交给框架。
    - 开发体验好：界面也是代码，让开发者的编程体验得到提升。
- 性能优越
    
    - 声明式UI前端和UI后端分层：UI后端采用C++语言构建，提供对应前端的基础组件、布局、动效、交互事件、组件状态管理和渲染管线。
    - 语言编译器和运行时的优化：统一字节码、高效FFI（Foreign Function Interface）、AOT（Ahead Of Time）、引擎极小化、类型优化等。
- 生态容易快速推进
    
    能够借力主流语言生态快速推进，语言相对中立友好，有相应的标准组织可以逐步演进。
    

## 整体架构

**图1** 整体架构图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163826.99677842590292424283240459096482:50001231000000:2800:4B27C8DC572BE038CC901FB8D19BE43E00A905408EBFBB38191BE99BF16166B7.png)

- **声明式UI前端**
    
    提供了UI开发范式的基础语言规范，并提供内置的UI组件、布局和动画，提供了多种状态管理机制，为应用开发者提供一系列接口支持。
    
- **语言运行时**
    
    选用方舟语言运行时，提供了针对UI范式语法的解析能力、跨语言调用支持的能力和TS语言高性能运行环境。
    
- **声明式UI后端引擎**
    
    后端引擎提供了兼容不同开发范式的UI渲染管线，提供多种基础组件、布局计算、动效、交互事件，提供了状态管理和绘制能力。
    
- **渲染引擎**
    
    提供了高效的绘制能力，将渲染管线收集的渲染指令，绘制到屏幕的能力。
    
- **平台适配层**
    
    提供了对系统平台的抽象接口，具备接入不同系统的能力，如系统渲染管线、生命周期调度等。
    

## 开发流程

使用UI开发框架开发应用时，主要涉及如下开发过程。

|任务|简介|相关指导|
|:--|:--|:--|
|学习ArkTS|介绍了ArkTS的基本语法、状态管理和渲染控制的场景。|- [基本语法](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-basic-syntax-overview)<br><br>- [状态管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-overview)<br><br>- [渲染控制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-overview)|
|设置组件导航和页面路由|介绍了如何设置组件间的导航以及页面路由。|- [组件导航（推荐）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation)<br><br>- [页面路由](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-routing)|
|组件布局|介绍了几种常用的布局方式。|- [常用布局](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-overview)|
|列表与网格|介绍了几种列表与网格组件的使用方法。|- [列表与网格](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-list-grid-development-overview)|
|使用文本|介绍了输入框、富文本和属性字符串等文本组件的使用方法。|- [文本显示](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display)<br><br>- [文本输入](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-input)<br><br>- [富文本](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-richeditor)<br><br>- [图标小符号](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-symbol)<br><br>- [属性字符串](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-styled-string)|
|媒体展示|介绍了几种媒体展示组件的使用方法。|- [显示图片 (Image)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-graphics-display)<br><br>- [视频播放 (Video)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-video-player)<br><br>- [创建轮播 (Swiper)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-looping)<br><br>- [创建弧形轮播 (ArcSwiper)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-arcswiper)|
|表单选择|介绍了几种常用表单选择组件的使用方法。|- [表单与选择组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-forms-overview)|
|添加组件|介绍了XComponent和Progress组件的使用方法。|- [自定义渲染 (XComponent)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-xcomponent-guidelines)<br><br>- [进度条 (Progress)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-progress-indicator)|
|使用弹窗|介绍了弹窗的应用场景与使用方法。|- [使用弹出框](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview)<br><br>- [菜单](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-menu-overview)<br><br>- [气泡提示](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-popup-overview)<br><br>- [绑定模态页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-modal-overview)<br><br>- [即时反馈](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-toast)<br><br>- [设置浮层](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-overlaymanager)|
|显示图形|介绍了如何显示图片、绘制自定义几何图形以及使用画布绘制自定义图形。|- [几何图形](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-geometric-shape-drawing)<br><br>- [画布](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-drawing-customization-on-canvas)|
|几何图形|介绍了如何绘制几何图形。|- [几何图形绘制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-shape-overview)|
|添加交互响应|介绍了交互基础机制、输入设备与事件和手势响应的能力。|- [交互基础机制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-basic-principles)<br><br>- [输入设备与事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/rkts-interaction-development-guide-raw-input-event)<br><br>- [手势响应](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/rkts-interaction-development-guide-support-gesture)|
|使用动画|介绍了组件和页面使用动画的典型场景。|- [属性动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-attribute-animation-overview)<br><br>- [转场动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-transition-overview)<br><br>- [粒子动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-particle-animation)<br><br>- [组件动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-component-animation)<br><br>- [动画曲线](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-traditional-curve)<br><br>- [动画衔接](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animation-smoothing)<br><br>- [动画效果](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-blur-effect)<br><br>- [帧动画](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animator)|
|使用自定义能力|介绍了自定义能力的基本概念和如何使用自定义能力。|- [自定义组合](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-composition)<br><br>- [自定义节点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-node)<br><br>- [自定义扩展](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-modifier)|
|UI国际化|介绍如何实现应用程序UI界面的国际化，包含资源配置和镜像布局。|- [UI国际化](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-internationalization)|
|无障碍与适老化|介绍了无障碍和适老化的使用场景和使用方法。|- [支持无障碍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-universal-attributes-accessibility)<br><br>- [支持适老化](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui-support-for-aging-adaptation)|
|主题设置|介绍了应用级和页面级的主题设置能力。|- [应用深浅色适配](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ui-dark-light-color-adaptation)<br><br>- [设置应用内主题换肤](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/theme_skinning)|
|UI系统场景化能力|介绍了如何使用UIContext中对应的接口获取与实例绑定的对象，以及全屏方式拉起元服务的方法。|- [使用UI上下文接口操作界面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-global-interface)<br><br>- [全屏启动元服务组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-fullscreencomponent)|

## 通用规则

- **默认单位**
    
    表示长度的入参单位默认为vp，即入参为number类型、以及[Length](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types#length)和[Dimension](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types#dimension10)类型中的number单位为vp。
    
- **异常值处理**
    
    输入的参数为异常（undefined，null或无效值）时，处理规则如下：
    
    （1）对应参数有默认值，按默认值处理；
    
    （2）对应参数无默认值，该参数对应的属性或接口不生效。
    # 基本语法概述

更新时间: 2025-12-16 16:38

在初步了解ArkTS语言后，本指南将以具体的示例来说明ArkTS的基本组成。

如下图所示，点击“按钮”时，文本内容从“Hello World”变为“Hello ArkUI”。

**图1** 示例效果图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163856.11141780793269377806891242130528:50001231000000:2800:6226B257CF346C1B332B42EC0F899472A2D46C63779E3EDD1090F9DB54B3F449.gif)

本示例中，ArkTS的基本组成如下所示。

**图2** ArkTS的基本组成

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163856.30126230128707271975624442001967:50001231000000:2800:D5AB7D011DDD13C0E053C270695DA698EFEDE62D0FEC25C8F85D6AD98A8752B3.png)

说明

自定义变量不能与基础通用属性/事件名重复。

- 装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，[@Component](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#component)表示自定义组件，[@Entry](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#entry)表示该自定义组件为入口组件，[@State](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state)表示组件中的状态变量，状态变量变化会触发UI刷新。
    
- [UI描述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-declarative-ui-description)：以声明式的方式来描述UI的结构，例如build()方法中的代码块。
    
- [自定义组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components)：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。
    
- 系统组件：ArkUI框架中默认内置的基础和容器组件，可以直接调用，例如示例中的Column、Text、Divider、Button。
    
- [属性方法](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-component-general-attributes)：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。
    
- [事件方法](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-component-general-events)：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。
    

除此之外，ArkTS扩展了多种语法范式来使开发更加便捷：

- [@Builder](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builder)/[@BuilderParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builderparam)：特殊的封装UI描述的方法，细粒度的封装和复用UI描述。
    
- [@Extend](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-extend)/[@Styles](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-style)：扩展系统组件和封装属性样式，更灵活地组合系统组件。
    
- [stateStyles](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-statestyles)：多态样式，可以依据组件的内部状态的不同，设置不同样式。
- # 声明式UI描述

更新时间: 2025-12-16 16:39

ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。

## 创建组件

根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。

说明

创建组件不需要使用new关键字。

### 无参数

如果组件接口定义中不包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如：Divider组件不包含构造参数。

1. Column() {
2.   Text('item 1')
3.   Divider()
4.   Text('item 2')
5. }

### 有参数

如果组件接口定义包含构造参数，则在组件后的“()”中配置相应参数。

- Image组件的必选参数src。
    
    1. Image('https://xyz/test.jpg')
    
- Text组件的非必选参数content。
    
    1. // string类型的参数
    2. Text('test')
    3. // $r形式引入应用资源，可应用于多语言场景
    4. Text($r('app.string.title_value'))
    5. // 无参数形式
    6. Text()
    
- 变量或表达式可以用于参数赋值，表达式结果类型必须符合参数要求。
    
    例如，设置变量或表达式来构造Image和Text组件的参数。
    
    1. Image(this.imagePath)
    2. Image('https://' + this.imageUrl)
    3. Text(`count: ${this.count}`)
    

## 配置属性

属性方法以“.”链式调用配置组件样式和其他属性，建议每个属性方法单独一行。

- 配置Text组件的字体大小。
    
    1. Text('test')
    2.   .fontSize(12)
    
- 配置组件的多个属性。
    
    1. Image('test.jpg')
    2.   .alt('error.jpg')
    3.   .width(100)
    4.   .height(100)
    
- 除了直接传递常量参数，还可以传递变量或表达式。
    
    1. Text('hello')
    2.   .fontSize(this.size)
    3. Image('test.jpg')
    4.   .width(this.count % 2 === 0 ? 100 : 200)
    5.   .height(this.offset + 100)
    
- 对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传递，但必须满足参数类型要求。
    
    例如，可以按以下方式配置Text组件的颜色和字体样式。
    
    1. Text('hello')
    2.   .fontSize(20)
    3.   .fontColor(Color.Red)
    4.   .fontWeight(FontWeight.Bold)
    

## 配置事件

事件方法以“.”链式调用的方式配置系统组件支持的事件，建议每个事件方法单独写一行。

- 使用箭头函数配置组件的事件方法。
    
    1. Button('Click me')
    2.   .onClick(() => {
    3.     this.myText = 'ArkUI';
    4.   })
    
- 使用箭头函数表达式配置组件的事件方法，要求使用“() => {...}”，以确保函数与组件绑定，同时符合ArkTS语法规范。
    
    1. Button('add counter')
    2.   .onClick(() => {
    3.     this.counter += 2;
    4.   })
    
- 使用组件的成员函数配置组件的事件方法，需要bind this。ArkTS语法不建议使用成员函数配合bind this来配置组件的事件方法。
    
    1. myClickHandler(): void {
    2.   this.counter += 2;
    3. }
    4. // ...
    5. Button('add counter')
    6.   .onClick(this.myClickHandler.bind(this))
    
- 使用声明的箭头函数时可以直接调用，不需要bind this。
    
    1. fn = () => {
    2.   console.info(`counter: ${this.counter}`)
    3.   this.counter++
    4. }
    5. // ...
    6. Button('add counter')
    7.   .onClick(this.fn)
    

说明

箭头函数内部的this是词法作用域，由上下文确定。匿名函数可能会出现this指向不明确的问题，因此在ArkTS中不允许使用。

## 配置子组件

如果组件支持子组件配置，则需在尾随闭包"{...}"中为组件添加子组件的UI描述。Column、Row、Stack、Grid、List等组件都是容器组件。

- 以下是简单的Column组件配置子组件的示例。
    
    1. Column() {
    2.   Text('Hello')
    3.     .fontSize(100)
    4.   Divider()
    5.   Text(this.myText)
    6.     .fontSize(100)
    7.     .fontColor(Color.Red)
    8. }
    
- 容器组件均支持子组件配置，可以实现相对复杂的多级嵌套。
    
    1. Column() {
    2.   Row() {
    3.     Image('test1.jpg')
    4.       .width(100)
    5.       .height(100)
    6.     Button('click +1')
    7.       .onClick(() => {
    8.         console.info('+1 clicked!');
    9.       })
    10.   }
    11. }
    # 创建自定义组件

更新时间: 2025-12-16 16:40

在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。进行UI界面开发时，不仅要组合使用系统组件，还需考虑代码的可复用性、业务逻辑与UI的分离，以及后续版本的演进等因素。因此，将UI和部分业务逻辑封装成自定义组件是不可或缺的能力。

自定义组件具有以下特点：

- 可组合：允许开发者组合使用系统组件及其属性和方法。
    
- 可重用：自定义组件可以被其他组件重用，并作为不同的实例在不同的父组件或容器中使用。
    
- 数据驱动UI更新：通过状态变量的改变，来驱动UI的刷新。
    

## 自定义组件的基本用法

以下示例展示了自定义组件的基本用法。

1. @Component
2. struct HelloComponent {
3.   @State message: string = 'Hello, World!';

4.   build() {
5.     // HelloComponent自定义组件组合系统组件Row和Text
6.     Row() {
7.       Text(this.message)
8.         .onClick(() => {
9.           // 状态变量message的改变驱动UI刷新，UI从'Hello, World!'刷新为'Hello, ArkUI!'
10.           this.message = 'Hello, ArkUI!';
11.         })
12.     }
13.   }
14. }

注意

如果在其他文件中引用自定义组件，需要使用export关键字导出组件，并在使用的页面import该自定义组件。

可以在其他自定义组件的build()函数中多次创建HelloComponent，以实现自定义组件的重用。

1. @Entry
2. @Component
3. struct ParentComponent {
4.   build() {
5.     Column() {
6.       Text('ArkUI message')
7.       HelloComponent({ message: 'Hello World!' });
8.       Divider()
9.       HelloComponent({ message: '你好，世界!' });
10.     }
11.   }
12. }

要完全理解上面的示例，需要了解自定义组件的以下概念定义，本文将在后面的小节中介绍：

- [自定义组件的基本结构](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84)
    
- [成员函数/变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F)
    
- [自定义组件的参数规定](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%84%E5%AE%9A)
    
- [build()函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#build%E5%87%BD%E6%95%B0)
    
- [自定义组件通用样式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E9%80%9A%E7%94%A8%E6%A0%B7%E5%BC%8F)
    

## 自定义组件的基本结构

### struct

自定义组件基于struct实现，struct + 自定义组件名 + {...}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。

说明

自定义组件名、类名、函数名不得与系统组件名重复。

### @Component

@Component装饰器仅装饰struct关键字声明的数据结构。被装饰的struct具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。@Component可以接受一个可选的boolean类型参数。

说明

从API version 9开始，该装饰器支持在ArkTS卡片中使用。

从API version 11开始，@Component可以接受一个可选的boolean类型参数。

从API version 11开始，该装饰器支持在元服务中使用。

1. @Component
2. struct MyComponent {
3. }

**freezeWhenInactive11+**

[组件冻结](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-custom-components-freeze)选项。

|名称|类型|只读|可选|说明|
|:--|:--|:--|:--|:--|
|freezeWhenInactive|boolean|否|否|是否开启组件冻结。默认值false。true表示开启组件冻结，false表示不开启组件冻结。|

1. @Component({ freezeWhenInactive: true })
2. struct MyComponent {
3. }

### build()函数

build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。

1. @Component
2. struct MyComponent {
3.   build() {
4.   }
5. }

### @Entry

@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，仅允许存在一个由@Entry装饰的自定义组件作为页面的入口。@Entry可以接受一个可选的[LocalStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage)参数。

说明

从API version 9开始，该装饰器支持在ArkTS卡片中使用。

从API version 10开始，@Entry可以接受一个可选的[LocalStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage)参数或者一个可选的EntryOptions10+参数。

从API version 11开始，该装饰器支持在元服务中使用。

1. @Entry
2. @Component
3. struct MyComponent {
4. }

**EntryOptions10+**

命名路由跳转选项。

|名称|类型|只读|可选|说明|
|:--|:--|:--|:--|:--|
|routeName|string|否|是|表示作为命名路由页面的名字。|
|storage|[LocalStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage)|否|是|页面级的UI状态存储。当未传入时，框架会创建一个新的LocalStorage实例作为默认值。|
|useSharedStorage12+|boolean|否|是|是否使用[loadContent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-windowstage#loadcontent9)传入的LocalStorage实例对象。默认值false。true：使用共享的[LocalStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage)实例对象。false：不使用共享的[LocalStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage)实例对象。|

说明

当useSharedStorage设置为true且storage已赋值时，useSharedStorage的值优先级更高。

1. @Entry({ routeName : 'myPage' })
2. @Component
3. struct MyComponent {
4. }

### @Reusable

@Reusable装饰的自定义组件具备可复用能力。详细请参考：[@Reusable装饰器：组件复用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)。

说明

从API version 10开始，该装饰器支持在ArkTS卡片中使用。

1. @Reusable
2. @Component
3. struct MyComponent {
4. }

## 成员函数/变量

自定义组件除了必须要实现build()函数外，还可以实现其他成员函数，成员函数具有以下约束：

- 自定义组件的成员函数仅能从组件内部访问，且不建议声明为静态函数。

自定义组件可以包含成员变量，成员变量具有以下约束：

- 自定义组件的成员变量仅能从组件内部访问，且不建议声明为静态变量。
    
- 自定义组件的成员变量本地初始化有些是可选的，有些是必选的。具体是否需要本地初始化，是否需要从父组件通过参数传递初始化子组件的成员变量，请参考[状态管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-overview)。
    

## 自定义组件的参数规定

以下示例展示了如何在build方法里创建自定义组件，并在创建自定义组件的过程中，根据装饰器的规则来初始化自定义组件的参数。

1. @Component
2. struct MyComponent {
3.   private countDownFrom: number = 0;
4.   private color: Color = Color.Blue;

5.   build() {
6.     Column() {
7.       Text(`${this.countDownFrom}`)
8.         .backgroundColor(this.color)
9.     }
10.   }
11. }

12. @Entry
13. @Component
14. struct ParentComponent {
15.   private someColor: Color = Color.Pink;

16.   build() {
17.     Column() {
18.       // 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor
19.       MyComponent({ countDownFrom: 10, color: this.someColor })
20.     }
21.   }
22. }

以下示例代码将父组件中的函数传递给子组件，并在子组件中调用。

1. @Entry
2. @Component
3. struct Parent {
4.   @State cnt: number = 0
5.   submit: () => void = () => {
6.     this.cnt++;
7.   }

8.   build() {
9.     Column() {
10.       Text(`${this.cnt}`)
11.       Son({ submitArrow: this.submit })
12.     }
13.   }
14. }

15. @Component
16. struct Son {
17.   submitArrow?: () => void

18.   build() {
19.     Row() {
20.       Button('add')
21.         .width(80)
22.         .onClick(() => {
23.           if (this.submitArrow) {
24.             this.submitArrow()
25.           }
26.         })
27.     }
28.     .height(56)
29.   }
30. }

## build()函数

所有在build()函数中声明的语句统称为UI描述，UI描述需要遵循以下规则：

- @Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。
    
    @Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。
    
    1. @Entry
    2. @Component
    3. struct MyComponent {
    4.   build() {
    5.     // 根节点唯一且必要，必须为容器组件
    6.     Row() {
    7.       ChildComponent()
    8.     }
    9.   }
    10. }
    
    11. @Component
    12. struct ChildComponent {
    13.   build() {
    14.     // 根节点唯一且必要，可为非容器组件
    15.     Image('test.jpg')
    16.   }
    17. }
    
- 不允许声明本地变量，反例如下。
    
    1. build() {
    2.   // 反例：不允许声明本地变量
    3.   let num: number = 1;
    4. }
    
- 不允许在UI描述里直接使用console.info，但允许在方法或者函数里使用，反例如下。
    
    1. build() {
    2.   // 反例：不允许console.info
    3.   console.info('print debug log');
    4. }
    
- 不允许创建本地的作用域，反例如下。
    
    1. build() {
    2.   // 反例：不允许本地作用域
    3.   {
    4.     // ...
    5.   }
    6. }
    
- 不允许调用没有用@Builder装饰的方法，允许系统组件的参数是TS方法的返回值。
    
    1. @Component
    2. struct ParentComponent {
    3.   doSomeCalculations() {
    4.   }
    
    5.   calcTextValue(): string {
    6.     return 'Hello World';
    7.   }
    
    8.   @Builder doSomeRender() {
    9.     Text(`Hello World`)
    10.   }
    
    11.   build() {
    12.     Column() {
    13.       // 反例：不能调用没有用@Builder装饰的方法
    14.       this.doSomeCalculations();
    15.       // 正例：可以调用
    16.       this.doSomeRender();
    17.       // 正例：参数可以为调用TS方法的返回值
    18.       Text(this.calcTextValue())
    19.     }
    20.   }
    21. }
    
- 不允许使用switch语法，当需要使用条件判断时，请使用[if](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-ifelse)。示例如下。
    
    1. build() {
    2.   Column() {
    3.     // 反例：不允许使用switch语法
    4.     switch (expression) {
    5.       case 1:
    6.         Text('...')
    7.         break;
    8.       case 2:
    9.         Image('...')
    10.         break;
    11.       default:
    12.         Text('...')
    13.         break;
    14.     }
    15.     // 正例：使用if
    16.     if(expression == 1) {
    17.       Text('...')
    18.     } else if(expression == 2) {
    19.       Image('...')
    20.     } else {
    21.       Text('...')
    22.     }
    23.   }
    24. }
    
- 不允许使用表达式，请使用if组件，示例如下。
    
    1. build() {
    2.   Column() {
    3.     // 反例：不允许使用表达式
    4.     (this.aVar > 10) ? Text('...') : Image('...')
    
    5.     // 正例：使用if判断
    6.     if(this.aVar > 10) {
    7.       Text('...')
    8.     } else {
    9.       Image('...')
    10.     }
    11.   }
    12. }
    
- 不允许直接改变状态变量，反例如下。详细分析见[@State常见问题：不允许在build里改状态变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state#%E4%B8%8D%E5%85%81%E8%AE%B8%E5%9C%A8build%E9%87%8C%E6%94%B9%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F)。
    
    1. @Component
    2. struct MyComponent {
    3.   @State textColor: Color = Color.Yellow;
    4.   @State columnColor: Color = Color.Green;
    5.   @State count: number = 1;
    6.   build() {
    7.     Column() {
    8.       // 应避免直接在Text组件内改变count的值
    9.       Text(`${this.count++}`)
    10.         .width(50)
    11.         .height(50)
    12.         .fontColor(this.textColor)
    13.         .onClick(() => {
    14.           this.columnColor = Color.Red;
    15.         })
    16.       Button("change textColor").onClick(() =>{
    17.         this.textColor = Color.Pink;
    18.       })
    19.     }
    20.     .backgroundColor(this.columnColor)
    21.   }
    22. }
    
    在ArkUI状态管理中，状态驱动UI更新。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164009.92080870358361048152722759391511:50001231000000:2800:3B8012A18813A95600E1F3C5492A33989D554986C70F6D2357D1A896F2917CBE.png)
    
    所以，不能在自定义组件的build()或@Builder方法里直接改变状态变量，这可能会造成循环渲染的风险。Text('${this.count++}')在全量更新或最小化更新会产生不同的影响：
    
    - 全量更新（API8及以前版本）： ArkUI可能会陷入一个无限的重渲染的循环里，因为Text组件的每一次渲染都会改变应用的状态，就会再引起下一轮渲染的开启。 当 this.columnColor 更改时，都会执行整个build构建函数，因此，Text(${this.count++})绑定的文本也会更改，每次重新渲染Text(${this.count++})，又会使this.count状态变量更新，导致新一轮的build执行，从而陷入无限循环。
    - 最小化更新（API9及以上版本）：当this.columnColor更新时，仅Column组件更新，Text组件不会更新。只有当this.textColor更改时，会去更新整个Text组件，其所有属性函数都会执行，所以会看到Text(${this.count++})自增。因为目前UI以组件为单位进行更新，如果组件上某一个属性发生改变，会更新整个的组件。所以整体的更新链路是：this.textColor = Color.Pink ->Text组件整个更新->this.count++ ->Text组件整个更新。值得注意的是，这种写法在初次渲染时会导致Text组件渲染两次，影响性能。
    
    build函数中更改应用状态的行为可能比上面的示例更加隐蔽，例如：
    
    - 在@Builder，@Extend或@Styles方法内改变状态变量 。
        
    - 在计算参数时调用函数中改变应用状态变量，例如 Text('${this.calcLabel()}')。
        
    - 对当前数组做出修改，sort()改变了数组this.arr，随后的filter方法会返回一个新的数组。
        
        1. // 反例
        2. @State arr : Array<...> = [ ... ];
        3. ForEach(this.arr.sort().filter(...),
        4.   item => {
        5.   // ...
        6. })
        7. // 正确的执行方式为：filter返回一个新数组，后面的sort方法才不会改变原数组this.arr
        8. ForEach(this.arr.filter(...).sort(),
        9.   item => {
        10.   // ...
        11. })
        

## 自定义组件通用样式

自定义组件通过“.”链式调用设置通用样式。

1. @Component
2. struct ChildComponent {
3.   build() {
4.     Button(`Hello World`)
5.   }
6. }

7. @Entry
8. @Component
9. struct MyComponent {
10.   build() {
11.     Row() {
12.       ChildComponent()
13.         .width(200)
14.         .height(300)
15.         .backgroundColor(Color.Red)
16.     }
17.   }
18. }

说明

ArkUI给自定义组件设置样式时，相当于给ChildComponent套了一个不可见的容器组件，这些样式是设置在容器组件上，而非直接设置给ChildComponent的Button组件。渲染结果显示，背景颜色红色并没有直接设置到Button上，而是设置在Button所在的不可见容器组件上。
# 自定义组件生命周期

更新时间: 2025-12-16 16:40

自定义组件生命周期，即用[@Component](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#component)或[@ComponentV2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-componentv2)装饰的自定义组件的生命周期，提供以下生命周期接口：

- [aboutToAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear)：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build函数之前执行。
    
- [onDidBuild](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#ondidbuild12)：在组件首次渲染触发的build函数执行完成之后回调该接口，后续组件重新渲染将不回调该接口。开发者可以在这个阶段实现埋点数据上报等不影响实际UI的功能。
    
- [aboutToDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttodisappear)：aboutToDisappear函数在自定义组件析构销毁之前执行。不允许在aboutToDisappear函数中改变状态变量，特别是@Link变量的修改可能会导致应用程序行为不稳定。
    

说明

页面生命周期及其相关内容参考[页面路由](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-routing#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)。

自定义组件生命周期流程如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164022.95956784393937385641182391724380:50001231000000:2800:A1149043F523608139001259434577377D6B872A88E2BF3CDD36AE9B93BF7511.png)

根据上面的流程图，接下来从自定义组件的初始创建、重新渲染和删除来详细说明。

## 自定义组件的创建和渲染流程

1. 自定义组件的创建：自定义组件的实例由ArkUI框架创建。
    
2. 初始化自定义组件的成员变量：通过本地默认值或者构造方法传递参数来初始化自定义组件的成员变量，初始化顺序为成员变量的定义顺序。
    
3. 如果开发者定义了aboutToAppear，则执行build方法之前执行该方法。
    
4. 在首次渲染的时候，执行build方法渲染系统组件，如果子组件为自定义组件，则创建自定义组件的实例。在首次渲染的过程中，框架会记录状态变量和组件的映射关系，当状态变量改变时，驱动其相关的组件刷新。
    
5. 如果开发者定义了onDidBuild，则执行build方法之后执行该方法。
    

## 自定义组件重新渲染

当触发事件（比如点击）改变状态变量时，或者[LocalStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage) / [AppStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage)中的属性更改，并导致绑定的状态变量更改其值时：

1. 框架观察到变化，启动重新渲染。
    
2. 根据框架记录的状态变量和组件的映射关系，仅刷新发生变化的状态变量所关联的组件，实现最小化更新。
    

## 自定义组件的删除

例如if组件的分支改变或ForEach循环渲染中数组的个数改变，组件将被移除：

1. 在删除组件之前，将调用其aboutToDisappear生命周期函数，标记着该节点将要被销毁。ArkUI的节点删除机制是：后端节点直接从组件树上摘下，后端节点被销毁，对前端节点解引用，前端节点已经没有引用时，将被Ark虚拟机垃圾回收。
    
2. 自定义组件和它的变量将被删除，如果组件有同步的变量（如[@Link](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-link)、[@Prop](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-prop)、[@StorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage#storagelink)），将从[同步源](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-overview#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)上取消注册。
    

不建议在生命周期aboutToDisappear中使用async await。如果在此生命周期中使用异步操作（如 Promise 或回调方法），自定义组件将被保留在Promise的闭包中，直到回调方法执行完毕，这会阻止自定义组件的垃圾回收。

## 自定义组件嵌套使用与示例

通过以下示例，来详细说明自定义组件在嵌套使用时，自定义组件生命周期的调用时序：

1. // Index.ets
2. @Entry
3. @Component
4. struct Parent {
5.   @State showChild: boolean = true;
6.   @State btnColor: string = '#FF007DFF';

7.   // 组件生命周期
8.   aboutToAppear() {
9.     console.info('Parent aboutToAppear');
10.   }

11.   // 组件生命周期
12.   onDidBuild() {
13.     console.info('Parent onDidBuild');
14.   }

15.   // 组件生命周期
16.   aboutToDisappear() {
17.     console.info('Parent aboutToDisappear');
18.   }

19.   build() {
20.     Column() {
21.       // this.showChild为true，创建Child子组件，执行Child aboutToAppear
22.       if (this.showChild) {
23.         Child()
24.       }
25.       Button('delete Child')
26.         .margin(20)
27.         .backgroundColor(this.btnColor)
28.         .onClick(() => {
29.           // 更改this.showChild为false，删除Child子组件，执行Child aboutToDisappear
30.           // 更改this.showChild为true，添加Child子组件，执行Child aboutToAppear
31.           this.showChild = !this.showChild;
32.         })
33.     }
34.   }
35. }

36. @Component
37. struct Child {
38.   @State title: string = 'Hello World';

39.   // 组件生命周期
40.   aboutToDisappear() {
41.     console.info('Child aboutToDisappear');
42.   }

43.   // 组件生命周期
44.   onDidBuild() {
45.     console.info('Child onDidBuild');
46.   }

47.   // 组件生命周期
48.   aboutToAppear() {
49.     console.info('Child aboutToAppear');
50.   }

51.   build() {
52.     Text(this.title)
53.       .fontSize(50)
54.       .margin(20)
55.       .onClick(() => {
56.         this.title = 'Hello ArkUI';
57.       })
58.   }
59. }

以上示例中，Index页面包含两个自定义组件，一个是Parent，一个是Child，Parent及其子组件Child分别声明了各自的自定义组件生命周期函数（aboutToAppear / onDidBuild / aboutToDisappear）。

- 应用冷启动的初始化流程为：Parent aboutToAppear --> Parent build --> Parent onDidBuild --> Child aboutToAppear --> Child build --> Child onDidBuild。此处体现了自定义组件懒展开特性，即Parent执行完onDidBuild之后才会执行Child组件的aboutToAppear。日志输出信息如下：

1. Parent aboutToAppear
2. Parent onDidBuild
3. Child aboutToAppear
4. Child onDidBuild

- 点击Button按钮，更改showChild为false，删除Child组件，执行Child aboutToDisappear方法。
    
- 如果直接退出应用，则会触发以下生命周期：Parent aboutToDisappear --> Child aboutToDisappear，此处体现了自定义组件删除顺序也是从父到子。日志输出信息如下：
    

1. Parent aboutToDisappear
2. Child aboutToDisappear

- 最小化应用或者应用进入后台，当前Index页面未被销毁，所以并不会执行组件的aboutToDisappear。
    
- 如果showChild的默认值为false，则应用冷启动的初始化流程为：Parent aboutToAppear --> Parent build --> Parent onDidBuild。日志输出信息如下：
    

1. Parent aboutToAppear
2. Parent onDidBuild

- 如果showChild的默认值为false，直接退出应用，则只执行Parent aboutToDisappear方法。
    
- 如果showChild的默认值为false，此时点击Button按钮，更改showChild为true，添加Child组件，添加流程为：Child aboutToAppear --> Child build --> Child onDidBuild。日志输出信息如下：
    

1. Child aboutToAppear
2. Child onDidBuild

当showChild为默认值true时，该示例的生命周期流程图如下所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164022.52182549701542031189746922275793:50001231000000:2800:549F50279DB027DEEA7878FF368753F2D7742986C5419A3D59AA558A39D804C7.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components "创建自定义组件")
# 自定义组件的自定义布局

更新时间: 2025-12-16 16:40

如果系统提供的布局组件（如[Flex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flex)，[Column](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-column)，[Row](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-row)等）无法满足复杂布局需求，或开发者希望自定义计算组件内子组件的大小和位置，建议在自定义组件中使用以下接口：

- [onMeasureSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-layout#onmeasuresize10)：组件每次布局时触发，开发者可以在这个回调中增加自定义组件内子组件的大小的计算逻辑，返回自定义组件的尺寸信息，其执行时间先于onPlaceChildren。
    
- [onPlaceChildren](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-layout#onplacechildren10)：组件每次布局时触发，开发者可以在这个回调中增加放置自定义组件内子组件位置的逻辑。
    

以下示例中，Index页面包含一个实现了自定义布局的自定义组件，且对应自定义组件的子组件通过index页面内的builder方式传入。

而在自定义组件中，调用了onMeasureSize和onPlaceChildren设置子组件大小和放置位置。例如，在本示例中，在onMeasureSize中初始化组件大小size=100，后续的每一个子组件size会加上上一个子组件大小的一半，实现组件大小递增的效果。而在onPlaceChildren中，定义startPos=300，设置每一个子组件的位置为startPos减去子组件自身的高度，所有子组件右下角一致在顶点位置(300, 300)，实现一个从右下角开始展示组件的类Stack组件。

**示例：**

1. // xxx.ets
2. @Entry
3. @Component
4. struct Index {
5.   build() {
6.     Column() {
7.       CustomLayout({ builder: ColumnChildren })
8.     }
9.   }
10. }

11. // 通过builder的方式传递多个组件，作为自定义组件的一级子组件（即不包含容器组件，如Column）
12. @Builder
13. function ColumnChildren() {
14.   ForEach([1, 2, 3], (index: number) => { // 暂不支持lazyForEach的写法
15.     Text('S' + index)
16.       .fontSize(30)
17.       .width(100)
18.       .height(100)
19.       .borderWidth(2)
20.       .offset({ x: 10, y: 20 })
21.   })
22. }

23. @Component
24. struct CustomLayout {
25.   @Builder
26.   doNothingBuilder() {
27.   };

28.   @BuilderParam builder: () => void = this.doNothingBuilder;
29.   @State startSize: number = 100;
30.   result: SizeResult = {
31.     width: 0,
32.     height: 0
33.   };

34.   // 第一步：计算各子组件的大小
35.   onMeasureSize(selfLayoutInfo: GeometryInfo, children: Array<Measurable>, constraint: ConstraintSizeOptions) {
36.     let size = 100;
37.     children.forEach((child) => {
38.       let result: MeasureResult = child.measure({ minHeight: size, minWidth: size, maxWidth: size, maxHeight: size })
39.       size += result.width / 2;
40.     })
41.     // this.result在该用例中代表自定义组件本身的大小，onMeasureSize方法返回的是组件自身的尺寸。
42.     this.result.width = 100;
43.     this.result.height = 400;
44.     return this.result;
45.   }
46.   // 第二步：放置各子组件的位置
47.   onPlaceChildren(selfLayoutInfo: GeometryInfo, children: Array<Layoutable>, constraint: ConstraintSizeOptions) {
48.     let startPos = 300;
49.     children.forEach((child) => {
50.       let pos = startPos - child.measureResult.height;
51.       child.layout({ x: pos, y: pos })
52.     })
53.   }

54.   build() {
55.     this.builder()
56.   }
57. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164034.25687620088850054917823160123744:50001231000000:2800:B3B2C81B965B253C665D6C0941DC243FB711649290E7F7FC1CF39FD93C9594A6.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-page-custom-components-lifecycle "自定义组件生命周期")
# 自定义组件成员属性访问限定符使用限制

更新时间: 2025-12-16 16:40

在状态管理V1版本中，完成自定义组件封装后，调用方难以明确知晓应传入哪些变量作为组件的输入参数。当组件开发者不希望状态变量被外部初始化时，可以使用private限定符来限制当前变量不允许被外部初始化。外部初始化也需要遵循装饰器自身的规则，具体规则见[使用限制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-custom-components-access-restrictions#%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6)。

ArkTS会对自定义组件的成员变量使用的访问限定符private/public/protected进行校验，当不按规范使用访问限定符private/public/protected时，会产生对应的日志信息。

在阅读本文档前，建议提前阅读：[状态管理概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-overview)。

说明

从API version 12开始，支持自定义组件成员属性访问限定符使用限制的规则。

## 使用限制

- [@State](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state)/[@Prop](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-prop)/[@Provide](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume)/[@BuilderParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builderparam)/常规成员变量(不涉及更新的普通变量)的初始化规则为可以被外部初始化，也可以使用本地值进行初始化。当组件开发者不希望当前变量被外部初始化时，可以使用private进行修饰，在这种情况下，错误进行外部初始化会有编译告警日志提示。
    
- [@StorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage#storagelink)/[@StorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage#storageprop)/[@LocalStorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage#localstoragelink)/[@LocalStorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage#localstorageprop)/[@Consume](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume)变量的初始化规则为不可以被外部初始化，当组件开发者希望当前变量被外部初始化而使用public修饰时，与装饰器本身的初始化规则不符，会有编译告警日志提示。
    
- [@Link](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-link)/[@ObjectLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-observed-and-objectlink)变量的初始化规则为必须被外部初始化，禁止本地初始化。当组件开发者使用private对变量进行修饰时，与装饰器本身的初始化规则不符，会有编译告警日志提示。
    
- 由于struct没有继承能力，上述所有的这些变量使用protected修饰时，会有编译告警日志提示。
    
- [@Require](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-require)含义是当前被@Require装饰的变量必须被外部初始化，当@Require和private同时装饰[@State](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state)/[@Prop](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-prop)/[@Provide](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume)/[@BuilderParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builderparam)/常规成员变量(不涉及更新的普通变量)时，他们的含义是自相矛盾的，会有编译告警日志提示。
    

## 使用场景

1. 当成员变量被private访问限定符和@State/@Prop/@Provide/@BuilderParam装饰器同时修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
    
    【反例】
    
    1. @Entry
    2. @Component
    3. struct AccessRestrictions {
    4.   @Builder
    5.   buildTest() {
    6.     Text('Parent builder')
    7.   }
    
    8.   build() {
    9.     Column() {
    10.       ComponentsChild({
    11.         state_value: 'Hello',
    12.         prop_value: 'Hello',
    13.         provide_value: 'Hello',
    14.         builder_value: this.buildTest,
    15.         regular_value: 'Hello'
    16.       })
    17.     }
    18.     .width('100%')
    19.   }
    20. }
    
    21. @Component
    22. struct ComponentsChild {
    23.   // 此处使用private修饰符时会出现告警日志
    24.   @State private state_value: string = 'Hello';
    25.   // 此处使用private修饰符时会出现告警日志
    26.   @Prop private prop_value: string = 'Hello';
    27.   // 此处使用private修饰符时会出现告警日志
    28.   @Provide private provide_value: string = 'Hello';
    29.   // 此处使用private修饰符时会出现告警日志
    30.   @BuilderParam private builder_value: () => void = this.buildTest;
    31.   // 此处使用private修饰符时会出现告警日志
    32.   private regular_value: string = 'Hello';
    
    33.   @Builder
    34.   buildTest() {
    35.     Text('Child builder')
    36.   }
    
    37.   build() {
    38.     Column() {
    39.       Text('Hello')
    40.         .fontSize(50)
    41.         .fontWeight(FontWeight.Bold)
    42.     }
    43.   }
    44. }
    
    编译告警日志如下：
    
    45. Property 'state_value' is private and can not be initialized through the component constructor.
    46. Property 'prop_value' is private and can not be initialized through the component constructor.
    47. Property 'provide_value' is private and can not be initialized through the component constructor.
    48. Property 'builder_value' is private and can not be initialized through the component constructor.
    49. Property 'regular_value' is private and can not be initialized through the component constructor.
    
    【正例】
    
    50. @Entry
    51. @Component
    52. struct AccessRestrictions {
    53.   @Builder
    54.   buildTest() {
    55.     Text('Parent builder')
    56.   }
    
    57.   build() {
    58.     Column() {
    59.       ComponentsChild({
    60.         state_value: 'Hello',
    61.         prop_value: 'Hello',
    62.         provide_value: 'Hello',
    63.         builder_value: this.buildTest,
    64.         regular_value: 'Hello'
    65.       })
    66.     }
    67.     .width('100%')
    68.   }
    69. }
    
    70. @Component
    71. struct ComponentsChild {
    72.   @State state_value: string = 'Hello';
    73.   @Prop prop_value: string = 'Hello';
    74.   @Provide provide_value: string = 'Hello';
    75.   @BuilderParam builder_value: () => void = this.buildTest;
    76.   regular_value: string = 'Hello';
    
    77.   @Builder
    78.   buildTest() {
    79.     Text('Child builder')
    80.   }
    
    81.   build() {
    82.     Column() {
    83.       Text('Hello')
    84.         .fontSize(50)
    85.         .fontWeight(FontWeight.Bold)
    86.     }
    87.   }
    88. }
    
2. 当成员变量被public访问限定符和@StorageLink/@StorageProp/@LocalStorageLink/@LocalStorageProp/@Consume装饰器同时修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
    
    【反例】
    
    1. @Entry
    2. @Component
    3. struct AccessRestrictions {
    4.   @Provide consume_value: string = 'Hello';
    5.   build() {
    6.     Column() {
    7.       ComponentChild()
    8.     }
    9.     .width('100%')
    10.   }
    11. }
    
    12. @Component
    13. struct ComponentChild {
    14.   // 此处使用public修饰符时会出现告警日志
    15.   @LocalStorageProp('sessionLocalProp') public local_prop_value: string = 'Hello';
    16.   // 此处使用public修饰符时会出现告警日志
    17.   @LocalStorageLink('sessionLocalLink') public local_link_value: string = 'Hello';
    18.   // 此处使用public修饰符时会出现告警日志
    19.   @StorageProp('sessionProp') public storage_prop_value: string = 'Hello';
    20.   // 此处使用public修饰符时会出现告警日志
    21.   @StorageLink('sessionLink') public storage_link_value: string = 'Hello';
    22.   // 此处使用public修饰符时会出现告警日志
    23.   @Consume public consume_value: string;
    
    24.   build() {
    25.     Column() {
    26.       Text('Hello')
    27.         .fontSize(50)
    28.         .fontWeight(FontWeight.Bold)
    29.     }
    30.   }
    31. }
    
    编译告警日志如下：
    
    32. Property 'local_prop_value' can not be decorated with both '@LocalStorageProp' and public.
    33. Property 'local_link_value' can not be decorated with both '@LocalStorageLink' and public.
    34. Property 'storage_prop_value' can not be decorated with both '@StorageProp' and public.
    35. Property 'storage_link_value' can not be decorated with both '@StorageLink' and public.
    36. Property 'consume_value' can not be decorated with both '@Consume' and public.
    
    【正例】
    
    37. @Entry
    38. @Component
    39. struct AccessRestrictions {
    40.   @Provide consume_value: string = 'Hello';
    41.   build() {
    42.     Column() {
    43.       ComponentChild()
    44.     }
    45.     .width('100%')
    46.   }
    47. }
    
    48. @Component
    49. struct ComponentChild {
    50.   @LocalStorageProp('sessionLocalProp') local_prop_value: string = 'Hello';
    51.   @LocalStorageLink('sessionLocalLink') local_link_value: string = 'Hello';
    52.   @StorageProp('sessionProp') storage_prop_value: string = 'Hello';
    53.   @StorageLink('sessionLink') storage_link_value: string = 'Hello';
    54.   @Consume consume_value: string;
    55.   build() {
    56.     Column() {
    57.       Text('Hello')
    58.         .fontSize(50)
    59.         .fontWeight(FontWeight.Bold)
    60.     }
    61.   }
    62. }
    
3. 当成员变量被private访问限定符和@Link/@ObjectLink装饰器同时修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
    
    【反例】
    
    1. @Entry
    2. @Component
    3. struct AccessRestrictions {
    4.   @State link_value: string = 'Hello';
    5.   @State objectLink_value: ComponentObj = new ComponentObj();
    6.   build() {
    7.     Column() {
    8.       ComponentChild({link_value: this.link_value, objectLink_value: this.objectLink_value})
    9.     }
    10.     .width('100%')
    11.   }
    12. }
    
    13. @Observed
    14. class ComponentObj {
    15.   count: number = 0;
    16. }
    17. @Component
    18. struct ComponentChild {
    19.   // 此处使用private修饰符时会出现告警日志
    20.   @Link private link_value: string;
    21.   // 此处使用private修饰符时会出现告警日志
    22.   @ObjectLink private objectLink_value: ComponentObj;
    23.   build() {
    24.     Column() {
    25.       Text('Hello')
    26.         .fontSize(50)
    27.         .fontWeight(FontWeight.Bold)
    28.     }
    29.   }
    30. }
    
    编译告警日志如下：
    
    31. Property 'link_value' can not be decorated with both '@Link' and private.
    32. Property 'objectLink_value' can not be decorated with both '@ObjectLink' and private.
    
    【正例】
    
    33. @Entry
    34. @Component
    35. struct AccessRestrictions {
    36.   @State link_value: string = 'Hello';
    37.   @State objectLink_value: ComponentObj = new ComponentObj();
    38.   build() {
    39.     Column() {
    40.       ComponentChild({link_value: this.link_value, objectLink_value: this.objectLink_value})
    41.     }
    42.     .width('100%')
    43.   }
    44. }
    
    45. @Observed
    46. class ComponentObj {
    47.   count: number = 0;
    48. }
    49. @Component
    50. struct ComponentChild {
    51.   @Link link_value: string;
    52.   @ObjectLink objectLink_value: ComponentObj;
    53.   build() {
    54.     Column() {
    55.       Text('Hello')
    56.         .fontSize(50)
    57.         .fontWeight(FontWeight.Bold)
    58.     }
    59.   }
    60. }
    
4. 当成员变量被protected访问限定符修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
    
    【反例】
    
    1. @Entry
    2. @Component
    3. struct AccessRestrictions {
    4.   build() {
    5.     Column() {
    6.       ComponentChild({regular_value: 'Hello'})
    7.     }
    8.     .width('100%')
    9.   }
    10. }
    
    11. @Component
    12. struct ComponentChild {
    13.   // 此处使用protected修饰符时会出现告警日志
    14.   protected regular_value: string = 'Hello';
    15.   build() {
    16.     Column() {
    17.       Text('Hello')
    18.         .fontSize(50)
    19.         .fontWeight(FontWeight.Bold)
    20.     }
    21.   }
    22. }
    
    编译告警日志如下：
    
    23. The member attributes of a struct can not be protected.
    
    【正例】
    
    24. @Entry
    25. @Component
    26. struct AccessRestrictions {
    27.   build() {
    28.     Column() {
    29.       ComponentChild({regular_value: 'Hello'})
    30.     }
    31.     .width('100%')
    32.   }
    33. }
    
    34. @Component
    35. struct ComponentChild {
    36.   regular_value: string = 'Hello';
    37.   build() {
    38.     Column() {
    39.       Text('Hello')
    40.         .fontSize(50)
    41.         .fontWeight(FontWeight.Bold)
    42.     }
    43.   }
    44. }
    
5. 当成员变量被private访问限定符、@Require和@State/@Prop/@Provide/@BuilderParam装饰器同时修饰，并且通过父组件初始化赋值时，ArkTS会进行校验并产生告警日志。
    
    【反例】
    
    1. @Entry
    2. @Component
    3. struct AccessRestrictions {
    4.   build() {
    5.     Column() {
    6.       ComponentChild({prop_value: 'Hello'})
    7.     }
    8.     .width('100%')
    9.   }
    10. }
    11. @Component
    12. struct ComponentChild {
    13.   // 此处使用private修饰符时会出现告警日志
    14.   @Require @Prop private prop_value: string = 'Hello';
    15.   build() {
    16.     Column() {
    17.       Text('Hello')
    18.         .fontSize(50)
    19.         .fontWeight(FontWeight.Bold)
    20.     }
    21.   }
    22. }
    
    编译告警日志如下：
    
    1. Property 'prop_value' can not be decorated with both '@Require' and private.
    2. Property 'prop_value' is private and can not be initialized through the component constructor.
    
    【正例】
    
    1. @Entry
    2. @Component
    3. struct AccessRestrictions {
    4.   build() {
    5.     Column() {
    6.       ComponentChild({prop_value: 'Hello'})
    7.     }
    8.     .width('100%')
    9.   }
    10. }
    11. @Component
    12. struct ComponentChild {
    13.   @Require @Prop prop_value: string = 'Hello';
    14.   build() {
    15.     Column() {
    16.       Text('Hello')
    17.         .fontSize(50)
    18.         .fontWeight(FontWeight.Bold)
    19.     }
    20.   }
    21. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-page-custom-components-layout "自定义组件的自定义布局")
# @Styles装饰器：定义组件重用样式

更新时间: 2025-12-16 16:39

如果每个组件的样式都需要单独设置，在开发过程中会出现大量代码在进行重复样式设置，虽然可以复制粘贴，但为了代码简洁性和后续方便维护，我们推出了可以提炼公共样式进行复用的装饰器@Styles。

@Styles装饰器可以将多条样式设置提炼成一个方法，直接在组件声明的位置调用。通过@Styles装饰器可以快速定义并复用自定义样式。

说明

从API version 9开始，该装饰器支持在ArkTS卡片中使用。

从API version 11开始，该装饰器支持在元服务中使用。

## 装饰器使用说明

- 当前@Styles仅支持[通用属性](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-component-general-attributes)和[通用事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-component-general-events)。
    
- @Styles可以定义在组件内或全局，在全局定义时需在方法名前面添加function关键字，组件内定义时则不需要添加function关键字。请参考用例[组件内styles和全局styles的用法](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-style#%E7%BB%84%E4%BB%B6%E5%86%85styles%E5%92%8C%E5%85%A8%E5%B1%80styles%E7%9A%84%E7%94%A8%E6%B3%95)。
    
- 组件内@Styles的优先级高于全局@Styles。框架优先找当前组件内的@Styles，如果找不到，则会全局查找。
    

说明

只能在当前文件内使用@Styles，不支持export。

若需要实现样式导出，推荐使用[AttributeModifier](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-extension-attributemodifier)。

定义在组件内的@Styles可以通过this访问组件的常量和状态变量，并可以在@Styles里通过事件来改变状态变量的值，示例如下：

1. @Entry
2. @Component
3. struct FancyUse {
4.   @State heightValue: number = 50;

5.   @Styles
6.   fancy() {
7.     .height(this.heightValue)
8.     .backgroundColor(Color.Blue)
9.     .onClick(() => {
10.       this.heightValue = 100;
11.     })
12.   }

13.   build() {
14.     Column() {
15.       Button('change height')
16.         .fancy()
17.     }
18.     .height('100%')
19.     .width('100%')
20.   }
21. }

## 限制条件

- @Styles方法不能有参数，编译期会报错，表明@Styles方法不支持参数。

1. // 错误写法： @Styles不支持参数，编译期报错
2. @Styles
3. function globalFancy (value: number) {
4.   .width(value)
5. }

6. // 正确写法
7. @Styles
8. function globalFancy () {
9.   .width(100)
10. }

- 不支持在@Styles方法内使用逻辑组件，逻辑组件内的属性不生效。

1. // 错误写法
2. @Styles
3. function backgroundColorStyle() {
4.   if (true) {
5.     .backgroundColor(Color.Red)
6.   }
7. }

8. // 正确写法
9. @Styles
10. function backgroundColorStyle() {
11.   .backgroundColor(Color.Red)
12. }

## 使用场景

### 组件内@Styles和全局@Styles的用法

1. // 定义在全局的@Styles封装的样式
2. @Styles
3. function globalFancy () {
4.   .width(150)
5.   .height(100)
6.   .backgroundColor(Color.Pink)
7. }

8. @Entry
9. @Component
10. struct FancyUse {
11.   @State heightValue: number = 100;
12.   // 定义在组件内的@Styles封装的样式
13.   @Styles fancy() {
14.     .width(200)
15.     .height(this.heightValue)
16.     .backgroundColor(Color.Yellow)
17.     .onClick(() => {
18.       this.heightValue = 200;
19.     })
20.   }

21.   build() {
22.     Column({ space: 10 }) {
23.       // 使用全局的@Styles封装的样式
24.       Text('FancyA')
25.         .globalFancy()
26.         .fontSize(30)
27.       // 使用组件内的@Styles封装的样式
28.       Text('FancyB')
29.         .fancy()
30.         .fontSize(30)
31.     }
32.   }
33. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-wrapbuilder "wrapBuilder：封装全局@Builder")
# @Extend装饰器：定义扩展组件样式

更新时间: 2025-12-16 16:39

在前文的示例中，可以使用[@Styles](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-style)用于样式的重用，在@Styles的基础上，我们提供了@Extend，用于扩展组件样式。

说明

从API version 9开始，该装饰器支持在ArkTS卡片中使用。

从API version 11开始，该装饰器支持在元服务中使用。

## 装饰器使用说明

### 语法

1. @Extend(UIComponentName) function functionName { ... }

### 使用规则

- 和@Styles不同，@Extend支持封装指定组件的私有属性、私有事件和自身定义的全局方法。
    
    1. // @Extend(Text)可以支持Text的私有属性fontColor
    2. @Extend(Text)
    3. function fancy() {
    4.   .fontColor(Color.Red)
    5. }
    
    6. // superFancyText可以调用预定义的fancy
    7. @Extend(Text)
    8. function superFancyText(size: number) {
    9.   .fontSize(size)
    10.   .fancy()
    11. }
    
- 和@Styles不同，@Extend装饰的方法支持参数，开发者可以在调用时传递参数，调用遵循TS方法传值调用。
    
    1. // xxx.ets
    2. @Extend(Text)
    3. function fancy(fontSize: number) {
    4.   .fontColor(Color.Red)
    5.   .fontSize(fontSize)
    6. }
    
    7. @Entry
    8. @Component
    9. struct FancyUse {
    10.   build() {
    11.     Row({ space: 10 }) {
    12.       Text('Fancy')
    13.         .fancy(16)
    14.       Text('Fancy')
    15.         .fancy(24)
    16.     }
    17.   }
    18. }
    
- @Extend装饰的方法的参数可以为function，作为Event事件的句柄。
    
    1. @Extend(Text)
    2. function makeMeClick(onClick: () => void) {
    3.   .backgroundColor(Color.Blue)
    4.   .onClick(onClick)
    5. }
    
    6. @Entry
    7. @Component
    8. struct FancyUse {
    9.   @State label: string = 'Hello World';
    
    10.   onClickHandler() {
    11.     this.label = 'Hello ArkUI';
    12.   }
    
    13.   build() {
    14.     Row({ space: 10 }) {
    15.       Text(`${this.label}`)
    16.         .makeMeClick(() => {
    17.           this.onClickHandler();
    18.         })
    19.     }
    20.   }
    21. }
    
- @Extend的参数可以为[状态变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-overview)，当状态变量改变时，UI可以正常的被刷新渲染。
    
    1. @Extend(Text)
    2. function fancy(fontSize: number) {
    3.   .fontColor(Color.Red)
    4.   .fontSize(fontSize)
    5. }
    
    6. @Entry
    7. @Component
    8. struct FancyUse {
    9.   @State fontSizeValue: number = 20;
    
    10.   build() {
    11.     Row({ space: 10 }) {
    12.       Text('Fancy')
    13.         .fancy(this.fontSizeValue)
    14.         .onClick(() => {
    15.           this.fontSizeValue = 30;
    16.         })
    17.     }
    18.   }
    19. }
    

## 限制条件

- 和@Styles不同，@Extend仅支持在全局定义，不支持在组件内部定义。

说明

仅限在当前文件内使用，不支持导出。

如果要实现export功能，推荐使用[AttributeModifier](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-extension-attributemodifier)。

【反例】

1. @Entry
2. @Component
3. struct FancyUse {
4.   // 错误写法，@Extend仅支持在全局定义，不支持在组件内部定义
5.   @Extend(Text) function fancy (fontSize: number) {
6.     .fontSize(fontSize)
7.   }

8.   build() {
9.     Row({ space: 10 }) {
10.       Text('Fancy')
11.         .fancy(16)
12.     }
13.   }
14. }

【正例】

1. // 正确写法
2. @Extend(Text)
3. function fancy(fontSize: number) {
4.   .fontSize(fontSize)
5. }

6. @Entry
7. @Component
8. struct FancyUse {
9.   build() {
10.     Row({ space: 10 }) {
11.       Text('Fancy')
12.         .fancy(16)
13.     }
14.   }
15. }

## 使用场景

以下示例声明了3个Text组件，每个Text组件均设置了fontStyle、fontWeight和backgroundColor样式。

1. @Entry
2. @Component
3. struct FancyUse {
4.   @State label: string = 'Hello World';

5.   build() {
6.     Row({ space: 10 }) {
7.       Text(`${this.label}`)
8.         .fontStyle(FontStyle.Italic)
9.         .fontWeight(100)
10.         .backgroundColor(Color.Blue)
11.       Text(`${this.label}`)
12.         .fontStyle(FontStyle.Italic)
13.         .fontWeight(200)
14.         .backgroundColor(Color.Pink)
15.       Text(`${this.label}`)
16.         .fontStyle(FontStyle.Italic)
17.         .fontWeight(300)
18.         .backgroundColor(Color.Orange)
19.     }.margin('20%')
20.   }
21. }

使用@Extend将样式组合复用，示例如下。

1. @Extend(Text)
2. function fancyText(weightValue: number, color: Color) {
3.   .fontStyle(FontStyle.Italic)
4.   .fontWeight(weightValue)
5.   .backgroundColor(color)
6. }

通过@Extend组合样式后，使得代码更加简洁，增强可读性。

1. @Entry
2. @Component
3. struct FancyUse {
4.   @State label: string = 'Hello World';

5.   build() {
6.     Row({ space: 10 }) {
7.       Text(`${this.label}`)
8.         .fancyText(100, Color.Blue)
9.       Text(`${this.label}`)
10.         .fancyText(200, Color.Pink)
11.       Text(`${this.label}`)
12.         .fancyText(300, Color.Orange)
13.     }.margin('20%')
14.   }
15. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-style "@Styles装饰器：定义组件重用样式")
# stateStyles：多态样式

更新时间: 2025-12-16 16:40

@Styles仅应用于静态页面的样式复用，stateStyles可以依据组件的内部状态的不同，快速设置不同样式。这就是我们本章要介绍的内容stateStyles（又称为：多态样式）。

说明

多态样式仅支持通用属性。如果多态样式不生效，则该属性可能为组件的私有属性，例如：[fontColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-text-style)、[TextInput](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput)组件的[backgroundColor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-background)等。此时，可以通过[attributeModifier](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-attribute-modifier#attributemodifier)动态设置组件属性来解决此问题。

## 概述

stateStyles是属性方法，可以根据UI内部状态来设置样式，类似于css伪类，但语法不同。ArkUI提供以下六种状态：

- focused：获焦态。
    
- normal：正常态。
    
- pressed：按压态。
    
- disabled：不可用态。
    
- clicked：点击态。
    
- selected10+：选中态。
    

说明

获焦态目前仅支持通过外接键盘的Tab键或方向键触发，不支持在嵌套滚动组件场景下通过按键触发。

## 使用场景

### 基础场景

下面的示例展示了stateStyles最基本的使用场景。Button1处于第一个组件，Button2处于第二个组件。按压时显示为pressed态指定的黑色。使用Tab键走焦，Button1获焦并显示为focused态指定的粉色。当Button2获焦的时候，Button2显示为focused态指定的粉色，Button1失焦显示normal态指定的蓝色。

1. @Entry
2. @Component
3. struct StateStylesSample {
4.   build() {
5.     Column() {
6.       Button('Button1')
7.         .stateStyles({
8.           focused: {
9.             .backgroundColor('#ffffeef0')
10.           },
11.           pressed: {
12.             .backgroundColor('#ff707070')
13.           },
14.           normal: {
15.             .backgroundColor('#ff2787d9')
16.           }
17.         })
18.         .margin(20)
19.       Button('Button2')
20.         .stateStyles({
21.           focused: {
22.             .backgroundColor('#ffffeef0')
23.           },
24.           pressed: {
25.             .backgroundColor('#ff707070')
26.           },
27.           normal: {
28.             .backgroundColor('#ff2787d9')
29.           }
30.         })
31.     }.margin('30%')
32.   }
33. }

**图1** 获焦态和按压态

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.58609718392067532302358987903723:50001231000000:2800:42CAA085A078C41FC3E01C641A762E7A5DDD14AB00F4D20CA987707854752D32.gif)

### @Styles和stateStyles联合使用

以下示例通过@Styles指定stateStyles的不同状态。

1. @Entry
2. @Component
3. struct MyComponent {
4.   @Styles normalStyle() {
5.     .backgroundColor(Color.Gray)
6.   }

7.   @Styles pressedStyle() {
8.     .backgroundColor(Color.Red)
9.   }

10.   build() {
11.     Column() {
12.       Text('Text1')
13.         .fontSize(50)
14.         .fontColor(Color.White)
15.         .stateStyles({
16.           normal: this.normalStyle,
17.           pressed: this.pressedStyle,
18.         })
19.     }
20.   }
21. }

**图2** 正常态和按压态

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.53013930624240574944207561807220:50001231000000:2800:79D6E2E99246DD5C61F547A8A86D544AAF84B18F1F33ABEE92A67E4ECA87970D.gif)

### 在stateStyles里使用常规变量和状态变量

stateStyles可以通过this绑定组件内的常规变量和状态变量。

1. @Entry
2. @Component
3. struct CompWithInlineStateStyles {
4.   @State focusedColor: Color = 0xD5D5D5;
5.   normalColor: Color = 0x004AAF;

6.   build() {
7.     Column() {
8.       Button('clickMe')
9.         .height(100)
10.         .width(100)
11.         .stateStyles({
12.           normal: {
13.             .backgroundColor(this.normalColor)
14.           },
15.           focused: {
16.             .backgroundColor(this.focusedColor)
17.           }
18.         })
19.         .onClick(() => {
20.           this.focusedColor = 0x707070;
21.         })
22.         .margin('30%')
23.     }
24.   }
25. }

Button默认normal态显示蓝色，第一次按下Tab键让Button获焦显示为focus态的浅灰色，点击事件触发后，再次按下Tab键让Button获焦，focus态变为深灰色。

**图3** 点击改变获焦态样式

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164004.51151388705586636318193697166878:50001231000000:2800:2E061E2F10CCA856D4C9D3E0C5C8B260D04E26FDBC775FD02B685D66F868BA43.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-extend "@Extend装饰器：定义扩展组件样式")
# @AnimatableExtend装饰器：定义可动画属性

更新时间: 2025-12-16 16:40

@AnimatableExtend装饰器用于自定义可动画的属性方法，在这个属性方法中修改组件不可动画的属性。在动画执行过程中，通过逐帧回调函数修改不可动画属性值，让不可动画属性也能实现动画效果。也可通过逐帧回调函数修改可动画属性的值，实现逐帧布局的效果。

- 可动画属性：如果一个属性方法在animation属性前调用，改变这个属性的值可以使animation属性的动画效果生效，这个属性称为可动画属性。比如height、width、backgroundColor、translate属性，和Text组件的fontSize属性等。
    
- 不可动画属性：如果一个属性方法在animation属性前调用，改变这个属性的值不能使animation属性的动画效果生效，这个属性称为不可动画属性。比如Polyline组件的points属性等。
    

说明

该装饰器从API version 10开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。

从API version 11开始，该装饰器支持在元服务中使用。

## 装饰器使用说明

### 语法

1. @AnimatableExtend(UIComponentName) function functionName(value: typeName) {
2.   .propertyName(value)
3. }

- @AnimatableExtend仅支持定义在全局，不支持在组件内部定义。
- @AnimatableExtend定义的函数参数类型必须为number类型或者实现 AnimatableArithmetic<T>接口的自定义类型。
- @AnimatableExtend定义的函数体内只能调用@AnimatableExtend括号内组件的属性方法。

### AnimatableArithmetic<T>接口说明

该接口定义非number数据类型的动画运算规则。对非number类型的数据（如数组、结构体、颜色等）做动画，需要实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数，

使得该数据能参与动画的插值运算和识别该数据是否发生改变。即定义它们为实现了AnimatableArithmetic<T>接口的类型。

|名称|入参类型|返回值类型|说明|
|:--|:--|:--|:--|
|plus|AnimatableArithmetic<T>|AnimatableArithmetic<T>|定义该数据类型的加法运算规则|
|subtract|AnimatableArithmetic<T>|AnimatableArithmetic<T>|定义该数据类型的减法运算规则|
|multiply|number|AnimatableArithmetic<T>|定义该数据类型的乘法运算规则|
|equals|AnimatableArithmetic<T>|boolean|定义该数据类型的相等判断规则|

## 使用场景

以下示例通过改变Text组件宽度实现逐帧布局的效果。

1. @AnimatableExtend(Text)
2. function animatableWidth(width: number) {
3.   .width(width)
4. }

5. @Entry
6. @Component
7. struct AnimatablePropertyExample {
8.   @State textWidth: number = 80;

9.   build() {
10.     Column() {
11.       Text("AnimatableProperty")
12.         .animatableWidth(this.textWidth)
13.         .animation({ duration: 2000, curve: Curve.Ease })
14.       Button("Play")
15.         .onClick(() => {
16.           this.textWidth = this.textWidth == 80 ? 160 : 80;
17.         })
18.     }.width("100%")
19.     .padding(10)
20.   }
21. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.47421154328893857725333044561371:50001231000000:2800:E667200FF95095D6E538ECC5165B5DAF8434C918F094318E0148151B90B34202.gif)

以下示例实现折线的动画效果。

1. class Point {
2.   x: number
3.   y: number

4.   constructor(x: number, y: number) {
5.     this.x = x
6.     this.y = y
7.   }

8.   plus(rhs: Point): Point {
9.     return new Point(this.x + rhs.x, this.y + rhs.y);
10.   }

11.   subtract(rhs: Point): Point {
12.     return new Point(this.x - rhs.x, this.y - rhs.y);
13.   }

14.   multiply(scale: number): Point {
15.     return new Point(this.x * scale, this.y * scale);
16.   }

17.   equals(rhs: Point): boolean {
18.     return this.x === rhs.x && this.y === rhs.y;
19.   }
20. }

21. // PointVector实现了AnimatableArithmetic<T>接口
22. class PointVector extends Array<Point> implements AnimatableArithmetic<PointVector> {
23.   constructor(value: Array<Point>) {
24.     super();
25.     value.forEach(p => this.push(p));
26.   }

27.   plus(rhs: PointVector): PointVector {
28.     let result = new PointVector([]);
29.     const len = Math.min(this.length, rhs.length);
30.     for (let i = 0; i < len; i++) {
31.       result.push((this as Array<Point>)[i].plus((rhs as Array<Point>)[i]));
32.     }
33.     return result;
34.   }

35.   subtract(rhs: PointVector): PointVector {
36.     let result = new PointVector([]);
37.     const len = Math.min(this.length, rhs.length);
38.     for (let i = 0; i < len; i++) {
39.       result.push((this as Array<Point>)[i].subtract((rhs as Array<Point>)[i]));
40.     }
41.     return result;
42.   }

43.   multiply(scale: number): PointVector {
44.     let result = new PointVector([]);
45.     for (let i = 0; i < this.length; i++) {
46.       result.push((this as Array<Point>)[i].multiply(scale));
47.     }
48.     return result;
49.   }

50.   equals(rhs: PointVector): boolean {
51.     if (this.length != rhs.length) {
52.       return false;
53.     }
54.     for (let i = 0; i < this.length; i++) {
55.       if (!(this as Array<Point>)[i].equals((rhs as Array<Point>)[i])) {
56.         return false;
57.       }
58.     }
59.     return true;
60.   }

61.   get(): Array<Object[]> {
62.     let result: Array<Object[]> = [];
63.     this.forEach(p => result.push([p.x, p.y]));
64.     return result;
65.   }
66. }

67. @AnimatableExtend(Polyline)
68. function animatablePoints(points: PointVector) {
69.   .points(points.get())
70. }

71. @Entry
72. @Component
73. struct AnimatablePropertyExample {
74.   @State points: PointVector = new PointVector([
75.     new Point(50, Math.random() * 200),
76.     new Point(100, Math.random() * 200),
77.     new Point(150, Math.random() * 200),
78.     new Point(200, Math.random() * 200),
79.     new Point(250, Math.random() * 200),
80.   ])

81.   build() {
82.     Column() {
83.       Polyline()
84.         .animatablePoints(this.points)
85.         .animation({ duration: 1000, curve: Curve.Ease })// 设置动画参数
86.         .size({ height: 220, width: 300 })
87.         .fill(Color.Green)
88.         .stroke(Color.Red)
89.         .backgroundColor('#eeaacc')
90.       Button("Play")
91.         .onClick(() => {
92.           // points是实现了可动画协议的数据类型，points在动画过程中可按照定义的运算规则、动画参数从之前的PointVector变为新的PointVector数据，产生每一帧的PointVector数据，进而产生动画
93.           this.points = new PointVector([
94.             new Point(50, Math.random() * 200),
95.             new Point(100, Math.random() * 200),
96.             new Point(150, Math.random() * 200),
97.             new Point(200, Math.random() * 200),
98.             new Point(250, Math.random() * 200),
99.           ]);
100.         })
101.     }.width("100%")
102.     .padding(10)
103.   }
104. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216164005.10663038976468191984243252585365:50001231000000:2800:00D6AA57D812BC18097AD5B83E12A8DE9D530DA1506DFB46F0E8B998DB629AC8.gif)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-statestyles "stateStyles：多态样式")
# @Require装饰器：校验构造传参

更新时间: 2025-12-16 16:40

@Require是校验@Prop、@State、@Provide、@BuilderParam、@Param和普通变量(无状态装饰器修饰的变量)是否需要构造传参的一个装饰器。

说明

从API version 11开始对@Prop/@BuilderParam进行校验。

从API version 11开始，该装饰器支持在ArkTS卡片中使用。

从API version 11开始，该装饰器支持在元服务中使用。

从API version 12开始对@State/@Provide/@Param/普通变量(无状态装饰器修饰的变量)进行校验。

## 概述

当@Require装饰器和[@Prop](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-prop)、[@State](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state)、[@Provide](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume)、[@Param](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-param)、[@BuilderParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builderparam)、普通变量(无状态装饰器修饰的变量)结合使用时，在构造该自定义组件时，@Prop、@State、@Provide、@Param、@BuilderParam和普通变量(无状态装饰器修饰的变量)必须在构造时传参。

## 限制条件

@Require装饰器仅用于装饰struct内的@Prop、@State、@Provide、@BuilderParam、@Param和普通变量(无状态装饰器修饰的变量)。

预览器的限制场景请参考[PreviewChecker检测规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-previewer-previewchecker-V5)。

## 使用场景

当Child组件内使用@Require装饰器和@Prop、@State、@Provide、@BuilderParam、@Param和普通变量(无状态装饰器修饰的变量)结合使用时，父组件Index在构造Child时必须传参，否则编译不通过。

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = 'Hello World';

5.   @Builder
6.   buildTest() {
7.     Row() {
8.       Text('Hello, world')
9.         .fontSize(30)
10.     }
11.   }

12.   build() {
13.     Row() {
14.       // 构造Child时需传入所有@Require对应参数，否则编译失败。
15.       Child({
16.         regular_value: this.message,
17.         state_value: this.message,
18.         provide_value: this.message,
19.         initMessage: this.message,
20.         message: this.message,
21.         buildTest: this.buildTest,
22.         initBuildTest: this.buildTest
23.       })
24.     }
25.   }
26. }

27. @Component
28. struct Child {
29.   @Builder
30.   buildFunction() {
31.     Column() {
32.       Text('initBuilderParam')
33.         .fontSize(30)
34.     }
35.   }

36.   @Require regular_value: string = 'Hello';
37.   @Require @State state_value: string = 'Hello';
38.   @Require @Provide provide_value: string = 'Hello';
39.   @Require @BuilderParam buildTest: () => void;
40.   @Require @BuilderParam initBuildTest: () => void = this.buildFunction;
41.   @Require @Prop initMessage: string = 'Hello';
42.   @Require @Prop message: string;

43.   build() {
44.     Column() {
45.       Text(this.initMessage)
46.         .fontSize(30)
47.       Text(this.message)
48.         .fontSize(30)
49.       this.initBuildTest();
50.       this.buildTest();
51.     }
52.     .width('100%')
53.     .height('100%')
54.   }
55. }

使用[@ComponentV2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-componentv2)修饰的自定义组件ChildPage通过父组件ParentPage进行初始化，因为有@Require装饰@Param，所以父组件必须进行构造赋值。

1. @ObservedV2
2. class Info {
3.   @Trace name: string = '';
4.   @Trace age: number = 0;
5. }

6. @ComponentV2
7. struct ChildPage {
8.   @Require @Param childInfo: Info = new Info();
9.   @Require @Param state_value: string = 'Hello';

10.   build() {
11.     Column() {
12.       Text(`ChildPage childInfo name :${this.childInfo.name}`)
13.         .fontSize(20)
14.         .fontWeight(FontWeight.Bold)
15.       Text(`ChildPage childInfo age :${this.childInfo.age}`)
16.         .fontSize(20)
17.         .fontWeight(FontWeight.Bold)
18.       Text(`ChildPage state_value age :${this.state_value}`)
19.         .fontSize(20)
20.         .fontWeight(FontWeight.Bold)
21.     }
22.   }
23. }

24. @Entry
25. @ComponentV2
26. struct ParentPage {
27.   info1: Info = { name: 'Tom', age: 25 };
28.   label1: string = 'Hello World';
29.   @Local info2: Info = { name: 'Tom', age: 25 };
30.   @Local label2: string = 'Hello World';

31.   build() {
32.     Column() {
33.       Text(`info1: ${this.info1.name}  ${this.info1.age}`) // Text1
34.         .fontSize(30)
35.         .fontWeight(FontWeight.Bold)
36.       // 父组件ParentPage构造子组件ChildPage时进行了构造赋值。
37.       // 为ChildPage中被@Require @Param装饰的childInfo和state_value属性传入了值。
38.       ChildPage({ childInfo: this.info1, state_value: this.label1 }) // 创建自定义组件。
39.       Line()
40.         .width('100%')
41.         .height(5)
42.         .backgroundColor('#000000').margin(10)
43.       Text(`info2: ${this.info2.name}  ${this.info2.age}`) // Text2。
44.         .fontSize(30)
45.         .fontWeight(FontWeight.Bold)
46.       // 同上，在父组件创建子组件的过程中进行构造赋值。
47.       ChildPage({ childInfo: this.info2, state_value: this.label2 }) // 创建自定义组件。
48.       Line()
49.         .width('100%')
50.         .height(5)
51.         .backgroundColor('#000000').margin(10)
52.       Button('change info1&info2')
53.         .onClick(() => {
54.           this.info1 = { name: 'Cat', age: 18 }; // Text1不会刷新，原因是info1没有装饰器装饰，监听不到值的改变。
55.           this.info2 = { name: 'Cat', age: 18 }; // Text2会刷新，原因是info2有装饰器装饰，能够监听到值的改变。
56.           this.label1 = 'Luck'; // 不会刷新，原因是label1没有装饰器装饰，监听不到值的改变。
57.           this.label2 = 'Luck'; // 会刷新，原因是label2有装饰器装饰，可以监听到值的改变。
58.         })
59.     }
60.   }
61. }

从API version 18开始，使用@Require装饰@State、@Prop、@Provide装饰的状态变量，可以在无本地初始值的情况下直接在组件内使用，不会编译报错。

1. @Entry
2. @Component
3. struct Index {
4.   message: string = 'Hello World';

5.   build() {
6.     Column() {
7.       Child({ message: this.message })
8.     }
9.   }
10. }

11. @Component
12. struct Child {
13.   @Require @State message: string;

14.   build() {
15.     Column() {
16.       Text(this.message) // 从API version 18开始，可以编译通过。
17.     }
18.   }
19. }

## 常见问题

当Child组件内将@Require装饰器与@Prop、@State、@Provide、@BuilderParam、普通变量（无状态装饰器修饰的变量）结合使用时，若父组件Index在构造Child时未传递相应参数，则会导致编译失败。当ChildV2组件内将@Require装饰器与@Param结合使用时，若父组件Index在构造ChildV2时未传递相应参数，则同样会导致编译失败。

【反例】

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = 'Hello World!';

5.   @Builder
6.   buildTest() {
7.     Row() {
8.       Text('Hello, world!!')
9.         .fontSize(30)
10.     }
11.   }

12.   build() {
13.     Row() {
14.       // 构造Child、ChildV2组件时没有传参，会导致编译不通过。
15.       Child()
16.       ChildV2()
17.     }
18.   }
19. }

20. @Component
21. struct Child {
22.   @Builder
23.   buildFunction() {
24.     Column() {
25.       Text('initBuilderParam')
26.         .fontSize(30)
27.     }
28.   }

29.   // 使用@Require必须构造时传参。
30.   @Require regular_value: string = 'Hello';
31.   @Require @State state_value: string = 'Hello';
32.   @Require @Provide provide_value: string = 'Hello';
33.   @Require @BuilderParam initBuildTest: () => void = this.buildFunction;
34.   @Require @Prop initMessage: string = 'Hello';

35.   build() {
36.     Column() {
37.       Text(this.initMessage)
38.         .fontSize(30)
39.       this.initBuildTest();
40.     }
41.   }
42. }

43. @ComponentV2
44. struct ChildV2 {
45.   // 使用@Require必须构造时传参。
46.   @Require @Param message: string;

47.   build() {
48.     Column() {
49.       Text(this.message)
50.     }
51.   }
52. }

当父组件Index在构造Child与ChildV2时传递了相应的参数，则编译通过。

【正例】

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = 'Hello World!';

5.   @Builder
6.   buildTest() {
7.     Row() {
8.       Text('Hello, world!!')
9.         .fontSize(30)
10.     }
11.   }

12.   build() {
13.     Row() {
14.       // 构造Child、ChildV2组件时传递相应参数，编译通过。
15.       Child({
16.         regular_value: 'Hello',
17.         state_value: 'Hello',
18.         provide_value: 'Hello',
19.         initBuildTest: this.buildTest,
20.         initMessage: 'Hello'
21.       })
22.       ChildV2({ message: this.message })
23.     }
24.   }
25. }

26. @Component
27. struct Child {
28.   @Builder
29.   buildFunction() {
30.     Column() {
31.       Text('initBuilderParam')
32.         .fontSize(30)
33.     }
34.   }

35.   // 使用@Require必须构造时传参。
36.   @Require regular_value: string = 'Hello';
37.   @Require @State state_value: string = 'Hello';
38.   @Require @Provide provide_value: string = 'Hello';
39.   @Require @BuilderParam initBuildTest: () => void = this.buildFunction;
40.   @Require @Prop initMessage: string = 'Hello';

41.   build() {
42.     Column() {
43.       Text(this.initMessage)
44.         .fontSize(30)
45.       this.initBuildTest();
46.     }
47.   }
48. }

49. @ComponentV2
50. struct ChildV2 {
51.   // 使用@Require必须构造时传参。
52.   @Require @Param message: string;

53.   build() {
54.     Column() {
55.       Text(this.message)
56.     }
57.   }
58. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animatable-extend "@AnimatableExtend装饰器：定义可动画属性")
# @Reusable装饰器：组件复用

更新时间: 2025-12-16 16:40

@Reusable装饰器标记的自定义组件支持视图节点、组件实例和状态上下文的复用，避免重复创建和销毁，提升性能。

## 概述

使用@Reusable装饰器时，表示该自定义组件可以复用。与[@Component装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#component)结合使用，标记为@Reusable的自定义组件在从组件树中移除时，组件及其对应的JS对象将被放入复用缓存中。后续创建新自定义组件节点时，将复用缓存中的节点，从而节约组件重新创建的时间。

说明

API version 10开始支持@Reusable，支持在ArkTS中使用。

关于组件复用的原理与使用、优化方法、适用场景，请参考最佳实践[组件复用最佳实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse)。

@Reusable标识之后，在组件上下树时ArkUI框架会调用该组件的[aboutToReuse](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoreuse10)方法和[aboutToRecycle](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttorecycle10)方法，因此，开发者在实现复用时，大部分代码都集中在这两个生命周期方法中。

如果一个组件里可复用的组件不止一个，可以使用[reuseId](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-reuse-id)来区分不同结构的复用组件。

## 限制条件

- @Reusable装饰器仅用于自定义组件。
    
- @Reusable不支持跟[@ComponentV2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-componentv2)搭配使用，@ComponentV2组件复用推荐[@ReusableV2装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-reusablev2)。
    

1. import { ComponentContent } from "@kit.ArkUI";

2. // @Builder加上@Reusable编译报错,不适用于builder。
3. // @Reusable
4. @Builder
5. function buildCreativeLoadingDialog(closedClick: () => void) {
6.   Crash()
7. }

8. @Component
9. export struct Crash {
10.   build() {
11.     Column() {
12.       Text("Crash")
13.         .fontSize(12)
14.         .lineHeight(18)
15.         .fontColor(Color.Blue)
16.         .margin({
17.           left: 6
18.         })
19.     }.width('100%')
20.     .height('100%')
21.     .justifyContent(FlexAlign.Center)
22.   }
23. }

24. @Entry
25. @Component
26. struct Index {
27.   @State message: string = 'Hello World';
28.   private uiContext = this.getUIContext();

29.   build() {
30.     RelativeContainer() {
31.       Text(this.message)
32.         .id('Index')
33.         .fontSize(50)
34.         .fontWeight(FontWeight.Bold)
35.         .alignRules({
36.           center: { anchor: '__container__', align: VerticalAlign.Center },
37.           middle: { anchor: '__container__', align: HorizontalAlign.Center }
38.         })
39.         .onClick(() => {
40.           let contentNode = new ComponentContent(this.uiContext, wrapBuilder(buildCreativeLoadingDialog), () => {
41.           });
42.           this.uiContext.getPromptAction().openCustomDialog(contentNode);
43.         })
44.     }
45.     .height('100%')
46.     .width('100%')
47.   }
48. }

- 被@Reusable装饰的自定义组件在复用时，会递归调用该自定义组件及其所有子组件的aboutToReuse回调函数。若在子组件的aboutToReuse函数中修改了父组件的状态变量，此次修改将不会生效，请避免此类用法。若需设置父组件的状态变量，可使用setTimeout设置延迟执行，将任务抛出组件复用的作用范围，使修改生效。
    
    【反例】
    
    在子组件的aboutToReuse中，直接修改父组件的状态变量。
    
    1. class BasicDataSource implements IDataSource {
    2.   private listener: DataChangeListener | undefined = undefined;
    3.   public dataArray: number[] = [];
    
    4.   totalCount(): number {
    5.     return this.dataArray.length;
    6.   }
    
    7.   getData(index: number): number {
    8.     return this.dataArray[index];
    9.   }
    
    10.   registerDataChangeListener(listener: DataChangeListener): void {
    11.     this.listener = listener;
    12.   }
    
    13.   unregisterDataChangeListener(listener: DataChangeListener): void {
    14.     this.listener = undefined;
    15.   }
    16. }
    
    17. @Entry
    18. @Component
    19. struct Index {
    20.   private data: BasicDataSource = new BasicDataSource();
    
    21.   aboutToAppear(): void {
    22.     for (let index = 1; index < 20; index++) {
    23.       this.data.dataArray.push(index);
    24.     }
    25.   }
    
    26.   build() {
    27.     List() {
    28.       LazyForEach(this.data, (item: number, index: number) => {
    29.         ListItem() {
    30.           ReuseComponent({ num: item })
    31.         }
    32.       }, (item: number, index: number) => index.toString())
    33.     }.cachedCount(0)
    34.   }
    35. }
    
    36. @Reusable
    37. @Component
    38. struct ReuseComponent {
    39.   @State num: number = 0;
    
    40.   aboutToReuse(params: ESObject): void {
    41.     this.num = params.num;
    42.   }
    
    43.   build() {
    44.     Column() {
    45.       Text('ReuseComponent num:' + this.num.toString())
    46.       ReuseComponentChild({ num: this.num })
    47.       Button('plus')
    48.         .onClick(() => {
    49.           this.num += 10;
    50.         })
    51.     }
    52.     .height(200)
    53.   }
    54. }
    
    55. @Component
    56. struct ReuseComponentChild {
    57.   @Link num: number;
    
    58.   aboutToReuse(params: ESObject): void {
    59.     this.num = -1 * params.num;
    60.   }
    
    61.   build() {
    62.     Text('ReuseComponentChild num:' + this.num.toString())
    63.   }
    64. }
    
    【正例】
    
    在子组件的aboutToReuse中，使用setTimeout，将修改抛出组件复用的作用范围。
    
    65. class BasicDataSource implements IDataSource {
    66.   private listener: DataChangeListener | undefined = undefined;
    67.   public dataArray: number[] = [];
    
    68.   totalCount(): number {
    69.     return this.dataArray.length;
    70.   }
    
    71.   getData(index: number): number {
    72.     return this.dataArray[index];
    73.   }
    
    74.   registerDataChangeListener(listener: DataChangeListener): void {
    75.     this.listener = listener;
    76.   }
    
    77.   unregisterDataChangeListener(listener: DataChangeListener): void {
    78.     this.listener = undefined;
    79.   }
    80. }
    
    81. @Entry
    82. @Component
    83. struct Index {
    84.   private data: BasicDataSource = new BasicDataSource();
    
    85.   aboutToAppear(): void {
    86.     for (let index = 1; index < 20; index++) {
    87.       this.data.dataArray.push(index);
    88.     }
    89.   }
    
    90.   build() {
    91.     List() {
    92.       LazyForEach(this.data, (item: number, index: number) => {
    93.         ListItem() {
    94.           ReuseComponent({ num: item })
    95.         }
    96.       }, (item: number, index: number) => index.toString())
    97.     }.cachedCount(0)
    98.   }
    99. }
    
    100. @Reusable
    101. @Component
    102. struct ReuseComponent {
    103.   @State num: number = 0;
    
    104.   aboutToReuse(params: ESObject): void {
    105.     this.num = params.num;
    106.   }
    
    107.   build() {
    108.     Column() {
    109.       Text('ReuseComponent num:' + this.num.toString())
    110.       ReuseComponentChild({ num: this.num })
    111.       Button('plus')
    112.         .onClick(() => {
    113.           this.num += 10;
    114.         })
    115.     }
    116.     .height(200)
    117.   }
    118. }
    
    119. @Component
    120. struct ReuseComponentChild {
    121.   @Link num: number;
    
    122.   aboutToReuse(params: ESObject): void {
    123.     setTimeout(() => {
    124.       this.num = -1 * params.num;
    125.     }, 1)
    126.   }
    
    127.   build() {
    128.     Text('ReuseComponentChild num:' + this.num.toString())
    129.   }
    130. }
    
- 被@Reusable装饰的自定义组件在复用前后，应保持组件的结构不变。否则，会在复用过程中创建或销毁子组件，降低复用效率和性能，甚至造成应用行为异常。
    
    对于复用过程中创建的子组件，框架会在其创建后依次调用aboutToReuse方法和aboutToAppear方法。在调用aboutToReuse方法时，由于其aboutToAppear方法还未执行，且内部子组件还未创建，因此可能引起预期外的行为。在调用aboutToReuse方法后，框架会再调用aboutToAppear方法并初始化组件。
    
    针对组件结构存在差异的场景，开发者需要通过设定不同的reuseId来进行区分，具体方式请参考[多种条目类型使用场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable#%E5%A4%9A%E7%A7%8D%E6%9D%A1%E7%9B%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)。
    
    【反例】
    
    组件结构存在差异，但未通过reuseId进行区分。
    
    以下示例中，先点击“show/hide branch A”按钮，组件被回收，再点击“show/hide branch B”按钮，组件被复用。子组件ReusableChildB在复用过程中被创建，aboutToReuse方法和aboutToAppear方法被同时依次调用。
    
    1. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    2. const TAG = '[Sample_ReusableComponent]';
    3. const DOMAIN = 0xF811;
    4. const BUNDLE = 'ReusableComponent_';
    
    5. @Entry
    6. @Component
    7. struct Index {
    8.   @State showBranchA: boolean = true;
    9.   @State showBranchB: boolean = false;
    
    10.   build() {
    11.     Column({ space: 5 }) {
    12.       Button('show/hide branch A')
    13.         .onClick(() => {
    14.           this.showBranchA = !this.showBranchA;
    15.         })
    16.       if (this.showBranchA) {
    17.         ReusableComponent({ flag: true })
    18.       }
    19.       Button('show/hide branch B')
    20.         .onClick(() => {
    21.           this.showBranchB = !this.showBranchB;
    22.         })
    23.       if (this.showBranchB) {
    24.         ReusableComponent({ flag: false })
    25.       }
    26.     }
    27.   }
    28. }
    
    29. @Reusable
    30. @Component
    31. struct ReusableComponent {
    32.   @Require @Prop flag: boolean = true;
    
    33.   aboutToAppear() {
    34.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableComponent aboutToAppear');
    35.   }
    
    36.   aboutToReuse(params: ESObject) {
    37.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableComponent aboutToReuse');
    38.     this.flag = params.flag;
    39.   }
    
    40.   build() {
    41.     Column({ space: 5 }) {
    42.       Text('ReusableComponent')
    43.       if (this.flag) {
    44.         ReusableChildA()
    45.       } else {
    46.         ReusableChildB()
    47.       }
    48.     }.border({ width: 1 })
    49.   }
    50. }
    
    51. @Component
    52. struct ReusableChildA {
    53.   aboutToAppear() {
    54.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildA aboutToAppear');
    55.   }
    
    56.   aboutToReuse() {
    57.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildA aboutToReuse');
    58.   }
    
    59.   build() {
    60.     Text('ReusableChildA')
    61.       .border({ width: 1 })
    62.   }
    63. }
    
    64. @Component
    65. struct ReusableChildB {
    66.   aboutToAppear() {
    67.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildB aboutToAppear');
    68.   }
    
    69.   aboutToReuse() {
    70.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildB aboutToReuse');
    71.   }
    
    72.   build() {
    73.     Text('ReusableChildB')
    74.       .border({ width: 1 })
    75.   }
    76. }
    
    【正例】
    
    组件结构存在差异，通过reuseId进行区分。
    
    77. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    78. const TAG = '[Sample_ReusableComponent]';
    79. const DOMAIN = 0xF811;
    80. const BUNDLE = 'ReusableComponent_';
    
    81. @Entry
    82. @Component
    83. struct Index {
    84.   @State showBranchA: boolean = true;
    85.   @State showBranchB: boolean = false;
    
    86.   build() {
    87.     Column({ space: 5 }) {
    88.       Button('show/hide branch A')
    89.         .onClick(() => {
    90.           this.showBranchA = !this.showBranchA;
    91.         })
    92.       if (this.showBranchA) {
    93.         ReusableComponent({ flag: true })
    94.           .reuseId('ReuseA') // 通过reuseId区分不同结构的复用组件
    95.       }
    96.       Button('show/hide branch B')
    97.         .onClick(() => {
    98.           this.showBranchB = !this.showBranchB;
    99.         })
    100.       if (this.showBranchB) {
    101.         ReusableComponent({ flag: false })
    102.           .reuseId('ReuseB') // 通过reuseId区分不同结构的复用组件
    103.       }
    104.     }
    105.   }
    106. }
    
    107. @Reusable
    108. @Component
    109. struct ReusableComponent {
    110.   @Require @Prop flag: boolean = true;
    
    111.   aboutToAppear() {
    112.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableComponent aboutToAppear');
    113.   }
    
    114.   aboutToReuse(params: ESObject) {
    115.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableComponent aboutToReuse');
    116.     this.flag = params.flag;
    117.   }
    
    118.   build() {
    119.     Column({ space: 5 }) {
    120.       Text('ReusableComponent')
    121.       if (this.flag) {
    122.         ReusableChildA()
    123.       } else {
    124.         ReusableChildB()
    125.       }
    126.     }.border({ width: 1 })
    127.   }
    128. }
    
    129. @Component
    130. struct ReusableChildA {
    131.   aboutToAppear() {
    132.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildA aboutToAppear');
    133.   }
    
    134.   aboutToReuse() {
    135.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildA aboutToReuse');
    136.   }
    
    137.   build() {
    138.     Text('ReusableChildA')
    139.       .border({ width: 1 })
    140.   }
    141. }
    
    142. @Component
    143. struct ReusableChildB {
    144.   aboutToAppear() {
    145.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildB aboutToAppear');
    146.   }
    
    147.   aboutToReuse() {
    148.     hilog.info(DOMAIN, TAG, BUNDLE + 'ReusableChildB aboutToReuse');
    149.   }
    
    150.   build() {
    151.     Text('ReusableChildB')
    152.       .border({ width: 1 })
    153.   }
    154. }
    
- ComponentContent不支持传入@Reusable装饰器装饰的自定义组件。
    

1. import { ComponentContent } from "@kit.ArkUI";

2. @Builder
3. function buildCreativeLoadingDialog(closedClick: () => void) {
4.   Crash()
5. }

6. // 如果注释掉就可以正常弹出弹窗，如果加上@Reusable就直接crash。
7. @Reusable
8. @Component
9. export struct Crash {
10.   build() {
11.     Column() {
12.       Text("Crash")
13.         .fontSize(12)
14.         .lineHeight(18)
15.         .fontColor(Color.Blue)
16.         .margin({
17.           left: 6
18.         })
19.     }.width('100%')
20.     .height('100%')
21.     .justifyContent(FlexAlign.Center)
22.   }
23. }

24. @Entry
25. @Component
26. struct Index {
27.   @State message: string = 'Hello World';
28.   private uiContext = this.getUIContext();

29.   build() {
30.     RelativeContainer() {
31.       Text(this.message)
32.         .id('Index')
33.         .fontSize(50)
34.         .fontWeight(FontWeight.Bold)
35.         .alignRules({
36.           center: { anchor: '__container__', align: VerticalAlign.Center },
37.           middle: { anchor: '__container__', align: HorizontalAlign.Center }
38.         })
39.         .onClick(() => {
40.           // ComponentContent底层是BuilderNode，BuilderNode不支持传入@Reusable注解的自定义组件。
41.           let contentNode = new ComponentContent(this.uiContext, wrapBuilder(buildCreativeLoadingDialog), () => {
42.           });
43.           this.uiContext.getPromptAction().openCustomDialog(contentNode);
44.         })
45.     }
46.     .height('100%')
47.     .width('100%')
48.   }
49. }

- @Reusable装饰器不建议嵌套使用，会增加内存，降低复用效率，加大维护难度。嵌套使用会导致额外缓存池的生成，各缓存池拥有相同树状结构，复用效率低下。此外，嵌套使用会使生命周期管理复杂，资源和变量共享困难。

## 使用场景

### 动态布局更新

重复创建与移除视图可能引起频繁的布局计算，从而影响帧率。采用组件复用可以避免不必要的视图创建与布局计算，提升性能。

以下示例中，将Child自定义组件标记为复用组件，通过Button点击更新Child，触发复用。

1. // xxx.ets
2. export class Message {
3.   value: string | undefined;

4.   constructor(value: string) {
5.     this.value = value;
6.   }
7. }

8. @Entry
9. @Component
10. struct Index {
11.   @State switch: boolean = true;

12.   build() {
13.     Column() {
14.       Button('Hello')
15.         .fontSize(30)
16.         .fontWeight(FontWeight.Bold)
17.         .onClick(() => {
18.           this.switch = !this.switch;
19.         })
20.       if (this.switch) {
21.         // 如果只有一个复用的组件，可以不用设置reuseId。
22.         Child({ message: new Message('Child') })
23.           .reuseId('Child')
24.       }
25.     }
26.     .height("100%")
27.     .width('100%')
28.   }
29. }

30. @Reusable
31. @Component
32. struct Child {
33.   @State message: Message = new Message('AboutToReuse');

34.   aboutToReuse(params: Record<string, ESObject>) {
35.     this.message = params.message as Message;
36.   }

37.   build() {
38.     Column() {
39.       Text(this.message.value)
40.         .fontSize(30)
41.     }
42.     .borderWidth(1)
43.     .height(100)
44.   }
45. }

### 列表滚动配合LazyForEach使用

- 当应用展示大量数据的列表并进行滚动操作时，频繁创建和销毁列表项视图可能导致卡顿和性能问题。使用列表组件的组件复用机制可以重用已创建的列表项视图，提高滚动流畅度。
    
- 以下示例代码将CardView自定义组件标记为复用组件，List上下滑动，触发CardView复用。
    

1. class MyDataSource implements IDataSource {
2.   private dataArray: string[] = [];
3.   private listener: DataChangeListener | undefined;

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.   }

13.   public reloadListener(): void {
14.     this.listener?.onDataReloaded();
15.   }

16.   public registerDataChangeListener(listener: DataChangeListener): void {
17.     this.listener = listener;
18.   }

19.   public unregisterDataChangeListener(listener: DataChangeListener): void {
20.     this.listener = undefined;
21.   }
22. }

23. @Entry
24. @Component
25. struct ReuseDemo {
26.   private data: MyDataSource = new MyDataSource();

27.   aboutToAppear() {
28.     for (let i = 1; i < 1000; i++) {
29.       this.data.pushData(i + "");
30.     }
31.   }

32.   // ...
33.   build() {
34.     Column() {
35.       List() {
36.         LazyForEach(this.data, (item: string) => {
37.           ListItem() {
38.             CardView({ item: item })
39.           }
40.         }, (item: string) => item)
41.       }
42.     }
43.   }
44. }

45. // 复用组件
46. @Reusable
47. @Component
48. export struct CardView {
49.   // 被@State修饰的变量item才能更新，未被@State修饰的变量不会更新。
50.   @State item: string = '';

51.   aboutToReuse(params: Record<string, Object>): void {
52.     this.item = params.item as string;
53.   }

54.   build() {
55.     Column() {
56.       Text(this.item)
57.         .fontSize(30)
58.     }
59.     .borderWidth(1)
60.     .height(100)
61.   }
62. }

### 列表滚动-if使用场景

以下示例代码将OneMoment自定义组件标记为复用组件。当List上下滑动时，会触发OneMoment的复用。设置reuseId可为复用组件分配复用组，相同reuseId的组件将在同一复用组中复用。单个复用组件无需设置reuseId。使用reuseId标识复用组件，可避免重复执行if语句的删除和重新创建逻辑，提高复用效率和性能。

1. @Entry
2. @Component
3. struct Index {
4.   private dataSource = new MyDataSource<FriendMoment>();

5.   aboutToAppear(): void {
6.     for (let i = 0; i < 20; i++) {
7.       let title = i + 1 + "test_if";
8.       this.dataSource.pushData(new FriendMoment(i.toString(), title, 'app.media.app_icon'));
9.     }

10.     for (let i = 0; i < 50; i++) {
11.       let title = i + 1 + "test_if";
12.       this.dataSource.pushData(new FriendMoment(i.toString(), title, ''));
13.     }
14.   }

15.   build() {
16.     Column() {
17.       // TopBar()
18.       List({ space: 3 }) {
19.         LazyForEach(this.dataSource, (moment: FriendMoment) => {
20.           ListItem() {
21.             // 使用reuseId进行组件复用的控制。
22.             OneMoment({ moment: moment })
23.               .reuseId((moment.image !== '') ? 'withImage' : 'noImage')
24.           }
25.         }, (moment: FriendMoment) => moment.id)
26.       }
27.       .cachedCount(0)
28.     }
29.   }
30. }

31. class FriendMoment {
32.   id: string = '';
33.   text: string = '';
34.   title: string = '';
35.   image: string = '';
36.   answers: Array<ResourceStr> = [];

37.   constructor(id: string, title: string, image: string) {
38.     this.text = id;
39.     this.title = title;
40.     this.image = image;
41.   }
42. }

43. @Reusable
44. @Component
45. export struct OneMoment {
46.   @Prop moment: FriendMoment;

47.   // 复用id相同的组件才能触发复用。
48.   aboutToReuse(params: ESObject): void {
49.     console.log("=====aboutToReuse====OneMoment==复用了==" + this.moment.text);
50.   }

51.   build() {
52.     Column() {
53.       Text(this.moment.text)
54.       // if分支判断。
55.       if (this.moment.image !== '') {
56.         Flex({ wrap: FlexWrap.Wrap }) {
57.           Image($r(this.moment.image)).height(50).width(50)
58.           Image($r(this.moment.image)).height(50).width(50)
59.           Image($r(this.moment.image)).height(50).width(50)
60.           Image($r(this.moment.image)).height(50).width(50)
61.         }
62.       }
63.     }
64.   }
65. }

66. class BasicDataSource<T> implements IDataSource {
67.   private listeners: DataChangeListener[] = [];
68.   private originDataArray: T[] = [];

69.   public totalCount(): number {
70.     return 0;
71.   }

72.   public getData(index: number): T {
73.     return this.originDataArray[index];
74.   }

75.   registerDataChangeListener(listener: DataChangeListener): void {
76.     if (this.listeners.indexOf(listener) < 0) {
77.       this.listeners.push(listener);
78.     }
79.   }

80.   unregisterDataChangeListener(listener: DataChangeListener): void {
81.     const pos = this.listeners.indexOf(listener);
82.     if (pos >= 0) {
83.       this.listeners.splice(pos, 1);
84.     }
85.   }

86.   notifyDataAdd(index: number): void {
87.     this.listeners.forEach(listener => {
88.       listener.onDataAdd(index);
89.     });
90.   }
91. }

92. export class MyDataSource<T> extends BasicDataSource<T> {
93.   private dataArray: T[] = [];

94.   public totalCount(): number {
95.     return this.dataArray.length;
96.   }

97.   public getData(index: number): T {
98.     return this.dataArray[index];
99.   }

100.   public pushData(data: T): void {
101.     this.dataArray.push(data);
102.     this.notifyDataAdd(this.dataArray.length - 1);
103.   }
104. }

### 列表滚动-Foreach使用场景

使用Foreach创建可复用的自定义组件，由于Foreach渲染控制语法的全展开属性，导致复用组件无法复用。示例中点击update，数据刷新成功，但滑动列表时，ListItemView无法复用。点击clear，再次点击update，ListItemView复用成功，因为一帧内重复创建多个已被销毁的自定义组件。

1. // xxx.ets
2. class MyDataSource implements IDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.   }

13.   public registerDataChangeListener(listener: DataChangeListener): void {
14.   }

15.   public unregisterDataChangeListener(listener: DataChangeListener): void {
16.   }
17. }

18. @Entry
19. @Component
20. struct Index {
21.   private data: MyDataSource = new MyDataSource();
22.   private data02: MyDataSource = new MyDataSource();
23.   @State isShow: boolean = true;
24.   @State dataSource: ListItemObject[] = [];

25.   aboutToAppear() {
26.     for (let i = 0; i < 100; i++) {
27.       this.data.pushData(i.toString());
28.     }

29.     for (let i = 30; i < 80; i++) {
30.       this.data02.pushData(i.toString());
31.     }
32.   }

33.   build() {
34.     Column() {
35.       Row() {
36.         Button('clear').onClick(() => {
37.           for (let i = 1; i < 50; i++) {
38.             this.dataSource.pop();
39.           }
40.         }).height(40)

41.         Button('update').onClick(() => {
42.           for (let i = 1; i < 50; i++) {
43.             let obj = new ListItemObject();
44.             obj.id = i;
45.             obj.uuid = Math.random().toString();
46.             obj.isExpand = false;
47.             this.dataSource.push(obj);
48.           }
49.         }).height(40)
50.       }

51.       List({ space: 10 }) {
52.         ForEach(this.dataSource, (item: ListItemObject) => {
53.           ListItem() {
54.             ListItemView({
55.               obj: item
56.             })
57.           }
58.         }, (item: ListItemObject) => {
59.           return item.uuid.toString();
60.         })

61.       }.cachedCount(0)
62.       .width('100%')
63.       .height('100%')
64.     }
65.   }
66. }

67. @Reusable
68. @Component
69. struct ListItemView {
70.   @ObjectLink obj: ListItemObject;
71.   @State item: string = '';

72.   aboutToAppear(): void {
73.     // 点击 update，首次进入，上下滑动，由于Foreach折叠展开属性，无法复用。
74.     console.log("=====aboutToAppear=====ListItemView==创建了==" + this.item);
75.   }

76.   aboutToReuse(params: ESObject) {
77.     this.item = params.item;
78.     // 点击clear，再次update，复用成功。
79.     // 符合一帧内重复创建多个已被销毁的自定义组件。
80.     console.log("=====aboutToReuse====ListItemView==复用了==" + this.item);
81.   }

82.   build() {
83.     Column({ space: 10 }) {
84.       Text(`${this.obj.id}.标题`)
85.         .fontSize(16)
86.         .fontColor('#000000')
87.         .padding({
88.           top: 20,
89.           bottom: 20,
90.         })

91.       if (this.obj.isExpand) {
92.         Text('')
93.           .fontSize(14)
94.           .fontColor('#999999')
95.       }
96.     }
97.     .width('100%')
98.     .borderRadius(10)
99.     .backgroundColor(Color.White)
100.     .padding(15)
101.     .onClick(() => {
102.       this.obj.isExpand = !this.obj.isExpand;
103.     })
104.   }
105. }

106. @Observed
107. class ListItemObject {
108.   uuid: string = "";
109.   id: number = 0;
110.   isExpand: boolean = false;
111. }

### Grid使用场景

示例中使用@Reusable装饰器修饰GridItem中的自定义组件ReusableChildComponent，即表示其具备组件复用的能力。

使用aboutToReuse可以在 Grid 滑动时，从复用缓存中加入到组件树之前触发，从而更新组件状态变量，展示正确内容。

需要注意的是无需在aboutToReuse中对[@Link](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-link)、[@StorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage#storagelink)、[@ObjectLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-observed-and-objectlink)、[@Consume](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume)等自动更新值的状态变量进行更新，可能触发不必要的组件刷新。

1. // MyDataSource类实现IDataSource接口。
2. class MyDataSource implements IDataSource {
3.   private dataArray: number[] = [];

4.   public pushData(data: number): void {
5.     this.dataArray.push(data);
6.   }

7.   // 数据源的数据总量。
8.   public totalCount(): number {
9.     return this.dataArray.length;
10.   }

11.   // 返回指定索引位置的数据。
12.   public getData(index: number): number {
13.     return this.dataArray[index];
14.   }

15.   registerDataChangeListener(listener: DataChangeListener): void {
16.   }

17.   unregisterDataChangeListener(listener: DataChangeListener): void {
18.   }
19. }

20. @Entry
21. @Component
22. struct MyComponent {
23.   // 数据源。
24.   private data: MyDataSource = new MyDataSource();

25.   aboutToAppear() {
26.     for (let i = 1; i < 1000; i++) {
27.       this.data.pushData(i);
28.     }
29.   }

30.   build() {
31.     Column({ space: 5 }) {
32.       Grid() {
33.         LazyForEach(this.data, (item: number) => {
34.           GridItem() {
35.             // 使用可复用自定义组件。
36.             ReusableChildComponent({ item: item })
37.           }
38.         }, (item: string) => item)
39.       }
40.       .cachedCount(2) // 设置GridItem的缓存数量。
41.       .columnsTemplate('1fr 1fr 1fr')
42.       .columnsGap(10)
43.       .rowsGap(10)
44.       .margin(10)
45.       .height(500)
46.       .backgroundColor(0xFAEEE0)
47.     }
48.   }
49. }

50. @Reusable
51. @Component
52. struct ReusableChildComponent {
53.   @State item: number = 0;

54.   // aboutToReuse从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容。
55.   // aboutToReuse参数类型已不支持any，这里使用Record指定明确的数据类型。Record用于构造一个对象类型，其属性键为Keys，属性值为Type。
56.   aboutToReuse(params: Record<string, number>) {
57.     this.item = params.item;
58.   }

59.   build() {
60.     Column() {
61.       // 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错。
62.       Image($r('app.media.app_icon'))
63.         .objectFit(ImageFit.Fill)
64.         .layoutWeight(1)
65.       Text(`图片${this.item}`)
66.         .fontSize(16)
67.         .textAlign(TextAlign.Center)
68.     }
69.     .width('100%')
70.     .height(120)
71.     .backgroundColor(0xF9CF93)
72.   }
73. }

### WaterFlow使用场景

- 在WaterFlow滑动场景中，FlowItem及其子组件频繁创建和销毁。可以将FlowItem中的组件封装成自定义组件，并使用@Reusable装饰器修饰，实现组件复用。

1. class WaterFlowDataSource implements IDataSource {
2.   private dataArray: number[] = [];
3.   private listeners: DataChangeListener[] = [];

4.   constructor() {
5.     for (let i = 0; i <= 60; i++) {
6.       this.dataArray.push(i);
7.     }
8.   }

9.   // 获取索引对应的数据。
10.   public getData(index: number): number {
11.     return this.dataArray[index];
12.   }

13.   // 通知控制器增加数据。
14.   notifyDataAdd(index: number): void {
15.     this.listeners.forEach(listener => {
16.       listener.onDataAdd(index);
17.     });
18.   }

19.   // 获取数据总数。
20.   public totalCount(): number {
21.     return this.dataArray.length;
22.   }

23.   // 注册改变数据的控制器。
24.   registerDataChangeListener(listener: DataChangeListener): void {
25.     if (this.listeners.indexOf(listener) < 0) {
26.       this.listeners.push(listener);
27.     }
28.   }

29.   // 注销改变数据的控制器。
30.   unregisterDataChangeListener(listener: DataChangeListener): void {
31.     const pos = this.listeners.indexOf(listener);
32.     if (pos >= 0) {
33.       this.listeners.splice(pos, 1);
34.     }
35.   }

36.   // 在数据尾部增加一个元素。
37.   public addLastItem(): void {
38.     this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length);
39.     this.notifyDataAdd(this.dataArray.length - 1);
40.   }
41. }

42. @Reusable
43. @Component
44. struct ReusableFlowItem {
45.   @State item: number = 0;

46.   // 从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容。
47.   aboutToReuse(params: ESObject) {
48.     this.item = params.item;
49.     console.log("=====aboutToReuse====FlowItem==复用了==" + this.item);
50.   }

51.   aboutToRecycle(): void {
52.     console.log("=====aboutToRecycle====FlowItem==回收了==" + this.item);
53.   }

54.   build() {
55.     // 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错。
56.     Column() {
57.       Text("N" + this.item).fontSize(24).height('26').margin(10)
58.       Image($r('app.media.app_icon'))
59.         .objectFit(ImageFit.Cover)
60.         .width(50)
61.         .height(50)
62.     }
63.   }
64. }

65. @Entry
66. @Component
67. struct Index {
68.   @State minSize: number = 50;
69.   @State maxSize: number = 80;
70.   @State fontSize: number = 24;
71.   @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F];
72.   scroller: Scroller = new Scroller();
73.   dataSource: WaterFlowDataSource = new WaterFlowDataSource();
74.   private itemWidthArray: number[] = [];
75.   private itemHeightArray: number[] = [];

76.   // 计算flow item宽/高。
77.   getSize() {
78.     let ret = Math.floor(Math.random() * this.maxSize);
79.     return (ret > this.minSize ? ret : this.minSize);
80.   }

81.   // 保存flow item宽/高。
82.   getItemSizeArray() {
83.     for (let i = 0; i < 100; i++) {
84.       this.itemWidthArray.push(this.getSize());
85.       this.itemHeightArray.push(this.getSize());
86.     }
87.   }

88.   aboutToAppear() {
89.     this.getItemSizeArray();
90.   }

91.   build() {
92.     Stack({ alignContent: Alignment.TopStart }) {
93.       Column({ space: 2 }) {
94.         Button('back top')
95.           .height('5%')
96.           .onClick(() => {

97.             // 点击后回到顶部。
98.             this.scroller.scrollEdge(Edge.Top);
99.           })
100.         WaterFlow({ scroller: this.scroller }) {
101.           LazyForEach(this.dataSource, (item: number) => {
102.             FlowItem() {
103.               ReusableFlowItem({ item: item })
104.             }.onAppear(() => {
105.               if (item + 20 == this.dataSource.totalCount()) {
106.                 for (let i = 0; i < 50; i++) {
107.                   this.dataSource.addLastItem();
108.                 }
109.               }
110.             })

111.           })
112.         }
113.       }
114.     }
115.   }
116. }

### Swiper使用场景

- 在Swiper滑动场景中，条目中的子组件频繁创建和销毁。可以将这些子组件封装成自定义组件，并使用@Reusable装饰器修饰，以实现组件复用。

1. @Entry
2. @Component
3. struct Index {
4.   private dataSource = new MyDataSource<Question>();

5.   aboutToAppear(): void {
6.     for (let i = 0; i < 1000; i++) {
7.       let title = i + 1 + "test_swiper";
8.       let answers = ["test1", "test2", "test3",
9.         "test4"];
10.       // 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错。
11.       this.dataSource.pushData(new Question(i.toString(), title, $r('app.media.app_icon'), answers));
12.     }
13.   }

14.   build() {
15.     Column({ space: 5 }) {
16.       Swiper() {
17.         LazyForEach(this.dataSource, (item: Question) => {
18.           QuestionSwiperItem({ itemData: item })
19.         }, (item: Question) => item.id)
20.       }
21.     }
22.     .width('100%')
23.     .margin({ top: 5 })
24.   }
25. }

26. class Question {
27.   id: string = '';
28.   title: ResourceStr = '';
29.   image: ResourceStr = '';
30.   answers: Array<ResourceStr> = [];

31.   constructor(id: string, title: ResourceStr, image: ResourceStr, answers: Array<ResourceStr>) {
32.     this.id = id;
33.     this.title = title;
34.     this.image = image;
35.     this.answers = answers;
36.   }
37. }

38. @Reusable
39. @Component
40. struct QuestionSwiperItem {
41.   @State itemData: Question | null = null;

42.   aboutToReuse(params: Record<string, Object>): void {
43.     this.itemData = params.itemData as Question;
44.     console.info("===aboutToReuse====QuestionSwiperItem==");
45.   }

46.   build() {
47.     Column() {
48.       Text(this.itemData?.title)
49.         .fontSize(18)
50.         .fontColor($r('sys.color.ohos_id_color_primary'))
51.         .alignSelf(ItemAlign.Start)
52.         .margin({
53.           top: 10,
54.           bottom: 16
55.         })
56.       Image(this.itemData?.image)
57.         .width('100%')
58.         .borderRadius(12)
59.         .objectFit(ImageFit.Contain)
60.         .margin({
61.           bottom: 16
62.         })
63.         .height(80)
64.         .width(80)

65.       Column({ space: 16 }) {
66.         ForEach(this.itemData?.answers, (item: Resource) => {
67.           Text(item)
68.             .fontSize(16)
69.             .fontColor($r('sys.color.ohos_id_color_primary'))
70.         }, (item: ResourceStr) => JSON.stringify(item))
71.       }
72.       .width('100%')
73.       .alignItems(HorizontalAlign.Start)
74.     }
75.     .width('100%')
76.     .padding({
77.       left: 16,
78.       right: 16
79.     })
80.   }
81. }

82. class BasicDataSource<T> implements IDataSource {
83.   private listeners: DataChangeListener[] = [];
84.   private originDataArray: T[] = [];

85.   public totalCount(): number {
86.     return 0;
87.   }

88.   public getData(index: number): T {
89.     return this.originDataArray[index];
90.   }

91.   registerDataChangeListener(listener: DataChangeListener): void {
92.     if (this.listeners.indexOf(listener) < 0) {
93.       this.listeners.push(listener);
94.     }
95.   }

96.   unregisterDataChangeListener(listener: DataChangeListener): void {
97.     const pos = this.listeners.indexOf(listener);
98.     if (pos >= 0) {
99.       this.listeners.splice(pos, 1);
100.     }
101.   }

102.   notifyDataAdd(index: number): void {
103.     this.listeners.forEach(listener => {
104.       listener.onDataAdd(index);
105.     });
106.   }
107. }

108. export class MyDataSource<T> extends BasicDataSource<T> {
109.   private dataArray: T[] = [];

110.   public totalCount(): number {
111.     return this.dataArray.length;
112.   }

113.   public getData(index: number): T {
114.     return this.dataArray[index];
115.   }

116.   public pushData(data: T): void {
117.     this.dataArray.push(data);
118.     this.notifyDataAdd(this.dataArray.length - 1);
119.   }
120. }

### 列表滚动-ListItemGroup使用场景

- 可以视作特殊List滑动场景，将ListItem需要移除重建的子组件封装成自定义组件，并使用@Reusable装饰器修饰，使其具备组件复用能力。

1. @Entry
2. @Component
3. struct ListItemGroupAndReusable {
4.   data: DataSrc2 = new DataSrc2();

5.   @Builder
6.   itemHead(text: string) {
7.     Text(text)
8.       .fontSize(20)
9.       .backgroundColor(0xAABBCC)
10.       .width('100%')
11.       .padding(10)
12.   }

13.   aboutToAppear() {
14.     for (let i = 0; i < 10000; i++) {
15.       let data_1 = new DataSrc1();
16.       for (let j = 0; j < 12; j++) {
17.         data_1.Data.push(`测试条目数据: ${i} - ${j}`);
18.       }
19.       this.data.Data.push(data_1);
20.     }
21.   }

22.   build() {
23.     Stack() {
24.       List() {
25.         LazyForEach(this.data, (item: DataSrc1, index: number) => {
26.           ListItemGroup({ header: this.itemHead(index.toString()) }) {
27.             LazyForEach(item, (ii: string, index: number) => {
28.               ListItem() {
29.                 Inner({ str: ii })
30.               }
31.             })
32.           }
33.           .width('100%')
34.           .height('60vp')
35.         })
36.       }
37.     }
38.     .width('100%')
39.     .height('100%')
40.   }
41. }

42. @Reusable
43. @Component
44. struct Inner {
45.   @State str: string = '';

46.   aboutToReuse(param: ESObject) {
47.     this.str = param.str;
48.   }

49.   build() {
50.     Text(this.str)
51.   }
52. }

53. class DataSrc1 implements IDataSource {
54.   listeners: DataChangeListener[] = [];
55.   Data: string[] = [];

56.   public totalCount(): number {
57.     return this.Data.length;
58.   }

59.   public getData(index: number): string {
60.     return this.Data[index];
61.   }

62.   // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听。
63.   registerDataChangeListener(listener: DataChangeListener): void {
64.     if (this.listeners.indexOf(listener) < 0) {
65.       this.listeners.push(listener);
66.     }
67.   }

68.   // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听。
69.   unregisterDataChangeListener(listener: DataChangeListener): void {
70.     const pos = this.listeners.indexOf(listener);
71.     if (pos >= 0) {
72.       this.listeners.splice(pos, 1);
73.     }
74.   }

75.   // 通知LazyForEach组件需要重载所有子组件。
76.   notifyDataReload(): void {
77.     this.listeners.forEach(listener => {
78.       listener.onDataReloaded();
79.     });
80.   }

81.   // 通知LazyForEach组件需要在index对应索引处添加子组件。
82.   notifyDataAdd(index: number): void {
83.     this.listeners.forEach(listener => {
84.       listener.onDataAdd(index);
85.     });
86.   }

87.   // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件。
88.   notifyDataChange(index: number): void {
89.     this.listeners.forEach(listener => {
90.       listener.onDataChange(index);
91.     });
92.   }

93.   // 通知LazyForEach组件需要在index对应索引处删除该子组件。
94.   notifyDataDelete(index: number): void {
95.     this.listeners.forEach(listener => {
96.       listener.onDataDelete(index);
97.     });
98.   }

99.   // 通知LazyForEach组件将from索引和to索引处的子组件进行交换。
100.   notifyDataMove(from: number, to: number): void {
101.     this.listeners.forEach(listener => {
102.       listener.onDataMove(from, to);
103.     });
104.   }
105. }

106. class DataSrc2 implements IDataSource {
107.   listeners: DataChangeListener[] = [];
108.   Data: DataSrc1[] = [];

109.   public totalCount(): number {
110.     return this.Data.length;
111.   }

112.   public getData(index: number): DataSrc1 {
113.     return this.Data[index];
114.   }

115.   // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听。
116.   registerDataChangeListener(listener: DataChangeListener): void {
117.     if (this.listeners.indexOf(listener) < 0) {
118.       this.listeners.push(listener);
119.     }
120.   }

121.   // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听。
122.   unregisterDataChangeListener(listener: DataChangeListener): void {
123.     const pos = this.listeners.indexOf(listener);
124.     if (pos >= 0) {
125.       this.listeners.splice(pos, 1);
126.     }
127.   }

128.   // 通知LazyForEach组件需要重载所有子组件。
129.   notifyDataReload(): void {
130.     this.listeners.forEach(listener => {
131.       listener.onDataReloaded();
132.     });
133.   }

134.   // 通知LazyForEach组件需要在index对应索引处添加子组件。
135.   notifyDataAdd(index: number): void {
136.     this.listeners.forEach(listener => {
137.       listener.onDataAdd(index);
138.     });
139.   }

140.   // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件。
141.   notifyDataChange(index: number): void {
142.     this.listeners.forEach(listener => {
143.       listener.onDataChange(index);
144.     });
145.   }

146.   // 通知LazyForEach组件需要在index对应索引处删除该子组件。
147.   notifyDataDelete(index: number): void {
148.     this.listeners.forEach(listener => {
149.       listener.onDataDelete(index);
150.     });
151.   }

152.   // 通知LazyForEach组件将from索引和to索引处的子组件进行交换。
153.   notifyDataMove(from: number, to: number): void {
154.     this.listeners.forEach(listener => {
155.       listener.onDataMove(from, to);
156.     });
157.   }
158. }

### 多种条目类型使用场景

**标准型**

复用组件的布局相同，示例参见本文列表滚动部分的描述。

**有限变化型**

复用组件间存在差异，但类型有限。例如，可以通过显式设置两个reuseId或使用两个自定义组件来实现复用。

1. class MyDataSource implements IDataSource {
2.   private dataArray: string[] = [];
3.   private listener: DataChangeListener | undefined;

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.   }

13.   public reloadListener(): void {
14.     this.listener?.onDataReloaded();
15.   }

16.   public registerDataChangeListener(listener: DataChangeListener): void {
17.     this.listener = listener;
18.   }

19.   public unregisterDataChangeListener(listener: DataChangeListener): void {
20.     this.listener = undefined;
21.   }
22. }

23. @Entry
24. @Component
25. struct Index {
26.   private data: MyDataSource = new MyDataSource();

27.   aboutToAppear() {
28.     for (let i = 0; i < 1000; i++) {
29.       this.data.pushData(i + "");
30.     }
31.   }

32.   build() {
33.     Column() {
34.       List({ space: 10 }) {
35.         LazyForEach(this.data, (item: number) => {
36.           ListItem() {
37.             ReusableComponent({ item: item })
38.               // 设置两种有限变化的reuseId
39.               .reuseId(item % 2 === 0 ? 'ReusableComponentOne' : 'ReusableComponentTwo')
40.           }
41.           .backgroundColor(Color.Orange)
42.           .width('100%')
43.         }, (item: number) => item.toString())
44.       }
45.       .cachedCount(2)
46.     }
47.   }
48. }

49. @Reusable
50. @Component
51. struct ReusableComponent {
52.   @State item: number = 0;

53.   aboutToReuse(params: ESObject) {
54.     this.item = params.item;
55.   }

56.   build() {
57.     Column() {
58.       // 组件内部根据类型差异渲染
59.       if (this.item % 2 === 0) {
60.         Text(`Item ${this.item} ReusableComponentOne`)
61.           .fontSize(20)
62.           .margin({ left: 10 })
63.       } else {
64.         Text(`Item ${this.item} ReusableComponentTwo`)
65.           .fontSize(20)
66.           .margin({ left: 10 })
67.       }
68.     }.margin({ left: 10, right: 10 })
69.   }
70. }

**组合型**

复用组件间存在多种差异，但通常具备共同的子组件。将三种复用组件以组合型方式转换为Builder函数后，内部的共享子组件将统一置于父组件MyComponent之下。复用这些子组件时，缓存池在父组件层面实现共享，减少组件创建过程中的资源消耗。

1. class MyDataSource implements IDataSource {
2.   private dataArray: string[] = [];
3.   private listener: DataChangeListener | undefined;

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.   }

13.   public reloadListener(): void {
14.     this.listener?.onDataReloaded();
15.   }

16.   public registerDataChangeListener(listener: DataChangeListener): void {
17.     this.listener = listener;
18.   }

19.   public unregisterDataChangeListener(listener: DataChangeListener): void {
20.     this.listener = undefined;
21.   }
22. }

23. @Entry
24. @Component
25. struct MyComponent {
26.   private data: MyDataSource = new MyDataSource();

27.   aboutToAppear() {
28.     for (let i = 0; i < 1000; i++) {
29.       this.data.pushData(i.toString());
30.     }
31.   }

32.   // itemBuilderOne作为复用组件的写法未展示，以下为转为Builder之后的写法。
33.   @Builder
34.   itemBuilderOne(item: string) {
35.     Column() {
36.       ChildComponentA({ item: item })
37.       ChildComponentB({ item: item })
38.       ChildComponentC({ item: item })
39.     }
40.   }

41.   // itemBuilderTwo转为Builder之后的写法。
42.   @Builder
43.   itemBuilderTwo(item: string) {
44.     Column() {
45.       ChildComponentA({ item: item })
46.       ChildComponentC({ item: item })
47.       ChildComponentD({ item: item })
48.     }
49.   }

50.   // itemBuilderThree转为Builder之后的写法。
51.   @Builder
52.   itemBuilderThree(item: string) {
53.     Column() {
54.       ChildComponentA({ item: item })
55.       ChildComponentB({ item: item })
56.       ChildComponentD({ item: item })
57.     }
58.   }

59.   build() {
60.     List({ space: 40 }) {
61.       LazyForEach(this.data, (item: string, index: number) => {
62.         ListItem() {
63.           if (index % 3 === 0) {
64.             this.itemBuilderOne(item)
65.           } else if (index % 5 === 0) {
66.             this.itemBuilderTwo(item)
67.           } else {
68.             this.itemBuilderThree(item)
69.           }
70.         }
71.         .backgroundColor('#cccccc')
72.         .width('100%')
73.         .onAppear(() => {
74.           console.log(`ListItem ${index} onAppear`);
75.         })
76.       }, (item: number) => item.toString())
77.     }
78.     .width('100%')
79.     .height('100%')
80.     .cachedCount(0)
81.   }
82. }

83. @Reusable
84. @Component
85. struct ChildComponentA {
86.   @State item: string = '';

87.   aboutToReuse(params: ESObject) {
88.     console.log(`ChildComponentA ${params.item} Reuse ${this.item}`);
89.     this.item = params.item;
90.   }

91.   aboutToRecycle(): void {
92.     console.log(`ChildComponentA ${this.item} Recycle`);
93.   }

94.   build() {
95.     Column() {
96.       Text(`Item ${this.item} Child Component A`)
97.         .fontSize(20)
98.         .margin({ left: 10 })
99.         .fontColor(Color.Blue)
100.       Grid() {
101.         ForEach((new Array(20)).fill(''), (item: string, index: number) => {
102.           GridItem() {
103.             // 请开发者自行在src/main/resources/base/media路径下添加app.media.startIcon图片，否则运行时会因资源缺失而报错。
104.             Image($r('app.media.startIcon'))
105.               .height(20)
106.           }
107.         })
108.       }
109.       .columnsTemplate('1fr 1fr 1fr 1fr 1fr')
110.       .rowsTemplate('1fr 1fr 1fr 1fr')
111.       .columnsGap(10)
112.       .width('90%')
113.       .height(160)
114.     }
115.     .margin({ left: 10, right: 10 })
116.     .backgroundColor(0xFAEEE0)
117.   }
118. }

119. @Reusable
120. @Component
121. struct ChildComponentB {
122.   @State item: string = '';

123.   aboutToReuse(params: ESObject) {
124.     this.item = params.item;
125.   }

126.   build() {
127.     Row() {
128.       Text(`Item ${this.item} Child Component B`)
129.         .fontSize(20)
130.         .margin({ left: 10 })
131.         .fontColor(Color.Red)
132.     }.margin({ left: 10, right: 10 })
133.   }
134. }

135. @Reusable
136. @Component
137. struct ChildComponentC {
138.   @State item: string = '';

139.   aboutToReuse(params: ESObject) {
140.     this.item = params.item;
141.   }

142.   build() {
143.     Row() {
144.       Text(`Item ${this.item} Child Component C`)
145.         .fontSize(20)
146.         .margin({ left: 10 })
147.         .fontColor(Color.Green)
148.     }.margin({ left: 10, right: 10 })
149.   }
150. }

151. @Reusable
152. @Component
153. struct ChildComponentD {
154.   @State item: string = '';

155.   aboutToReuse(params: ESObject) {
156.     this.item = params.item;
157.   }

158.   build() {
159.     Row() {
160.       Text(`Item ${this.item} Child Component D`)
161.         .fontSize(20)
162.         .margin({ left: 10 })
163.         .fontColor(Color.Orange)
164.     }.margin({ left: 10, right: 10 })
165.   }
166. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-require "@Require装饰器：校验构造传参")
# if/else：条件渲染

更新时间: 2025-12-16 16:39

ArkTS提供了渲染控制能力。条件渲染可根据应用状态，使用if、else和else if渲染相应的UI内容。

说明

从API version 9开始，该接口支持在ArkTS卡片中使用。

## 使用规则

- 支持if、else和else if语句。
    
- if和else if后的条件语句可以使用状态变量或常规变量（状态变量的值改变时会实时渲染UI，而常规变量的值改变则不会）。
    
- 允许在容器组件内使用，通过条件渲染语句构建不同的子组件。
    
- 条件渲染语句在涉及到组件的父子关系时是“透明”的，父组件和子组件之间的条件渲染语句不影响父组件关于子组件使用的限制。例如，某些容器组件限制子组件的类型或数量。将条件渲染语句用于这些组件内时，这些限制同样适用于条件渲染语句内创建的组件。具体而言，[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)容器组件的子组件仅支持[GridItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-griditem)组件。在Grid内使用条件渲染语句时，条件渲染语句内仅允许使用GridItem组件。
    
- 每个分支内部的构建函数必须遵循构建函数的规则，并创建一个或多个组件。无法创建组件的空构建函数会产生语法错误。关于构建函数的规则，请参考：[基本语法概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-basic-syntax-overview)、[声明式UI描述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-declarative-ui-description)。
    

## 更新机制

当if、else if后跟随的状态判断中使用的状态变量值变化时，条件渲染语句会进行更新，更新步骤如下：

1. 评估if和else if的状态判断条件，如果分支没有变化，无需执行以下步骤。如果分支有变化，则执行2、3步骤。
    
2. 移除此前构建的所有子组件。
    
3. 执行新分支的构造函数，将生成的子组件添加到if父容器中。如果缺少适用的else分支，则不创建任何内容。
    

条件可以包含Typescript表达式。构造函数中的表达式不得更改应用程序状态。

## 使用场景

### 使用if进行条件渲染

1. @Entry
2. @Component
3. struct MyComponent {
4.   @State count: number = 0;

5.   build() {
6.     Column() {
7.       Text(`count=${this.count}`)

8.       if (this.count > 0) {
9.         Text(`count is positive`)
10.           .fontColor(Color.Green)
11.       }

12.       Button('increase count')
13.         .onClick(() => {
14.           this.count++;
15.         })

16.       Button('decrease count')
17.         .onClick(() => {
18.           this.count--;
19.         })
20.     }
21.   }
22. }

if语句的每个分支都包含一个构建函数。此类构建函数必须创建一个或多个子组件。在初始渲染时，if语句会执行构建函数，并将生成的子组件添加到其父组件中。

每当if或else if条件语句中使用的状态变量发生变化时，条件语句都会更新并重新评估新的条件值。如果条件值评估发生了变化，这意味着需要构建另一个条件分支。此时ArkUI框架将：

1. 移除所有以前渲染的（早期分支的）组件。
    
2. 执行新分支的构造函数，将生成的子组件添加到其父组件中。
    

在以上示例中，当count从0增至1时，if (this.count > 0)更新为true，执行该分支的构造函数，创建一个Text组件并添加到父组件Column中。如果后续count更改为0，则Text组件将从Column组件中删除。由于没有else分支，因此不会执行新的构造函数。

### if ... else ...语句和子组件状态

以下示例包含if ... else ...语句与拥有[@State](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state)装饰变量的子组件。

1. @Component
2. struct CounterView {
3.   @State counter: number = 0;
4.   label: string = 'unknown';

5.   build() {
6.     Column({ space: 20 }) {
7.       Text(`${this.label}`)
8.       Button(`counter ${this.counter} +1`)
9.         .onClick(() => {
10.           this.counter += 1;
11.         })
12.     }
13.     .margin(10)
14.     .padding(10)
15.     .border({ width: 1 })
16.   }
17. }

18. @Entry
19. @Component
20. struct MainView {
21.   @State toggle: boolean = true;

22.   build() {
23.     Column() {
24.       if (this.toggle) {
25.         CounterView({ label: 'CounterView #positive' })
26.       } else {
27.         CounterView({ label: 'CounterView #negative' })
28.       }
29.       Button(`toggle ${this.toggle}`)
30.         .onClick(() => {
31.           this.toggle = !this.toggle;
32.         })
33.     }
34.     .width('100%')
35.     .justifyContent(FlexAlign.Center)
36.   }
37. }

**初次渲染**：创建CounterView子组件（label为 'CounterView #positive'），其状态变量counter初始值为0。

**修改CounterView的counter状态变量**：CounterView子组件（label为 'CounterView #positive'）重新渲染并保留状态变量值。

**修改MainView.toggle状态变量为false**：MainView父组件内的if语句将更新，并进行以下处理：

1. 删除旧的CounterView子组件（label为 'CounterView #positive'）。
2. 创建新的CounterView子组件（label为 'CounterView #negative'），其状态变量counter初始值为0。

说明

CounterView（label为 'CounterView #positive'）和CounterView（label为 'CounterView #negative'）是同一自定义组件的两个不同实例。if分支的更改，不会更新现有子组件，也不会保留状态。

以下示例展示了条件更改时，若需要保留counter值所做的修改。

1. @Component
2. struct CounterView {
3.   @Link counter: number;
4.   label: string = 'unknown';

5.   build() {
6.     Column({ space: 20 }) {
7.       Text(`${this.label}`)
8.         .fontSize(20)
9.       Button(`counter ${this.counter} +1`)
10.         .onClick(() => {
11.           this.counter += 1;
12.         })
13.     }
14.     .margin(10)
15.     .padding(10)
16.     .border({ width: 1 })
17.   }
18. }

19. @Entry
20. @Component
21. struct MainView {
22.   @State toggle: boolean = true;
23.   @State counter: number = 0;

24.   build() {
25.     Column() {
26.       if (this.toggle) {
27.         CounterView({ counter: $counter, label: 'CounterView #positive' })
28.       } else {
29.         CounterView({ counter: $counter, label: 'CounterView #negative' })
30.       }
31.       Button(`toggle ${this.toggle}`)
32.         .onClick(() => {
33.           this.toggle = !this.toggle;
34.         })
35.     }
36.     .width('100%')
37.     .justifyContent(FlexAlign.Center)
38.   }
39. }

此处，@State counter变量归父组件所有。因此，当CounterView组件实例被删除时，该变量不会被销毁。CounterView组件通过[@Link](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-link)装饰器引用状态。状态必须从子级移动到其父级（或父级的父级），以避免在条件内容或重复内容被销毁时丢失状态。

### 嵌套if语句

嵌套条件语句不会影响父组件的相关规则。

1. @Entry
2. @Component
3. struct MyComponent {
4.   @State toggle: boolean = false;
5.   @State toggleColor: boolean = false;

6.   build() {
7.     Column({ space: 20 }) {
8.       Text('Before')
9.         .fontSize(15)
10.       if (this.toggle) {
11.         Text('Top True, positive 1 top')
12.           .backgroundColor('#aaffaa').fontSize(20)
13.         // 内部if语句
14.         if (this.toggleColor) {
15.           Text('Top True, Nested True, positive COLOR  Nested ')
16.             .backgroundColor('#00aaaa').fontSize(15)
17.         } else {
18.           Text('Top True, Nested False, Negative COLOR  Nested ')
19.             .backgroundColor('#aaaaff').fontSize(15)
20.         }
21.       } else {
22.         Text('Top false, negative top level').fontSize(20)
23.           .backgroundColor('#ffaaaa')
24.         if (this.toggleColor) {
25.           Text('positive COLOR  Nested ')
26.             .backgroundColor('#00aaaa').fontSize(15)
27.         } else {
28.           Text('Negative COLOR  Nested ')
29.             .backgroundColor('#aaaaff').fontSize(15)
30.         }
31.       }
32.       Text('After')
33.         .fontSize(15)
34.       Button('Toggle Outer')
35.         .onClick(() => {
36.           this.toggle = !this.toggle;
37.         })
38.       Button('Toggle Inner')
39.         .onClick(() => {
40.           this.toggleColor = !this.toggleColor;
41.         })
42.     }
43.     .width('100%')
44.     .justifyContent(FlexAlign.Center)
45.   }
46. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-overview "渲染控制概述")
# LazyForEach：数据懒加载

更新时间: 2025-12-16 16:39

API参数说明见：[LazyForEach API参数说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach)。

## 概述

LazyForEach为开发者提供了基于数据源渲染出一系列子组件的能力。具体而言，LazyForEach从数据源中按需迭代数据，并在每次迭代时创建相应组件。当在滚动容器中使用了LazyForEach，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会销毁并回收组件以降低内存占用。

本文档依次介绍了LazyForEach的[基本用法](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95)、[高级用法](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95)和[常见问题](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)，开发者可以按需阅读。在[首次渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93)小节中，给出了简单的示例，可以帮助开发者快速上手LazyForEach的使用。

说明

在大量子组件的的场景下，LazyForEach与缓存列表项、动态预加载、组件复用等方法配合使用，可以进一步提升滑动帧率并降低应用内存占用。最佳实践请参考[长列表加载丢帧优化](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list)。

## 使用限制

- LazyForEach必须在容器组件内使用，仅有[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)、[ListItemGroup](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-listitemgroup)、[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid)、[Swiper](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper)以及[WaterFlow](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow)组件支持数据懒加载（可配置cachedCount属性，即只加载可视部分以及其前后少量数据用于缓冲），其他组件仍然是一次性加载所有的数据。支持数据懒加载的父组件根据自身及子组件的高度或宽度计算可视区域内需布局的子节点数量，高度或宽度的缺失会导致部分场景[懒加载失效](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A4%B1%E6%95%88)。
- LazyForEach依赖生成的键值判断是否刷新子组件，键值不变则不触发刷新。
- 容器组件内只能包含一个LazyForEach。以List为例，不建议同时包含ListItem、ForEach、LazyForEach，不建议同时包含多个LazyForEach。
- LazyForEach在每次迭代中，必须创建且只允许创建一个子组件；即LazyForEach的子组件生成函数有且只有一个根组件。
- 生成的子组件必须是允许包含在LazyForEach父容器组件中的子组件。
- 允许LazyForEach包含在if/else条件渲染语句中，也允许LazyForEach中出现if/else条件渲染语句。
- 键值生成器必须针对每个数据生成唯一的值，如果键值相同，将导致键值相同的UI组件渲染出现问题。
- LazyForEach必须使用一个数据变化监听器DataChangeListener对象进行更新（具体参数使用参考[LazyForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach)），重新赋值第一个参数dataSource会导致异常；dataSource使用状态变量时，状态变量改变不会触发LazyForEach的UI刷新。
- 为了高性能渲染，使用DataChangeListener对象的onDataChange方法更新UI时，需要生成不同于原来的键值来触发组件刷新。
- LazyForEach和[@Reusable装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable)一起使用能触发节点复用。使用方法：将@Reusable装饰在LazyForEach列表的组件上，见[列表滚动配合LazyForEach使用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable#%E5%88%97%E8%A1%A8%E6%BB%9A%E5%8A%A8%E9%85%8D%E5%90%88lazyforeach%E4%BD%BF%E7%94%A8)。
- LazyForEach和[@ReusableV2装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-reusablev2)一起使用能触发节点复用。详见@ReusableV2装饰器指南文档中的[在LazyForEach组件中使用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-reusablev2#%E5%9C%A8lazyforeach%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8)。
- LazyForEach的子节点在离开可视区域和预加载区域时，不会立即被析构或回收，LazyForEach会在空闲时析构或回收这些节点。

## 基本用法

### 设置数据源

为了管理[DataChangeListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#datachangelistener)监听器和通知LazyForEach更新数据，开发者需要使用如下方法：首先实现LazyForEach提供的[IDataSource](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#idatasource)接口，将其作为LazyForEach的数据源，然后管理监听器和更新数据。

为实现基本的数据管理和监听能力，开发者需要实现IDataSource的[totalCount](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#totalcount)、[getData](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#getdata)、[registerDataChangeListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#registerdatachangelistener)和[unregisterDataChangeListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#unregisterdatachangelistener)方法，具体请参考[BasicDataSource示例代码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#basicdatasource%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81)。当数据源变化时，通过调用监听器的接口通知LazyForEach更新，具体请参考[数据更新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0)。

### 键值生成规则

在LazyForEach循环渲染过程中，系统为每个item生成一个唯一且持久的键值，用于标识对应的组件。键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并基于新的键值创建新的组件。

LazyForEach提供了参数keyGenerator，开发者可以使用该函数生成自定义键值。如果未定义keyGenerator函数，ArkUI框架将使用默认的键值生成函数：(item: Object, index: number) => { return viewId + '-' + index.toString(); }。viewId在编译器转换过程中生成，同一个LazyForEach组件内的viewId一致。

键值应满足以下条件。

1. 键值具有唯一性，每个数据项对应的键值互不相同。
2. 键值具有一致性，数据项不变时对应的键值也不变。

上述条件保证LazyForEach正确、高效地更新子组件，否则可能存在渲染结果异常、渲染效率降低等问题。

### 组件创建规则

在确定键值生成规则后，LazyForEach的第二个参数itemGenerator函数会根据组件创建规则为数据源的每个数组项创建组件。组件的创建包括两种情况：LazyForEach[首次渲染](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93)和LazyForEach非首次渲染的[数据更新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0)。

### 首次渲染

使用LazyForEach时，开发者需要提供数据源、键值生成函数和组件创建函数。**开发者需保证键值生成函数为每项数据生成不同的键值。**

在LazyForEach首次渲染时，会根据上述键值生成规则为数据源的每个数组项生成唯一键值并创建相应的组件。

对于预加载区域内的节点，若创建耗时较长，框架会分帧执行创建任务。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Entry
16. @Component
17. struct MyComponent {
18.   private data: MyDataSource = new MyDataSource();

19.   aboutToAppear() {
20.     for (let i = 0; i <= 20; i++) {
21.       this.data.pushData(`Hello ${i}`);
22.     }
23.   }

24.   build() {
25.     List({ space: 3 }) {
26.       LazyForEach(this.data, (item: string) => {
27.         ListItem() {
28.           Row() {
29.             Text(item).fontSize(50)
30.               .onAppear(() => {
31.                 console.info(`appear: ${item}`);
32.               })
33.           }.margin({ left: 10, right: 10 })
34.         }
35.       }, (item: string) => item)
36.     }.cachedCount(5)
37.   }
38. }

在上述代码中，keyGenerator函数的返回值是item。LazyForEach循环渲染时，为数据源数组项依次生成键值Hello 0、Hello 1 ... Hello 20，并创建对应的ListItem子组件渲染到界面上。

运行效果如下图所示。

**图1** LazyForEach正常首次渲染

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163945.41140068263652180764056903748987:50001231000000:2800:EB7A0106C4BC638E497D99ADD3BD609F502DF3FA691A8784F41BE717159C4C29.gif)

**错误案例：键值相同导致渲染异常**

当不同数据项生成的键值相同时，框架的行为是不可预测的。例如，在以下代码中，LazyForEach渲染的数据项键值均相同，在滑动过程中，LazyForEach会预加载划入划出当前页面的子组件，而新建的子组件和销毁的旧子组件具有相同的键值，框架可能取用错误的缓存，导致子组件渲染出现问题。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Entry
16. @Component
17. struct MyComponent {
18.   private data: MyDataSource = new MyDataSource();

19.   aboutToAppear() {
20.     for (let i = 0; i <= 20; i++) {
21.       this.data.pushData(`Hello ${i}`);
22.     }
23.   }

24.   build() {
25.     List({ space: 3 }) {
26.       LazyForEach(this.data, (item: string) => {
27.         ListItem() {
28.           Row() {
29.             Text(item).fontSize(50)
30.               .onAppear(() => {
31.                 console.info(`appear: ${item}`);
32.               })
33.           }.margin({ left: 10, right: 10 })
34.         }
35.       }, (item: string) => `same key`) // 自定义键值生成函数，返回相同键值
36.     }.cachedCount(5)
37.   }
38. }

运行效果如下图所示。

**图2** LazyForEach存在相同键值

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163945.16317690581967053878672170495546:50001231000000:2800:34C7EC6C3C65668DDA85D9DC1EA8D638934499DAA410A70E9159E9D8B2A95FA3.gif)

修改上述示例中LazyForEach的键值生成函数，使每个数据项生成唯一的键值，保证渲染效果符合预期。

1. LazyForEach(this.data, (item: string) => {
2.   ListItem() {
3.    Row() {
4.     Text(item).fontSize(50)
5.       .onAppear(() => {
6.         console.info(`appear: ${item}`);
7.       })
8.     }.margin({ left: 10, right: 10 })
9.   }
10. }, (item: string, index: number) => `${item}-${index}`) // 自定义键值生成函数，返回唯一键值

修改后运行效果如下图所示。

**图3** LazyForEach生成唯一键值

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163945.21578851806088103605759699816179:50001231000000:2800:03A17C18B9AB740D67C27B08C1B31BF458B6ABB62A9230CEADB0F32F107F349A.gif)

### 数据更新

当LazyForEach数据源发生变化，需要再次渲染时，开发者应根据数据源的变化情况调用listener对应的接口，通知LazyForEach做相应的更新。LazyForEach的更新操作包括：添加数据、删除数据、交换数据、改变单个数据、改变多个数据以及精准批量修改数据，各使用场景示例如下。

**添加数据**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Entry
16. @Component
17. struct MyComponent {
18.   private data: MyDataSource = new MyDataSource();

19.   aboutToAppear() {
20.     for (let i = 0; i <= 20; i++) {
21.       this.data.pushData(`Hello ${i}`);
22.     }
23.   }

24.   build() {
25.     List({ space: 3 }) {
26.       LazyForEach(this.data, (item: string) => {
27.         ListItem() {
28.           Row() {
29.             Text(item).fontSize(50)
30.               .onAppear(() => {
31.                 console.info(`appear: ${item}`);
32.               })
33.           }.margin({ left: 10, right: 10 })
34.         }
35.         .onClick(() => {
36.           // 点击追加子组件
37.           this.data.pushData(`Hello ${this.data.totalCount()}`);
38.         })
39.       }, (item: string) => item)
40.     }.cachedCount(5)
41.   }
42. }

点击LazyForEach的子组件时，首先调用数据源data的pushData方法。此方法会在数据源末尾添加数据，并调用notifyDataAdd方法。notifyDataAdd方法内部会调用listener.onDataAdd方法，通知LazyForEach有数据添加。LazyForEach接收到通知后，在该索引处新建子组件。

运行效果如下图所示。

**图4** LazyForEach添加数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.62602198990997454456435861984947:50001231000000:2800:BD6D6EBA93850953AFDA543EA8D0BC31714F78DB8B813CB3CB11BF08BCF42B31.gif)

**删除数据**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public getAllData(): string[] {
11.     return this.dataArray;
12.   }

13.   public pushData(data: string): void {
14.     this.dataArray.push(data);
15.   }

16.   public deleteData(index: number): void {
17.     this.dataArray.splice(index, 1);
18.     this.notifyDataDelete(index);
19.   }
20. }

21. @Entry
22. @Component
23. struct MyComponent {
24.   private data: MyDataSource = new MyDataSource();

25.   aboutToAppear() {
26.     for (let i = 0; i <= 20; i++) {
27.       this.data.pushData(`Hello ${i}`);
28.     }
29.   }

30.   build() {
31.     List({ space: 3 }) {
32.       LazyForEach(this.data, (item: string, index: number) => {
33.         ListItem() {
34.           Row() {
35.             Text(item).fontSize(50)
36.               .onAppear(() => {
37.                 console.info(`appear: ${item}`);
38.               })
39.           }.margin({ left: 10, right: 10 })
40.         }
41.         .onClick(() => {
42.           // 点击删除子组件
43.           this.data.deleteData(this.data.getAllData().indexOf(item));
44.         })
45.       }, (item: string) => item)
46.     }.cachedCount(5)
47.   }
48. }

点击LazyForEach的子组件时，调用数据源data的deleteData方法。此方法删除数据源中对应索引的数据，并调用notifyDataDelete方法。notifyDataDelete方法内调用listener.onDataDelete方法，通知 LazyForEach删除该索引处的子组件。

运行效果如下图所示。

**图5** LazyForEach删除数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.17291737946690652466906958079562:50001231000000:2800:0185AD7BCCF7CF3B4B1AFF887C0D94057E4359F283EA9FA993D8C92442B2A0E9.gif)

**交换数据**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public getAllData(): string[] {
11.     return this.dataArray;
12.   }

13.   public pushData(data: string): void {
14.     this.dataArray.push(data);
15.   }

16.   public moveData(from: number, to: number): void {
17.     let temp: string = this.dataArray[from];
18.     this.dataArray[from] = this.dataArray[to];
19.     this.dataArray[to] = temp;
20.     this.notifyDataMove(from, to);
21.   }
22. }

23. @Entry
24. @Component
25. struct MyComponent {
26.   private moved: number[] = [];
27.   private data: MyDataSource = new MyDataSource();

28.   aboutToAppear() {
29.     for (let i = 0; i <= 20; i++) {
30.       this.data.pushData(`Hello ${i}`);
31.     }
32.   }

33.   build() {
34.     List({ space: 3 }) {
35.       LazyForEach(this.data, (item: string, index: number) => {
36.         ListItem() {
37.           Row() {
38.             Text(item).fontSize(50)
39.               .onAppear(() => {
40.                 console.info(`appear: ${item}`);
41.               })
42.           }.margin({ left: 10, right: 10 })
43.         }
44.         .onClick(() => {
45.           this.moved.push(this.data.getAllData().indexOf(item));
46.           if (this.moved.length === 2) {
47.             // 点击交换子组件
48.             this.data.moveData(this.moved[0], this.moved[1]);
49.             this.moved = [];
50.           }
51.         })
52.       }, (item: string) => item)
53.     }.cachedCount(5)
54.   }
55. }

首次点击LazyForEach的子组件时，将要移动的数据索引存储在moved成员变量中。再次点击LazyForEach的另一个子组件时，将首次点击的子组件移到此处。调用数据源data的moveData方法，该方法将数据源中的数据移动到预期位置，并调用notifyDataMove方法。notifyDataMove方法会调用listener.onDataMove方法，通知LazyForEach在该处有数据需要移动。LazyForEach将from和to索引处的子组件进行位置调换。

运行效果如下图所示。

**图6** LazyForEach交换数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.06958948193021443493944577970577:50001231000000:2800:B069B3FBDAD59FD747FE9558F79148135BDFBF8B50BD3CA88F2518583E845261.gif)

**改变单个数据**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.   }

13.   public changeData(index: number, data: string): void {
14.     this.dataArray.splice(index, 1, data);
15.     this.notifyDataChange(index);
16.   }
17. }

18. @Entry
19. @Component
20. struct MyComponent {
21.   private data: MyDataSource = new MyDataSource();

22.   aboutToAppear() {
23.     for (let i = 0; i <= 20; i++) {
24.       this.data.pushData(`Hello ${i}`);
25.     }
26.   }

27.   build() {
28.     List({ space: 3 }) {
29.       LazyForEach(this.data, (item: string, index: number) => {
30.         ListItem() {
31.           Row() {
32.             Text(item).fontSize(50)
33.               .onAppear(() => {
34.                 console.info(`appear: ${item}`);
35.               })
36.           }.margin({ left: 10, right: 10 })
37.         }
38.         .onClick(() => {
39.           this.data.changeData(index, item + '00');
40.         })
41.       }, (item: string) => item)
42.     }.cachedCount(5)
43.   }
44. }

点击LazyForEach的子组件时，首先改变当前数据，然后调用数据源data的changeData方法。changeData 方法会调用notifyDataChange方法，该方法又会调用listener.onDataChange方法，通知LazyForEach组件数据发生变化。LazyForEach会在对应索引处重建子组件。

运行效果如下图所示。

**图7** LazyForEach改变单个数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.62099682252848888306333469503206:50001231000000:2800:637AA3D270D377EE902FE7D57182ED1E0B008BB01D7DE58126D948A69203D225.gif)

**改变多个数据**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.   }

13.   public reloadData(): void {
14.     this.notifyDataReload();
15.   }

16.   public modifyAllData(): void {
17.     this.dataArray = this.dataArray.map((item: string) => {
18.       return item + '0';
19.     });
20.   }
21. }

22. @Entry
23. @Component
24. struct MyComponent {
25.   private data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(`Hello ${i}`);
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: string, index: number) => {
34.         ListItem() {
35.           Row() {
36.             Text(item).fontSize(50)
37.               .onAppear(() => {
38.                 console.info(`appear: ${item}`);
39.               })
40.           }.margin({ left: 10, right: 10 })
41.         }
42.         .onClick(() => {
43.           this.data.modifyAllData();
44.           this.data.reloadData();
45.         })
46.       }, (item: string) => item)
47.     }.cachedCount(5)
48.   }
49. }

点击LazyForEach的子组件时，首先调用data的modifyAllData方法修改数据源中的所有数据，然后调用数据源的reloadData方法。该方法内会调用notifyDataReload方法，notifyDataReload方法内会调用listener.onDataReloaded方法，通知LazyForEach重建所有子节点。LazyForEach会将原数据项和新数据项进行键值比对，若键值相同则使用缓存，若键值不同则重新构建。

运行效果如下图所示。

**图8** LazyForEach改变多个数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.28700881958198316762323198860955:50001231000000:2800:F116E78D90BD264BA00C4A42AF614C09147F717F86B7B23825AAEFACAC64EBC2.gif)

**精准批量修改数据**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public operateData(): void {
11.     console.info(`[${this.dataArray.join(', ')}]`);
12.     this.dataArray.splice(4, 0, this.dataArray[1]);
13.     this.dataArray.splice(1, 1);
14.     let temp = this.dataArray[4];
15.     this.dataArray[4] = this.dataArray[6];
16.     this.dataArray[6] = temp;
17.     this.dataArray.splice(8, 0, 'Hello 1', 'Hello 2');
18.     this.dataArray.splice(12, 2);
19.     console.info(`[${this.dataArray.join(', ')}]`);
20.     this.notifyDatasetChange([
21.       { type: DataOperationType.MOVE, index: { from: 1, to: 3 } },
22.       { type: DataOperationType.EXCHANGE, index: { start: 4, end: 6 } },
23.       { type: DataOperationType.ADD, index: 8, count: 2 },
24.       { type: DataOperationType.DELETE, index: 10, count: 2 }]);
25.   }

26.   public init(): void {
27.     this.dataArray.splice(0, 0, 'Hello a', 'Hello b', 'Hello c', 'Hello d', 'Hello e', 'Hello f', 'Hello g', 'Hello h',
28.       'Hello i', 'Hello j', 'Hello k', 'Hello l', 'Hello m', 'Hello n', 'Hello o', 'Hello p', 'Hello q', 'Hello r');
29.   }
30. }

31. @Entry
32. @Component
33. struct MyComponent {
34.   private data: MyDataSource = new MyDataSource();

35.   aboutToAppear() {
36.     this.data.init();
37.   }

38.   build() {
39.     Column() {
40.       Text('change data')
41.         .fontSize(10)
42.         .backgroundColor(Color.Blue)
43.         .fontColor(Color.White)
44.         .borderRadius(50)
45.         .padding(5)
46.         .onClick(() => {
47.           this.data.operateData();
48.         })
49.       List({ space: 3 }) {
50.         LazyForEach(this.data, (item: string, index: number) => {
51.           ListItem() {
52.             Row() {
53.               Text(item).fontSize(35)
54.                 .onAppear(() => {
55.                   console.info(`appear: ${item}`);
56.                 })
57.             }.margin({ left: 10, right: 10 })
58.           }

59.         }, (item: string) => item + new Date().getTime())
60.       }.cachedCount(5)
61.     }
62.   }
63. }

onDatasetChange接口允许开发者一次性通知LazyForEach进行数据添加、删除、移动和交换等操作。在上述例子中，点击“change data”文本后，第二项数据被移动到第四项位置，第五项与第七项数据交换位置，并且从第九项开始添加了数据"Hello 1"和"Hello 2"，同时从第十一项开始删除了两项数据。

**图9** LazyForEach改变多个数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.07428604698035507193124668580513:50001231000000:2800:98B1CE66AAF17CEE438678D5CD60AE049E9060CCB1E391F8DFB81271C12A115F.gif)

第二个例子，直接给数组赋值，不涉及 splice 操作。operations直接从比较原数组和新数组得到。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public operateData(): void {
11.     this.dataArray =
12.       ['Hello x', 'Hello 1', 'Hello 2', 'Hello b', 'Hello c', 'Hello e', 'Hello d', 'Hello f', 'Hello g', 'Hello h'];
13.     this.notifyDatasetChange([
14.       { type: DataOperationType.CHANGE, index: 0 },
15.       { type: DataOperationType.ADD, index: 1, count: 2 },
16.       { type: DataOperationType.EXCHANGE, index: { start: 3, end: 4 } },
17.     ]);
18.   }

19.   public init(): void {
20.     this.dataArray = ['Hello a', 'Hello b', 'Hello c', 'Hello d', 'Hello e', 'Hello f', 'Hello g', 'Hello h'];
21.   }
22. }

23. @Entry
24. @Component
25. struct MyComponent {
26.   private data: MyDataSource = new MyDataSource();

27.   aboutToAppear() {
28.     this.data.init();
29.   }

30.   build() {
31.     Column() {
32.       Text('Multi-Data Change')
33.         .fontSize(10)
34.         .backgroundColor(Color.Blue)
35.         .fontColor(Color.White)
36.         .borderRadius(50)
37.         .padding(5)
38.         .onClick(() => {
39.           this.data.operateData();
40.         })
41.       List({ space: 3 }) {
42.         LazyForEach(this.data, (item: string, index: number) => {
43.           ListItem() {
44.             Row() {
45.               Text(item).fontSize(35)
46.                 .onAppear(() => {
47.                   console.info(`appear: ${item}`);
48.                 })
49.             }.margin({ left: 10, right: 10 })
50.           }

51.         }, (item: string) => item + new Date().getTime())
52.       }.cachedCount(5)
53.     }
54.   }
55. }

**图10** LazyForEach改变多个数据

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.50988095528600364935076937749452:50001231000000:2800:AEA828D6567ADE3D49349EF4045D179CD861CCA2C1DF505CF6F230E764481ECC.gif)

使用该接口时请注意以下事项。

1. 不要将onDatasetChange与其他操作数据的接口混用。
    
2. 传入onDatasetChange的operations中，每一项operation的index均从修改前的原数组中查找。因此，operations中的index不总是与Datasource中的index一一对应，并且不能为负数。
    
    第一个例子清楚地显示了这一点:
    
    1. // 修改之前的数组
    2. ['Hello a','Hello b','Hello c','Hello d','Hello e','Hello f','Hello g','Hello h','Hello i','Hello j','Hello k','Hello l','Hello m','Hello n','Hello o','Hello p','Hello q','Hello r']
    3. // 修改之后的数组
    4. ['Hello a','Hello c','Hello d','Hello b','Hello g','Hello f','Hello e','Hello h','Hello 1','Hello 2','Hello i','Hello j','Hello m','Hello n','Hello o','Hello p','Hello q','Hello r']
    
    "Hello b" 从第2项变成第4项，因此第一个 operation 为 { type: DataOperationType.MOVE, index: { from: 1, to: 3 } }。
    
    "Hello e" 跟 "Hello g" 对调了，而 "Hello e" 在修改前的原数组中的 index=4，"Hello g" 在修改前的原数组中的 index=6, 因此第二个 operation 为 { type: DataOperationType.EXCHANGE, index: { start: 4, end: 6 } }。
    
    "Hello 1","Hello 2" 在 "Hello h" 之后插入，而 "Hello h" 在修改前的原数组中的 index=7，因此第三个 operation 为 { type: DataOperationType.ADD, index: 8, count: 2 }。
    
    "Hello k","Hello l" 被删除了，而 "Hello k" 在原数组中的 index=10，因此第四个 operation 为 { type: DataOperationType.DELETE, index: 10, count: 2 }。
    
3. 在同一个onDatasetChange批量处理数据时，如果多个DataOperation操作同一个index，只有第一个DataOperation生效。
    
4. 部分操作由开发者传入键值，LazyForEach不再重复调用keygenerator获取键值，开发者需保证传入键值的正确性。
    
5. 若操作集合中包含RELOAD操作，则其他操作均不生效。
    

## 高级用法

### 改变数据子属性

若仅靠LazyForEach的刷新机制，当item变化时若想更新子组件，需要将原来的子组件全部销毁再重新构建，在子组件结构较为复杂的情况下，靠改变键值去刷新渲染性能较低。因此框架提供了[@Observed装饰器和@ObjectLink装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-observed-and-objectlink)机制进行深度观测，可以做到仅刷新使用了该属性的组件，提高渲染性能。开发者可根据其自身业务特点选择使用哪种刷新方式。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Observed
16. class StringData {
17.   message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @Component
24. struct MyComponent {
25.   private data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item })
36.         }
37.         .onClick(() => {
38.           item.message += '0';
39.         })
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @Component
45. struct ChildComponent {
46.   @ObjectLink data: StringData;

47.   build() {
48.     Row() {
49.       Text(this.data.message).fontSize(50)
50.         .onAppear(() => {
51.           console.info(`appear: ${this.data.message}`);
52.         })
53.     }.margin({ left: 10, right: 10 })
54.   }
55. }

点击LazyForEach子组件改变item.message时，重渲染依赖ChildComponent的@ObjectLink成员变量对子属性的监听。框架仅刷新Text(this.data.message)，不会重建整个ListItem子组件。

**图11** LazyForEach改变数据子属性

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.86573944337673717607837165555306:50001231000000:2800:70AF9D1190DECEB7D69A19AF66E2268801F6B65CDDE23F79169F66ED5B8014D0.gif)

### 使用状态管理V2

状态管理V2提供[@ObservedV2装饰器和@Trace装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-observedv2-and-trace)，用于实现属性的深度观测。使用[@Local装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-local)和[@Param装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-param)，可以管理子组件的刷新，仅刷新使用了对应属性的组件。

**嵌套类属性变化观测**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   firstLayer: FirstLayer;

17.   constructor(firstLayer: FirstLayer) {
18.     this.firstLayer = firstLayer;
19.   }
20. }

21. class FirstLayer {
22.   secondLayer: SecondLayer;

23.   constructor(secondLayer: SecondLayer) {
24.     this.secondLayer = secondLayer;
25.   }
26. }

27. class SecondLayer {
28.   thirdLayer: ThirdLayer;

29.   constructor(thirdLayer: ThirdLayer) {
30.     this.thirdLayer = thirdLayer;
31.   }
32. }

33. @ObservedV2
34. class ThirdLayer {
35.   @Trace fourthLayer: string;

36.   constructor(fourthLayer: string) {
37.     this.fourthLayer = fourthLayer;
38.   }
39. }

40. @Entry
41. @ComponentV2
42. struct MyComponent {
43.   private data: MyDataSource = new MyDataSource();

44.   aboutToAppear() {
45.     for (let i = 0; i <= 20; i++) {
46.       this.data.pushData(new StringData(new FirstLayer(new SecondLayer(new ThirdLayer(`Hello ${i}`)))));
47.     }
48.   }

49.   build() {
50.     List({ space: 3 }) {
51.       LazyForEach(this.data, (item: StringData, index: number) => {
52.         ListItem() {
53.           Text(item.firstLayer.secondLayer.thirdLayer.fourthLayer).fontSize(50)
54.             .onClick(() => {
55.               item.firstLayer.secondLayer.thirdLayer.fourthLayer += '!';
56.             })
57.         }
58.       }, (item: StringData, index: number) => index.toString())
59.     }.cachedCount(5)
60.   }
61. }

@ObservedV2与@Trace用于装饰类以及类中的属性，配合使用能深度观测被装饰的类和属性。示例中，展示了深度嵌套类结构下，通过@ObservedV2和@Trace实现对多层嵌套属性变化的观测和子组件刷新。当点击子组件Text修改被@Trace修饰的嵌套类最内层的类成员属性时，仅重新渲染依赖了该属性的组件。

**组件内部状态**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           Row() {

36.             Text(item.message).fontSize(50)
37.               .onClick(() => {
38.                 // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
39.                 item.message += '!';
40.               })
41.             ChildComponent()
42.           }
43.         }
44.       }, (item: StringData, index: number) => index.toString())
45.     }.cachedCount(5)
46.   }
47. }

48. @ComponentV2
49. struct ChildComponent {
50.   @Local message: string = '?';

51.   build() {
52.     Row() {
53.       Text(this.message).fontSize(50)
54.         .onClick(() => {
55.           // 修改@Local装饰的变量，触发刷新此处Text组件
56.           this.message += '?';
57.         })
58.     }
59.   }
60. }

@Local使得自定义组件内被修饰的变量具有观测其变化的能力，该变量必须在组件内部进行初始化。示例中，点击Text组件修改item.message触发变量更新并刷新使用该变量的组件，ChildComponent中@Local装饰的变量message变化时也能刷新子组件。

**组件外部输入**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item.message })
36.             .onClick(() => {
37.               item.message += '!';
38.             })
39.         }
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @ComponentV2
45. struct ChildComponent {
46.   @Param @Require data: string = '';

47.   build() {
48.     Row() {
49.       Text(this.data).fontSize(50)
50.     }
51.   }
52. }

使用@Param装饰器，子组件可以接受外部输入参数，实现父子组件间的数据同步。在MyComponent中创建子组件时，传递item.message，并用@Param修饰的变量data与其关联。点击ListItem中的组件修改item.message，数据变化会从父组件传递到子组件，触发子组件刷新。

### 拖拽排序

当LazyForEach在List组件下使用，并且设置了[onMove](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-drag-sorting#onmove)事件，可以使能拖拽排序。拖拽排序释放后，如果数据位置发生变化，将触发onMove事件，上报原始索引号和目标索引号。在onMove事件中，根据上报的索引号修改数据源。修改数据源时，无需调用DataChangeListener接口通知数据源变化。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public moveDataWithoutNotify(from: number, to: number): void {
11.     let tmp = this.dataArray.splice(from, 1);
12.     this.dataArray.splice(to, 0, tmp[0]);
13.   }

14.   public pushData(data: string): void {
15.     this.dataArray.push(data);
16.     this.notifyDataAdd(this.dataArray.length - 1);
17.   }
18. }

19. @Entry
20. @Component
21. struct Parent {
22.   private data: MyDataSource = new MyDataSource();

23.   aboutToAppear(): void {
24.     for (let i = 0; i < 100; i++) {
25.       this.data.pushData(i.toString());
26.     }
27.   }

28.   build() {
29.     Row() {
30.       List() {
31.         LazyForEach(this.data, (item: string) => {
32.           ListItem() {
33.             Text(item.toString())
34.               .fontSize(16)
35.               .textAlign(TextAlign.Center)
36.               .size({ height: 100, width: '100%' })
37.           }.margin(10)
38.           .borderRadius(10)
39.           .backgroundColor('#FFFFFFFF')
40.         }, (item: string) => item)
41.           .onMove((from: number, to: number) => {
42.             this.data.moveDataWithoutNotify(from, to);
43.           })
44.       }
45.       .width('100%')
46.       .height('100%')
47.       .backgroundColor('#FFDCDCDC')
48.     }
49.   }
50. }

**图12** LazyForEach拖拽排序效果图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.79872815745800611896550687727063:50001231000000:2800:3CBB47BD9F68E7E5759AB5EB2A0458783C6C097AD7A72E9D8DEFFD71F389AA60.gif)

## 常见问题

### 渲染结果非预期

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }

14.   public deleteData(index: number): void {
15.     this.dataArray.splice(index, 1);
16.     this.notifyDataDelete(index);
17.   }
18. }

19. @Entry
20. @Component
21. struct MyComponent {
22.   private data: MyDataSource = new MyDataSource();

23.   aboutToAppear() {
24.     for (let i = 0; i <= 20; i++) {
25.       this.data.pushData(`Hello ${i}`);
26.     }
27.   }

28.   build() {
29.     List({ space: 3 }) {
30.       LazyForEach(this.data, (item: string, index: number) => {
31.         ListItem() {
32.           Row() {
33.             Text(item).fontSize(50)
34.               .onAppear(() => {
35.                 console.info(`appear: ${item}`);
36.               })
37.           }.margin({ left: 10, right: 10 })
38.         }
39.         .onClick(() => {
40.           // 点击删除子组件
41.           this.data.deleteData(index);
42.         })
43.       }, (item: string) => item)
44.     }.cachedCount(5)
45.   }
46. }

**图13** LazyForEach删除数据非预期

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.33030181564705804490569896874694:50001231000000:2800:0B8A6F6E6E78CAFF93114041CEB16D0AF6C4FD463E13661C3F01BDA4F15F11F4.gif)

多次点击子组件时，发现删除的不一定是点击的那个子组件。原因在于删除某个子组件后，该子组件之后的数据项的index应减1，但实际后续数据项对应的子组件仍使用最初分配的index，itemGenerator中的index未更新，导致删除结果与预期不符。

修复代码如下。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }

14.   public deleteData(index: number): void {
15.     this.dataArray.splice(index, 1);
16.     this.notifyDataDelete(index);
17.   }

18.   public reloadData(): void {
19.     this.notifyDataReload();
20.   }
21. }

22. @Entry
23. @Component
24. struct MyComponent {
25.   private data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(`Hello ${i}`);
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: string, index: number) => {
34.         ListItem() {
35.           Row() {
36.             Text(item).fontSize(50)
37.               .onAppear(() => {
38.                 console.info(`appear: ${item}`);
39.               })
40.           }.margin({ left: 10, right: 10 })
41.         }
42.         .onClick(() => {
43.           // 点击删除子组件
44.           this.data.deleteData(index);
45.           // 重置所有子组件的index索引
46.           this.data.reloadData();
47.         })
48.       }, (item: string, index: number) => item + index.toString())
49.     }.cachedCount(5)
50.   }
51. }

在删除一个数据项后调用reloadData方法，重建后面的数据项，以达到更新index索引的目的。要保证reloadData方法重建数据项，必须保证数据项能生成新的key。这里用了item + index.toString()保证被删除数据项后面的数据项都被重建。如果用item + Date.now().toString()替代，那么所有数据项都生成新的key，导致所有数据项都被重建。这种方法，效果是一样的，只是性能略差。

**图14** 修复LazyForEach删除数据非预期

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.79849597709093500147638956133738:50001231000000:2800:A54992B562DCACF96248560CC752C5FFA9FF7EF677DBE51080624BBFED70B7D3.gif)

### 重渲染时图片闪烁

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }

14.   public reloadData(): void {
15.     this.notifyDataReload();
16.   }
17. }

18. class StringData {
19.   message: string;
20.   imgSrc: Resource;

21.   constructor(message: string, imgSrc: Resource) {
22.     this.message = message;
23.     this.imgSrc = imgSrc;
24.   }
25. }

26. @Entry
27. @Component
28. struct MyComponent {
29.   private moved: number[] = [];
30.   private data: MyDataSource = new MyDataSource();

31.   aboutToAppear() {
32.     for (let i = 0; i <= 20; i++) {
33.       // 此处'app.media.img'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
34.       this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));
35.     }
36.   }

37.   build() {
38.     List({ space: 3 }) {
39.       LazyForEach(this.data, (item: StringData, index: number) => {
40.         ListItem() {
41.           Column() {
42.             Text(item.message).fontSize(50)
43.               .onAppear(() => {
44.                 console.info(`appear: ${item.message}`);
45.               })
46.             Image(item.imgSrc)
47.               .width(500)
48.               .height(200)
49.           }.margin({ left: 10, right: 10 })
50.         }
51.         .onClick(() => {
52.           item.message += '00';
53.           this.data.reloadData();
54.         })
55.       }, (item: StringData, index: number) => item.message) // 修改message属性会导致键值变化
56.     }.cachedCount(5)
57.   }
58. }

**图15** LazyForEach仅改变文字但是图片闪烁问题

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.48621283665703744066328107905709:50001231000000:2800:2D31E1D751C3C7466095D037121AFB372A71FD28639CED9EC76CAE982DF85599.gif)

单击ListItem子组件时，只改变了数据项的message属性，但因为键值发生变化，导致整个ListItem被重建。由于Image组件异步刷新，视觉上图片会闪烁。解决方法是保持键值不变，并使用@ObjectLink和@Observed单独刷新子组件Text。

修复代码如下。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. // @Observed类装饰器 和 @ObjectLink 用于在涉及嵌套对象或数组的场景中进行双向数据同步
16. @Observed
17. class StringData {
18.   message: string;
19.   imgSrc: Resource;

20.   constructor(message: string, imgSrc: Resource) {
21.     this.message = message;
22.     this.imgSrc = imgSrc;
23.   }
24. }

25. @Entry
26. @Component
27. struct MyComponent {
28.   private data: MyDataSource = new MyDataSource();

29.   aboutToAppear() {
30.     for (let i = 0; i <= 20; i++) {
31.       // 此处'app.media.img'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
32.       this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));
33.     }
34.   }

35.   build() {
36.     List({ space: 3 }) {
37.       LazyForEach(this.data, (item: StringData, index: number) => {
38.         ListItem() {
39.           ChildComponent({ data: item })
40.         }
41.         .onClick(() => {
42.           item.message += '0';
43.         })
44.       }, (item: StringData, index: number) => index.toString()) // 键值不受message属性影响
45.     }.cachedCount(5)
46.   }
47. }

48. @Component
49. struct ChildComponent {
50.   // 用状态变量来驱动UI刷新，而不是通过Lazyforeach的api来驱动UI刷新
51.   @ObjectLink data: StringData;

52.   build() {
53.     Column() {
54.       Text(this.data.message).fontSize(50)
55.         .onAppear(() => {
56.           console.info(`appear: ${this.data.message}`);
57.         })
58.       Image(this.data.imgSrc)
59.         .width(500)
60.         .height(200)
61.     }.margin({ left: 10, right: 10 })
62.   }
63. }

**图16** 修复LazyForEach仅改变文字但是图片闪烁问题

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.01120955685363301686263583087538:50001231000000:2800:7B4CBEEF4377C8CFCD7C1D2653EEE663B602B647B197CA5CBBCE438E8F1A004E.gif)

### @ObjectLink属性变化UI未更新

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Observed
16. class StringData {
17.   message: NestedString;

18.   constructor(message: NestedString) {
19.     this.message = message;
20.   }
21. }

22. @Observed
23. class NestedString {
24.   message: string;

25.   constructor(message: string) {
26.     this.message = message;
27.   }
28. }

29. @Entry
30. @Component
31. struct MyComponent {
32.   private moved: number[] = [];
33.   private data: MyDataSource = new MyDataSource();

34.   aboutToAppear() {
35.     for (let i = 0; i <= 20; i++) {
36.       this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));
37.     }
38.   }

39.   build() {
40.     List({ space: 3 }) {
41.       LazyForEach(this.data, (item: StringData, index: number) => {
42.         ListItem() {
43.           ChildComponent({ data: item })
44.         }
45.         .onClick(() => {
46.           item.message.message += '0';
47.         })
48.       }, (item: StringData, index: number) => item.message.message + index.toString())
49.     }.cachedCount(5)
50.   }
51. }

52. @Component
53. struct ChildComponent {
54.   @ObjectLink data: StringData;

55.   build() {
56.     Row() {
57.       Text(this.data.message.message).fontSize(50)
58.         .onAppear(() => {
59.           console.info(`appear: ${this.data.message.message}`);
60.         })
61.     }.margin({ left: 10, right: 10 })
62.   }
63. }

**图17** ObjectLink属性变化后UI未更新

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.79945457127792213556459215072088:50001231000000:2800:649B4C86EEF3CC6810590552342EC634894312FC6EEC775CD5EC160421539CD7.gif)

@ObjectLink装饰的成员变量仅能监听到其子属性的变化，无法监听深层嵌套属性，因此，只能通过修改子属性来通知组件重新渲染。具体请查看[@ObjectLink装饰器与@Observed装饰器的详细使用方法和限制条件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-observed-and-objectlink)。

修复代码如下。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Observed
16. class StringData {
17.   message: NestedString;

18.   constructor(message: NestedString) {
19.     this.message = message;
20.   }
21. }

22. @Observed
23. class NestedString {
24.   message: string;

25.   constructor(message: string) {
26.     this.message = message;
27.   }
28. }

29. @Entry
30. @Component
31. struct MyComponent {
32.   private moved: number[] = [];
33.   private data: MyDataSource = new MyDataSource();

34.   aboutToAppear() {
35.     for (let i = 0; i <= 20; i++) {
36.       this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));
37.     }
38.   }

39.   build() {
40.     List({ space: 3 }) {
41.       LazyForEach(this.data, (item: StringData, index: number) => {
42.         ListItem() {
43.           ChildComponent({ data: item })
44.         }
45.         .onClick(() => {
46.           // @ObjectLink装饰的成员变量仅能监听到其子属性的变化，再深入嵌套的属性便无法观测到
47.           item.message = new NestedString(item.message.message + '0');
48.         })
49.       }, (item: StringData, index: number) => item.message.message + index.toString())
50.     }.cachedCount(5)
51.   }
52. }

53. @Component
54. struct ChildComponent {
55.   @ObjectLink data: StringData;

56.   build() {
57.     Row() {
58.       Text(this.data.message.message).fontSize(50)
59.         .onAppear(() => {
60.           console.info(`appear: ${this.data.message.message}`);
61.         })
62.     }.margin({ left: 10, right: 10 })
63.   }
64. }

**图18** 修复ObjectLink属性变化后UI更新

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.58173914423403132155059269662543:50001231000000:2800:B9B3C60C3A46C0BA4750FE94134F1A7964AC03C23FDF725C6FB6364F5BD8AA0E.gif)

### 在List内使用屏幕闪烁

在List的onScrollIndex方法中调用onDataReloaded可能会导致屏幕闪烁。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }

14.   operateData(): void {
15.     const totalCount = this.dataArray.length;
16.     const batch = 5;
17.     for (let i = totalCount; i < totalCount + batch; i++) {
18.       this.dataArray.push(`Hello ${i}`);
19.     }
20.     this.notifyDataReload();
21.   }
22. }

23. @Entry
24. @Component
25. struct MyComponent {
26.   private moved: number[] = [];
27.   private data: MyDataSource = new MyDataSource();

28.   aboutToAppear() {
29.     for (let i = 0; i <= 10; i++) {
30.       this.data.pushData(`Hello ${i}`);
31.     }
32.   }

33.   build() {
34.     List({ space: 3 }) {
35.       LazyForEach(this.data, (item: string, index: number) => {
36.         ListItem() {
37.           Row() {
38.             Text(item)
39.               .width('100%')
40.               .height(80)
41.               .backgroundColor(Color.Gray)
42.               .onAppear(() => {
43.                 console.info(`appear: ${item}`);
44.               })
45.           }.margin({ left: 10, right: 10 })
46.         }
47.       }, (item: string) => item)
48.     }.cachedCount(10)
49.     .onScrollIndex((start, end, center) => {
50.       if (end === this.data.totalCount() - 1) {
51.         console.info('scroll to end');
52.         this.data.operateData();
53.       }
54.     })
55.   }
56. }

**图19** 当List下拉到底时，屏幕闪烁

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.85350843901989014204475387751140:50001231000000:2800:892588CB6EDD57E85A3EF927658D47E07265353D14C3043A6706849DB6334926.gif)

使用onDatasetChange代替onDataReloaded，不仅可以修复闪屏问题，还能提升加载性能。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }

14.   operateData(): void {
15.     const totalCount = this.dataArray.length;
16.     const batch = 5;
17.     for (let i = totalCount; i < totalCount + batch; i++) {
18.       this.dataArray.push(`Hello ${i}`);
19.     }
20.     // 替换 notifyDataReload
21.     this.notifyDatasetChange([{ type: DataOperationType.ADD, index: totalCount - 1, count: batch }]);
22.   }
23. }

24. @Entry
25. @Component
26. struct MyComponent {
27.   private moved: number[] = [];
28.   private data: MyDataSource = new MyDataSource();

29.   aboutToAppear() {
30.     for (let i = 0; i <= 10; i++) {
31.       this.data.pushData(`Hello ${i}`);
32.     }
33.   }

34.   build() {
35.     List({ space: 3 }) {
36.       LazyForEach(this.data, (item: string, index: number) => {
37.         ListItem() {
38.           Row() {
39.             Text(item)
40.               .width('100%')
41.               .height(80)
42.               .backgroundColor(Color.Gray)
43.               .onAppear(() => {
44.                 console.info(`appear: ${item}`);
45.               })
46.           }.margin({ left: 10, right: 10 })
47.         }
48.       }, (item: string) => item)
49.     }.cachedCount(10)
50.     .onScrollIndex((start, end, center) => {
51.       if (end === this.data.totalCount() - 1) {
52.         console.info('scroll to end');
53.         this.data.operateData();
54.       }
55.     })
56.   }
57. }

**图20** 修复后，当List下拉到底时，屏幕不闪烁

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163946.89014012020159826788367943584961:50001231000000:2800:E7615FF069B82F7D77529D6C462ADC4FE501AA987AFE87026A959211CF573A2C.gif)

### 组件复用渲染异常

@Reusable装饰器与[@ComponentV2装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-componentv2)混用会导致组件渲染异常。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   message: string;

17.   constructor(message: string) {
18.     this.message = message;
19.   }
20. }

21. @Entry
22. @ComponentV2
23. struct MyComponent {
24.   data: MyDataSource = new MyDataSource();

25.   aboutToAppear() {
26.     for (let i = 0; i <= 30; i++) {
27.       this.data.pushData(new StringData(`Hello${i}`));
28.     }
29.   }

30.   build() {
31.     List({ space: 3 }) {
32.       LazyForEach(this.data, (item: StringData, index: number) => {
33.         ListItem() {
34.           ChildComponent({ data: item })
35.             .onAppear(() => {
36.               console.info(`onAppear: ${item.message}`);
37.             })
38.         }
39.       }, (item: StringData, index: number) => index.toString())
40.     }.cachedCount(5)
41.   }
42. }

43. @Reusable
44. @Component
45. struct ChildComponent {
46.   @State data: StringData = new StringData('');

47.   aboutToAppear(): void {
48.     console.info(`aboutToAppear: ${this.data.message}`);
49.   }

50.   aboutToRecycle(): void {
51.     console.info(`aboutToRecycle: ${this.data.message}`);
52.   }

53.   // 对复用的组件进行数据更新
54.   aboutToReuse(params: Record<string, ESObject>): void {
55.     this.data = params.data as StringData;
56.     console.info(`aboutToReuse: ${this.data.message}`);
57.   }

58.   build() {
59.     Row() {
60.       Text(this.data.message).fontSize(50)
61.     }
62.   }
63. }

反例中，在@ComponentV2装饰的组件MyComponent中，LazyForEach列表使用了@Reusable装饰的组件ChildComponent，导致组件渲染失败。从日志中可以看到，组件触发了onAppear，但没有触发aboutToAppear。

将@ComponentV2修改为[@Component](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components#component)可以修复渲染异常。修复后，当滑动事件触发组件节点下树时，对应的可复用组件ChildComponent会被加入复用缓存，而非被销毁，并触发aboutToRecycle事件，打印日志信息。当列表滑动，出现新节点时，会将可复用的组件从复用缓存中重新加入到节点树，触发aboutToReuse刷新组件数据，并打印日志信息。

### 组件不刷新

开发者需要定义合适的键值生成函数，返回与目标数据相关联的键值。目标数据发生改变时，LazyForEach识别到键值改变才会刷新对应组件。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }

14.   public updateAllData(): void {
15.     this.dataArray = this.dataArray.map((item: string) => item + `!`);
16.     this.notifyDataReload();
17.   }
18. }

19. @Entry
20. @Component
21. struct MyComponent {
22.   private data: MyDataSource = new MyDataSource();

23.   aboutToAppear() {
24.     for (let i = 0; i <= 20; i++) {
25.       this.data.pushData(`Hello ${i}`);
26.     }
27.   }

28.   build() {
29.     Column() {
30.       Button(`update all`)
31.         .onClick(() => {
32.           this.data.updateAllData();
33.         })
34.       List({ space: 3 }) {
35.         LazyForEach(this.data, (item: string) => {
36.           ListItem() {
37.             Text(item).fontSize(50)
38.           }
39.         })
40.       }.cachedCount(5)
41.     }
42.   }
43. }

**图21** 点击按钮更新数据，组件不会刷新

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.29975353379451077941688498548567:50001231000000:2800:65B08417A8AE9D713213A7F999A7EC7CF443E23F528D9A61BF3FAFABC98D5F99.gif)

LazyForEach依赖生成的键值判断是否刷新子组件，如果更新的数据没有改变键值（如示例中开发者没有定义键值生成函数，此时键值仅与组件索引index有关，更新数据时键值不变），则LazyForEach不会刷新对应组件。

1. LazyForEach(this.data, (item: string) => {
2.   ListItem() {
3.     Text(item).fontSize(50)
4.   }
5. }, (item: string) => item) // 定义键值生成函数

**图22** 定义键值生成函数后，点击按钮更新数据，组件刷新

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163947.51812777395659702003813931248026:50001231000000:2800:A4335038F336190CD9CEC2C8DE8EBED1224B3B53A3F9CCFFDB0E9A23146A851B.gif)

### 懒加载失效

支持数据懒加载的父组件基于自身和子组件的高度或宽度计算可视范围内应布局的子节点数量，高度或宽度的缺失会导致部分场景懒加载失效。如下示例，在纵向布局中，首次渲染时子组件的高度缺失，所有数据项对应组件都会被创建。

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   public dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Entry
16. @Component
17. struct MyComponent {
18.   private data: MyDataSource = new MyDataSource();

19.   aboutToAppear() {
20.     for (let i = 0; i <= 100; i++) {
21.       this.data.pushData(``);
22.     }
23.   }

24.   build() {
25.     List() {
26.       LazyForEach(this.data, (item: string, index: number) => {
27.         ChildComponent({ message: item, index: index })
28.         // 子组件未设置默认高度，首次渲染时所有数据项对应组件都被创建
29.         // .height(60)
30.       }, (item: string, index: number) => item + index)
31.     }
32.     .cachedCount(2)
33.   }
34. }

35. @Component
36. struct ChildComponent {
37.   message: string = ``;
38.   index: number = -1;

39.   aboutToAppear(): void {
40.     console.info(`about to appear ${this.index}`);
41.   }

42.   build() {
43.     Text(this.message).fontSize(50)
44.   }
45. }

上述示例由于子组件ChildComponent的变量message初始值为空字符串，导致其内部的Text组件高度为 0，同时子组件未显式设置默认高度（如.height(60)），因此在首次渲染时所有子组件的高度均被计算为0。父组件List在基于高度计算可视范围时，判断所有子组件均位于可视区域内，导致懒加载机制失效，最终触发了全部数据项对应组件的创建（可通过日志观察到所有about to appear打印）。

为子组件设置默认高度，确保父组件能正确计算可视范围，从而恢复此场景下懒加载功能。

1. List() {
2.   LazyForEach(this.data, (item: string, index: number) => {
3.     ChildComponent({ message: item, index: index })
4.       // 设置子组件默认高度，首次渲染懒加载生效
5.       .height(60)
6.   }, (item: string, index: number) => item + index)
7. }
8. .cachedCount(2)

## BasicDataSource示例代码

### string类型数组的BasicDataSource代码

1. // BasicDataSource实现了IDataSource接口，用于管理listener监听，以及通知LazyForEach数据更新
2. class BasicDataSource implements IDataSource {
3.   private listeners: DataChangeListener[] = [];
4.   private originDataArray: string[] = [];

5.   public totalCount(): number {
6.     return this.originDataArray.length;
7.   }

8.   public getData(index: number): string {
9.     return this.originDataArray[index];
10.   }

11.   // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
12.   registerDataChangeListener(listener: DataChangeListener): void {
13.     if (this.listeners.indexOf(listener) < 0) {
14.       console.info('add listener');
15.       this.listeners.push(listener);
16.     }
17.   }

18.   // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
19.   unregisterDataChangeListener(listener: DataChangeListener): void {
20.     const pos = this.listeners.indexOf(listener);
21.     if (pos >= 0) {
22.       console.info('remove listener');
23.       this.listeners.splice(pos, 1);
24.     }
25.   }

26.   // 通知LazyForEach组件需要重载所有子组件
27.   notifyDataReload(): void {
28.     this.listeners.forEach(listener => {
29.       listener.onDataReloaded();
30.     });
31.   }

32.   // 通知LazyForEach组件需要在index对应索引处添加子组件
33.   notifyDataAdd(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataAdd(index);
36.       // 写法2：listener.onDatasetChange([{type: DataOperationType.ADD, index: index}]);
37.     });
38.   }

39.   // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
40.   notifyDataChange(index: number): void {
41.     this.listeners.forEach(listener => {
42.       listener.onDataChange(index);
43.       // 写法2：listener.onDatasetChange([{type: DataOperationType.CHANGE, index: index}]);
44.     });
45.   }

46.   // 通知LazyForEach组件需要在index对应索引处删除该子组件
47.   notifyDataDelete(index: number): void {
48.     this.listeners.forEach(listener => {
49.       listener.onDataDelete(index);
50.       // 写法2：listener.onDatasetChange([{type: DataOperationType.DELETE, index: index}]);
51.     });
52.   }

53.   // 通知LazyForEach组件将from索引和to索引处的子组件进行交换
54.   notifyDataMove(from: number, to: number): void {
55.     this.listeners.forEach(listener => {
56.       listener.onDataMove(from, to);
57.       // 写法2：listener.onDatasetChange(
58.       //         [{type: DataOperationType.EXCHANGE, index: {start: from, end: to}}]);
59.     });
60.   }

61.   notifyDatasetChange(operations: DataOperation[]): void {
62.     this.listeners.forEach(listener => {
63.       listener.onDatasetChange(operations);
64.     });
65.   }
66. }

### StringData类型数组的BasicDataSource代码

1. class BasicDataSource implements IDataSource {
2.   private listeners: DataChangeListener[] = [];
3.   private originDataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.originDataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.originDataArray[index];
9.   }

10.   registerDataChangeListener(listener: DataChangeListener): void {
11.     if (this.listeners.indexOf(listener) < 0) {
12.       console.info('add listener');
13.       this.listeners.push(listener);
14.     }
15.   }

16.   unregisterDataChangeListener(listener: DataChangeListener): void {
17.     const pos = this.listeners.indexOf(listener);
18.     if (pos >= 0) {
19.       console.info('remove listener');
20.       this.listeners.splice(pos, 1);
21.     }
22.   }

23.   notifyDataReload(): void {
24.     this.listeners.forEach(listener => {
25.       listener.onDataReloaded();
26.     });
27.   }

28.   notifyDataAdd(index: number): void {
29.     this.listeners.forEach(listener => {
30.       listener.onDataAdd(index);
31.     });
32.   }

33.   notifyDataChange(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataChange(index);
36.     });
37.   }

38.   notifyDataDelete(index: number): void {
39.     this.listeners.forEach(listener => {
40.       listener.onDataDelete(index);
41.     });
42.   }

43.   notifyDataMove(from: number, to: number): void {
44.     this.listeners.forEach(listener => {
45.       listener.onDataMove(from, to);
46.     });
47.   }

48.   notifyDatasetChange(operations: DataOperation[]): void {
49.     this.listeners.forEach(listener => {
50.       listener.onDatasetChange(operations);
51.     });
52.   }
53. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach "ForEach：循环渲染")
# LazyForEach迁移Repeat指南

更新时间: 2025-12-16 16:39

[Repeat](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat)是ArkUI在API version 12中新引入的循环渲染组件，相比[LazyForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)具有更简洁的API、更丰富的功能以及更强的性能优化能力。本指南帮助开发者将LazyForEach平滑地迁移到Repeat。

## 基础用法迁移

### 数据首次渲染

**LazyForEach示例**

LazyForEach根据数据源循环渲染子组件。

示例1中，在容器组件[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list)中使用LazyForEach，并基于数据源循环渲染出了一系列[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display)子组件。

**示例1 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Entry
16. @Component
17. struct MyComponent {
18.   private data: MyDataSource = new MyDataSource();

19.   aboutToAppear() {
20.     for (let i = 0; i <= 20; i++) {
21.       this.data.pushData(`Hello ${i}`);
22.     }
23.   }

24.   build() {
25.     List({ space: 3 }) {
26.       LazyForEach(this.data, (item: string) => {
27.         ListItem() {
28.           Row() {
29.             Text(item).fontSize(50)
30.               .onAppear(() => {
31.                 console.info(`appear: ${item}`);
32.               })
33.           }.margin({ left: 10, right: 10 })
34.         }
35.       }, (item: string) => item)
36.     }.cachedCount(5)
37.   }
38. }

以上是一个典型的使用LazyForEach循环渲染子组件的场景，下面将介绍如何将此示例迁移至Repeat。

**迁移步骤**

1. 使用状态管理V2装饰器。
    
    Repeat推荐和状态管理V2装饰器配合使用（[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E8%83%BD%E5%8A%9B%E8%AF%B4%E6%98%8E)模式下只支持和状态管理V2装饰器配合使用）。如果之前使用的是状态管理V1装饰器，需要修改为状态管理V2装饰器。
    
    1. // 迁移前 - LazyForEach
    2. @Component // 状态管理V1
    3. struct MyComponent {
    4.   build() {
    5.     // ...
    6.     LazyForEach(...)
    7.     // ...
    8.   }
    9.   // ...其他属性、方法
    10. }
    
    11. // 迁移后 - Repeat
    12. @ComponentV2 // 状态管理V2
    13. struct MyComponent {
    14.   build() {
    15.     // ...
    16.     Repeat(...)
    17.     // ...
    18.   }
    19.   // ...其他属性、方法
    20. }
    
2. 迁移数据源。
    
    LazyForEach使用专用的数据结构[IDataSource](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#idatasource)作为数据源。迁移至Repeat后，不再使用IDataSource作为数据源，而是使用状态管理V2装饰的数组作为数据源。
    
    1. // 迁移前 - LazyForEach
    2. class MyDataSource implements IDataSource {
    3.   private dataArray: string[] = [];
    
    4.   public totalCount(): number {
    5.     return this.dataArray.length;
    6.   }
    
    7.   public getData(index: number): string {
    8.     return this.dataArray[index];
    9.   }
    
    10.   // ...其他方法
    11. }
    
    12. // 迁移后 - Repeat
    13. @Local data: Array<string> = [];
    
3. 迁移组件生成函数和键值生成函数。
    
    LazyForEach与Repeat均通过组件生成函数，为每一项数据创建一个子组件；通过键值生成函数，为每一项数据生成一个唯一的键值。
    
    从LazyForEach迁移至Repeat时，两者的语法存在差异。Repeat需要在[.each()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#each)或[.template()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#template)中设置组件生成函数，在[.key()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#key)中设置键值生成函数。
    
    1. // 迁移前 - LazyForEach
    2. List() {
    3.   LazyForEach(
    4.     this.data, // 数据源
    5.     (item: string, index: number) => { // 组件生成函数
    6.       ListItem() {
    7.         Text(item)
    8.       }
    9.     },
    10.     (item: string, index: number) => item // 键值生成函数
    11.   )
    12. }
    
    13. // 迁移后 - Repeat
    14. List() {
    15.   Repeat<string>(this.data) // 数据源
    16.     .each((repeatItem: RepeatItem<string>) => { // 组件生成函数
    17.       ListItem() {
    18.         Text(repeatItem.item)
    19.       }
    20.     })
    21.     .key((item: string, index: number) => item) // 键值生成函数
    22. }
    
4. 配置懒加载功能。
    
    Repeat具有[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E8%83%BD%E5%8A%9B%E8%AF%B4%E6%98%8E)和[全量加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%85%B3%E9%97%AD%E6%87%92%E5%8A%A0%E8%BD%BD)两种模式。
    
    - 全量加载模式渲染所有子节点（对标[ForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)）。
    - 懒加载模式动态渲染屏幕区域和预加载区域内的子节点（需要与容器组件配合使用，对标LazyForEach）。
    
    从LazyForEach迁移至Repeat时，需要调用[virtualScroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#virtualscroll))属性，使能懒加载。
    
    1. // 迁移前 - LazyForEach
    2. LazyForEach(data, (item) => {...}, (item) => item)
    
    3. // 迁移后 - Repeat
    4. Repeat(data)
    5.   .virtualScroll() // 使能懒加载
    

**迁移后代码**

通过以上步骤，可以将示例1从LazyForEach迁移至Repeat，迁移后的完整示例如下所示。

**示例1 - 迁移后**

1. @Entry
2. @ComponentV2 // 使用状态管理V2
3. struct MyComponent {
4.   @Local data: Array<string> = []; // 数据源为状态管理V2装饰的数组

5.   aboutToAppear() {
6.     for (let i = 0; i <= 20; i++) {
7.       this.data.push(`Hello ${i}`);
8.     }
9.   }

10.   build() {
11.     List({ space: 3 }) {
12.       Repeat(this.data) // 使用Repeat
13.         .each((repeatItem: RepeatItem<string>) => { // 组件生成函数
14.           ListItem() {
15.             Row() {
16.               Text(repeatItem.item).fontSize(50)
17.                 .onAppear(() => {
18.                   console.info(`appear: ${repeatItem.item}`);
19.                 })
20.             }.margin({ left: 10, right: 10 })
21.           }
22.         })
23.         .key((item: string) => item) // 键值生成函数
24.         .virtualScroll() // 使能懒加载
25.     }.cachedCount(5)
26.   }
27. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.62687963044335291653345093467222:50001231000000:2800:E646A9E8F759C173C6DA35673112979325C60EE00AD6B6D6653A61C483F5895B.gif)

### 数据更新操作

**LazyForEach示例**

当LazyForEach的数据源发生变化时，开发者需要根据数据源的变化情况调用[DataChangeListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#datachangelistener)对应的接口，通知LazyForEach做相应的更新。主要的数据操作包括：添加数据、删除数据、交换数据、修改单个数据、修改多个数据、精准批量修改数据。

示例2演示了主要的数据操作。

**示例2 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   // 添加数据
11.   public pushData(data: string): void {
12.     this.dataArray.push(data);
13.     this.notifyDataAdd(this.dataArray.length - 1);
14.   }

15.   // 删除数据
16.   public deleteData(index: number): void {
17.     this.dataArray.splice(index, 1);
18.     this.notifyDataDelete(index);
19.   }

20.   // 交换数据
21.   public moveData(from: number, to: number): void {
22.     let temp: string = this.dataArray[from];
23.     this.dataArray[from] = this.dataArray[to];
24.     this.dataArray[to] = temp;
25.     this.notifyDataMove(from, to);
26.   }

27.   // 修改单个数据
28.   public changeData(index: number, data: string): void {
29.     this.dataArray.splice(index, 1, data);
30.     this.notifyDataChange(index);
31.   }

32.   // 修改多个数据
33.   public modifyAllData(): void {
34.     this.dataArray = this.dataArray.map((item: string) => {
35.         return 'Changed ' + item;
36.     });
37.     this.notifyDataReload();
38.   }
39. }

40. @Entry
41. @Component
42. struct MyComponent {
43.   private data: MyDataSource = new MyDataSource();
44.   private count: number = 0;

45.   aboutToAppear() {
46.     for (let i = 0; i <= 10; i++) {
47.       this.data.pushData(`Hello ${i}`);
48.     }
49.   }

50.   build() {
51.     Column({ space: 3 }) {
52.       // 点击追加子组件
53.       Button('Add new item')
54.         .onClick(() => {
55.           this.data.pushData(`New item ${this.count++}`);
56.         })
57.       // 点击删除子组件
58.       Button('Delete item 0')
59.         .onClick(() => {
60.           this.data.deleteData(0);
61.         })
62.       // 点击交换子组件
63.       Button('Swap item 0 and item 1')
64.         .onClick(() => {
65.           this.data.moveData(0, 1);
66.         })
67.       // 点击修改单个子组件
68.       Button('Change item 0')
69.         .onClick(() => {
70.           this.data.changeData(0, `Changed item ${this.count++}`);
71.         })
72.       // 点击修改多个子组件
73.       Button('Change all items')
74.         .onClick(() => {
75.           this.data.modifyAllData();
76.         })
77.       List({ space: 3 }) {
78.         LazyForEach(this.data, (item: string) => {
79.           ListItem() {
80.             Row() {
81.               Text(item).fontSize(25)
82.             }
83.           }
84.         }, (item: string) => item)
85.       }.cachedCount(5)
86.     }
87.   }
88. }

以上是一个典型的更新数据后LazyForEach重新渲染子组件的场景，下面将介绍如何将此示例迁移至Repeat。

**迁移步骤**

1. 迁移准备。
    
    根据数据首次渲染小节中的步骤，将LazyForEach替换为Repeat。
    
    1. 使用状态管理V2装饰器。
    2. 迁移数据源。
    3. 迁移组件生成函数与键值生成函数。
    4. 使能懒加载。
2. 迁移数据源修改方式。
    
    - 对于LazyForEach，在修改数据源后需要调用对应的接口通知其更新。
    - 对于Repeat，由状态管理V2监听其数据源变化，并触发更新。因此，开发者直接修改数据源即可，无需其他额外操作。
    
    1. // 以修改单个数据为例
    2. // 迁移前 - LazyForEach
    3. class MyDataSource implements IDataSource {
    4.   private dataArray: string[] = [];
    
    5.   public changeData(index: number, newData: string): void {
    6.     this.dataArray.splice(index, 1, data);
    7.     this.notifyDataChange(index);
    8.   }
    
    9.   // ...其他方法
    10. }
    
    11. // 迁移后 - Repeat
    12. this.data.splice(index, 1, data);
    
    其他数据更新操作，如添加数据、删除数据、交换数据等，与以上方法类似，可通过直接修改数据源数组实现。
    

**迁移后代码**

迁移后的完整示例如下。

**示例2 - 迁移后**

1. @Entry
2. @ComponentV2
3. struct MyComponent {
4.   @Local data: Array<string> = [];
5.   private count: number = 0;

6.   aboutToAppear() {
7.     for (let i = 0; i <= 10; i++) {
8.       this.data.push(`Hello ${i}`);
9.     }
10.   }

11.   build() {
12.     Column({ space: 3 }) {
13.       // 点击追加子组件
14.       Button('Add new item')
15.         .onClick(() => { this.data.push(`New item ${this.count++}`); })
16.       // 点击删除子组件
17.       Button('Delete item 0')
18.         .onClick(() => { this.data.splice(0, 1); })
19.       // 点击交换子组件
20.       Button('Swap item 0 and item 1')
21.         .onClick(() => { let temp: string = this.data[0];
22.                          this.data[0] = this.data[1];
23.                          this.data[1] = temp; })
24.       // 点击修改单个子组件
25.       Button('Change item 0')
26.         .onClick(() => { this.data.splice(0, 1, `Changed item ${this.count++}`); })
27.       // 点击修改多个子组件
28.       Button('Change all items')
29.         .onClick(() => { this.data = this.data.map((item: string) => { return 'Changed ' + item; }); })
30.       List({ space: 3 }) {
31.         Repeat(this.data)
32.           .each((repeatItem: RepeatItem<string>) => {
33.             ListItem() {
34.               Row() {
35.                 Text(repeatItem.item).fontSize(25)
36.               }
37.             }
38.           })
39.           .key((item: string) => item)
40.           .virtualScroll()
41.       }.cachedCount(5)
42.     }
43.   }
44. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.11265996241335720350651991932968:50001231000000:2800:F4FD69EEBCCC06E46710835E4A45D5C513032A0460CCAE3FB242E4CBA0728C6A.gif)

## 典型场景迁移

### 修改数据子属性

**LazyForEach示例**

LazyForEach可以使用[@Observed与@ObjectLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-observed-and-objectlink)装饰器实现对数据子属性的观测。当有数据子属性发生变化时，仅更新使用了该子属性的组件，从而提高性能。

示例3演示了对子属性的观测。

**示例3 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Observed
16. class StringData {
17.   message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @Component
24. struct MyComponent {
25.   private data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item })
36.         }
37.         .onClick(() => {
38.           item.message += '0';
39.         })
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @Component
45. struct ChildComponent {
46.   @ObjectLink data: StringData;

47.   build() {
48.     Row() {
49.       Text(this.data.message).fontSize(50)
50.         .onAppear(() => {
51.           console.info(`appear: ${this.data.message}`);
52.         })
53.     }.margin({ left: 10, right: 10 })
54.   }
55. }

**迁移Repeat**

Repeat需要和状态管理V2一起使用，状态管理V2提供了[@ObserveV2和@Trace](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-observedv2-and-trace)装饰器对子属性进行深度观测。迁移时，需要将@Observe和@ObjectLink装饰器迁移至@ObserveV2和@Trace装饰器。

迁移后的示例如下所示。

**示例3 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string; // 观测子属性

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             Text(repeatItem.item.message).fontSize(50)
23.               .onAppear(() => {
24.                 console.info(`appear: ${repeatItem.item.message}`);
25.               })
26.           }
27.           .onClick(() => {
28.             repeatItem.item.message += '0';
29.           })
30.         })
31.         .key((item: StringData, index: number) => index.toString())
32.         .virtualScroll()
33.     }.cachedCount(5)
34.   }
35. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.32541381118823681067088850163641:50001231000000:2800:6DC836D57AD8076BADB0DA63972483D68B833E42BD062B584B80D32363B0530D.gif)

### 状态管理V2观测组件内部状态

**LazyForEach示例**

状态管理V2的[@Local](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-local)装饰器提供了观测自定义组件内部变量的能力。被@Local装饰的变量发生变化时，会通知LazyForEach更新对应的组件。

示例4演示了在LazyForEach中使用@Local装饰器观测数据变化，触发组件更新。

**示例4 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           Row() {
36.             Text(item.message).fontSize(50)
37.               .onClick(() => {
38.                 // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
39.                 item.message += '!';
40.               })
41.             ChildComponent()
42.           }
43.         }
44.       }, (item: StringData, index: number) => index.toString())
45.     }.cachedCount(5)
46.   }
47. }

48. @ComponentV2
49. struct ChildComponent {
50.   @Local message: string = '?';

51.   build() {
52.     Row() {
53.       Text(this.message).fontSize(50)
54.         .onClick(() => {
55.           // 修改@Local装饰的变量，触发刷新此处Text组件
56.           this.message += '?';
57.         })
58.     }
59.   }
60. }

**迁移Repeat**

Repeat本身支持与状态管理V2联合使用，将LazyForEach相关代码修改为Repeat后，即可实现对组件内部状态变量的观测。

迁移后的示例如下所示。

**示例4 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string;

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             Row() {
23.               Text(repeatItem.item.message).fontSize(50)
24.                 .onClick(() => {
25.                   // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
26.                   repeatItem.item.message += '!';
27.                 })
28.               ChildComponent()
29.             }
30.           }
31.         })
32.         .key((item: StringData, index: number) => index.toString())
33.         .virtualScroll()
34.     }.cachedCount(5)
35.   }
36. }

37. @ComponentV2
38. struct ChildComponent {
39.   @Local message: string = '?';

40.   build() {
41.     Row() {
42.       Text(this.message).fontSize(50)
43.         .onClick(() => {
44.           // 修改@Local装饰的变量，触发刷新此处Text组件
45.           this.message += '?';
46.         })
47.     }
48.   }
49. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.07940817595587609092357466015835:50001231000000:2800:55F4286074152FE31295E59C0F225F1BD4F9819FEADF363E992B70AC51CA12C5.gif)

### 状态管理V2观测组件外部输入

**LazyForEach示例**

状态管理V2的[@Param](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-param)装饰器提供了观测自定义组件外部输入变量的能力，可以实现父子组件间的数据同步。将父组件的变量传递给子组件，并用@Param装饰，当父组件变量发生变化时，会通知对应的组件更新。

示例5演示了在LazyForEach中使用@Param装饰器观测数据变化，触发组件更新。

**示例5 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item.message }) // 向自定义组件内传入变量
36.             .onClick(() => {
37.               item.message += '!';
38.             })
39.         }
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @ComponentV2
45. struct ChildComponent {
46.   @Param @Require data: string = ''; // 接收来自外部的变量

47.   build() {
48.     Row() {
49.       Text(this.data).fontSize(50)
50.     }
51.   }
52. }

**迁移Repeat**

Repeat本身支持与状态管理V2联合使用，将LazyForEach相关代码修改为Repeat后，即可实现对组件外部输入状态变量的观测。

迁移后的示例如下所示。

**示例5 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string;

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             ChildComponent({ data: repeatItem.item.message }) // 向自定义组件内传入变量
23.               .onClick(() => {
24.                 repeatItem.item.message += '!';
25.               })
26.           }
27.         })
28.         .key((item: StringData, index: number) => index.toString())
29.         .virtualScroll()
30.     }.cachedCount(5)
31.   }
32. }

33. @ComponentV2
34. struct ChildComponent {
35.   @Param @Require data: string = ''; // 接收来自外部的变量

36.   build() {
37.     Row() {
38.       Text(this.data).fontSize(50)
39.     }
40.   }
41. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.90430579311480355869393459661229:50001231000000:2800:D4D2486C4784B911F9EE9A49363DC9C8BDDA17CD0B1BC1A8E5741ECB7881C668.gif)

### 拖拽排序

**LazyForEach示例**

LazyForEach的[onMove](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-drag-sorting#onmove)属性提供了拖拽排序能力。

示例6为典型用例。

**示例6 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public moveDataWithoutNotify(from: number, to: number): void {
11.     let tmp = this.dataArray.splice(from, 1);
12.     this.dataArray.splice(to, 0, tmp[0]);
13.   }

14.   public pushData(data: string): void {
15.     this.dataArray.push(data);
16.     this.notifyDataAdd(this.dataArray.length - 1);
17.   }
18. }

19. @Entry
20. @Component
21. struct Parent {
22.   private data: MyDataSource = new MyDataSource();

23.   aboutToAppear(): void {
24.     for (let i = 0; i < 100; i++) {
25.       this.data.pushData(i.toString());
26.     }
27.   }

28.   build() {
29.     Row() {
30.       List() {
31.         LazyForEach(this.data, (item: string) => {
32.           ListItem() {
33.             Text(item.toString())
34.               .fontSize(16)
35.               .textAlign(TextAlign.Center)
36.               .size({ height: 100, width: '100%' })
37.           }.margin(10)
38.           .borderRadius(10)
39.           .backgroundColor('#FFFFFFFF')
40.         }, (item: string) => item)
41.           .onMove((from: number, to: number) => { // 实现拖拽排序
42.             this.data.moveDataWithoutNotify(from, to);
43.           })
44.       }
45.       .width('100%')
46.       .height('100%')
47.       .backgroundColor('#FFDCDCDC')
48.     }
49.   }
50. }

**迁移Repeat**

Repeat具有与LazyForEach相同的onMove属性。将LazyForEach相关代码修改为Repeat后，即可实现拖拽排序。

迁移后的示例如下所示。

**示例6 - 迁移后**

1. @Entry
2. @ComponentV2
3. struct Parent {
4.   @Local data: string[] = [];

5.   aboutToAppear(): void {
6.     for (let i = 0; i < 100; i++) {
7.       this.data.push(i.toString());
8.     }
9.   }

10.   moveData(from: number, to: number) {
11.     let tmp = this.data.splice(from, 1);
12.     this.data.splice(to, 0, tmp[0]);
13.   }

14.   build() {
15.     Row() {
16.       List() {
17.         Repeat(this.data)
18.           .each((repeatItem) => {
19.             ListItem() {
20.               Text(repeatItem.item.toString())
21.                 .fontSize(16)
22.                 .textAlign(TextAlign.Center)
23.                 .size({ height: 100, width: '100%' })
24.             }.margin(10)
25.             .borderRadius(10)
26.             .backgroundColor('#FFFFFFFF')
27.           })
28.           .key((item: string) => item)
29.           .virtualScroll()
30.           .onMove((from: number, to: number) => { // 实现拖拽排序
31.             this.moveData(from, to);
32.           })
33.       }
34.       .width('100%')
35.       .height('100%')
36.       .backgroundColor('#FFDCDCDC')
37.     }
38.   }
39. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.50484491938529264108091518082071:50001231000000:2800:7CAE3B2495540FB53C8B4D3E84D871A4940E6E483AA646ACA1E03F8F75D22A5D.gif)

### 组件复用

**LazyForEach示例**

LazyForEach自身并不具备组件复用能力，为实现组件复用，需要与[@Reusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable)装饰器配合使用（被@Reusable装饰的自定义组件具有复用能力）。

示例7演示了组件复用的典型场景。

**示例7 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   message: string;

17.   constructor(message: string) {
18.     this.message = message;
19.   }
20. }

21. @Entry
22. @Component
23. struct MyComponent {
24.   data: MyDataSource = new MyDataSource();

25.   aboutToAppear() {
26.     for (let i = 0; i <= 30; i++) {
27.       this.data.pushData(new StringData(`Hello${i}`));
28.     }
29.   }

30.   build() {
31.     List({ space: 3 }) {
32.       LazyForEach(this.data, (item: StringData, index: number) => {
33.         ListItem() {
34.           ChildComponent({ data: item })
35.             .onAppear(() => {
36.               console.info(`onAppear: ${item.message}`);
37.             })
38.         }
39.       }, (item: StringData, index: number) => index.toString())
40.     }.cachedCount(5)
41.   }
42. }

43. @Reusable
44. @Component
45. struct ChildComponent {
46.   @State data: StringData = new StringData('');

47.   aboutToAppear(): void {
48.     console.info(`aboutToAppear: ${this.data.message}`);
49.   }

50.   aboutToRecycle(): void {
51.     console.info(`aboutToRecycle: ${this.data.message}`);
52.   }

53.   // 对复用的组件进行数据更新
54.   aboutToReuse(params: Record<string, ESObject>): void {
55.     this.data = params.data as StringData;
56.     console.info(`aboutToReuse: ${this.data.message}`);
57.   }

58.   build() {
59.     Row() {
60.       Text(this.data.message).fontSize(50)
61.     }
62.   }
63. }

**迁移Repeat**

Repeat本身具备组件复用能力，同时也支持与状态管理V2的[@ReusableV2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-reusablev2)装饰器联合使用。因此，迁移至Repeat后，其组件复用具有两种实现方案。

1. 直接使用Repeat自身的复用能力。
2. 使用@ReusableV2装饰器提供的复用能力。

需要注意的是，Repeat默认使能自身的复用能力，且优先级高于@ReusableV2装饰器。若要使用@ReusableV2装饰器，需要先手动关闭Repeat自身的复用能力（@ReusableV2装饰器从API version 18开始支持，Repeat从API version 19开始支持关闭自身复用能力）。

**示例7 - 迁移方案1：使用Repeat自身的复用能力**

Repeat本身具备复用能力，且默认开启。将LazyForEach相关代码迁移至Repeat后，便已经具备了复用能力。

修改后的示例如下。

1. class StringData {
2.   message: string;

3.   constructor(message: string) {
4.     this.message = message;
5.   }
6. }

7. @Entry
8. @ComponentV2
9. struct MyComponent {
10.   @Local data: StringData[] = [];

11.   aboutToAppear() {
12.     for (let i = 0; i <= 30; i++) {
13.       this.data.push(new StringData(`Hello${i}`));
14.     }
15.   }

16.   build() {
17.     List({ space: 3 }) {
18.       Repeat(this.data) // Repeat自身具备复用功能
19.         .each((repeatItem) => {
20.           ListItem() {
21.             Text(repeatItem.item.message).fontSize(50)
22.           }
23.         })
24.         .key((item: StringData, index: number) => index.toString())
25.         .virtualScroll()
26.     }.cachedCount(5)
27.   }
28. }

**示例7 - 迁移方案2：使用@ReusableV2装饰器**

若要使用@ReusableV2装饰器，首先需要通过.virtualScroll({ reusable: false })关闭Repeat自身的复用功能，再用@ReusableV2装饰需要复用的自定义组件。

相较于Repeat自身的复用，@ReusableV2装饰的自定义组件在回收和复用时，会触发aboutToRecycle和aboutToReuse两个生命周期。

使用@ReusableV2装饰器的迁移示例如下所示。

1. class StringData {
2.   message: string;

3.   constructor(message: string) {
4.     this.message = message;
5.   }
6. }

7. @Entry
8. @ComponentV2
9. struct MyComponent {
10.   @Local data: StringData[] = [];

11.   aboutToAppear() {
12.     for (let i = 0; i <= 30; i++) {
13.       this.data.push(new StringData(`Hello${i}`));
14.     }
15.   }

16.   build() {
17.     List({ space: 3 }) {
18.       Repeat(this.data)
19.         .each((repeatItem) => {
20.           ListItem() {
21.             ChildComponent({ data: repeatItem.item })
22.               .onAppear(() => {
23.                 console.info(`onAppear: ${repeatItem.item.message}`);
24.               })
25.           }
26.         })
27.         .key((item: StringData, index: number) => index.toString())
28.         .virtualScroll({ reusable: false }) // 关闭Repeat自身的复用功能（API 19）
29.     }.cachedCount(5)
30.   }
31. }

32. // 使用@ReusableV2实现组件复用（API 18）
33. @ReusableV2
34. @ComponentV2
35. struct ChildComponent {
36.   @Param data: StringData = new StringData('');

37.   aboutToAppear(): void {
38.     console.info(`aboutToAppear: ${this.data.message}`);
39.   }

40.   aboutToRecycle(): void {
41.     console.info(`aboutToRecycle: ${this.data.message}`);
42.   }

43.   aboutToReuse(): void {
44.     console.info(`aboutToReuse: ${this.data.message}`);
45.   }

46.   build() {
47.     Row() {
48.       Text(this.data.message).fontSize(50)
49.     }
50.   }
51. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.24263212202420592585590536450661:50001231000000:2800:16BFB5890C31649EC35FF4CE09025AA08349FC37026607631E2C028628AD3731.gif)

### 模板渲染

**LazyForEach示例**

LazyForEach自身并不具备模板渲染能力。为实现模板渲染能力，需要开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板。

示例8演示了模板渲染的典型场景。

**示例8 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   message: string;
17.   type: number;

18.   constructor(message: string, type: number) {
19.     this.message = message;
20.     this.type = type;
21.   }

22.   getType(): number {
23.     if (this.type >= 1) {
24.       return 1;
25.     } else {
26.       return 0;
27.     }
28.   }
29. }

30. @Entry
31. @Component
32. struct MyComponent {
33.   data: MyDataSource = new MyDataSource();

34.   aboutToAppear() {
35.     for (let i = 0; i <= 200; i++) {
36.       this.data.pushData(new StringData(`Hello${i}`, i % 2));
37.     }
38.   }

39.   build() {
40.     List({ space: 3 }) {
41.       LazyForEach(this.data, (item: StringData, index: number) => {
42.         ListItem() {
43.           // 开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板
44.           if (item.getType() == 0) {
45.             // 模板A
46.             ChildComponentA({ data: item })
47.               .onAppear(() => {
48.                 console.info(`type A onAppear: ${item.message}`);
49.               })
50.           } else {
51.             // 模板B
52.             ChildComponentB({ data: item })
53.               .onAppear(() => {
54.                 console.info(`type B onAppear: ${item.message}`);
55.               })
56.           }
57.         }
58.       }, (item: StringData, index: number) => index.toString())
59.     }.cachedCount(5)
60.   }
61. }

62. // 使用@Reusable实现组件复用
63. @Reusable
64. @Component
65. struct ChildComponentA {
66.   @State data: StringData = new StringData('', 0);

67.   aboutToAppear(): void {
68.     console.info(`type A aboutToAppear: ${this.data.message}`);
69.   }

70.   aboutToRecycle(): void {
71.     console.info(`type A aboutToRecycle: ${this.data.message}`);
72.   }

73.   aboutToReuse(params: Record<string, ESObject>): void {
74.     this.data = params.data as StringData;
75.     console.info(`type A aboutToReuse: ${this.data.message}`);
76.   }

77.   build() {
78.     Row() {
79.       Text(this.data.message).fontSize(50)
80.       Button('Type A')
81.     }
82.   }
83. }

84. @Reusable
85. @Component
86. struct ChildComponentB {
87.   @State data: StringData = new StringData('', 0);

88.   aboutToAppear(): void {
89.     console.info(`type B aboutToAppear: ${this.data.message}`);
90.   }

91.   aboutToRecycle(): void {
92.     console.info(`type B aboutToRecycle: ${this.data.message}`);
93.   }

94.   aboutToReuse(params: Record<string, ESObject>): void {
95.     this.data = params.data as StringData;
96.     console.info(`type B aboutToReuse: ${this.data.message}`);
97.   }

98.   build() {
99.     Row() {
100.       Text(this.data.message).fontSize(50).fontColor(Color.Gray)
101.       Text('Type B')
102.     }
103.   }
104. }

**迁移Repeat**

Repeat本身具备模板渲染能力，开发者可以通过[templateId](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#templateid)方法为不同的数据项选择不同的模板，再通过[template](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#template)方法为不同的模板配置不同的组件生成函数。同时，开发者仍然可以选择自己实现逻辑判断，为不同的数据项分配不同的模板。

需要注意的是，如果开发者选择自己实现模板渲染，则需要关闭Repeat自身的复用功能。否则，Repeat在复用子组件时无法选择正确的模板，会导致渲染异常。

**示例8 - 迁移方案1：使用Repeat自身的模板渲染能力**

1. class StringData {
2.   message: string;
3.   type: number;

4.   constructor(message: string, type: number) {
5.     this.message = message;
6.     this.type = type;
7.   }

8.   getType(): number {
9.     if (this.type >= 1) {
10.       return 1;
11.     } else {
12.       return 0;
13.     }
14.   }
15. }

16. @Entry
17. @ComponentV2
18. struct MyComponent {
19.   data: StringData[] = [];

20.   aboutToAppear() {
21.     for (let i = 0; i <= 200; i++) {
22.       this.data.push(new StringData(`Hello${i}`, i % 2));
23.     }
24.   }

25.   build() {
26.     List({ space: 3 }) {
27.       Repeat(this.data)
28.         .each((repeatItem) => {
29.           ListItem() {
30.             Text('Default item')
31.           }
32.         })
33.         .template('A', (repeatItem) => { // 模板A
34.           ListItem() {
35.             Row() {
36.               Text(repeatItem.item.message).fontSize(50)
37.               Button('Type A')
38.             }
39.           }
40.         })
41.         .template('B', (repeatItem) => { // 模板B
42.           ListItem() {
43.             Row() {
44.               Text(repeatItem.item.message).fontSize(50).fontColor(Color.Gray)
45.               Text('Type B')
46.             }
47.           }
48.         })
49.         .templateId((item: StringData) => { // 为不同的数据项选择不同的模板
50.           if (item.getType() == 0) {
51.             return 'A';
52.           } else {
53.             return 'B';
54.           }
55.         })
56.         .key((item: StringData, index: number) => index.toString())
57.         .virtualScroll()
58.     }.cachedCount(5)
59.   }
60. }

**示例8 - 迁移方案2：由开发者实现模板渲染能力**

1. class StringData {
2.   message: string;
3.   type: number;

4.   constructor(message: string, type: number) {
5.     this.message = message;
6.     this.type = type;
7.   }

8.   getType(): number {
9.     if (this.type >= 1) {
10.       return 1;
11.     } else {
12.       return 0;
13.     }
14.   }
15. }

16. @Entry
17. @ComponentV2
18. struct MyComponent {
19.   data: StringData[] = [];

20.   aboutToAppear() {
21.     for (let i = 0; i <= 200; i++) {
22.       this.data.push(new StringData(`Hello${i}`, i % 2));
23.     }
24.   }

25.   build() {
26.     List({ space: 3 }) {
27.       Repeat(this.data)
28.         .each((repeatItem) => {
29.           ListItem() {
30.             // 开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板
31.             if (repeatItem.item.getType() == 0) {
32.               ChildComponentA({ data: repeatItem.item }) // 模板A
33.                 .onAppear(() => {
34.                   console.info(`type A onAppear: ${repeatItem.item.message}`);
35.                 })
36.             } else {
37.               ChildComponentB({ data: repeatItem.item }) // 模板B
38.                 .onAppear(() => {
39.                   console.info(`type B onAppear: ${repeatItem.item.message}`);
40.                 })
41.             }
42.           }
43.         })
44.         .key((item: StringData, index: number) => index.toString())
45.         .virtualScroll({ reusable: false }) // 关闭Repeat自身的复用功能（API 19），避免渲染异常
46.     }.cachedCount(5)
47.   }
48. }

49. // 使用@ReusableV2实现组件复用（API 18）
50. @ReusableV2
51. @ComponentV2
52. struct ChildComponentA {
53.   @Param data: StringData = new StringData('', 0);

54.   aboutToAppear(): void {
55.     console.info(`type A aboutToAppear: ${this.data.message}`);
56.   }

57.   aboutToRecycle(): void {
58.     console.info(`type A aboutToRecycle: ${this.data.message}`);
59.   }

60.   aboutToReuse(): void {
61.     console.info(`type A aboutToReuse: ${this.data.message}`);
62.   }

63.   build() {
64.     Row() {
65.       Text(this.data.message).fontSize(50)
66.       Button('Type A')
67.     }
68.   }
69. }

70. @ReusableV2
71. @ComponentV2
72. struct ChildComponentB {
73.   @Param data: StringData = new StringData('', 0);

74.   aboutToAppear(): void {
75.     console.info(`type B aboutToAppear: ${this.data.message}`);
76.   }

77.   aboutToRecycle(): void {
78.     console.info(`type B aboutToRecycle: ${this.data.message}`);
79.   }

80.   aboutToReuse(): void {
81.     console.info(`type B aboutToReuse: ${this.data.message}`);
82.   }

83.   build() {
84.     Row() {
85.       Text(this.data.message).fontSize(50).fontColor(Color.Gray)
86.       Text('Type B')
87.     }
88.   }
89. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.16951959361312922505157389391226:50001231000000:2800:13C72E252FDC6CE53545D7A59467B7BD1037B80FD52FCFA7AE75684E3288912F.gif)

## BasicDataSource示例代码

### string类型数组的BasicDataSource代码

1. // BasicDataSource实现了IDataSource接口，用于管理listener监听，以及通知LazyForEach数据更新
2. class BasicDataSource implements IDataSource {
3.   private listeners: DataChangeListener[] = [];
4.   private originDataArray: string[] = [];

5.   public totalCount(): number {
6.     return this.originDataArray.length;
7.   }

8.   public getData(index: number): string {
9.     return this.originDataArray[index];
10.   }

11.   // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
12.   registerDataChangeListener(listener: DataChangeListener): void {
13.     if (this.listeners.indexOf(listener) < 0) {
14.       console.info('add listener');
15.       this.listeners.push(listener);
16.     }
17.   }

18.   // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
19.   unregisterDataChangeListener(listener: DataChangeListener): void {
20.     const pos = this.listeners.indexOf(listener);
21.     if (pos >= 0) {
22.       console.info('remove listener');
23.       this.listeners.splice(pos, 1);
24.     }
25.   }

26.   // 通知LazyForEach组件需要重载所有子组件
27.   notifyDataReload(): void {
28.     this.listeners.forEach(listener => {
29.       listener.onDataReloaded();
30.     });
31.   }

32.   // 通知LazyForEach组件需要在index对应索引处添加子组件
33.   notifyDataAdd(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataAdd(index);
36.       // 写法2：listener.onDatasetChange([{type: DataOperationType.ADD, index: index}]);
37.     });
38.   }

39.   // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
40.   notifyDataChange(index: number): void {
41.     this.listeners.forEach(listener => {
42.       listener.onDataChange(index);
43.       // 写法2：listener.onDatasetChange([{type: DataOperationType.CHANGE, index: index}]);
44.     });
45.   }

46.   // 通知LazyForEach组件需要在index对应索引处删除该子组件
47.   notifyDataDelete(index: number): void {
48.     this.listeners.forEach(listener => {
49.       listener.onDataDelete(index);
50.       // 写法2：listener.onDatasetChange([{type: DataOperationType.DELETE, index: index}]);
51.     });
52.   }

53.   // 通知LazyForEach组件将from索引和to索引处的子组件进行交换
54.   notifyDataMove(from: number, to: number): void {
55.     this.listeners.forEach(listener => {
56.       listener.onDataMove(from, to);
57.       // 写法2：listener.onDatasetChange(
58.       //         [{type: DataOperationType.EXCHANGE, index: {start: from, end: to}}]);
59.     });
60.   }

61.   notifyDatasetChange(operations: DataOperation[]): void {
62.     this.listeners.forEach(listener => {
63.       listener.onDatasetChange(operations);
64.     });
65.   }
66. }

### StringData类型数组的BasicDataSource代码

1. class BasicDataSource implements IDataSource {
2.   private listeners: DataChangeListener[] = [];
3.   private originDataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.originDataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.originDataArray[index];
9.   }

10.   registerDataChangeListener(listener: DataChangeListener): void {
11.     if (this.listeners.indexOf(listener) < 0) {
12.       console.info('add listener');
13.       this.listeners.push(listener);
14.     }
15.   }

16.   unregisterDataChangeListener(listener: DataChangeListener): void {
17.     const pos = this.listeners.indexOf(listener);
18.     if (pos >= 0) {
19.       console.info('remove listener');
20.       this.listeners.splice(pos, 1);
21.     }
22.   }

23.   notifyDataReload(): void {
24.     this.listeners.forEach(listener => {
25.       listener.onDataReloaded();
26.     });
27.   }

28.   notifyDataAdd(index: number): void {
29.     this.listeners.forEach(listener => {
30.       listener.onDataAdd(index);
31.     });
32.   }

33.   notifyDataChange(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataChange(index);
36.     });
37.   }

38.   notifyDataDelete(index: number): void {
39.     this.listeners.forEach(listener => {
40.       listener.onDataDelete(index);
41.     });
42.   }

43.   notifyDataMove(from: number, to: number): void {
44.     this.listeners.forEach(listener => {
45.       listener.onDataMove(from, to);
46.     });
47.   }

48.   notifyDatasetChange(operations: DataOperation[]): void {
49.     this.listeners.forEach(listener => {
50.       listener.onDatasetChange(operations);
51.     });
52.   }
53. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat "Repeat：可复用的循环渲染")
# LazyForEach迁移Repeat指南

更新时间: 2025-12-16 16:39

[Repeat](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat)是ArkUI在API version 12中新引入的循环渲染组件，相比[LazyForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)具有更简洁的API、更丰富的功能以及更强的性能优化能力。本指南帮助开发者将LazyForEach平滑地迁移到Repeat。

## 基础用法迁移

### 数据首次渲染

**LazyForEach示例**

LazyForEach根据数据源循环渲染子组件。

示例1中，在容器组件[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list)中使用LazyForEach，并基于数据源循环渲染出了一系列[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display)子组件。

**示例1 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Entry
16. @Component
17. struct MyComponent {
18.   private data: MyDataSource = new MyDataSource();

19.   aboutToAppear() {
20.     for (let i = 0; i <= 20; i++) {
21.       this.data.pushData(`Hello ${i}`);
22.     }
23.   }

24.   build() {
25.     List({ space: 3 }) {
26.       LazyForEach(this.data, (item: string) => {
27.         ListItem() {
28.           Row() {
29.             Text(item).fontSize(50)
30.               .onAppear(() => {
31.                 console.info(`appear: ${item}`);
32.               })
33.           }.margin({ left: 10, right: 10 })
34.         }
35.       }, (item: string) => item)
36.     }.cachedCount(5)
37.   }
38. }

以上是一个典型的使用LazyForEach循环渲染子组件的场景，下面将介绍如何将此示例迁移至Repeat。

**迁移步骤**

1. 使用状态管理V2装饰器。
    
    Repeat推荐和状态管理V2装饰器配合使用（[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E8%83%BD%E5%8A%9B%E8%AF%B4%E6%98%8E)模式下只支持和状态管理V2装饰器配合使用）。如果之前使用的是状态管理V1装饰器，需要修改为状态管理V2装饰器。
    
    1. // 迁移前 - LazyForEach
    2. @Component // 状态管理V1
    3. struct MyComponent {
    4.   build() {
    5.     // ...
    6.     LazyForEach(...)
    7.     // ...
    8.   }
    9.   // ...其他属性、方法
    10. }
    
    11. // 迁移后 - Repeat
    12. @ComponentV2 // 状态管理V2
    13. struct MyComponent {
    14.   build() {
    15.     // ...
    16.     Repeat(...)
    17.     // ...
    18.   }
    19.   // ...其他属性、方法
    20. }
    
2. 迁移数据源。
    
    LazyForEach使用专用的数据结构[IDataSource](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#idatasource)作为数据源。迁移至Repeat后，不再使用IDataSource作为数据源，而是使用状态管理V2装饰的数组作为数据源。
    
    1. // 迁移前 - LazyForEach
    2. class MyDataSource implements IDataSource {
    3.   private dataArray: string[] = [];
    
    4.   public totalCount(): number {
    5.     return this.dataArray.length;
    6.   }
    
    7.   public getData(index: number): string {
    8.     return this.dataArray[index];
    9.   }
    
    10.   // ...其他方法
    11. }
    
    12. // 迁移后 - Repeat
    13. @Local data: Array<string> = [];
    
3. 迁移组件生成函数和键值生成函数。
    
    LazyForEach与Repeat均通过组件生成函数，为每一项数据创建一个子组件；通过键值生成函数，为每一项数据生成一个唯一的键值。
    
    从LazyForEach迁移至Repeat时，两者的语法存在差异。Repeat需要在[.each()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#each)或[.template()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#template)中设置组件生成函数，在[.key()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#key)中设置键值生成函数。
    
    1. // 迁移前 - LazyForEach
    2. List() {
    3.   LazyForEach(
    4.     this.data, // 数据源
    5.     (item: string, index: number) => { // 组件生成函数
    6.       ListItem() {
    7.         Text(item)
    8.       }
    9.     },
    10.     (item: string, index: number) => item // 键值生成函数
    11.   )
    12. }
    
    13. // 迁移后 - Repeat
    14. List() {
    15.   Repeat<string>(this.data) // 数据源
    16.     .each((repeatItem: RepeatItem<string>) => { // 组件生成函数
    17.       ListItem() {
    18.         Text(repeatItem.item)
    19.       }
    20.     })
    21.     .key((item: string, index: number) => item) // 键值生成函数
    22. }
    
4. 配置懒加载功能。
    
    Repeat具有[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E8%83%BD%E5%8A%9B%E8%AF%B4%E6%98%8E)和[全量加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%85%B3%E9%97%AD%E6%87%92%E5%8A%A0%E8%BD%BD)两种模式。
    
    - 全量加载模式渲染所有子节点（对标[ForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)）。
    - 懒加载模式动态渲染屏幕区域和预加载区域内的子节点（需要与容器组件配合使用，对标LazyForEach）。
    
    从LazyForEach迁移至Repeat时，需要调用[virtualScroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#virtualscroll))属性，使能懒加载。
    
    1. // 迁移前 - LazyForEach
    2. LazyForEach(data, (item) => {...}, (item) => item)
    
    3. // 迁移后 - Repeat
    4. Repeat(data)
    5.   .virtualScroll() // 使能懒加载
    

**迁移后代码**

通过以上步骤，可以将示例1从LazyForEach迁移至Repeat，迁移后的完整示例如下所示。

**示例1 - 迁移后**

1. @Entry
2. @ComponentV2 // 使用状态管理V2
3. struct MyComponent {
4.   @Local data: Array<string> = []; // 数据源为状态管理V2装饰的数组

5.   aboutToAppear() {
6.     for (let i = 0; i <= 20; i++) {
7.       this.data.push(`Hello ${i}`);
8.     }
9.   }

10.   build() {
11.     List({ space: 3 }) {
12.       Repeat(this.data) // 使用Repeat
13.         .each((repeatItem: RepeatItem<string>) => { // 组件生成函数
14.           ListItem() {
15.             Row() {
16.               Text(repeatItem.item).fontSize(50)
17.                 .onAppear(() => {
18.                   console.info(`appear: ${repeatItem.item}`);
19.                 })
20.             }.margin({ left: 10, right: 10 })
21.           }
22.         })
23.         .key((item: string) => item) // 键值生成函数
24.         .virtualScroll() // 使能懒加载
25.     }.cachedCount(5)
26.   }
27. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.62687963044335291653345093467222:50001231000000:2800:E646A9E8F759C173C6DA35673112979325C60EE00AD6B6D6653A61C483F5895B.gif)

### 数据更新操作

**LazyForEach示例**

当LazyForEach的数据源发生变化时，开发者需要根据数据源的变化情况调用[DataChangeListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#datachangelistener)对应的接口，通知LazyForEach做相应的更新。主要的数据操作包括：添加数据、删除数据、交换数据、修改单个数据、修改多个数据、精准批量修改数据。

示例2演示了主要的数据操作。

**示例2 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   // 添加数据
11.   public pushData(data: string): void {
12.     this.dataArray.push(data);
13.     this.notifyDataAdd(this.dataArray.length - 1);
14.   }

15.   // 删除数据
16.   public deleteData(index: number): void {
17.     this.dataArray.splice(index, 1);
18.     this.notifyDataDelete(index);
19.   }

20.   // 交换数据
21.   public moveData(from: number, to: number): void {
22.     let temp: string = this.dataArray[from];
23.     this.dataArray[from] = this.dataArray[to];
24.     this.dataArray[to] = temp;
25.     this.notifyDataMove(from, to);
26.   }

27.   // 修改单个数据
28.   public changeData(index: number, data: string): void {
29.     this.dataArray.splice(index, 1, data);
30.     this.notifyDataChange(index);
31.   }

32.   // 修改多个数据
33.   public modifyAllData(): void {
34.     this.dataArray = this.dataArray.map((item: string) => {
35.         return 'Changed ' + item;
36.     });
37.     this.notifyDataReload();
38.   }
39. }

40. @Entry
41. @Component
42. struct MyComponent {
43.   private data: MyDataSource = new MyDataSource();
44.   private count: number = 0;

45.   aboutToAppear() {
46.     for (let i = 0; i <= 10; i++) {
47.       this.data.pushData(`Hello ${i}`);
48.     }
49.   }

50.   build() {
51.     Column({ space: 3 }) {
52.       // 点击追加子组件
53.       Button('Add new item')
54.         .onClick(() => {
55.           this.data.pushData(`New item ${this.count++}`);
56.         })
57.       // 点击删除子组件
58.       Button('Delete item 0')
59.         .onClick(() => {
60.           this.data.deleteData(0);
61.         })
62.       // 点击交换子组件
63.       Button('Swap item 0 and item 1')
64.         .onClick(() => {
65.           this.data.moveData(0, 1);
66.         })
67.       // 点击修改单个子组件
68.       Button('Change item 0')
69.         .onClick(() => {
70.           this.data.changeData(0, `Changed item ${this.count++}`);
71.         })
72.       // 点击修改多个子组件
73.       Button('Change all items')
74.         .onClick(() => {
75.           this.data.modifyAllData();
76.         })
77.       List({ space: 3 }) {
78.         LazyForEach(this.data, (item: string) => {
79.           ListItem() {
80.             Row() {
81.               Text(item).fontSize(25)
82.             }
83.           }
84.         }, (item: string) => item)
85.       }.cachedCount(5)
86.     }
87.   }
88. }

以上是一个典型的更新数据后LazyForEach重新渲染子组件的场景，下面将介绍如何将此示例迁移至Repeat。

**迁移步骤**

1. 迁移准备。
    
    根据数据首次渲染小节中的步骤，将LazyForEach替换为Repeat。
    
    1. 使用状态管理V2装饰器。
    2. 迁移数据源。
    3. 迁移组件生成函数与键值生成函数。
    4. 使能懒加载。
2. 迁移数据源修改方式。
    
    - 对于LazyForEach，在修改数据源后需要调用对应的接口通知其更新。
    - 对于Repeat，由状态管理V2监听其数据源变化，并触发更新。因此，开发者直接修改数据源即可，无需其他额外操作。
    
    1. // 以修改单个数据为例
    2. // 迁移前 - LazyForEach
    3. class MyDataSource implements IDataSource {
    4.   private dataArray: string[] = [];
    
    5.   public changeData(index: number, newData: string): void {
    6.     this.dataArray.splice(index, 1, data);
    7.     this.notifyDataChange(index);
    8.   }
    
    9.   // ...其他方法
    10. }
    
    11. // 迁移后 - Repeat
    12. this.data.splice(index, 1, data);
    
    其他数据更新操作，如添加数据、删除数据、交换数据等，与以上方法类似，可通过直接修改数据源数组实现。
    

**迁移后代码**

迁移后的完整示例如下。

**示例2 - 迁移后**

1. @Entry
2. @ComponentV2
3. struct MyComponent {
4.   @Local data: Array<string> = [];
5.   private count: number = 0;

6.   aboutToAppear() {
7.     for (let i = 0; i <= 10; i++) {
8.       this.data.push(`Hello ${i}`);
9.     }
10.   }

11.   build() {
12.     Column({ space: 3 }) {
13.       // 点击追加子组件
14.       Button('Add new item')
15.         .onClick(() => { this.data.push(`New item ${this.count++}`); })
16.       // 点击删除子组件
17.       Button('Delete item 0')
18.         .onClick(() => { this.data.splice(0, 1); })
19.       // 点击交换子组件
20.       Button('Swap item 0 and item 1')
21.         .onClick(() => { let temp: string = this.data[0];
22.                          this.data[0] = this.data[1];
23.                          this.data[1] = temp; })
24.       // 点击修改单个子组件
25.       Button('Change item 0')
26.         .onClick(() => { this.data.splice(0, 1, `Changed item ${this.count++}`); })
27.       // 点击修改多个子组件
28.       Button('Change all items')
29.         .onClick(() => { this.data = this.data.map((item: string) => { return 'Changed ' + item; }); })
30.       List({ space: 3 }) {
31.         Repeat(this.data)
32.           .each((repeatItem: RepeatItem<string>) => {
33.             ListItem() {
34.               Row() {
35.                 Text(repeatItem.item).fontSize(25)
36.               }
37.             }
38.           })
39.           .key((item: string) => item)
40.           .virtualScroll()
41.       }.cachedCount(5)
42.     }
43.   }
44. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.11265996241335720350651991932968:50001231000000:2800:F4FD69EEBCCC06E46710835E4A45D5C513032A0460CCAE3FB242E4CBA0728C6A.gif)

## 典型场景迁移

### 修改数据子属性

**LazyForEach示例**

LazyForEach可以使用[@Observed与@ObjectLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-observed-and-objectlink)装饰器实现对数据子属性的观测。当有数据子属性发生变化时，仅更新使用了该子属性的组件，从而提高性能。

示例3演示了对子属性的观测。

**示例3 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Observed
16. class StringData {
17.   message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @Component
24. struct MyComponent {
25.   private data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item })
36.         }
37.         .onClick(() => {
38.           item.message += '0';
39.         })
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @Component
45. struct ChildComponent {
46.   @ObjectLink data: StringData;

47.   build() {
48.     Row() {
49.       Text(this.data.message).fontSize(50)
50.         .onAppear(() => {
51.           console.info(`appear: ${this.data.message}`);
52.         })
53.     }.margin({ left: 10, right: 10 })
54.   }
55. }

**迁移Repeat**

Repeat需要和状态管理V2一起使用，状态管理V2提供了[@ObserveV2和@Trace](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-observedv2-and-trace)装饰器对子属性进行深度观测。迁移时，需要将@Observe和@ObjectLink装饰器迁移至@ObserveV2和@Trace装饰器。

迁移后的示例如下所示。

**示例3 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string; // 观测子属性

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             Text(repeatItem.item.message).fontSize(50)
23.               .onAppear(() => {
24.                 console.info(`appear: ${repeatItem.item.message}`);
25.               })
26.           }
27.           .onClick(() => {
28.             repeatItem.item.message += '0';
29.           })
30.         })
31.         .key((item: StringData, index: number) => index.toString())
32.         .virtualScroll()
33.     }.cachedCount(5)
34.   }
35. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.32541381118823681067088850163641:50001231000000:2800:6DC836D57AD8076BADB0DA63972483D68B833E42BD062B584B80D32363B0530D.gif)

### 状态管理V2观测组件内部状态

**LazyForEach示例**

状态管理V2的[@Local](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-local)装饰器提供了观测自定义组件内部变量的能力。被@Local装饰的变量发生变化时，会通知LazyForEach更新对应的组件。

示例4演示了在LazyForEach中使用@Local装饰器观测数据变化，触发组件更新。

**示例4 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           Row() {
36.             Text(item.message).fontSize(50)
37.               .onClick(() => {
38.                 // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
39.                 item.message += '!';
40.               })
41.             ChildComponent()
42.           }
43.         }
44.       }, (item: StringData, index: number) => index.toString())
45.     }.cachedCount(5)
46.   }
47. }

48. @ComponentV2
49. struct ChildComponent {
50.   @Local message: string = '?';

51.   build() {
52.     Row() {
53.       Text(this.message).fontSize(50)
54.         .onClick(() => {
55.           // 修改@Local装饰的变量，触发刷新此处Text组件
56.           this.message += '?';
57.         })
58.     }
59.   }
60. }

**迁移Repeat**

Repeat本身支持与状态管理V2联合使用，将LazyForEach相关代码修改为Repeat后，即可实现对组件内部状态变量的观测。

迁移后的示例如下所示。

**示例4 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string;

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             Row() {
23.               Text(repeatItem.item.message).fontSize(50)
24.                 .onClick(() => {
25.                   // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
26.                   repeatItem.item.message += '!';
27.                 })
28.               ChildComponent()
29.             }
30.           }
31.         })
32.         .key((item: StringData, index: number) => index.toString())
33.         .virtualScroll()
34.     }.cachedCount(5)
35.   }
36. }

37. @ComponentV2
38. struct ChildComponent {
39.   @Local message: string = '?';

40.   build() {
41.     Row() {
42.       Text(this.message).fontSize(50)
43.         .onClick(() => {
44.           // 修改@Local装饰的变量，触发刷新此处Text组件
45.           this.message += '?';
46.         })
47.     }
48.   }
49. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.07940817595587609092357466015835:50001231000000:2800:55F4286074152FE31295E59C0F225F1BD4F9819FEADF363E992B70AC51CA12C5.gif)

### 状态管理V2观测组件外部输入

**LazyForEach示例**

状态管理V2的[@Param](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-param)装饰器提供了观测自定义组件外部输入变量的能力，可以实现父子组件间的数据同步。将父组件的变量传递给子组件，并用@Param装饰，当父组件变量发生变化时，会通知对应的组件更新。

示例5演示了在LazyForEach中使用@Param装饰器观测数据变化，触发组件更新。

**示例5 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item.message }) // 向自定义组件内传入变量
36.             .onClick(() => {
37.               item.message += '!';
38.             })
39.         }
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @ComponentV2
45. struct ChildComponent {
46.   @Param @Require data: string = ''; // 接收来自外部的变量

47.   build() {
48.     Row() {
49.       Text(this.data).fontSize(50)
50.     }
51.   }
52. }

**迁移Repeat**

Repeat本身支持与状态管理V2联合使用，将LazyForEach相关代码修改为Repeat后，即可实现对组件外部输入状态变量的观测。

迁移后的示例如下所示。

**示例5 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string;

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             ChildComponent({ data: repeatItem.item.message }) // 向自定义组件内传入变量
23.               .onClick(() => {
24.                 repeatItem.item.message += '!';
25.               })
26.           }
27.         })
28.         .key((item: StringData, index: number) => index.toString())
29.         .virtualScroll()
30.     }.cachedCount(5)
31.   }
32. }

33. @ComponentV2
34. struct ChildComponent {
35.   @Param @Require data: string = ''; // 接收来自外部的变量

36.   build() {
37.     Row() {
38.       Text(this.data).fontSize(50)
39.     }
40.   }
41. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.90430579311480355869393459661229:50001231000000:2800:D4D2486C4784B911F9EE9A49363DC9C8BDDA17CD0B1BC1A8E5741ECB7881C668.gif)

### 拖拽排序

**LazyForEach示例**

LazyForEach的[onMove](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-drag-sorting#onmove)属性提供了拖拽排序能力。

示例6为典型用例。

**示例6 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public moveDataWithoutNotify(from: number, to: number): void {
11.     let tmp = this.dataArray.splice(from, 1);
12.     this.dataArray.splice(to, 0, tmp[0]);
13.   }

14.   public pushData(data: string): void {
15.     this.dataArray.push(data);
16.     this.notifyDataAdd(this.dataArray.length - 1);
17.   }
18. }

19. @Entry
20. @Component
21. struct Parent {
22.   private data: MyDataSource = new MyDataSource();

23.   aboutToAppear(): void {
24.     for (let i = 0; i < 100; i++) {
25.       this.data.pushData(i.toString());
26.     }
27.   }

28.   build() {
29.     Row() {
30.       List() {
31.         LazyForEach(this.data, (item: string) => {
32.           ListItem() {
33.             Text(item.toString())
34.               .fontSize(16)
35.               .textAlign(TextAlign.Center)
36.               .size({ height: 100, width: '100%' })
37.           }.margin(10)
38.           .borderRadius(10)
39.           .backgroundColor('#FFFFFFFF')
40.         }, (item: string) => item)
41.           .onMove((from: number, to: number) => { // 实现拖拽排序
42.             this.data.moveDataWithoutNotify(from, to);
43.           })
44.       }
45.       .width('100%')
46.       .height('100%')
47.       .backgroundColor('#FFDCDCDC')
48.     }
49.   }
50. }

**迁移Repeat**

Repeat具有与LazyForEach相同的onMove属性。将LazyForEach相关代码修改为Repeat后，即可实现拖拽排序。

迁移后的示例如下所示。

**示例6 - 迁移后**

1. @Entry
2. @ComponentV2
3. struct Parent {
4.   @Local data: string[] = [];

5.   aboutToAppear(): void {
6.     for (let i = 0; i < 100; i++) {
7.       this.data.push(i.toString());
8.     }
9.   }

10.   moveData(from: number, to: number) {
11.     let tmp = this.data.splice(from, 1);
12.     this.data.splice(to, 0, tmp[0]);
13.   }

14.   build() {
15.     Row() {
16.       List() {
17.         Repeat(this.data)
18.           .each((repeatItem) => {
19.             ListItem() {
20.               Text(repeatItem.item.toString())
21.                 .fontSize(16)
22.                 .textAlign(TextAlign.Center)
23.                 .size({ height: 100, width: '100%' })
24.             }.margin(10)
25.             .borderRadius(10)
26.             .backgroundColor('#FFFFFFFF')
27.           })
28.           .key((item: string) => item)
29.           .virtualScroll()
30.           .onMove((from: number, to: number) => { // 实现拖拽排序
31.             this.moveData(from, to);
32.           })
33.       }
34.       .width('100%')
35.       .height('100%')
36.       .backgroundColor('#FFDCDCDC')
37.     }
38.   }
39. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.50484491938529264108091518082071:50001231000000:2800:7CAE3B2495540FB53C8B4D3E84D871A4940E6E483AA646ACA1E03F8F75D22A5D.gif)

### 组件复用

**LazyForEach示例**

LazyForEach自身并不具备组件复用能力，为实现组件复用，需要与[@Reusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable)装饰器配合使用（被@Reusable装饰的自定义组件具有复用能力）。

示例7演示了组件复用的典型场景。

**示例7 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   message: string;

17.   constructor(message: string) {
18.     this.message = message;
19.   }
20. }

21. @Entry
22. @Component
23. struct MyComponent {
24.   data: MyDataSource = new MyDataSource();

25.   aboutToAppear() {
26.     for (let i = 0; i <= 30; i++) {
27.       this.data.pushData(new StringData(`Hello${i}`));
28.     }
29.   }

30.   build() {
31.     List({ space: 3 }) {
32.       LazyForEach(this.data, (item: StringData, index: number) => {
33.         ListItem() {
34.           ChildComponent({ data: item })
35.             .onAppear(() => {
36.               console.info(`onAppear: ${item.message}`);
37.             })
38.         }
39.       }, (item: StringData, index: number) => index.toString())
40.     }.cachedCount(5)
41.   }
42. }

43. @Reusable
44. @Component
45. struct ChildComponent {
46.   @State data: StringData = new StringData('');

47.   aboutToAppear(): void {
48.     console.info(`aboutToAppear: ${this.data.message}`);
49.   }

50.   aboutToRecycle(): void {
51.     console.info(`aboutToRecycle: ${this.data.message}`);
52.   }

53.   // 对复用的组件进行数据更新
54.   aboutToReuse(params: Record<string, ESObject>): void {
55.     this.data = params.data as StringData;
56.     console.info(`aboutToReuse: ${this.data.message}`);
57.   }

58.   build() {
59.     Row() {
60.       Text(this.data.message).fontSize(50)
61.     }
62.   }
63. }

**迁移Repeat**

Repeat本身具备组件复用能力，同时也支持与状态管理V2的[@ReusableV2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-reusablev2)装饰器联合使用。因此，迁移至Repeat后，其组件复用具有两种实现方案。

1. 直接使用Repeat自身的复用能力。
2. 使用@ReusableV2装饰器提供的复用能力。

需要注意的是，Repeat默认使能自身的复用能力，且优先级高于@ReusableV2装饰器。若要使用@ReusableV2装饰器，需要先手动关闭Repeat自身的复用能力（@ReusableV2装饰器从API version 18开始支持，Repeat从API version 19开始支持关闭自身复用能力）。

**示例7 - 迁移方案1：使用Repeat自身的复用能力**

Repeat本身具备复用能力，且默认开启。将LazyForEach相关代码迁移至Repeat后，便已经具备了复用能力。

修改后的示例如下。

1. class StringData {
2.   message: string;

3.   constructor(message: string) {
4.     this.message = message;
5.   }
6. }

7. @Entry
8. @ComponentV2
9. struct MyComponent {
10.   @Local data: StringData[] = [];

11.   aboutToAppear() {
12.     for (let i = 0; i <= 30; i++) {
13.       this.data.push(new StringData(`Hello${i}`));
14.     }
15.   }

16.   build() {
17.     List({ space: 3 }) {
18.       Repeat(this.data) // Repeat自身具备复用功能
19.         .each((repeatItem) => {
20.           ListItem() {
21.             Text(repeatItem.item.message).fontSize(50)
22.           }
23.         })
24.         .key((item: StringData, index: number) => index.toString())
25.         .virtualScroll()
26.     }.cachedCount(5)
27.   }
28. }

**示例7 - 迁移方案2：使用@ReusableV2装饰器**

若要使用@ReusableV2装饰器，首先需要通过.virtualScroll({ reusable: false })关闭Repeat自身的复用功能，再用@ReusableV2装饰需要复用的自定义组件。

相较于Repeat自身的复用，@ReusableV2装饰的自定义组件在回收和复用时，会触发aboutToRecycle和aboutToReuse两个生命周期。

使用@ReusableV2装饰器的迁移示例如下所示。

1. class StringData {
2.   message: string;

3.   constructor(message: string) {
4.     this.message = message;
5.   }
6. }

7. @Entry
8. @ComponentV2
9. struct MyComponent {
10.   @Local data: StringData[] = [];

11.   aboutToAppear() {
12.     for (let i = 0; i <= 30; i++) {
13.       this.data.push(new StringData(`Hello${i}`));
14.     }
15.   }

16.   build() {
17.     List({ space: 3 }) {
18.       Repeat(this.data)
19.         .each((repeatItem) => {
20.           ListItem() {
21.             ChildComponent({ data: repeatItem.item })
22.               .onAppear(() => {
23.                 console.info(`onAppear: ${repeatItem.item.message}`);
24.               })
25.           }
26.         })
27.         .key((item: StringData, index: number) => index.toString())
28.         .virtualScroll({ reusable: false }) // 关闭Repeat自身的复用功能（API 19）
29.     }.cachedCount(5)
30.   }
31. }

32. // 使用@ReusableV2实现组件复用（API 18）
33. @ReusableV2
34. @ComponentV2
35. struct ChildComponent {
36.   @Param data: StringData = new StringData('');

37.   aboutToAppear(): void {
38.     console.info(`aboutToAppear: ${this.data.message}`);
39.   }

40.   aboutToRecycle(): void {
41.     console.info(`aboutToRecycle: ${this.data.message}`);
42.   }

43.   aboutToReuse(): void {
44.     console.info(`aboutToReuse: ${this.data.message}`);
45.   }

46.   build() {
47.     Row() {
48.       Text(this.data.message).fontSize(50)
49.     }
50.   }
51. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.24263212202420592585590536450661:50001231000000:2800:16BFB5890C31649EC35FF4CE09025AA08349FC37026607631E2C028628AD3731.gif)

### 模板渲染

**LazyForEach示例**

LazyForEach自身并不具备模板渲染能力。为实现模板渲染能力，需要开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板。

示例8演示了模板渲染的典型场景。

**示例8 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   message: string;
17.   type: number;

18.   constructor(message: string, type: number) {
19.     this.message = message;
20.     this.type = type;
21.   }

22.   getType(): number {
23.     if (this.type >= 1) {
24.       return 1;
25.     } else {
26.       return 0;
27.     }
28.   }
29. }

30. @Entry
31. @Component
32. struct MyComponent {
33.   data: MyDataSource = new MyDataSource();

34.   aboutToAppear() {
35.     for (let i = 0; i <= 200; i++) {
36.       this.data.pushData(new StringData(`Hello${i}`, i % 2));
37.     }
38.   }

39.   build() {
40.     List({ space: 3 }) {
41.       LazyForEach(this.data, (item: StringData, index: number) => {
42.         ListItem() {
43.           // 开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板
44.           if (item.getType() == 0) {
45.             // 模板A
46.             ChildComponentA({ data: item })
47.               .onAppear(() => {
48.                 console.info(`type A onAppear: ${item.message}`);
49.               })
50.           } else {
51.             // 模板B
52.             ChildComponentB({ data: item })
53.               .onAppear(() => {
54.                 console.info(`type B onAppear: ${item.message}`);
55.               })
56.           }
57.         }
58.       }, (item: StringData, index: number) => index.toString())
59.     }.cachedCount(5)
60.   }
61. }

62. // 使用@Reusable实现组件复用
63. @Reusable
64. @Component
65. struct ChildComponentA {
66.   @State data: StringData = new StringData('', 0);

67.   aboutToAppear(): void {
68.     console.info(`type A aboutToAppear: ${this.data.message}`);
69.   }

70.   aboutToRecycle(): void {
71.     console.info(`type A aboutToRecycle: ${this.data.message}`);
72.   }

73.   aboutToReuse(params: Record<string, ESObject>): void {
74.     this.data = params.data as StringData;
75.     console.info(`type A aboutToReuse: ${this.data.message}`);
76.   }

77.   build() {
78.     Row() {
79.       Text(this.data.message).fontSize(50)
80.       Button('Type A')
81.     }
82.   }
83. }

84. @Reusable
85. @Component
86. struct ChildComponentB {
87.   @State data: StringData = new StringData('', 0);

88.   aboutToAppear(): void {
89.     console.info(`type B aboutToAppear: ${this.data.message}`);
90.   }

91.   aboutToRecycle(): void {
92.     console.info(`type B aboutToRecycle: ${this.data.message}`);
93.   }

94.   aboutToReuse(params: Record<string, ESObject>): void {
95.     this.data = params.data as StringData;
96.     console.info(`type B aboutToReuse: ${this.data.message}`);
97.   }

98.   build() {
99.     Row() {
100.       Text(this.data.message).fontSize(50).fontColor(Color.Gray)
101.       Text('Type B')
102.     }
103.   }
104. }

**迁移Repeat**

Repeat本身具备模板渲染能力，开发者可以通过[templateId](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#templateid)方法为不同的数据项选择不同的模板，再通过[template](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#template)方法为不同的模板配置不同的组件生成函数。同时，开发者仍然可以选择自己实现逻辑判断，为不同的数据项分配不同的模板。

需要注意的是，如果开发者选择自己实现模板渲染，则需要关闭Repeat自身的复用功能。否则，Repeat在复用子组件时无法选择正确的模板，会导致渲染异常。

**示例8 - 迁移方案1：使用Repeat自身的模板渲染能力**

1. class StringData {
2.   message: string;
3.   type: number;

4.   constructor(message: string, type: number) {
5.     this.message = message;
6.     this.type = type;
7.   }

8.   getType(): number {
9.     if (this.type >= 1) {
10.       return 1;
11.     } else {
12.       return 0;
13.     }
14.   }
15. }

16. @Entry
17. @ComponentV2
18. struct MyComponent {
19.   data: StringData[] = [];

20.   aboutToAppear() {
21.     for (let i = 0; i <= 200; i++) {
22.       this.data.push(new StringData(`Hello${i}`, i % 2));
23.     }
24.   }

25.   build() {
26.     List({ space: 3 }) {
27.       Repeat(this.data)
28.         .each((repeatItem) => {
29.           ListItem() {
30.             Text('Default item')
31.           }
32.         })
33.         .template('A', (repeatItem) => { // 模板A
34.           ListItem() {
35.             Row() {
36.               Text(repeatItem.item.message).fontSize(50)
37.               Button('Type A')
38.             }
39.           }
40.         })
41.         .template('B', (repeatItem) => { // 模板B
42.           ListItem() {
43.             Row() {
44.               Text(repeatItem.item.message).fontSize(50).fontColor(Color.Gray)
45.               Text('Type B')
46.             }
47.           }
48.         })
49.         .templateId((item: StringData) => { // 为不同的数据项选择不同的模板
50.           if (item.getType() == 0) {
51.             return 'A';
52.           } else {
53.             return 'B';
54.           }
55.         })
56.         .key((item: StringData, index: number) => index.toString())
57.         .virtualScroll()
58.     }.cachedCount(5)
59.   }
60. }

**示例8 - 迁移方案2：由开发者实现模板渲染能力**

1. class StringData {
2.   message: string;
3.   type: number;

4.   constructor(message: string, type: number) {
5.     this.message = message;
6.     this.type = type;
7.   }

8.   getType(): number {
9.     if (this.type >= 1) {
10.       return 1;
11.     } else {
12.       return 0;
13.     }
14.   }
15. }

16. @Entry
17. @ComponentV2
18. struct MyComponent {
19.   data: StringData[] = [];

20.   aboutToAppear() {
21.     for (let i = 0; i <= 200; i++) {
22.       this.data.push(new StringData(`Hello${i}`, i % 2));
23.     }
24.   }

25.   build() {
26.     List({ space: 3 }) {
27.       Repeat(this.data)
28.         .each((repeatItem) => {
29.           ListItem() {
30.             // 开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板
31.             if (repeatItem.item.getType() == 0) {
32.               ChildComponentA({ data: repeatItem.item }) // 模板A
33.                 .onAppear(() => {
34.                   console.info(`type A onAppear: ${repeatItem.item.message}`);
35.                 })
36.             } else {
37.               ChildComponentB({ data: repeatItem.item }) // 模板B
38.                 .onAppear(() => {
39.                   console.info(`type B onAppear: ${repeatItem.item.message}`);
40.                 })
41.             }
42.           }
43.         })
44.         .key((item: StringData, index: number) => index.toString())
45.         .virtualScroll({ reusable: false }) // 关闭Repeat自身的复用功能（API 19），避免渲染异常
46.     }.cachedCount(5)
47.   }
48. }

49. // 使用@ReusableV2实现组件复用（API 18）
50. @ReusableV2
51. @ComponentV2
52. struct ChildComponentA {
53.   @Param data: StringData = new StringData('', 0);

54.   aboutToAppear(): void {
55.     console.info(`type A aboutToAppear: ${this.data.message}`);
56.   }

57.   aboutToRecycle(): void {
58.     console.info(`type A aboutToRecycle: ${this.data.message}`);
59.   }

60.   aboutToReuse(): void {
61.     console.info(`type A aboutToReuse: ${this.data.message}`);
62.   }

63.   build() {
64.     Row() {
65.       Text(this.data.message).fontSize(50)
66.       Button('Type A')
67.     }
68.   }
69. }

70. @ReusableV2
71. @ComponentV2
72. struct ChildComponentB {
73.   @Param data: StringData = new StringData('', 0);

74.   aboutToAppear(): void {
75.     console.info(`type B aboutToAppear: ${this.data.message}`);
76.   }

77.   aboutToRecycle(): void {
78.     console.info(`type B aboutToRecycle: ${this.data.message}`);
79.   }

80.   aboutToReuse(): void {
81.     console.info(`type B aboutToReuse: ${this.data.message}`);
82.   }

83.   build() {
84.     Row() {
85.       Text(this.data.message).fontSize(50).fontColor(Color.Gray)
86.       Text('Type B')
87.     }
88.   }
89. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.16951959361312922505157389391226:50001231000000:2800:13C72E252FDC6CE53545D7A59467B7BD1037B80FD52FCFA7AE75684E3288912F.gif)

## BasicDataSource示例代码

### string类型数组的BasicDataSource代码

1. // BasicDataSource实现了IDataSource接口，用于管理listener监听，以及通知LazyForEach数据更新
2. class BasicDataSource implements IDataSource {
3.   private listeners: DataChangeListener[] = [];
4.   private originDataArray: string[] = [];

5.   public totalCount(): number {
6.     return this.originDataArray.length;
7.   }

8.   public getData(index: number): string {
9.     return this.originDataArray[index];
10.   }

11.   // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
12.   registerDataChangeListener(listener: DataChangeListener): void {
13.     if (this.listeners.indexOf(listener) < 0) {
14.       console.info('add listener');
15.       this.listeners.push(listener);
16.     }
17.   }

18.   // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
19.   unregisterDataChangeListener(listener: DataChangeListener): void {
20.     const pos = this.listeners.indexOf(listener);
21.     if (pos >= 0) {
22.       console.info('remove listener');
23.       this.listeners.splice(pos, 1);
24.     }
25.   }

26.   // 通知LazyForEach组件需要重载所有子组件
27.   notifyDataReload(): void {
28.     this.listeners.forEach(listener => {
29.       listener.onDataReloaded();
30.     });
31.   }

32.   // 通知LazyForEach组件需要在index对应索引处添加子组件
33.   notifyDataAdd(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataAdd(index);
36.       // 写法2：listener.onDatasetChange([{type: DataOperationType.ADD, index: index}]);
37.     });
38.   }

39.   // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
40.   notifyDataChange(index: number): void {
41.     this.listeners.forEach(listener => {
42.       listener.onDataChange(index);
43.       // 写法2：listener.onDatasetChange([{type: DataOperationType.CHANGE, index: index}]);
44.     });
45.   }

46.   // 通知LazyForEach组件需要在index对应索引处删除该子组件
47.   notifyDataDelete(index: number): void {
48.     this.listeners.forEach(listener => {
49.       listener.onDataDelete(index);
50.       // 写法2：listener.onDatasetChange([{type: DataOperationType.DELETE, index: index}]);
51.     });
52.   }

53.   // 通知LazyForEach组件将from索引和to索引处的子组件进行交换
54.   notifyDataMove(from: number, to: number): void {
55.     this.listeners.forEach(listener => {
56.       listener.onDataMove(from, to);
57.       // 写法2：listener.onDatasetChange(
58.       //         [{type: DataOperationType.EXCHANGE, index: {start: from, end: to}}]);
59.     });
60.   }

61.   notifyDatasetChange(operations: DataOperation[]): void {
62.     this.listeners.forEach(listener => {
63.       listener.onDatasetChange(operations);
64.     });
65.   }
66. }

### StringData类型数组的BasicDataSource代码

1. class BasicDataSource implements IDataSource {
2.   private listeners: DataChangeListener[] = [];
3.   private originDataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.originDataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.originDataArray[index];
9.   }

10.   registerDataChangeListener(listener: DataChangeListener): void {
11.     if (this.listeners.indexOf(listener) < 0) {
12.       console.info('add listener');
13.       this.listeners.push(listener);
14.     }
15.   }

16.   unregisterDataChangeListener(listener: DataChangeListener): void {
17.     const pos = this.listeners.indexOf(listener);
18.     if (pos >= 0) {
19.       console.info('remove listener');
20.       this.listeners.splice(pos, 1);
21.     }
22.   }

23.   notifyDataReload(): void {
24.     this.listeners.forEach(listener => {
25.       listener.onDataReloaded();
26.     });
27.   }

28.   notifyDataAdd(index: number): void {
29.     this.listeners.forEach(listener => {
30.       listener.onDataAdd(index);
31.     });
32.   }

33.   notifyDataChange(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataChange(index);
36.     });
37.   }

38.   notifyDataDelete(index: number): void {
39.     this.listeners.forEach(listener => {
40.       listener.onDataDelete(index);
41.     });
42.   }

43.   notifyDataMove(from: number, to: number): void {
44.     this.listeners.forEach(listener => {
45.       listener.onDataMove(from, to);
46.     });
47.   }

48.   notifyDatasetChange(operations: DataOperation[]): void {
49.     this.listeners.forEach(listener => {
50.       listener.onDatasetChange(operations);
51.     });
52.   }
53. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat "Repeat：可复用的循环渲染")
# LazyForEach迁移Repeat指南

更新时间: 2025-12-16 16:39

[Repeat](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat)是ArkUI在API version 12中新引入的循环渲染组件，相比[LazyForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach)具有更简洁的API、更丰富的功能以及更强的性能优化能力。本指南帮助开发者将LazyForEach平滑地迁移到Repeat。

## 基础用法迁移

### 数据首次渲染

**LazyForEach示例**

LazyForEach根据数据源循环渲染子组件。

示例1中，在容器组件[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list)中使用LazyForEach，并基于数据源循环渲染出了一系列[Text](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-text-display)子组件。

**示例1 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: string): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Entry
16. @Component
17. struct MyComponent {
18.   private data: MyDataSource = new MyDataSource();

19.   aboutToAppear() {
20.     for (let i = 0; i <= 20; i++) {
21.       this.data.pushData(`Hello ${i}`);
22.     }
23.   }

24.   build() {
25.     List({ space: 3 }) {
26.       LazyForEach(this.data, (item: string) => {
27.         ListItem() {
28.           Row() {
29.             Text(item).fontSize(50)
30.               .onAppear(() => {
31.                 console.info(`appear: ${item}`);
32.               })
33.           }.margin({ left: 10, right: 10 })
34.         }
35.       }, (item: string) => item)
36.     }.cachedCount(5)
37.   }
38. }

以上是一个典型的使用LazyForEach循环渲染子组件的场景，下面将介绍如何将此示例迁移至Repeat。

**迁移步骤**

1. 使用状态管理V2装饰器。
    
    Repeat推荐和状态管理V2装饰器配合使用（[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E8%83%BD%E5%8A%9B%E8%AF%B4%E6%98%8E)模式下只支持和状态管理V2装饰器配合使用）。如果之前使用的是状态管理V1装饰器，需要修改为状态管理V2装饰器。
    
    1. // 迁移前 - LazyForEach
    2. @Component // 状态管理V1
    3. struct MyComponent {
    4.   build() {
    5.     // ...
    6.     LazyForEach(...)
    7.     // ...
    8.   }
    9.   // ...其他属性、方法
    10. }
    
    11. // 迁移后 - Repeat
    12. @ComponentV2 // 状态管理V2
    13. struct MyComponent {
    14.   build() {
    15.     // ...
    16.     Repeat(...)
    17.     // ...
    18.   }
    19.   // ...其他属性、方法
    20. }
    
2. 迁移数据源。
    
    LazyForEach使用专用的数据结构[IDataSource](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#idatasource)作为数据源。迁移至Repeat后，不再使用IDataSource作为数据源，而是使用状态管理V2装饰的数组作为数据源。
    
    1. // 迁移前 - LazyForEach
    2. class MyDataSource implements IDataSource {
    3.   private dataArray: string[] = [];
    
    4.   public totalCount(): number {
    5.     return this.dataArray.length;
    6.   }
    
    7.   public getData(index: number): string {
    8.     return this.dataArray[index];
    9.   }
    
    10.   // ...其他方法
    11. }
    
    12. // 迁移后 - Repeat
    13. @Local data: Array<string> = [];
    
3. 迁移组件生成函数和键值生成函数。
    
    LazyForEach与Repeat均通过组件生成函数，为每一项数据创建一个子组件；通过键值生成函数，为每一项数据生成一个唯一的键值。
    
    从LazyForEach迁移至Repeat时，两者的语法存在差异。Repeat需要在[.each()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#each)或[.template()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#template)中设置组件生成函数，在[.key()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#key)中设置键值生成函数。
    
    1. // 迁移前 - LazyForEach
    2. List() {
    3.   LazyForEach(
    4.     this.data, // 数据源
    5.     (item: string, index: number) => { // 组件生成函数
    6.       ListItem() {
    7.         Text(item)
    8.       }
    9.     },
    10.     (item: string, index: number) => item // 键值生成函数
    11.   )
    12. }
    
    13. // 迁移后 - Repeat
    14. List() {
    15.   Repeat<string>(this.data) // 数据源
    16.     .each((repeatItem: RepeatItem<string>) => { // 组件生成函数
    17.       ListItem() {
    18.         Text(repeatItem.item)
    19.       }
    20.     })
    21.     .key((item: string, index: number) => item) // 键值生成函数
    22. }
    
4. 配置懒加载功能。
    
    Repeat具有[懒加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E8%83%BD%E5%8A%9B%E8%AF%B4%E6%98%8E)和[全量加载](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat#%E5%85%B3%E9%97%AD%E6%87%92%E5%8A%A0%E8%BD%BD)两种模式。
    
    - 全量加载模式渲染所有子节点（对标[ForEach](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach)）。
    - 懒加载模式动态渲染屏幕区域和预加载区域内的子节点（需要与容器组件配合使用，对标LazyForEach）。
    
    从LazyForEach迁移至Repeat时，需要调用[virtualScroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#virtualscroll))属性，使能懒加载。
    
    1. // 迁移前 - LazyForEach
    2. LazyForEach(data, (item) => {...}, (item) => item)
    
    3. // 迁移后 - Repeat
    4. Repeat(data)
    5.   .virtualScroll() // 使能懒加载
    

**迁移后代码**

通过以上步骤，可以将示例1从LazyForEach迁移至Repeat，迁移后的完整示例如下所示。

**示例1 - 迁移后**

1. @Entry
2. @ComponentV2 // 使用状态管理V2
3. struct MyComponent {
4.   @Local data: Array<string> = []; // 数据源为状态管理V2装饰的数组

5.   aboutToAppear() {
6.     for (let i = 0; i <= 20; i++) {
7.       this.data.push(`Hello ${i}`);
8.     }
9.   }

10.   build() {
11.     List({ space: 3 }) {
12.       Repeat(this.data) // 使用Repeat
13.         .each((repeatItem: RepeatItem<string>) => { // 组件生成函数
14.           ListItem() {
15.             Row() {
16.               Text(repeatItem.item).fontSize(50)
17.                 .onAppear(() => {
18.                   console.info(`appear: ${repeatItem.item}`);
19.                 })
20.             }.margin({ left: 10, right: 10 })
21.           }
22.         })
23.         .key((item: string) => item) // 键值生成函数
24.         .virtualScroll() // 使能懒加载
25.     }.cachedCount(5)
26.   }
27. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.62687963044335291653345093467222:50001231000000:2800:E646A9E8F759C173C6DA35673112979325C60EE00AD6B6D6653A61C483F5895B.gif)

### 数据更新操作

**LazyForEach示例**

当LazyForEach的数据源发生变化时，开发者需要根据数据源的变化情况调用[DataChangeListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-lazyforeach#datachangelistener)对应的接口，通知LazyForEach做相应的更新。主要的数据操作包括：添加数据、删除数据、交换数据、修改单个数据、修改多个数据、精准批量修改数据。

示例2演示了主要的数据操作。

**示例2 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   // 添加数据
11.   public pushData(data: string): void {
12.     this.dataArray.push(data);
13.     this.notifyDataAdd(this.dataArray.length - 1);
14.   }

15.   // 删除数据
16.   public deleteData(index: number): void {
17.     this.dataArray.splice(index, 1);
18.     this.notifyDataDelete(index);
19.   }

20.   // 交换数据
21.   public moveData(from: number, to: number): void {
22.     let temp: string = this.dataArray[from];
23.     this.dataArray[from] = this.dataArray[to];
24.     this.dataArray[to] = temp;
25.     this.notifyDataMove(from, to);
26.   }

27.   // 修改单个数据
28.   public changeData(index: number, data: string): void {
29.     this.dataArray.splice(index, 1, data);
30.     this.notifyDataChange(index);
31.   }

32.   // 修改多个数据
33.   public modifyAllData(): void {
34.     this.dataArray = this.dataArray.map((item: string) => {
35.         return 'Changed ' + item;
36.     });
37.     this.notifyDataReload();
38.   }
39. }

40. @Entry
41. @Component
42. struct MyComponent {
43.   private data: MyDataSource = new MyDataSource();
44.   private count: number = 0;

45.   aboutToAppear() {
46.     for (let i = 0; i <= 10; i++) {
47.       this.data.pushData(`Hello ${i}`);
48.     }
49.   }

50.   build() {
51.     Column({ space: 3 }) {
52.       // 点击追加子组件
53.       Button('Add new item')
54.         .onClick(() => {
55.           this.data.pushData(`New item ${this.count++}`);
56.         })
57.       // 点击删除子组件
58.       Button('Delete item 0')
59.         .onClick(() => {
60.           this.data.deleteData(0);
61.         })
62.       // 点击交换子组件
63.       Button('Swap item 0 and item 1')
64.         .onClick(() => {
65.           this.data.moveData(0, 1);
66.         })
67.       // 点击修改单个子组件
68.       Button('Change item 0')
69.         .onClick(() => {
70.           this.data.changeData(0, `Changed item ${this.count++}`);
71.         })
72.       // 点击修改多个子组件
73.       Button('Change all items')
74.         .onClick(() => {
75.           this.data.modifyAllData();
76.         })
77.       List({ space: 3 }) {
78.         LazyForEach(this.data, (item: string) => {
79.           ListItem() {
80.             Row() {
81.               Text(item).fontSize(25)
82.             }
83.           }
84.         }, (item: string) => item)
85.       }.cachedCount(5)
86.     }
87.   }
88. }

以上是一个典型的更新数据后LazyForEach重新渲染子组件的场景，下面将介绍如何将此示例迁移至Repeat。

**迁移步骤**

1. 迁移准备。
    
    根据数据首次渲染小节中的步骤，将LazyForEach替换为Repeat。
    
    1. 使用状态管理V2装饰器。
    2. 迁移数据源。
    3. 迁移组件生成函数与键值生成函数。
    4. 使能懒加载。
2. 迁移数据源修改方式。
    
    - 对于LazyForEach，在修改数据源后需要调用对应的接口通知其更新。
    - 对于Repeat，由状态管理V2监听其数据源变化，并触发更新。因此，开发者直接修改数据源即可，无需其他额外操作。
    
    1. // 以修改单个数据为例
    2. // 迁移前 - LazyForEach
    3. class MyDataSource implements IDataSource {
    4.   private dataArray: string[] = [];
    
    5.   public changeData(index: number, newData: string): void {
    6.     this.dataArray.splice(index, 1, data);
    7.     this.notifyDataChange(index);
    8.   }
    
    9.   // ...其他方法
    10. }
    
    11. // 迁移后 - Repeat
    12. this.data.splice(index, 1, data);
    
    其他数据更新操作，如添加数据、删除数据、交换数据等，与以上方法类似，可通过直接修改数据源数组实现。
    

**迁移后代码**

迁移后的完整示例如下。

**示例2 - 迁移后**

1. @Entry
2. @ComponentV2
3. struct MyComponent {
4.   @Local data: Array<string> = [];
5.   private count: number = 0;

6.   aboutToAppear() {
7.     for (let i = 0; i <= 10; i++) {
8.       this.data.push(`Hello ${i}`);
9.     }
10.   }

11.   build() {
12.     Column({ space: 3 }) {
13.       // 点击追加子组件
14.       Button('Add new item')
15.         .onClick(() => { this.data.push(`New item ${this.count++}`); })
16.       // 点击删除子组件
17.       Button('Delete item 0')
18.         .onClick(() => { this.data.splice(0, 1); })
19.       // 点击交换子组件
20.       Button('Swap item 0 and item 1')
21.         .onClick(() => { let temp: string = this.data[0];
22.                          this.data[0] = this.data[1];
23.                          this.data[1] = temp; })
24.       // 点击修改单个子组件
25.       Button('Change item 0')
26.         .onClick(() => { this.data.splice(0, 1, `Changed item ${this.count++}`); })
27.       // 点击修改多个子组件
28.       Button('Change all items')
29.         .onClick(() => { this.data = this.data.map((item: string) => { return 'Changed ' + item; }); })
30.       List({ space: 3 }) {
31.         Repeat(this.data)
32.           .each((repeatItem: RepeatItem<string>) => {
33.             ListItem() {
34.               Row() {
35.                 Text(repeatItem.item).fontSize(25)
36.               }
37.             }
38.           })
39.           .key((item: string) => item)
40.           .virtualScroll()
41.       }.cachedCount(5)
42.     }
43.   }
44. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.11265996241335720350651991932968:50001231000000:2800:F4FD69EEBCCC06E46710835E4A45D5C513032A0460CCAE3FB242E4CBA0728C6A.gif)

## 典型场景迁移

### 修改数据子属性

**LazyForEach示例**

LazyForEach可以使用[@Observed与@ObjectLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-observed-and-objectlink)装饰器实现对数据子属性的观测。当有数据子属性发生变化时，仅更新使用了该子属性的组件，从而提高性能。

示例3演示了对子属性的观测。

**示例3 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @Observed
16. class StringData {
17.   message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @Component
24. struct MyComponent {
25.   private data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item })
36.         }
37.         .onClick(() => {
38.           item.message += '0';
39.         })
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @Component
45. struct ChildComponent {
46.   @ObjectLink data: StringData;

47.   build() {
48.     Row() {
49.       Text(this.data.message).fontSize(50)
50.         .onAppear(() => {
51.           console.info(`appear: ${this.data.message}`);
52.         })
53.     }.margin({ left: 10, right: 10 })
54.   }
55. }

**迁移Repeat**

Repeat需要和状态管理V2一起使用，状态管理V2提供了[@ObserveV2和@Trace](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-observedv2-and-trace)装饰器对子属性进行深度观测。迁移时，需要将@Observe和@ObjectLink装饰器迁移至@ObserveV2和@Trace装饰器。

迁移后的示例如下所示。

**示例3 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string; // 观测子属性

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             Text(repeatItem.item.message).fontSize(50)
23.               .onAppear(() => {
24.                 console.info(`appear: ${repeatItem.item.message}`);
25.               })
26.           }
27.           .onClick(() => {
28.             repeatItem.item.message += '0';
29.           })
30.         })
31.         .key((item: StringData, index: number) => index.toString())
32.         .virtualScroll()
33.     }.cachedCount(5)
34.   }
35. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.32541381118823681067088850163641:50001231000000:2800:6DC836D57AD8076BADB0DA63972483D68B833E42BD062B584B80D32363B0530D.gif)

### 状态管理V2观测组件内部状态

**LazyForEach示例**

状态管理V2的[@Local](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-local)装饰器提供了观测自定义组件内部变量的能力。被@Local装饰的变量发生变化时，会通知LazyForEach更新对应的组件。

示例4演示了在LazyForEach中使用@Local装饰器观测数据变化，触发组件更新。

**示例4 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           Row() {
36.             Text(item.message).fontSize(50)
37.               .onClick(() => {
38.                 // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
39.                 item.message += '!';
40.               })
41.             ChildComponent()
42.           }
43.         }
44.       }, (item: StringData, index: number) => index.toString())
45.     }.cachedCount(5)
46.   }
47. }

48. @ComponentV2
49. struct ChildComponent {
50.   @Local message: string = '?';

51.   build() {
52.     Row() {
53.       Text(this.message).fontSize(50)
54.         .onClick(() => {
55.           // 修改@Local装饰的变量，触发刷新此处Text组件
56.           this.message += '?';
57.         })
58.     }
59.   }
60. }

**迁移Repeat**

Repeat本身支持与状态管理V2联合使用，将LazyForEach相关代码修改为Repeat后，即可实现对组件内部状态变量的观测。

迁移后的示例如下所示。

**示例4 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string;

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             Row() {
23.               Text(repeatItem.item.message).fontSize(50)
24.                 .onClick(() => {
25.                   // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
26.                   repeatItem.item.message += '!';
27.                 })
28.               ChildComponent()
29.             }
30.           }
31.         })
32.         .key((item: StringData, index: number) => index.toString())
33.         .virtualScroll()
34.     }.cachedCount(5)
35.   }
36. }

37. @ComponentV2
38. struct ChildComponent {
39.   @Local message: string = '?';

40.   build() {
41.     Row() {
42.       Text(this.message).fontSize(50)
43.         .onClick(() => {
44.           // 修改@Local装饰的变量，触发刷新此处Text组件
45.           this.message += '?';
46.         })
47.     }
48.   }
49. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.07940817595587609092357466015835:50001231000000:2800:55F4286074152FE31295E59C0F225F1BD4F9819FEADF363E992B70AC51CA12C5.gif)

### 状态管理V2观测组件外部输入

**LazyForEach示例**

状态管理V2的[@Param](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-param)装饰器提供了观测自定义组件外部输入变量的能力，可以实现父子组件间的数据同步。将父组件的变量传递给子组件，并用@Param装饰，当父组件变量发生变化时，会通知对应的组件更新。

示例5演示了在LazyForEach中使用@Param装饰器观测数据变化，触发组件更新。

**示例5 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. @ObservedV2
16. class StringData {
17.   @Trace message: string;

18.   constructor(message: string) {
19.     this.message = message;
20.   }
21. }

22. @Entry
23. @ComponentV2
24. struct MyComponent {
25.   data: MyDataSource = new MyDataSource();

26.   aboutToAppear() {
27.     for (let i = 0; i <= 20; i++) {
28.       this.data.pushData(new StringData(`Hello ${i}`));
29.     }
30.   }

31.   build() {
32.     List({ space: 3 }) {
33.       LazyForEach(this.data, (item: StringData, index: number) => {
34.         ListItem() {
35.           ChildComponent({ data: item.message }) // 向自定义组件内传入变量
36.             .onClick(() => {
37.               item.message += '!';
38.             })
39.         }
40.       }, (item: StringData, index: number) => index.toString())
41.     }.cachedCount(5)
42.   }
43. }

44. @ComponentV2
45. struct ChildComponent {
46.   @Param @Require data: string = ''; // 接收来自外部的变量

47.   build() {
48.     Row() {
49.       Text(this.data).fontSize(50)
50.     }
51.   }
52. }

**迁移Repeat**

Repeat本身支持与状态管理V2联合使用，将LazyForEach相关代码修改为Repeat后，即可实现对组件外部输入状态变量的观测。

迁移后的示例如下所示。

**示例5 - 迁移后**

1. @ObservedV2
2. class StringData {
3.   @Trace message: string;

4.   constructor(message: string) {
5.     this.message = message;
6.   }
7. }

8. @Entry
9. @ComponentV2
10. struct MyComponent {
11.   @Local data: StringData[] = [];

12.   aboutToAppear() {
13.     for (let i = 0; i <= 20; i++) {
14.       this.data.push(new StringData(`Hello ${i}`));
15.     }
16.   }

17.   build() {
18.     List({ space: 3 }) {
19.       Repeat(this.data)
20.         .each((repeatItem) => {
21.           ListItem() {
22.             ChildComponent({ data: repeatItem.item.message }) // 向自定义组件内传入变量
23.               .onClick(() => {
24.                 repeatItem.item.message += '!';
25.               })
26.           }
27.         })
28.         .key((item: StringData, index: number) => index.toString())
29.         .virtualScroll()
30.     }.cachedCount(5)
31.   }
32. }

33. @ComponentV2
34. struct ChildComponent {
35.   @Param @Require data: string = ''; // 接收来自外部的变量

36.   build() {
37.     Row() {
38.       Text(this.data).fontSize(50)
39.     }
40.   }
41. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.90430579311480355869393459661229:50001231000000:2800:D4D2486C4784B911F9EE9A49363DC9C8BDDA17CD0B1BC1A8E5741ECB7881C668.gif)

### 拖拽排序

**LazyForEach示例**

LazyForEach的[onMove](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-drag-sorting#onmove)属性提供了拖拽排序能力。

示例6为典型用例。

**示例6 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: string[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): string {
8.     return this.dataArray[index];
9.   }

10.   public moveDataWithoutNotify(from: number, to: number): void {
11.     let tmp = this.dataArray.splice(from, 1);
12.     this.dataArray.splice(to, 0, tmp[0]);
13.   }

14.   public pushData(data: string): void {
15.     this.dataArray.push(data);
16.     this.notifyDataAdd(this.dataArray.length - 1);
17.   }
18. }

19. @Entry
20. @Component
21. struct Parent {
22.   private data: MyDataSource = new MyDataSource();

23.   aboutToAppear(): void {
24.     for (let i = 0; i < 100; i++) {
25.       this.data.pushData(i.toString());
26.     }
27.   }

28.   build() {
29.     Row() {
30.       List() {
31.         LazyForEach(this.data, (item: string) => {
32.           ListItem() {
33.             Text(item.toString())
34.               .fontSize(16)
35.               .textAlign(TextAlign.Center)
36.               .size({ height: 100, width: '100%' })
37.           }.margin(10)
38.           .borderRadius(10)
39.           .backgroundColor('#FFFFFFFF')
40.         }, (item: string) => item)
41.           .onMove((from: number, to: number) => { // 实现拖拽排序
42.             this.data.moveDataWithoutNotify(from, to);
43.           })
44.       }
45.       .width('100%')
46.       .height('100%')
47.       .backgroundColor('#FFDCDCDC')
48.     }
49.   }
50. }

**迁移Repeat**

Repeat具有与LazyForEach相同的onMove属性。将LazyForEach相关代码修改为Repeat后，即可实现拖拽排序。

迁移后的示例如下所示。

**示例6 - 迁移后**

1. @Entry
2. @ComponentV2
3. struct Parent {
4.   @Local data: string[] = [];

5.   aboutToAppear(): void {
6.     for (let i = 0; i < 100; i++) {
7.       this.data.push(i.toString());
8.     }
9.   }

10.   moveData(from: number, to: number) {
11.     let tmp = this.data.splice(from, 1);
12.     this.data.splice(to, 0, tmp[0]);
13.   }

14.   build() {
15.     Row() {
16.       List() {
17.         Repeat(this.data)
18.           .each((repeatItem) => {
19.             ListItem() {
20.               Text(repeatItem.item.toString())
21.                 .fontSize(16)
22.                 .textAlign(TextAlign.Center)
23.                 .size({ height: 100, width: '100%' })
24.             }.margin(10)
25.             .borderRadius(10)
26.             .backgroundColor('#FFFFFFFF')
27.           })
28.           .key((item: string) => item)
29.           .virtualScroll()
30.           .onMove((from: number, to: number) => { // 实现拖拽排序
31.             this.moveData(from, to);
32.           })
33.       }
34.       .width('100%')
35.       .height('100%')
36.       .backgroundColor('#FFDCDCDC')
37.     }
38.   }
39. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.50484491938529264108091518082071:50001231000000:2800:7CAE3B2495540FB53C8B4D3E84D871A4940E6E483AA646ACA1E03F8F75D22A5D.gif)

### 组件复用

**LazyForEach示例**

LazyForEach自身并不具备组件复用能力，为实现组件复用，需要与[@Reusable](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable)装饰器配合使用（被@Reusable装饰的自定义组件具有复用能力）。

示例7演示了组件复用的典型场景。

**示例7 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   message: string;

17.   constructor(message: string) {
18.     this.message = message;
19.   }
20. }

21. @Entry
22. @Component
23. struct MyComponent {
24.   data: MyDataSource = new MyDataSource();

25.   aboutToAppear() {
26.     for (let i = 0; i <= 30; i++) {
27.       this.data.pushData(new StringData(`Hello${i}`));
28.     }
29.   }

30.   build() {
31.     List({ space: 3 }) {
32.       LazyForEach(this.data, (item: StringData, index: number) => {
33.         ListItem() {
34.           ChildComponent({ data: item })
35.             .onAppear(() => {
36.               console.info(`onAppear: ${item.message}`);
37.             })
38.         }
39.       }, (item: StringData, index: number) => index.toString())
40.     }.cachedCount(5)
41.   }
42. }

43. @Reusable
44. @Component
45. struct ChildComponent {
46.   @State data: StringData = new StringData('');

47.   aboutToAppear(): void {
48.     console.info(`aboutToAppear: ${this.data.message}`);
49.   }

50.   aboutToRecycle(): void {
51.     console.info(`aboutToRecycle: ${this.data.message}`);
52.   }

53.   // 对复用的组件进行数据更新
54.   aboutToReuse(params: Record<string, ESObject>): void {
55.     this.data = params.data as StringData;
56.     console.info(`aboutToReuse: ${this.data.message}`);
57.   }

58.   build() {
59.     Row() {
60.       Text(this.data.message).fontSize(50)
61.     }
62.   }
63. }

**迁移Repeat**

Repeat本身具备组件复用能力，同时也支持与状态管理V2的[@ReusableV2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-reusablev2)装饰器联合使用。因此，迁移至Repeat后，其组件复用具有两种实现方案。

1. 直接使用Repeat自身的复用能力。
2. 使用@ReusableV2装饰器提供的复用能力。

需要注意的是，Repeat默认使能自身的复用能力，且优先级高于@ReusableV2装饰器。若要使用@ReusableV2装饰器，需要先手动关闭Repeat自身的复用能力（@ReusableV2装饰器从API version 18开始支持，Repeat从API version 19开始支持关闭自身复用能力）。

**示例7 - 迁移方案1：使用Repeat自身的复用能力**

Repeat本身具备复用能力，且默认开启。将LazyForEach相关代码迁移至Repeat后，便已经具备了复用能力。

修改后的示例如下。

1. class StringData {
2.   message: string;

3.   constructor(message: string) {
4.     this.message = message;
5.   }
6. }

7. @Entry
8. @ComponentV2
9. struct MyComponent {
10.   @Local data: StringData[] = [];

11.   aboutToAppear() {
12.     for (let i = 0; i <= 30; i++) {
13.       this.data.push(new StringData(`Hello${i}`));
14.     }
15.   }

16.   build() {
17.     List({ space: 3 }) {
18.       Repeat(this.data) // Repeat自身具备复用功能
19.         .each((repeatItem) => {
20.           ListItem() {
21.             Text(repeatItem.item.message).fontSize(50)
22.           }
23.         })
24.         .key((item: StringData, index: number) => index.toString())
25.         .virtualScroll()
26.     }.cachedCount(5)
27.   }
28. }

**示例7 - 迁移方案2：使用@ReusableV2装饰器**

若要使用@ReusableV2装饰器，首先需要通过.virtualScroll({ reusable: false })关闭Repeat自身的复用功能，再用@ReusableV2装饰需要复用的自定义组件。

相较于Repeat自身的复用，@ReusableV2装饰的自定义组件在回收和复用时，会触发aboutToRecycle和aboutToReuse两个生命周期。

使用@ReusableV2装饰器的迁移示例如下所示。

1. class StringData {
2.   message: string;

3.   constructor(message: string) {
4.     this.message = message;
5.   }
6. }

7. @Entry
8. @ComponentV2
9. struct MyComponent {
10.   @Local data: StringData[] = [];

11.   aboutToAppear() {
12.     for (let i = 0; i <= 30; i++) {
13.       this.data.push(new StringData(`Hello${i}`));
14.     }
15.   }

16.   build() {
17.     List({ space: 3 }) {
18.       Repeat(this.data)
19.         .each((repeatItem) => {
20.           ListItem() {
21.             ChildComponent({ data: repeatItem.item })
22.               .onAppear(() => {
23.                 console.info(`onAppear: ${repeatItem.item.message}`);
24.               })
25.           }
26.         })
27.         .key((item: StringData, index: number) => index.toString())
28.         .virtualScroll({ reusable: false }) // 关闭Repeat自身的复用功能（API 19）
29.     }.cachedCount(5)
30.   }
31. }

32. // 使用@ReusableV2实现组件复用（API 18）
33. @ReusableV2
34. @ComponentV2
35. struct ChildComponent {
36.   @Param data: StringData = new StringData('');

37.   aboutToAppear(): void {
38.     console.info(`aboutToAppear: ${this.data.message}`);
39.   }

40.   aboutToRecycle(): void {
41.     console.info(`aboutToRecycle: ${this.data.message}`);
42.   }

43.   aboutToReuse(): void {
44.     console.info(`aboutToReuse: ${this.data.message}`);
45.   }

46.   build() {
47.     Row() {
48.       Text(this.data.message).fontSize(50)
49.     }
50.   }
51. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.24263212202420592585590536450661:50001231000000:2800:16BFB5890C31649EC35FF4CE09025AA08349FC37026607631E2C028628AD3731.gif)

### 模板渲染

**LazyForEach示例**

LazyForEach自身并不具备模板渲染能力。为实现模板渲染能力，需要开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板。

示例8演示了模板渲染的典型场景。

**示例8 - 迁移前**

1. /** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/

2. class MyDataSource extends BasicDataSource {
3.   private dataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.dataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.dataArray[index];
9.   }

10.   public pushData(data: StringData): void {
11.     this.dataArray.push(data);
12.     this.notifyDataAdd(this.dataArray.length - 1);
13.   }
14. }

15. class StringData {
16.   message: string;
17.   type: number;

18.   constructor(message: string, type: number) {
19.     this.message = message;
20.     this.type = type;
21.   }

22.   getType(): number {
23.     if (this.type >= 1) {
24.       return 1;
25.     } else {
26.       return 0;
27.     }
28.   }
29. }

30. @Entry
31. @Component
32. struct MyComponent {
33.   data: MyDataSource = new MyDataSource();

34.   aboutToAppear() {
35.     for (let i = 0; i <= 200; i++) {
36.       this.data.pushData(new StringData(`Hello${i}`, i % 2));
37.     }
38.   }

39.   build() {
40.     List({ space: 3 }) {
41.       LazyForEach(this.data, (item: StringData, index: number) => {
42.         ListItem() {
43.           // 开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板
44.           if (item.getType() == 0) {
45.             // 模板A
46.             ChildComponentA({ data: item })
47.               .onAppear(() => {
48.                 console.info(`type A onAppear: ${item.message}`);
49.               })
50.           } else {
51.             // 模板B
52.             ChildComponentB({ data: item })
53.               .onAppear(() => {
54.                 console.info(`type B onAppear: ${item.message}`);
55.               })
56.           }
57.         }
58.       }, (item: StringData, index: number) => index.toString())
59.     }.cachedCount(5)
60.   }
61. }

62. // 使用@Reusable实现组件复用
63. @Reusable
64. @Component
65. struct ChildComponentA {
66.   @State data: StringData = new StringData('', 0);

67.   aboutToAppear(): void {
68.     console.info(`type A aboutToAppear: ${this.data.message}`);
69.   }

70.   aboutToRecycle(): void {
71.     console.info(`type A aboutToRecycle: ${this.data.message}`);
72.   }

73.   aboutToReuse(params: Record<string, ESObject>): void {
74.     this.data = params.data as StringData;
75.     console.info(`type A aboutToReuse: ${this.data.message}`);
76.   }

77.   build() {
78.     Row() {
79.       Text(this.data.message).fontSize(50)
80.       Button('Type A')
81.     }
82.   }
83. }

84. @Reusable
85. @Component
86. struct ChildComponentB {
87.   @State data: StringData = new StringData('', 0);

88.   aboutToAppear(): void {
89.     console.info(`type B aboutToAppear: ${this.data.message}`);
90.   }

91.   aboutToRecycle(): void {
92.     console.info(`type B aboutToRecycle: ${this.data.message}`);
93.   }

94.   aboutToReuse(params: Record<string, ESObject>): void {
95.     this.data = params.data as StringData;
96.     console.info(`type B aboutToReuse: ${this.data.message}`);
97.   }

98.   build() {
99.     Row() {
100.       Text(this.data.message).fontSize(50).fontColor(Color.Gray)
101.       Text('Type B')
102.     }
103.   }
104. }

**迁移Repeat**

Repeat本身具备模板渲染能力，开发者可以通过[templateId](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#templateid)方法为不同的数据项选择不同的模板，再通过[template](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-rendering-control-repeat#template)方法为不同的模板配置不同的组件生成函数。同时，开发者仍然可以选择自己实现逻辑判断，为不同的数据项分配不同的模板。

需要注意的是，如果开发者选择自己实现模板渲染，则需要关闭Repeat自身的复用功能。否则，Repeat在复用子组件时无法选择正确的模板，会导致渲染异常。

**示例8 - 迁移方案1：使用Repeat自身的模板渲染能力**

1. class StringData {
2.   message: string;
3.   type: number;

4.   constructor(message: string, type: number) {
5.     this.message = message;
6.     this.type = type;
7.   }

8.   getType(): number {
9.     if (this.type >= 1) {
10.       return 1;
11.     } else {
12.       return 0;
13.     }
14.   }
15. }

16. @Entry
17. @ComponentV2
18. struct MyComponent {
19.   data: StringData[] = [];

20.   aboutToAppear() {
21.     for (let i = 0; i <= 200; i++) {
22.       this.data.push(new StringData(`Hello${i}`, i % 2));
23.     }
24.   }

25.   build() {
26.     List({ space: 3 }) {
27.       Repeat(this.data)
28.         .each((repeatItem) => {
29.           ListItem() {
30.             Text('Default item')
31.           }
32.         })
33.         .template('A', (repeatItem) => { // 模板A
34.           ListItem() {
35.             Row() {
36.               Text(repeatItem.item.message).fontSize(50)
37.               Button('Type A')
38.             }
39.           }
40.         })
41.         .template('B', (repeatItem) => { // 模板B
42.           ListItem() {
43.             Row() {
44.               Text(repeatItem.item.message).fontSize(50).fontColor(Color.Gray)
45.               Text('Type B')
46.             }
47.           }
48.         })
49.         .templateId((item: StringData) => { // 为不同的数据项选择不同的模板
50.           if (item.getType() == 0) {
51.             return 'A';
52.           } else {
53.             return 'B';
54.           }
55.         })
56.         .key((item: StringData, index: number) => index.toString())
57.         .virtualScroll()
58.     }.cachedCount(5)
59.   }
60. }

**示例8 - 迁移方案2：由开发者实现模板渲染能力**

1. class StringData {
2.   message: string;
3.   type: number;

4.   constructor(message: string, type: number) {
5.     this.message = message;
6.     this.type = type;
7.   }

8.   getType(): number {
9.     if (this.type >= 1) {
10.       return 1;
11.     } else {
12.       return 0;
13.     }
14.   }
15. }

16. @Entry
17. @ComponentV2
18. struct MyComponent {
19.   data: StringData[] = [];

20.   aboutToAppear() {
21.     for (let i = 0; i <= 200; i++) {
22.       this.data.push(new StringData(`Hello${i}`, i % 2));
23.     }
24.   }

25.   build() {
26.     List({ space: 3 }) {
27.       Repeat(this.data)
28.         .each((repeatItem) => {
29.           ListItem() {
30.             // 开发者自己实现逻辑判断，为不同的数据项选择不同的渲染模板
31.             if (repeatItem.item.getType() == 0) {
32.               ChildComponentA({ data: repeatItem.item }) // 模板A
33.                 .onAppear(() => {
34.                   console.info(`type A onAppear: ${repeatItem.item.message}`);
35.                 })
36.             } else {
37.               ChildComponentB({ data: repeatItem.item }) // 模板B
38.                 .onAppear(() => {
39.                   console.info(`type B onAppear: ${repeatItem.item.message}`);
40.                 })
41.             }
42.           }
43.         })
44.         .key((item: StringData, index: number) => index.toString())
45.         .virtualScroll({ reusable: false }) // 关闭Repeat自身的复用功能（API 19），避免渲染异常
46.     }.cachedCount(5)
47.   }
48. }

49. // 使用@ReusableV2实现组件复用（API 18）
50. @ReusableV2
51. @ComponentV2
52. struct ChildComponentA {
53.   @Param data: StringData = new StringData('', 0);

54.   aboutToAppear(): void {
55.     console.info(`type A aboutToAppear: ${this.data.message}`);
56.   }

57.   aboutToRecycle(): void {
58.     console.info(`type A aboutToRecycle: ${this.data.message}`);
59.   }

60.   aboutToReuse(): void {
61.     console.info(`type A aboutToReuse: ${this.data.message}`);
62.   }

63.   build() {
64.     Row() {
65.       Text(this.data.message).fontSize(50)
66.       Button('Type A')
67.     }
68.   }
69. }

70. @ReusableV2
71. @ComponentV2
72. struct ChildComponentB {
73.   @Param data: StringData = new StringData('', 0);

74.   aboutToAppear(): void {
75.     console.info(`type B aboutToAppear: ${this.data.message}`);
76.   }

77.   aboutToRecycle(): void {
78.     console.info(`type B aboutToRecycle: ${this.data.message}`);
79.   }

80.   aboutToReuse(): void {
81.     console.info(`type B aboutToReuse: ${this.data.message}`);
82.   }

83.   build() {
84.     Row() {
85.       Text(this.data.message).fontSize(50).fontColor(Color.Gray)
86.       Text('Type B')
87.     }
88.   }
89. }

运行后界面如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163959.16951959361312922505157389391226:50001231000000:2800:13C72E252FDC6CE53545D7A59467B7BD1037B80FD52FCFA7AE75684E3288912F.gif)

## BasicDataSource示例代码

### string类型数组的BasicDataSource代码

1. // BasicDataSource实现了IDataSource接口，用于管理listener监听，以及通知LazyForEach数据更新
2. class BasicDataSource implements IDataSource {
3.   private listeners: DataChangeListener[] = [];
4.   private originDataArray: string[] = [];

5.   public totalCount(): number {
6.     return this.originDataArray.length;
7.   }

8.   public getData(index: number): string {
9.     return this.originDataArray[index];
10.   }

11.   // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
12.   registerDataChangeListener(listener: DataChangeListener): void {
13.     if (this.listeners.indexOf(listener) < 0) {
14.       console.info('add listener');
15.       this.listeners.push(listener);
16.     }
17.   }

18.   // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
19.   unregisterDataChangeListener(listener: DataChangeListener): void {
20.     const pos = this.listeners.indexOf(listener);
21.     if (pos >= 0) {
22.       console.info('remove listener');
23.       this.listeners.splice(pos, 1);
24.     }
25.   }

26.   // 通知LazyForEach组件需要重载所有子组件
27.   notifyDataReload(): void {
28.     this.listeners.forEach(listener => {
29.       listener.onDataReloaded();
30.     });
31.   }

32.   // 通知LazyForEach组件需要在index对应索引处添加子组件
33.   notifyDataAdd(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataAdd(index);
36.       // 写法2：listener.onDatasetChange([{type: DataOperationType.ADD, index: index}]);
37.     });
38.   }

39.   // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
40.   notifyDataChange(index: number): void {
41.     this.listeners.forEach(listener => {
42.       listener.onDataChange(index);
43.       // 写法2：listener.onDatasetChange([{type: DataOperationType.CHANGE, index: index}]);
44.     });
45.   }

46.   // 通知LazyForEach组件需要在index对应索引处删除该子组件
47.   notifyDataDelete(index: number): void {
48.     this.listeners.forEach(listener => {
49.       listener.onDataDelete(index);
50.       // 写法2：listener.onDatasetChange([{type: DataOperationType.DELETE, index: index}]);
51.     });
52.   }

53.   // 通知LazyForEach组件将from索引和to索引处的子组件进行交换
54.   notifyDataMove(from: number, to: number): void {
55.     this.listeners.forEach(listener => {
56.       listener.onDataMove(from, to);
57.       // 写法2：listener.onDatasetChange(
58.       //         [{type: DataOperationType.EXCHANGE, index: {start: from, end: to}}]);
59.     });
60.   }

61.   notifyDatasetChange(operations: DataOperation[]): void {
62.     this.listeners.forEach(listener => {
63.       listener.onDatasetChange(operations);
64.     });
65.   }
66. }

### StringData类型数组的BasicDataSource代码

1. class BasicDataSource implements IDataSource {
2.   private listeners: DataChangeListener[] = [];
3.   private originDataArray: StringData[] = [];

4.   public totalCount(): number {
5.     return this.originDataArray.length;
6.   }

7.   public getData(index: number): StringData {
8.     return this.originDataArray[index];
9.   }

10.   registerDataChangeListener(listener: DataChangeListener): void {
11.     if (this.listeners.indexOf(listener) < 0) {
12.       console.info('add listener');
13.       this.listeners.push(listener);
14.     }
15.   }

16.   unregisterDataChangeListener(listener: DataChangeListener): void {
17.     const pos = this.listeners.indexOf(listener);
18.     if (pos >= 0) {
19.       console.info('remove listener');
20.       this.listeners.splice(pos, 1);
21.     }
22.   }

23.   notifyDataReload(): void {
24.     this.listeners.forEach(listener => {
25.       listener.onDataReloaded();
26.     });
27.   }

28.   notifyDataAdd(index: number): void {
29.     this.listeners.forEach(listener => {
30.       listener.onDataAdd(index);
31.     });
32.   }

33.   notifyDataChange(index: number): void {
34.     this.listeners.forEach(listener => {
35.       listener.onDataChange(index);
36.     });
37.   }

38.   notifyDataDelete(index: number): void {
39.     this.listeners.forEach(listener => {
40.       listener.onDataDelete(index);
41.     });
42.   }

43.   notifyDataMove(from: number, to: number): void {
44.     this.listeners.forEach(listener => {
45.       listener.onDataMove(from, to);
46.     });
47.   }

48.   notifyDatasetChange(operations: DataOperation[]): void {
49.     this.listeners.forEach(listener => {
50.       listener.onDatasetChange(operations);
51.     });
52.   }
53. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat "Repeat：可复用的循环渲染")
# 组件导航(Navigation) (推荐)

更新时间: 2025-12-16 16:39

组件导航（[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)）主要用于实现Navigation页面（[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)）间的跳转，支持在不同Navigation页面间传递参数，提供灵活的跳转栈操作，从而更便捷地实现对不同页面的访问和复用。本文将从组件导航（Navigation）的显示模式、路由操作、子页面管理、跨包跳转以及跳转动效等几个方面进行详细介绍。

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)是路由导航的根视图容器，一般作为页面（@Entry）的根容器，包括单栏（Stack）、分栏（Split）和自适应（Auto）三种显示模式。Navigation组件适用于模块内和跨模块的路由切换，通过组件级路由能力实现更加自然流畅的转场体验，并提供多种标题栏样式来呈现更好的标题和内容联动效果。一次开发，多端部署场景下，Navigation组件能够自动适配窗口显示大小，在窗口较大的场景下自动切换分栏展示效果。

Navigation组件主要包含​导航页和子页。导航页由标题栏（包含菜单栏）、内容区和工具栏组成，可以通过[hideNavBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#hidenavbar9)属性进行隐藏，导航页不存在[路由栈](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)中，与子页，以及子页之间可以通过路由操作进行切换。

在API version 9上，Navigation需要配合[NavRouter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navrouter)组件实现页面路由。从API version 10开始，更推荐使用[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)实现页面路由。

## 设置页面显示模式

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)组件通过[mode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#mode9)属性设置页面的显示模式。

- 自适应模式
    
    Navigation组件默认为自适应模式，此时mode属性为NavigationMode.Auto。自适应模式下，当页面宽度大于等于一定阈值( API version 9及以前：520vp，API version 10及以后：600vp )时，Navigation组件采用分栏模式，反之采用单栏模式。
    
    收起
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .mode(NavigationMode.Auto)
    
- 单栏模式
    
    单栏模式适用于窄屏设备，发生路由跳转时，整个页面都会被替换。
    
    **图1** 单栏布局示意图
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.39247956913604846372315161784606:50001231000000:2800:925B5823D0F65790083C974E6538E7DE423A4CD226690DE88CA88D854F7E3F88.png)
    
    将mode属性设置为NavigationMode.Stack，Navigation组件即可设置为单栏显示模式。
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .mode(NavigationMode.Stack)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.94781536402667387449603288907682:50001231000000:2800:5E623CF9E47772521FAF0D79441B418D1FBF0ED5B16BADE1E1FC081CCAEFACA4.jpg)
    
- 分栏模式
    
    分栏模式适用于宽屏设备，分为左右两部分，发生路由跳转时，只有右边子页会被替换。
    
    **图2** 分栏布局示意图
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.44635127908442444956882181138608:50001231000000:2800:29D142503D371ED20B0604DA5CCCBD05F9767952FCC5D5CE19B49743361AF01D.png)
    
    将mode属性设置为NavigationMode.Split，Navigation组件即可设置为分栏显示模式。
    
    1. import { hilog } from '@kit.PerformanceAnalysisKit';
    2. const DOMAIN = 0x0000;
    3. @Entry
    4. @Component
    5. struct NavigationExample {
    6.   @State toolTmp: ToolbarItem = {
    7.     'value': "func",
    8.     'icon': "./image/ic_public_highlights.svg",  // 当前目录image文件夹下的图标资源
    9.     'action': () => {}
    10.   };
    11.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
    12.   private arr: number[] = [1, 2, 3];
    
    13.   @Builder
    14.   pageMap(name: string) {
    15.     if (name === "NavDestinationTitle1") {
    16.       pageOneTmp();
    17.     } else if (name === "NavDestinationTitle2") {
    18.       pageTwoTmp();
    19.     } else if (name === "NavDestinationTitle3") {
    20.       pageThreeTmp();
    21.     }
    22.   }
    
    23.   build() {
    24.     Column() {
    25.       Navigation(this.navPathStack) {
    26.         TextInput({ placeholder: 'search...' })
    27.           .width("90%")
    28.           .height(40)
    29.           .backgroundColor('#FFFFFF')
    
    30.         List({ space: 12 }) {
    31.           ForEach(this.arr, (item: number) => {
    32.             ListItem() {
    33.               Text("Page" + item)
    34.                 .width("100%")
    35.                 .height(72)
    36.                 .backgroundColor('#FFFFFF')
    37.                 .borderRadius(24)
    38.                 .fontSize(16)
    39.                 .fontWeight(500)
    40.                 .textAlign(TextAlign.Center)
    41.                 .onClick(() => {
    42.                   this.navPathStack.pushPath({ name: 'NavDestinationTitle' + item });
    43.                 })
    44.             }
    45.           }, (item: number) => item.toString())
    46.         }
    47.         .width("90%")
    48.         .margin({ top: 12 })
    49.       }
    50.       .title("主标题")
    51.       .mode(NavigationMode.Split)
    52.       .navDestination(this.pageMap)
    53.       .menus([
    54.         {
    55.           value: "", icon: "./image/ic_public_search.svg", action: () => {
    56.           }
    57.         },
    58.         {
    59.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    60.           }
    61.         },
    62.         {
    63.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    64.           }
    65.         },
    66.         {
    67.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    68.           }
    69.         },
    70.         {
    71.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    72.           }
    73.         }
    74.       ])
    75.       .toolbarConfiguration([this.toolTmp, this.toolTmp, this.toolTmp])
    76.     }
    77.     .height('100%')
    78.     .width('100%')
    79.     .backgroundColor('#F1F3F5')
    80.   }
    81. }
    
    82. // PageOne.ets
    83. @Component
    84. export struct pageOneTmp {
    85.   @Consume('navPathStack') navPathStack: NavPathStack;
    86.   context = this.getUIContext().getHostContext();
    87.   build() {
    88.     NavDestination() {
    89.       Column() {
    90.         Text("NavDestinationContent1")
    91.       }.width('100%').height('100%')
    92.     }.title("NavDestinationTitle1")
    93.     .onBackPressed(() => {
    94.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    95.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    96.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    97.         JSON.stringify(popDestinationInfo));
    98.       return true;
    99.     })
    100.   }
    101. }
    
    102. // PageTwo.ets
    103. @Component
    104. export struct pageTwoTmp {
    105.   @Consume('navPathStack') navPathStack: NavPathStack;
    106.   context = this.getUIContext().getHostContext();
    107.   build() {
    108.     NavDestination() {
    109.       Column() {
    110.         Text("NavDestinationContent2")
    111.       }.width('100%').height('100%')
    112.     }.title("NavDestinationTitle2")
    113.     .onBackPressed(() => {
    114.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    115.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    116.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    117.         JSON.stringify(popDestinationInfo));
    118.       return true;
    119.     })
    120.   }
    121. }
    
    122. // PageThree.ets
    123. @Component
    124. export struct pageThreeTmp {
    125.   @Consume('navPathStack') navPathStack: NavPathStack;
    126.   context = this.getUIContext().getHostContext();
    127.   build() {
    128.     NavDestination() {
    129.       Column() {
    130.         Text("NavDestinationContent3")
    131.       }.width('100%').height('100%')
    132.     }.title("NavDestinationTitle3")
    133.     .onBackPressed(() => {
    134.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    135.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    136.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    137.         JSON.stringify(popDestinationInfo));
    138.       return true;
    139.     })
    140.   }
    141. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.38522712307407973042152555339603:50001231000000:2800:210862FB40488CA357496A333F8C814C3375FF85E9C6EC2074FEB76A3517DB98.jpg)
    

## 设置标题栏模式

标题栏在界面顶部，用于呈现界面名称和操作入口，Navigation组件通过[titleMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#titlemode)属性设置标题栏模式。

说明

Navigation或NavDestination未设置主副标题并且没有返回键时，不显示标题栏。

- Mini模式
    
    普通型标题栏，用于一级页面不需要突出标题的场景。
    
    **图3** Mini模式标题栏
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.88917640640829362862283509704068:50001231000000:2800:A6899C99862B2B677DC35E58E135729F02D8AFC91611D3785F415702713E36CA.jpg)
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .titleMode(NavigationTitleMode.Mini)
    
- Full模式
    
    强调型标题栏，用于一级页面需要突出标题的场景。
    
    **图4** Full模式标题栏
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.76716253096362819389528325214830:50001231000000:2800:4F8C50DC6DC180EEDFCCD3B4029968E2FF19618370ED06D5B688BD572BCFB1EA.jpg)
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .titleMode(NavigationTitleMode.Full)
    

## 设置菜单栏

菜单栏位于Navigation组件的右上角，开发者可以通过[menus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#menus)属性进行设置。menus支持Array<[NavigationMenuItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationmenuitem)>和[CustomBuilder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types#custombuilder8)两种参数类型。使用Array<NavigationMenuItem>类型时，竖屏最多支持显示3个图标，横屏最多支持显示5个图标，多余的图标会被放入自动生成的更多图标。

**图5** 设置了3个图标的菜单栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.73673441631946749215245150548418:50001231000000:2800:807E87EF7E5ADFFA9A9A846ED20101AC4AB9A0643F48CF41A0150795BC65B0DD.jpg)

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       .menus([toolTmp, toolTmp, toolTmp])

图片也可以引用resources中的资源。

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'resources/base/media/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       .menus([toolTmp, toolTmp, toolTmp])

**图6** 设置了4个图标的菜单栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.50787801697064920089908207920699:50001231000000:2800:E62E892050408B63ACDFEA78F71C670DAD4153B291E146916FEB0AD290D16B77.jpg)

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       // 竖屏最多支持显示3个图标，多余的图标会被放入自动生成的更多图标
11.       .menus([toolTmp, toolTmp, toolTmp, toolTmp])

## 设置工具栏

工具栏位于Navigation组件的底部，开发者可以通过[toolbarConfiguration](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#toolbarconfiguration10)属性进行设置。

**图7** 工具栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.17051218093016793180970087149026:50001231000000:2800:99FD7107F1BDE63C8614828B7CB573E786230469AEF4242386295E47BECFC7B5.jpg)

1. let toolTmp: ToolbarItem = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_highlights.svg',
4.   'action': () => {}
5. };
6. let tooBar: ToolbarItem[] = [toolTmp,toolTmp,toolTmp];
7. // ...
8.       Navigation(this.navPathStack) {
9.         // ...
10.       }
11.       .toolbarConfiguration(tooBar)

## 路由操作

Navigation路由相关的操作都是基于导航控制器[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)提供的方法进行，每个Navigation都需要创建并传入一个NavPathStack对象，用于管理页面。主要涉及页面跳转、页面返回、页面替换、页面删除、参数获取、路由拦截等功能。

从API version 12开始，导航控制器允许被继承。开发者可以在派生类中自定义属性和方法，也可以重写父类的方法。派生类对象可以替代基类NavPathStack对象使用。Navigation中的[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)页面存在于NavPathStack中，以栈的结构管理，我们称为路由栈。具体示例代码参见：[导航控制器继承示例代码](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B10%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B4%BE%E7%94%9F%E7%B1%BB)。

说明

1.不建议开发者通过监听生命周期的方式管理自己的路由栈。

2.在应用处于后台状态下，调用NavPathStack的栈操作方法，会在应用再次回到前台状态时触发刷新。

1. @Entry
2. @Component
3. struct Index {
4.   // 创建一个导航控制器对象并传入Navigation
5.   pageStack: NavPathStack = new NavPathStack();

6.   build() {
7.     Navigation(this.pageStack) {
8.     }
9.     .title('Main')
10.   }
11. }

### 页面跳转

NavPathStack通过Push相关的接口（如[pushPath](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpath10)、[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)、[pushDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushdestination11)、[pushDestinationByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushdestinationbyname11)）去实现页面跳转的功能，主要分为以下三类：

1. 普通跳转，通过页面的name去跳转，并可以携带param。
    
    1. this.pageStack.pushPath({ name: "PageOne", param: "PageOne Param" });
    2. this.pageStack.pushPathByName("PageOne", "PageOne Param");
    
2. 带返回回调的跳转，跳转时添加onPop回调，能在页面出栈时获取返回信息，并进行处理。
    
    1. this.pageStack.pushPathByName('PageOne', "PageOne Param", (popInfo) => {
    2.   console.info('Pop page name is: ' + popInfo.info.name + ', result: ' + JSON.stringify(popInfo.result));
    3. });
    
3. 带错误码的跳转，跳转结束会触发异步回调，返回错误码信息。
    
    1. this.pageStack.pushDestination({name: "PageOne", param: "PageOne Param"})
    2.   .catch((error: BusinessError) => {
    3.     console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
    4.   }).then(() => {
    5.     console.info('Push destination succeed.');
    6.   });
    7. this.pageStack.pushDestinationByName("PageOne", "PageOne Param")
    8.   .catch((error: BusinessError) => {
    9.     console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
    10.   }).then(() => {
    11.     console.info('Push destination succeed.');
    12.   });
    

### 页面返回

NavPathStack通过pop相关接口（如[pop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pop10)、[popToName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#poptoname10)、[popToIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#poptoindex10)、[clear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#clear10)）去实现页面返回功能。

1. // 返回到上一页
2. this.pageStack.pop();
3. // 返回到上一个PageOne页面
4. this.pageStack.popToName("PageOne");
5. // 返回到索引为1的页面
6. this.pageStack.popToIndex(1);
7. // 返回到根首页（清除栈中所有页面）
8. this.pageStack.clear();

### 页面替换

NavPathStack通过Replace相关接口（如[replacePath](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacepath11)、[replacePathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacepathbyname11)、[replaceDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacedestination18)）去实现页面替换功能。

1. // 将栈顶页面替换为PageOne
2. this.pageStack.replacePath({ name: "PageOne", param: "PageOne Param" });
3. this.pageStack.replacePathByName("PageOne", "PageOne Param");
4. // 带错误码的替换，跳转结束会触发异步回调，返回错误码信息
5. this.pageStack.replaceDestination({name: "PageOne", param: "PageOne Param"})
6.   .catch((error: BusinessError) => {
7.     console.error(`Replace destination failed, error code = ${error.code}, error.message = ${error.message}.`);
8.   }).then(() => {
9.     console.info('Replace destination succeed.');
10.   })

### 页面删除

NavPathStack通过Remove相关接口（如[removeByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebyname11)、[removeByIndexes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebyindexes11)、[removeByNavDestinationId](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebynavdestinationid12)）去实现删除路由栈中特定页面的功能。

1. // 删除栈中name为PageOne的所有页面
2. this.pageStack.removeByName("PageOne");
3. // 删除指定索引的页面
4. this.pageStack.removeByIndexes([1, 3, 5]);
5. // 删除指定id的页面
6. this.pageStack.removeByNavDestinationId("1");

### 移动页面

NavPathStack通过Move相关接口（如[moveToTop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#movetotop10)、[moveIndexToTop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#moveindextotop10)）去实现移动路由栈中特定页面到栈顶的功能。

1. // 移动栈中name为PageOne的页面到栈顶
2. this.pageStack.moveToTop("PageOne");
3. // 移动栈中索引为1的页面到栈顶
4. this.pageStack.moveIndexToTop(1);

### 参数获取

[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)子页第一次创建时会触发[onReady](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onready11)回调，可以获取此页面对应的参数。

1. @Component
2. struct Page01 {
3.   pathStack: NavPathStack | undefined = undefined;
4.   pageParam: string = '';

5.   build() {
6.     NavDestination() {
7.       // ...
8.     }.title('Page01')
9.     .onReady((context: NavDestinationContext) => {
10.       this.pathStack = context.pathStack;
11.       this.pageParam = context.pathInfo.param as string;
12.     })
13.   }
14. }

NavDestination组件中可以通过设置[onResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onresult15)接口，接收返回时传递的路由参数。

1. class NavParam {
2.   desc: string = 'navigation-param'
3. }

4. @Component
5. struct DemoNavDestination {
6.   // ...
7.   build() {
8.     NavDestination() {
9.       // ...
10.     }
11.     .onResult((param: Object) => {
12.       if (param instanceof NavParam) {
13.         console.info('TestTag', 'get NavParam, its desc: ' + (param as NavParam).desc);
14.         return;
15.       }
16.       console.info('TestTag', 'param not instance of NavParam');
17.     })
18.   }
19. }

其他业务场景，可以通过主动调用NavPathStack的Get相关接口（如[getAllPathName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getallpathname10)、[getParamByIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getparambyindex10)、[getParamByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getparambyname10)、[getIndexByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getindexbyname10)）去获取指定页面的参数。

1. // 获取栈中所有页面name集合
2. this.pageStack.getAllPathName();
3. // 获取索引为1的页面参数
4. this.pageStack.getParamByIndex(1);
5. // 获取PageOne页面的参数
6. this.pageStack.getParamByName("PageOne");
7. // 获取PageOne页面的索引集合
8. this.pageStack.getIndexByName("PageOne");

### 路由拦截

NavPathStack提供了[setInterception](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#setinterception12)方法，用于设置Navigation页面跳转拦截回调。该方法需要传入一个[NavigationInterception](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationinterception12)对象，该对象包含三个回调函数：

|名称|描述|
|:--|:--|
|willShow|页面跳转前回调，允许操作栈，在当前跳转生效。|
|didShow|页面跳转后回调，在该回调中操作栈会在下一次跳转生效。|
|modeChange|Navigation单双栏显示状态发生变更时触发该回调。|

说明

无论是哪个回调，在进入回调时路由栈都已经发生了变化。

开发者可以在willShow回调中通过修改路由栈来实现路由拦截重定向的能力。

1. this.pageStack.setInterception({
2.   willShow: (from: NavDestinationContext | "navBar", to: NavDestinationContext | "navBar",
3.     operation: NavigationOperation, animated: boolean) => {
4.     if (typeof to === "string") {
5.       console.info("target page is navigation home page.");
6.       return;
7.     }
8.     // 将跳转到PageTwo的路由重定向到PageOne
9.     let target: NavDestinationContext = to as NavDestinationContext;
10.     if (target.pathInfo.name === 'PageTwo') {
11.       target.pathStack.pop();
12.       target.pathStack.pushPathByName('PageOne', null);
13.     }
14.   }
15. })

### 单例跳转

通过设置[LaunchMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#launchmode12%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)为LaunchMode.MOVE_TO_TOP_SINGLETON或LaunchMode.POP_TO_SINGLETON，可以实现Navigation路由栈的单实例跳转。单实例跳转的规则如下：

1. 当指定为LaunchMode.MOVE_TO_TOP_SINGLETON时，系统会从栈底到栈顶查找具有指定名称的NavDestination。找到后，该页面将被移动到栈顶（replace操作会用指定的NavDestination替换当前栈顶）。
2. 若指定为LaunchMode.POP_TO_SINGLETON，系统同样会从栈底到栈顶查找具有指定名称的NavDestination。找到后，便会移除该NavDestination上方的所有页面（replace操作会用指定的NavDestination替换当前栈顶）。

当栈中存在的NavDestination页面通过单实例方式移动到栈顶时，将触发[onNewParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onnewparam19)回调。

有关单实例跳转的示例代码，可以参考[Navigation单例跳转示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B2%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95)。

## 子页面

[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)是[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)子页面的根容器，用于承载子页面的一些特殊属性以及生命周期等。NavDestination可以设置独立的标题栏和菜单栏等属性，使用方法与Navigation相同。NavDestination也可以通过[mode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#mode11)属性设置不同的显示类型，用于满足不同页面的诉求。

### 页面显示类型

- 标准类型
    
    NavDestination组件默认为标准类型，此时mode属性为NavDestinationMode.STANDARD。标准类型的NavDestination的生命周期跟随其在NavPathStack路由栈中的位置变化而改变。
    
- 弹窗类型
    
    NavDestination设置mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination默认透明显示。弹窗类型的NavDestination显示和消失时不会影响下层标准类型的NavDestination的显示和生命周期，两者可以同时显示。
    
    1. // Dialog NavDestination
    2. @Entry
    3. @Component
    4.  struct Index {
    5.    @Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack();
    
    6.    @Builder
    7.    PagesMap(name: string) {
    8.      if (name == 'DialogPage') {
    9.        DialogPage();
    10.      }
    11.    }
    
    12.    build() {
    13.      Navigation(this.pageStack) {
    14.        Button('Push DialogPage')
    15.          .margin(20)
    16.          .width('80%')
    17.          .onClick(() => {
    18.            this.pageStack.pushPathByName('DialogPage', '');
    19.          })
    20.      }
    21.      .mode(NavigationMode.Stack)
    22.      .title('Main')
    23.      .navDestination(this.PagesMap)
    24.    }
    25.  }
    
    26.  @Component
    27.  export struct DialogPage {
    28.    @Consume('NavPathStack') pageStack: NavPathStack;
    
    29.    build() {
    30.      NavDestination() {
    31.        Stack({ alignContent: Alignment.Center }) {
    32.          Column() {
    33.            Text("Dialog NavDestination")
    34.              .fontSize(20)
    35.              .margin({ bottom: 100 })
    36.            Button("Close").onClick(() => {
    37.              this.pageStack.pop();
    38.            }).width('30%')
    39.          }
    40.          .justifyContent(FlexAlign.Center)
    41.          .backgroundColor(Color.White)
    42.          .borderRadius(10)
    43.          .height('30%')
    44.          .width('80%')
    45.        }.height("100%").width('100%')
    46.      }
    47.      .backgroundColor('rgba(0,0,0,0.5)')
    48.      .hideTitleBar(true)
    49.      .mode(NavDestinationMode.DIALOG)
    50.    }
    51.  }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.54044996889160545821333494615153:50001231000000:2800:1C6F64946E20589F1ADDBC055027E949D521EFD4BDC226343350F6401D3A6E86.png)
    

### 页面生命周期

Navigation作为路由容器，其生命周期承载在NavDestination组件上，以组件事件的形式开放。

其生命周期大致可分为三类，自定义组件生命周期、通用组件生命周期和自有生命周期。其中，[aboutToAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear)和[aboutToDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttodisappear)是自定义组件的生命周期(NavDestination外层包含的自定义组件)，[OnAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-show-hide#onappear)和[OnDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-show-hide#ondisappear)是组件的通用生命周期。剩下的生命周期为NavDestination独有。

生命周期时序如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.71014053475673058396905454101583:50001231000000:2800:2E7A765B6F0E13E37F64EA39C86F41B0C6FD73A0946A0B1D7B98F3744C840BB3.png)

- **aboutToAppear**：在创建自定义组件后，执行其build()函数之前执行（NavDestination创建之前），允许在该方法中改变状态变量，更改将在后续执行build()函数中生效。
- **onWillAppear**：NavDestination创建后，挂载到组件树之前执行，在该方法中更改状态变量会在当前帧显示生效。
- **onAppear**：通用生命周期事件，NavDestination组件挂载到组件树时执行。
- **onWillShow**：NavDestination组件布局显示之前执行，此时页面不可见（应用切换到前台不会触发）。
- **onShown**：NavDestination组件布局显示之后执行，此时页面已完成布局。
- **onActive**：NavDestination处于激活态（处于栈顶可操作，且上层无特殊组件遮挡）触发。
- **onWillHide**：NavDestination组件触发隐藏之前执行（应用切换到后台不会触发）。
- **onInactive**：NavDestination组件处于非激活态（处于非栈顶不可操作，或处于栈顶时上层有特殊组件遮挡）触发。
- **onHidden**：NavDestination组件触发隐藏后执行（非栈顶页面push进栈，栈顶页面pop出栈或应用切换到后台）。
- **onWillDisappear**：NavDestination组件即将销毁之前执行，如果有转场动画，会在动画前触发（栈顶页面pop出栈）。
- **onDisappear**：通用生命周期事件，NavDestination组件从组件树上卸载销毁时执行。
- **aboutToDisappear**：自定义组件析构销毁之前执行，不允许在该方法中改变状态变量。

### 页面监听和查询

为了方便组件跟页面解耦，在NavDestination子页面内部的自定义组件可以通过全局方法监听或查询到页面的一些状态信息。

- 页面信息查询
    
    自定义组件提供[queryNavDestinationInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-api#querynavdestinationinfo)方法，可以在NavDestination内部查询到当前所属页面的信息，返回值为[NavDestinationInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#navdestinationinfo)，若查询不到则返回undefined。
    
    1.  import { uiObserver } from '@kit.ArkUI';
    
    2.  // NavDestination内的自定义组件
    3.  @Component
    4.  struct MyComponent {
    5.    navDesInfo: uiObserver.NavDestinationInfo | undefined;
    
    6.    aboutToAppear(): void {
    7.      this.navDesInfo = this.queryNavDestinationInfo();
    8.    }
    
    9.    build() {
    10.        Column() {
    11.          Text("所属页面Name: " + this.navDesInfo?.name)
    12.        }.width('100%').height('100%')
    13.    }
    14.  }
    
- 页面状态监听
    
    通过[observer.on('navDestinationUpdate')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#uiobserveronnavdestinationupdate)提供的注册接口可以注册NavDestination生命周期变化的监听，使用方式如下：
    
    1. uiObserver.on('navDestinationUpdate', (info) => {
    2.      console.info('NavDestination state update', JSON.stringify(info));
    3.  });
    
    也可以注册页面切换的状态回调，能在页面发生路由切换的时候拿到对应的页面信息[NavDestinationSwitchInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#navdestinationswitchinfo12)，并且提供了UIAbilityContext和UIContext不同范围的监听：
    
    4.  // 在UIAbility中使用
    5.  import { UIContext, uiObserver } from '@kit.ArkUI';
    
    6.  // callbackFunc是开发者定义的监听回调函数
    7.  function callbackFunc(info: uiObserver.NavDestinationSwitchInfo) {}
    8.  uiObserver.on('navDestinationSwitch', this.context, callbackFunc);
    
    9.  // 可以通过窗口的getUIContext()方法获取对应的UIContent
    10.  uiContext: UIContext | null = null;
    11.  uiObserver.on('navDestinationSwitch', this.uiContext, callbackFunc);
    

## 页面转场

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)默认提供了页面切换的转场动画，通过导航控制器操作时，会触发不同的转场效果（API version 13之前，[Dialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview)类型的页面默认无转场动画。从API version13开始，Dialog类型的页面支持系统转场动画。），Navigation也提供了关闭系统转场、自定义转场以及共享元素转场的能力。系统默认动画时长由物理曲线参数决定，不同设备上动画时长存在差异。

### 关闭转场

- 全局关闭
    
    Navigation通过NavPathStack中提供的[disableAnimation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#disableanimation11)方法可以在当前Navigation中关闭或打开所有转场动画。
    
    1. pageStack: NavPathStack = new NavPathStack();
    
    2. aboutToAppear(): void {
    3.   this.pageStack.disableAnimation(true);
    4. }
    
- 单次关闭
    
    NavPathStack中提供的Push、Pop、Replace等接口中可以设置animated参数，默认为true表示有转场动画，需要单次关闭转场动画可以置为false，不影响下次转场动画。
    
    1. pageStack: NavPathStack = new NavPathStack();
    
    2. this.pageStack.pushPath({ name: "PageOne" }, false);
    3. this.pageStack.pop(false);
    

### 自定义转场

- Navigation自定义转场
    
    Navigation自定义转场动画能力通过[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)事件提供，可以通过以下三步定义自定义转场动画：
    
    1. 构建一个自定义转场动画工具类CustomNavigationUtils，通过一个Map管理各页面的自定义动画对象CustomTransition。页面在创建时注册其自定义转场动画对象，在销毁时取消注册。
    2. 实现一个转场协议对象[NavigationAnimatedTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationanimatedtransition11)。其中，timeout属性表示转场结束的超时时间，默认为1000ms，transition属性为自定义的转场动画方法。开发者需在此实现自己的转场动画逻辑，系统在转场开始时会调用此方法，onTransitionEnd为转场结束时的回调。
    3. 调用customNavContentTransition方法并返回实现的转场协议对象，若返回undefined，则使用系统默认转场。
    
    具体示例代码可参考[Navigation自定义转场示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B3%E8%AE%BE%E7%BD%AE%E5%8F%AF%E4%BA%A4%E4%BA%92%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB)。
    
- NavDestination自定义转场
    
    [NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)支持自定义转场动画，通过设置[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)属性即可实现单个页面的自定义转场效果。要实现这一功能，需完成以下步骤：
    
    1. 实现[NavDestination的转场代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#navdestinationtransitiondelegate15)，针对不同的堆栈操作类型返回自定义的转场协议对象[NavDestinationTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#navdestinationtransition15)。其中，event是必填参数，需在此处编写自定义转场动画的逻辑；而onTransitionEnd、duration、curve与delay为可选参数，分别对应动画结束后的回调、动画持续时间、动画曲线类型与开始前的延时。若在转场代理中返回多个转场协议对象，这些动画效果将逐层叠加。
    2. 通过调用NavDestination组件的customTransition属性，并传入上述实现的转场代理，完成自定义转场的设置。
    
    具体示例代码可以参考[NavDestination自定义转场示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#%E7%A4%BA%E4%BE%8B2%E8%AE%BE%E7%BD%AEnavdestination%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA)。
    
- 使用建议
    
    1. Navigation自定义转场[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)适用于控制Navigation内所有页面，统一转场动画效果。
    2. NavDestination自定义转场[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)适用于控制单个页面的转场效果。
    3. 在同时使用[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)和[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)时，customNavContentTransition优先级更高。

### 共享元素转场

NavDestination之间切换时可以通过[geometryTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-geometrytransition#geometrytransition)实现共享元素转场。配置了共享元素转场的页面同时需要关闭系统默认的转场动画。

1. 为需要实现共享元素转场的组件添加geometryTransition属性，id参数必须在两个NavDestination之间保持一致。
    
    1. // 起始页配置共享元素id
    2. NavDestination() {
    3.   Column() {
    4.     // ...
    5.     // $r('app.media.startIcon')需要替换为开发者所需的资源文件
    6.     Image($r('app.media.startIcon'))
    7.     .geometryTransition('sharedId')
    8.     .width(100)
    9.     .height(100)
    10.   }
    11. }
    12. .title('FromPage')
    
    13. // 目的页配置共享元素id
    14. NavDestination() {
    15.   Column() {
    16.     // ...
    17.     // $r('app.media.startIcon')需要替换为开发者所需的资源文件
    18.     Image($r('app.media.startIcon'))
    19.     .geometryTransition('sharedId')
    20.     .width(200)
    21.     .height(200)
    22.   }
    23. }
    24. .title('ToPage')
    
2. 将页面路由的操作，放到animateTo动画闭包中，配置对应的动画参数以及关闭系统默认的转场。
    
    1. NavDestination() {
    2.   Column() {
    3.     Button('跳转目的页')
    4.     .width('80%')
    5.     .height(40)
    6.     .margin(20)
    7.     .onClick(() => {
    8.         this.getUIContext()?.animateTo({ duration: 1000 }, () => {
    9.           this.pageStack.pushPath({ name: 'ToPage' }, false)
    10.         });
    11.     })
    12.   }
    13. }
    14. .title('FromPage')
    

## 跨包路由

系统提供[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)和[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)两种实现方式。

- 系统路由表相对自定义路由表，使用更简单，只需要添加对应页面跳转配置项，即可实现页面跳转。
    
- 自定义路由表使用起来更复杂，但是可以根据应用业务进行定制处理。
    

支持自定义路由表和系统路由表混用。

### 路由表能力对比

不同路由方式适用于不同需求，易用性或可扩展性需根据项目特点权衡选择。

|路由方式|跨包跳转能力|可扩展性|易用性|
|:--|:--|:--|:--|
|[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)|跳转前无需import页面文件，页面按需动态加载。|可扩展性一般。|易用性更强，系统自动维护路由表。|
|[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)|跳转前需要import页面文件。|可扩展性更强。|易用性一般，需要开发者自行维护路由表。|

### 系统路由表

系统路由表是动态路由的一种实现方式。从API version 12开始，[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)支持使用系统路由表的方式进行动态路由。各业务模块（[HSP](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp)/[HAR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package)）中需要独立配置route_map.json文件，在触发路由跳转时，应用只需要通过NavPathStack提供的路由方法，传入需要路由的页面配置名称，此时系统会自动完成路由模块的动态加载、页面组件构建，并完成路由跳转，从而实现了开发层面的模块解耦。系统路由表支持模拟器但不支持预览器。其主要步骤如下：

1. 在跳转目标模块的配置文件[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)添加路由表配置：
    
    1.   {
    2.     "module" : {
    3.       "routerMap": "$profile:route_map"
    4.     }
    5.   }
    
2. 添加完路由配置文件地址后，需要在工程resources/base/profile中创建route_map.json文件。添加如下配置信息：
    
    1.   {
    2.     "routerMap": [
    3.       {
    4.         "name": "PageOne",
    5.         "pageSourceFile": "src/main/ets/pages/PageOne.ets",
    6.         "buildFunction": "PageOneBuilder",
    7.         "data": {
    8.           "description" : "this is PageOne"
    9.         }
    10.       }
    11.     ]
    12.   }
    
    配置说明如下：
    
    |配置项|说明|
    |:--|:--|
    |name|可自定义的跳转页面名称。|
    |pageSourceFile|跳转目标页在包内的路径，相对src目录的相对路径。|
    |buildFunction|跳转目标页的入口函数名称，必须以@Builder修饰。|
    |data|应用自定义字段。可以通过配置项读取接口getConfigInRouteMap获取。|
    
3. 在跳转目标页面中，需要配置入口Builder函数，函数名称需要和route_map.json配置文件中的buildFunction保持一致，否则在编译时会报错。
    
    1.   // 跳转页面入口函数
    2.   @Builder
    3.   export function PageOneBuilder() {
    4.     PageOne();
    5.   }
    
    6.   @Component
    7.   struct PageOne {
    8.     pathStack: NavPathStack = new NavPathStack();
    
    9.     build() {
    10.       NavDestination() {
    11.       }
    12.       .title('PageOne')
    13.       .onReady((context: NavDestinationContext) => {
    14.          this.pathStack = context.pathStack;
    15.       })
    16.     }
    17.   }
    
4. 通过[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)等路由接口进行页面跳转。(注意：此时Navigation中可以不用配置[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性。)
    
    1.   @Entry
    2.   @Component
    3.   struct Index {
    4.     pageStack : NavPathStack = new NavPathStack();
    
    5.     build() {
    6.       Navigation(this.pageStack){
    7.       }.onAppear(() => {
    8.         this.pageStack.pushPathByName("PageOne", null, false);
    9.       })
    10.       .hideNavBar(true)
    11.     }
    12.   }
    

### 自定义路由表

自定义路由表通过给Navigation的[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性设置Builder函数实现，其特点是需要import页面。有两种import页面的方式，静态import和动态import，二者的区别在于：

|import方式|模块间耦合度|实现复杂度|性能|
|:--|:--|:--|:--|
|动态import|模块间解耦。|复杂度高。|性能好，按需加载，跳转前再加载对应页面。|
|静态import|模块间耦合。|复杂度低。|性能一般，初始化时一次性加载所有依赖的页面。|

**动态import（推荐）**

动态import旨在解决多个模块（HAR/HSP）能够复用相同的业务逻辑，实现各业务模块间的解耦，同时支持路由功能的扩展与整合，可以按需import，具体实现方法请参考[Navigation自定义动态路由](https://gitcode.com/harmonyos-cases/cases/blob/master/CommonAppDevelopment/common/routermodule/README_AUTO_GENERATE.md)示例。

动态import的优势：

- 路由定义除了跳转的URL以外，可以配置丰富的扩展信息，如横竖屏默认模式、是否需要鉴权等等，做路由跳转时统一处理。
- 给每个路由页面设置一个名字，按照名称进行跳转而不是文件路径。
- 页面的加载可以使用动态import（按需加载），防止首个页面加载大量代码导致卡顿。

实现方案：

1. 定义页面跳转配置项。
    - 使用资源文件进行定义，通过资源管理[@ohos.resourceManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resource-manager)在运行时对资源文件解析。
    - 在ets文件中配置路由加载配置项，一般包括路由页面名称（即pushPath等接口中页面的别名），文件所在模块名称（hsp/har的模块名），加载页面在模块内的路径（相对src目录的路径）。
2. 加载目标跳转页面，通过[动态import](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dynamic-import)将跳转目标页面所在的模块在运行时加载，在模块加载完成后，调用模块中的方法，通过import在模块的方法中加载模块中显示的目标页面，并返回页面加载完成后定义的Builder函数。
3. 触发页面跳转，在Navigation的[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性执行步骤2中加载的Builder函数，即可跳转到目标页面。

**静态import**

静态import实现方式简单，但通过静态import页面进行路由跳转会导致不同模块之间的依赖耦合，并增加首页加载时间长等问题。建议使用[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)的动态import或[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)。

实现方案：

1. import { hilog } from '@kit.PerformanceAnalysisKit';
2. const DOMAIN = 0x0000;
3. @Entry
4. @Component
5. struct NavigationExample {
6.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
7.   private arr: number[] = [1, 2];

8.   @Builder
9.   pageMap(name: string) {
10.     if (name === "NavDestinationTitle1") {
11.       pageOneTmp();
12.     } else if (name === "NavDestinationTitle2") {
13.       pageTwoTmp();
14.     }
15.   }

16.   build() {
17.     Column() {
18.       Navigation(this.navPathStack) {
19.         TextInput({ placeholder: 'search...' })
20.           .width("90%")
21.           .height(40)

22.         List({ space: 12 }) {
23.           ForEach(this.arr, (item: number) => {
24.             ListItem() {
25.               Text("Page" + item)
26.                 .width("100%")
27.                 .height(72)
28.                 .borderRadius(24)
29.                 .fontSize(16)
30.                 .fontWeight(500)
31.                 .textAlign(TextAlign.Center)
32.                 .onClick(() => {
33.                   this.navPathStack.pushPath({ name: 'NavDestinationTitle' + item });
34.                 })
35.             }
36.           }, (item: number) => item.toString())
37.         }
38.         .width("90%")
39.         .margin({ top: 12 })
40.       }
41.       // $r('app.string.mainTitle')需要替换为开发者所需的字符串资源文件
42.       .title($r('app.string.mainTitle'))
43.       .navDestination(this.pageMap)
44.       .mode(NavigationMode.Split)
45.     }
46.     .height('100%')
47.     .width('100%')
48.   }
49. }

50. @Component
51. export struct pageTwoTmp {
52.   @Consume('navPathStack') navPathStack: NavPathStack;
53.   context = this.getUIContext().getHostContext();
54.   build() {
55.     NavDestination() {
56.       Column() {
57.         Text("NavDestinationContent2")
58.       }.width('100%').height('100%')
59.     }.title("NavDestinationTitle2")
60.     .onBackPressed(() => {
61.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈的栈顶元素
62.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
63.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
64.         JSON.stringify(popDestinationInfo));
65.       return true;
66.     })
67.   }
68. }

69. // pageOne.ets
70. @Component
71. export struct pageOneTmp {
72.   @Consume('navPathStack') navPathStack: NavPathStack;
73.   context = this.getUIContext().getHostContext();
74.   build() {
75.     NavDestination() {
76.       Column() {
77.         Text("NavDestinationContent1")
78.       }.width('100%').height('100%')
79.     }.title("NavDestinationTitle1")
80.     .onBackPressed(() => {
81.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈的栈顶元素
82.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
83.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
84.         JSON.stringify(popDestinationInfo));
85.       return true;
86.     })
87.   }
88. }

## 导航示例

### 创建导航首页

实现步骤为：

1.使用[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)创建导航主页，并创建导航控制器NavPathStack以此来实现不同页面之间的跳转。

2.在Navigation中增加[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)组件，来定义导航主页中不同的一级界面。

3.在List内的组件添加onClick方法，并在其中使用导航控制器NavPathStack的[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。

1. @Entry
2. @Component
3. struct NavigationDemo {
4.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
5.   private listArray: Array<string> = ['WLAN', 'Bluetooth', 'Personal Hotspot', 'Connect & Share'];

6.   build() {
7.     Column() {
8.       Navigation(this.navPathStack) {
9.         TextInput({ placeholder: '输入关键字搜索' })
10.           .width('90%')
11.           .height(40)
12.           .margin({ bottom: 10 })

13.         // 通过List定义导航的一级界面
14.         List({ space: 12, initialIndex: 0 }) {
15.           ForEach(this.listArray, (item: string) => {
16.             ListItem() {
17.               Row() {
18.                 Row() {
19.                   Text(`${item.slice(0, 1)}`)
20.                     .fontColor(Color.White)
21.                     .fontSize(14)
22.                     .fontWeight(FontWeight.Bold)
23.                 }
24.                 .width(30)
25.                 .height(30)
26.                 .backgroundColor('#a8a8a8')
27.                 .margin({ right: 20 })
28.                 .borderRadius(20)
29.                 .justifyContent(FlexAlign.Center)

30.                 Column() {
31.                   Text(item)
32.                     .fontSize(16)
33.                     .margin({ bottom: 5 })
34.                 }
35.                 .alignItems(HorizontalAlign.Start)

36.                 Blank()

37.                 Row()
38.                   .width(12)
39.                   .height(12)
40.                   .margin({ right: 15 })
41.                   .border({
42.                     width: { top: 2, right: 2 },
43.                     color: 0xcccccc
44.                   })
45.                   .rotate({ angle: 45 })
46.               }
47.               .borderRadius(15)
48.               .shadow({ radius: 100, color: '#ededed' })
49.               .width('90%')
50.               .alignItems(VerticalAlign.Center)
51.               .padding({ left: 15, top: 15, bottom: 15 })
52.               .backgroundColor(Color.White)
53.             }
54.             .width('100%')
55.             .onClick(() => {
56.               this.navPathStack.pushPathByName(`${item}`, '详情页面参数'); // 将name指定的NaviDestination页面信息入栈,传递的参数为param
57.             })
58.           }, (item: string): string => item)
59.         }
60.         .listDirection(Axis.Vertical)
61.         .edgeEffect(EdgeEffect.Spring)
62.         .sticky(StickyStyle.Header)
63.         .chainAnimation(false)
64.         .width('100%')
65.       }
66.       .width('100%')
67.       .mode(NavigationMode.Auto)
68.       .title('设置') // 设置标题文字
69.     }
70.     .size({ width: '100%', height: '100%' })
71.     .backgroundColor(0xf4f4f5)
72.   }
73. }

### 创建导航子页

导航子页1实现步骤为：

1.使用[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)，来创建导航子页PageOne。

2.创建导航控制器[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)并在[onReady](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onready11)时进行初始化，获取当前所在的导航控制器，以此来实现不同页面之间的跳转。

3.在子页面内的组件添加onClick，并在其中使用导航控制器NavPathStack的[pop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pop10)方法，使组件可以在点击之后弹出路由栈栈顶元素实现页面的返回。

1. //PageOne.ets
2. @Builder
3. export function PageOneBuilder(name: string, param: string) {
4.   PageOne({ name: name, value: param });
5. }

6. @Component
7. export struct PageOne {
8.   navPathStack: NavPathStack = new NavPathStack();
9.   name: string = '';
10.   @State value: string = '';

11.   build() {
12.     NavDestination() {
13.       Column() {
14.         Text(`${this.name}设置页面`)
15.           .width('100%')
16.           .fontSize(20)
17.           .fontColor(0x333333)
18.           .textAlign(TextAlign.Center)
19.           .textShadow({
20.             radius: 2,
21.             offsetX: 4,
22.             offsetY: 4,
23.             color: 0x909399
24.           })
25.           .padding({ top: 30 })
26.         Text(`${JSON.stringify(this.value)}`)
27.           .width('100%')
28.           .fontSize(18)
29.           .fontColor(0x666666)
30.           .textAlign(TextAlign.Center)
31.           .padding({ top: 45 })
32.         Button('返回')
33.           .width('50%')
34.           .height(40)
35.           .margin({ top: 50 })
36.           .onClick(() => {
37.             //弹出路由栈栈顶元素，返回上个页面
38.             this.navPathStack.pop();
39.           })
40.       }
41.       .size({ width: '100%', height: '100%' })
42.     }.title(`${this.name}`)
43.     .onReady((ctx: NavDestinationContext) => {
44.       // NavDestinationContext获取当前所在的导航控制器
45.       this.navPathStack = ctx.pathStack;
46.     })
47.   }
48. }

导航子页2实现步骤为：

1.使用NavDestination，来创建导航子页PageTwo。

2.创建导航控制器NavPathStack并在onReady时进行初始化，获取当前所在的导航控制器，以此来实现不同页面之间的跳转。

3.在子页面内的组件添加onClick，并在其中使用导航控制器NavPathStack的[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。

1. //PageTwo.ets
2. @Builder
3. export function PageTwoBuilder(name: string) {
4.   PageTwo({ name: name });
5. }

6. @Component
7. export struct PageTwo {
8.   navPathStack: NavPathStack = new NavPathStack();
9.   name: string = '';
10.   private listArray: Array<string> = ['Projection', 'Print', 'VPN', 'Private DNS', 'NFC'];

11.   build() {
12.     NavDestination() {
13.       Column() {
14.         List({ space: 12, initialIndex: 0 }) {
15.           ForEach(this.listArray, (item: string) => {
16.             ListItem() {
17.               Row() {
18.                 Row() {
19.                   Text(`${item.slice(0, 1)}`)
20.                     .fontColor(Color.White)
21.                     .fontSize(14)
22.                     .fontWeight(FontWeight.Bold)
23.                 }
24.                 .width(30)
25.                 .height(30)
26.                 .backgroundColor('#a8a8a8')
27.                 .margin({ right: 20 })
28.                 .borderRadius(20)
29.                 .justifyContent(FlexAlign.Center)

30.                 Column() {
31.                   Text(item)
32.                     .fontSize(16)
33.                     .margin({ bottom: 5 })
34.                 }
35.                 .alignItems(HorizontalAlign.Start)

36.                 Blank()

37.                 Row()
38.                   .width(12)
39.                   .height(12)
40.                   .margin({ right: 15 })
41.                   .border({
42.                     width: { top: 2, right: 2 },
43.                     color: 0xcccccc
44.                   })
45.                   .rotate({ angle: 45 })
46.               }
47.               .borderRadius(15)
48.               .shadow({ radius: 100, color: '#ededed' })
49.               .width('90%')
50.               .alignItems(VerticalAlign.Center)
51.               .padding({ left: 15, top: 15, bottom: 15 })
52.               .backgroundColor(Color.White)
53.             }
54.             .width('100%')
55.             .onClick(() => {
56.               this.navPathStack.pushPathByName(`${item}`, '页面设置参数');
57.             })
58.           }, (item: string): string => item)
59.         }
60.         .listDirection(Axis.Vertical)
61.         .edgeEffect(EdgeEffect.Spring)
62.         .sticky(StickyStyle.Header)
63.         .width('100%')
64.       }
65.       .size({ width: '100%', height: '100%' })
66.     }.title(`${this.name}`)
67.     .onReady((ctx: NavDestinationContext) => {
68.       // NavDestinationContext获取当前所在的导航控制器
69.       this.navPathStack = ctx.pathStack;
70.     })
71.   }
72. }

### 创建路由跳转

实现步骤为：

1.工程配置文件[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中配置 {"routerMap": "$profile:router_map"}。

2.router_map.json中配置全局路由表，导航控制器NavPathStack可根据路由表中的name将对应页面信息入栈。

1. {
2.   "routerMap" : [
3.     {
4.       "name" : "WLAN",
5.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
6.       "buildFunction" : "PageOneBuilder"
7.     },
8.     {
9.       "name" : "Bluetooth",
10.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
11.       "buildFunction" : "PageOneBuilder"
12.     },
13.     {
14.       "name" : "Personal Hotspot",
15.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
16.       "buildFunction" : "PageOneBuilder"
17.     },
18.     {
19.       "name" : "Connect & Share",
20.       "pageSourceFile"  : "src/main/ets/pages/PageTwo.ets",
21.       "buildFunction" : "PageTwoBuilder"
22.     },
23.     {
24.       "name" : "Projection",
25.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
26.       "buildFunction" : "PageOneBuilder"
27.     },
28.     {
29.       "name" : "Print",
30.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
31.       "buildFunction" : "PageOneBuilder"
32.     },
33.     {
34.       "name" : "VPN",
35.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
36.       "buildFunction" : "PageOneBuilder"
37.     },
38.     {
39.       "name" : "Private DNS",
40.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
41.       "buildFunction" : "PageOneBuilder"
42.     },
43.     {
44.       "name" : "NFC",
45.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
46.       "buildFunction" : "PageOneBuilder"
47.     }
48.   ]
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.30221763759141194730167703387201:50001231000000:2800:EB5B03A9F555626B4E13396CEDB9352183B61BA8917A1A339930A3837013D609.gif)

## 示例代码

- [Navigation系统路由](https://gitcode.com/harmonyos_samples/system-router-map)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-introduction "组件导航和页面路由概述")
# 组件导航(Navigation) (推荐)

更新时间: 2025-12-16 16:39

组件导航（[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)）主要用于实现Navigation页面（[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)）间的跳转，支持在不同Navigation页面间传递参数，提供灵活的跳转栈操作，从而更便捷地实现对不同页面的访问和复用。本文将从组件导航（Navigation）的显示模式、路由操作、子页面管理、跨包跳转以及跳转动效等几个方面进行详细介绍。

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)是路由导航的根视图容器，一般作为页面（@Entry）的根容器，包括单栏（Stack）、分栏（Split）和自适应（Auto）三种显示模式。Navigation组件适用于模块内和跨模块的路由切换，通过组件级路由能力实现更加自然流畅的转场体验，并提供多种标题栏样式来呈现更好的标题和内容联动效果。一次开发，多端部署场景下，Navigation组件能够自动适配窗口显示大小，在窗口较大的场景下自动切换分栏展示效果。

Navigation组件主要包含​导航页和子页。导航页由标题栏（包含菜单栏）、内容区和工具栏组成，可以通过[hideNavBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#hidenavbar9)属性进行隐藏，导航页不存在[路由栈](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)中，与子页，以及子页之间可以通过路由操作进行切换。

在API version 9上，Navigation需要配合[NavRouter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navrouter)组件实现页面路由。从API version 10开始，更推荐使用[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)实现页面路由。

## 设置页面显示模式

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)组件通过[mode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#mode9)属性设置页面的显示模式。

- 自适应模式
    
    Navigation组件默认为自适应模式，此时mode属性为NavigationMode.Auto。自适应模式下，当页面宽度大于等于一定阈值( API version 9及以前：520vp，API version 10及以后：600vp )时，Navigation组件采用分栏模式，反之采用单栏模式。
    
    收起
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .mode(NavigationMode.Auto)
    
- 单栏模式
    
    单栏模式适用于窄屏设备，发生路由跳转时，整个页面都会被替换。
    
    **图1** 单栏布局示意图
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.39247956913604846372315161784606:50001231000000:2800:925B5823D0F65790083C974E6538E7DE423A4CD226690DE88CA88D854F7E3F88.png)
    
    将mode属性设置为NavigationMode.Stack，Navigation组件即可设置为单栏显示模式。
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .mode(NavigationMode.Stack)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.94781536402667387449603288907682:50001231000000:2800:5E623CF9E47772521FAF0D79441B418D1FBF0ED5B16BADE1E1FC081CCAEFACA4.jpg)
    
- 分栏模式
    
    分栏模式适用于宽屏设备，分为左右两部分，发生路由跳转时，只有右边子页会被替换。
    
    **图2** 分栏布局示意图
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.44635127908442444956882181138608:50001231000000:2800:29D142503D371ED20B0604DA5CCCBD05F9767952FCC5D5CE19B49743361AF01D.png)
    
    将mode属性设置为NavigationMode.Split，Navigation组件即可设置为分栏显示模式。
    
    1. import { hilog } from '@kit.PerformanceAnalysisKit';
    2. const DOMAIN = 0x0000;
    3. @Entry
    4. @Component
    5. struct NavigationExample {
    6.   @State toolTmp: ToolbarItem = {
    7.     'value': "func",
    8.     'icon': "./image/ic_public_highlights.svg",  // 当前目录image文件夹下的图标资源
    9.     'action': () => {}
    10.   };
    11.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
    12.   private arr: number[] = [1, 2, 3];
    
    13.   @Builder
    14.   pageMap(name: string) {
    15.     if (name === "NavDestinationTitle1") {
    16.       pageOneTmp();
    17.     } else if (name === "NavDestinationTitle2") {
    18.       pageTwoTmp();
    19.     } else if (name === "NavDestinationTitle3") {
    20.       pageThreeTmp();
    21.     }
    22.   }
    
    23.   build() {
    24.     Column() {
    25.       Navigation(this.navPathStack) {
    26.         TextInput({ placeholder: 'search...' })
    27.           .width("90%")
    28.           .height(40)
    29.           .backgroundColor('#FFFFFF')
    
    30.         List({ space: 12 }) {
    31.           ForEach(this.arr, (item: number) => {
    32.             ListItem() {
    33.               Text("Page" + item)
    34.                 .width("100%")
    35.                 .height(72)
    36.                 .backgroundColor('#FFFFFF')
    37.                 .borderRadius(24)
    38.                 .fontSize(16)
    39.                 .fontWeight(500)
    40.                 .textAlign(TextAlign.Center)
    41.                 .onClick(() => {
    42.                   this.navPathStack.pushPath({ name: 'NavDestinationTitle' + item });
    43.                 })
    44.             }
    45.           }, (item: number) => item.toString())
    46.         }
    47.         .width("90%")
    48.         .margin({ top: 12 })
    49.       }
    50.       .title("主标题")
    51.       .mode(NavigationMode.Split)
    52.       .navDestination(this.pageMap)
    53.       .menus([
    54.         {
    55.           value: "", icon: "./image/ic_public_search.svg", action: () => {
    56.           }
    57.         },
    58.         {
    59.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    60.           }
    61.         },
    62.         {
    63.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    64.           }
    65.         },
    66.         {
    67.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    68.           }
    69.         },
    70.         {
    71.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    72.           }
    73.         }
    74.       ])
    75.       .toolbarConfiguration([this.toolTmp, this.toolTmp, this.toolTmp])
    76.     }
    77.     .height('100%')
    78.     .width('100%')
    79.     .backgroundColor('#F1F3F5')
    80.   }
    81. }
    
    82. // PageOne.ets
    83. @Component
    84. export struct pageOneTmp {
    85.   @Consume('navPathStack') navPathStack: NavPathStack;
    86.   context = this.getUIContext().getHostContext();
    87.   build() {
    88.     NavDestination() {
    89.       Column() {
    90.         Text("NavDestinationContent1")
    91.       }.width('100%').height('100%')
    92.     }.title("NavDestinationTitle1")
    93.     .onBackPressed(() => {
    94.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    95.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    96.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    97.         JSON.stringify(popDestinationInfo));
    98.       return true;
    99.     })
    100.   }
    101. }
    
    102. // PageTwo.ets
    103. @Component
    104. export struct pageTwoTmp {
    105.   @Consume('navPathStack') navPathStack: NavPathStack;
    106.   context = this.getUIContext().getHostContext();
    107.   build() {
    108.     NavDestination() {
    109.       Column() {
    110.         Text("NavDestinationContent2")
    111.       }.width('100%').height('100%')
    112.     }.title("NavDestinationTitle2")
    113.     .onBackPressed(() => {
    114.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    115.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    116.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    117.         JSON.stringify(popDestinationInfo));
    118.       return true;
    119.     })
    120.   }
    121. }
    
    122. // PageThree.ets
    123. @Component
    124. export struct pageThreeTmp {
    125.   @Consume('navPathStack') navPathStack: NavPathStack;
    126.   context = this.getUIContext().getHostContext();
    127.   build() {
    128.     NavDestination() {
    129.       Column() {
    130.         Text("NavDestinationContent3")
    131.       }.width('100%').height('100%')
    132.     }.title("NavDestinationTitle3")
    133.     .onBackPressed(() => {
    134.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    135.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    136.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    137.         JSON.stringify(popDestinationInfo));
    138.       return true;
    139.     })
    140.   }
    141. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.38522712307407973042152555339603:50001231000000:2800:210862FB40488CA357496A333F8C814C3375FF85E9C6EC2074FEB76A3517DB98.jpg)
    

## 设置标题栏模式

标题栏在界面顶部，用于呈现界面名称和操作入口，Navigation组件通过[titleMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#titlemode)属性设置标题栏模式。

说明

Navigation或NavDestination未设置主副标题并且没有返回键时，不显示标题栏。

- Mini模式
    
    普通型标题栏，用于一级页面不需要突出标题的场景。
    
    **图3** Mini模式标题栏
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.88917640640829362862283509704068:50001231000000:2800:A6899C99862B2B677DC35E58E135729F02D8AFC91611D3785F415702713E36CA.jpg)
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .titleMode(NavigationTitleMode.Mini)
    
- Full模式
    
    强调型标题栏，用于一级页面需要突出标题的场景。
    
    **图4** Full模式标题栏
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.76716253096362819389528325214830:50001231000000:2800:4F8C50DC6DC180EEDFCCD3B4029968E2FF19618370ED06D5B688BD572BCFB1EA.jpg)
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .titleMode(NavigationTitleMode.Full)
    

## 设置菜单栏

菜单栏位于Navigation组件的右上角，开发者可以通过[menus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#menus)属性进行设置。menus支持Array<[NavigationMenuItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationmenuitem)>和[CustomBuilder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types#custombuilder8)两种参数类型。使用Array<NavigationMenuItem>类型时，竖屏最多支持显示3个图标，横屏最多支持显示5个图标，多余的图标会被放入自动生成的更多图标。

**图5** 设置了3个图标的菜单栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.73673441631946749215245150548418:50001231000000:2800:807E87EF7E5ADFFA9A9A846ED20101AC4AB9A0643F48CF41A0150795BC65B0DD.jpg)

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       .menus([toolTmp, toolTmp, toolTmp])

图片也可以引用resources中的资源。

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'resources/base/media/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       .menus([toolTmp, toolTmp, toolTmp])

**图6** 设置了4个图标的菜单栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.50787801697064920089908207920699:50001231000000:2800:E62E892050408B63ACDFEA78F71C670DAD4153B291E146916FEB0AD290D16B77.jpg)

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       // 竖屏最多支持显示3个图标，多余的图标会被放入自动生成的更多图标
11.       .menus([toolTmp, toolTmp, toolTmp, toolTmp])

## 设置工具栏

工具栏位于Navigation组件的底部，开发者可以通过[toolbarConfiguration](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#toolbarconfiguration10)属性进行设置。

**图7** 工具栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.17051218093016793180970087149026:50001231000000:2800:99FD7107F1BDE63C8614828B7CB573E786230469AEF4242386295E47BECFC7B5.jpg)

1. let toolTmp: ToolbarItem = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_highlights.svg',
4.   'action': () => {}
5. };
6. let tooBar: ToolbarItem[] = [toolTmp,toolTmp,toolTmp];
7. // ...
8.       Navigation(this.navPathStack) {
9.         // ...
10.       }
11.       .toolbarConfiguration(tooBar)

## 路由操作

Navigation路由相关的操作都是基于导航控制器[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)提供的方法进行，每个Navigation都需要创建并传入一个NavPathStack对象，用于管理页面。主要涉及页面跳转、页面返回、页面替换、页面删除、参数获取、路由拦截等功能。

从API version 12开始，导航控制器允许被继承。开发者可以在派生类中自定义属性和方法，也可以重写父类的方法。派生类对象可以替代基类NavPathStack对象使用。Navigation中的[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)页面存在于NavPathStack中，以栈的结构管理，我们称为路由栈。具体示例代码参见：[导航控制器继承示例代码](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B10%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B4%BE%E7%94%9F%E7%B1%BB)。

说明

1.不建议开发者通过监听生命周期的方式管理自己的路由栈。

2.在应用处于后台状态下，调用NavPathStack的栈操作方法，会在应用再次回到前台状态时触发刷新。

1. @Entry
2. @Component
3. struct Index {
4.   // 创建一个导航控制器对象并传入Navigation
5.   pageStack: NavPathStack = new NavPathStack();

6.   build() {
7.     Navigation(this.pageStack) {
8.     }
9.     .title('Main')
10.   }
11. }

### 页面跳转

NavPathStack通过Push相关的接口（如[pushPath](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpath10)、[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)、[pushDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushdestination11)、[pushDestinationByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushdestinationbyname11)）去实现页面跳转的功能，主要分为以下三类：

1. 普通跳转，通过页面的name去跳转，并可以携带param。
    
    1. this.pageStack.pushPath({ name: "PageOne", param: "PageOne Param" });
    2. this.pageStack.pushPathByName("PageOne", "PageOne Param");
    
2. 带返回回调的跳转，跳转时添加onPop回调，能在页面出栈时获取返回信息，并进行处理。
    
    1. this.pageStack.pushPathByName('PageOne', "PageOne Param", (popInfo) => {
    2.   console.info('Pop page name is: ' + popInfo.info.name + ', result: ' + JSON.stringify(popInfo.result));
    3. });
    
3. 带错误码的跳转，跳转结束会触发异步回调，返回错误码信息。
    
    1. this.pageStack.pushDestination({name: "PageOne", param: "PageOne Param"})
    2.   .catch((error: BusinessError) => {
    3.     console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
    4.   }).then(() => {
    5.     console.info('Push destination succeed.');
    6.   });
    7. this.pageStack.pushDestinationByName("PageOne", "PageOne Param")
    8.   .catch((error: BusinessError) => {
    9.     console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
    10.   }).then(() => {
    11.     console.info('Push destination succeed.');
    12.   });
    

### 页面返回

NavPathStack通过pop相关接口（如[pop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pop10)、[popToName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#poptoname10)、[popToIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#poptoindex10)、[clear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#clear10)）去实现页面返回功能。

1. // 返回到上一页
2. this.pageStack.pop();
3. // 返回到上一个PageOne页面
4. this.pageStack.popToName("PageOne");
5. // 返回到索引为1的页面
6. this.pageStack.popToIndex(1);
7. // 返回到根首页（清除栈中所有页面）
8. this.pageStack.clear();

### 页面替换

NavPathStack通过Replace相关接口（如[replacePath](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacepath11)、[replacePathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacepathbyname11)、[replaceDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacedestination18)）去实现页面替换功能。

1. // 将栈顶页面替换为PageOne
2. this.pageStack.replacePath({ name: "PageOne", param: "PageOne Param" });
3. this.pageStack.replacePathByName("PageOne", "PageOne Param");
4. // 带错误码的替换，跳转结束会触发异步回调，返回错误码信息
5. this.pageStack.replaceDestination({name: "PageOne", param: "PageOne Param"})
6.   .catch((error: BusinessError) => {
7.     console.error(`Replace destination failed, error code = ${error.code}, error.message = ${error.message}.`);
8.   }).then(() => {
9.     console.info('Replace destination succeed.');
10.   })

### 页面删除

NavPathStack通过Remove相关接口（如[removeByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebyname11)、[removeByIndexes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebyindexes11)、[removeByNavDestinationId](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebynavdestinationid12)）去实现删除路由栈中特定页面的功能。

1. // 删除栈中name为PageOne的所有页面
2. this.pageStack.removeByName("PageOne");
3. // 删除指定索引的页面
4. this.pageStack.removeByIndexes([1, 3, 5]);
5. // 删除指定id的页面
6. this.pageStack.removeByNavDestinationId("1");

### 移动页面

NavPathStack通过Move相关接口（如[moveToTop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#movetotop10)、[moveIndexToTop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#moveindextotop10)）去实现移动路由栈中特定页面到栈顶的功能。

1. // 移动栈中name为PageOne的页面到栈顶
2. this.pageStack.moveToTop("PageOne");
3. // 移动栈中索引为1的页面到栈顶
4. this.pageStack.moveIndexToTop(1);

### 参数获取

[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)子页第一次创建时会触发[onReady](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onready11)回调，可以获取此页面对应的参数。

1. @Component
2. struct Page01 {
3.   pathStack: NavPathStack | undefined = undefined;
4.   pageParam: string = '';

5.   build() {
6.     NavDestination() {
7.       // ...
8.     }.title('Page01')
9.     .onReady((context: NavDestinationContext) => {
10.       this.pathStack = context.pathStack;
11.       this.pageParam = context.pathInfo.param as string;
12.     })
13.   }
14. }

NavDestination组件中可以通过设置[onResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onresult15)接口，接收返回时传递的路由参数。

1. class NavParam {
2.   desc: string = 'navigation-param'
3. }

4. @Component
5. struct DemoNavDestination {
6.   // ...
7.   build() {
8.     NavDestination() {
9.       // ...
10.     }
11.     .onResult((param: Object) => {
12.       if (param instanceof NavParam) {
13.         console.info('TestTag', 'get NavParam, its desc: ' + (param as NavParam).desc);
14.         return;
15.       }
16.       console.info('TestTag', 'param not instance of NavParam');
17.     })
18.   }
19. }

其他业务场景，可以通过主动调用NavPathStack的Get相关接口（如[getAllPathName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getallpathname10)、[getParamByIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getparambyindex10)、[getParamByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getparambyname10)、[getIndexByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getindexbyname10)）去获取指定页面的参数。

1. // 获取栈中所有页面name集合
2. this.pageStack.getAllPathName();
3. // 获取索引为1的页面参数
4. this.pageStack.getParamByIndex(1);
5. // 获取PageOne页面的参数
6. this.pageStack.getParamByName("PageOne");
7. // 获取PageOne页面的索引集合
8. this.pageStack.getIndexByName("PageOne");

### 路由拦截

NavPathStack提供了[setInterception](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#setinterception12)方法，用于设置Navigation页面跳转拦截回调。该方法需要传入一个[NavigationInterception](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationinterception12)对象，该对象包含三个回调函数：

|名称|描述|
|:--|:--|
|willShow|页面跳转前回调，允许操作栈，在当前跳转生效。|
|didShow|页面跳转后回调，在该回调中操作栈会在下一次跳转生效。|
|modeChange|Navigation单双栏显示状态发生变更时触发该回调。|

说明

无论是哪个回调，在进入回调时路由栈都已经发生了变化。

开发者可以在willShow回调中通过修改路由栈来实现路由拦截重定向的能力。

1. this.pageStack.setInterception({
2.   willShow: (from: NavDestinationContext | "navBar", to: NavDestinationContext | "navBar",
3.     operation: NavigationOperation, animated: boolean) => {
4.     if (typeof to === "string") {
5.       console.info("target page is navigation home page.");
6.       return;
7.     }
8.     // 将跳转到PageTwo的路由重定向到PageOne
9.     let target: NavDestinationContext = to as NavDestinationContext;
10.     if (target.pathInfo.name === 'PageTwo') {
11.       target.pathStack.pop();
12.       target.pathStack.pushPathByName('PageOne', null);
13.     }
14.   }
15. })

### 单例跳转

通过设置[LaunchMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#launchmode12%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)为LaunchMode.MOVE_TO_TOP_SINGLETON或LaunchMode.POP_TO_SINGLETON，可以实现Navigation路由栈的单实例跳转。单实例跳转的规则如下：

1. 当指定为LaunchMode.MOVE_TO_TOP_SINGLETON时，系统会从栈底到栈顶查找具有指定名称的NavDestination。找到后，该页面将被移动到栈顶（replace操作会用指定的NavDestination替换当前栈顶）。
2. 若指定为LaunchMode.POP_TO_SINGLETON，系统同样会从栈底到栈顶查找具有指定名称的NavDestination。找到后，便会移除该NavDestination上方的所有页面（replace操作会用指定的NavDestination替换当前栈顶）。

当栈中存在的NavDestination页面通过单实例方式移动到栈顶时，将触发[onNewParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onnewparam19)回调。

有关单实例跳转的示例代码，可以参考[Navigation单例跳转示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B2%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95)。

## 子页面

[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)是[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)子页面的根容器，用于承载子页面的一些特殊属性以及生命周期等。NavDestination可以设置独立的标题栏和菜单栏等属性，使用方法与Navigation相同。NavDestination也可以通过[mode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#mode11)属性设置不同的显示类型，用于满足不同页面的诉求。

### 页面显示类型

- 标准类型
    
    NavDestination组件默认为标准类型，此时mode属性为NavDestinationMode.STANDARD。标准类型的NavDestination的生命周期跟随其在NavPathStack路由栈中的位置变化而改变。
    
- 弹窗类型
    
    NavDestination设置mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination默认透明显示。弹窗类型的NavDestination显示和消失时不会影响下层标准类型的NavDestination的显示和生命周期，两者可以同时显示。
    
    1. // Dialog NavDestination
    2. @Entry
    3. @Component
    4.  struct Index {
    5.    @Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack();
    
    6.    @Builder
    7.    PagesMap(name: string) {
    8.      if (name == 'DialogPage') {
    9.        DialogPage();
    10.      }
    11.    }
    
    12.    build() {
    13.      Navigation(this.pageStack) {
    14.        Button('Push DialogPage')
    15.          .margin(20)
    16.          .width('80%')
    17.          .onClick(() => {
    18.            this.pageStack.pushPathByName('DialogPage', '');
    19.          })
    20.      }
    21.      .mode(NavigationMode.Stack)
    22.      .title('Main')
    23.      .navDestination(this.PagesMap)
    24.    }
    25.  }
    
    26.  @Component
    27.  export struct DialogPage {
    28.    @Consume('NavPathStack') pageStack: NavPathStack;
    
    29.    build() {
    30.      NavDestination() {
    31.        Stack({ alignContent: Alignment.Center }) {
    32.          Column() {
    33.            Text("Dialog NavDestination")
    34.              .fontSize(20)
    35.              .margin({ bottom: 100 })
    36.            Button("Close").onClick(() => {
    37.              this.pageStack.pop();
    38.            }).width('30%')
    39.          }
    40.          .justifyContent(FlexAlign.Center)
    41.          .backgroundColor(Color.White)
    42.          .borderRadius(10)
    43.          .height('30%')
    44.          .width('80%')
    45.        }.height("100%").width('100%')
    46.      }
    47.      .backgroundColor('rgba(0,0,0,0.5)')
    48.      .hideTitleBar(true)
    49.      .mode(NavDestinationMode.DIALOG)
    50.    }
    51.  }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.54044996889160545821333494615153:50001231000000:2800:1C6F64946E20589F1ADDBC055027E949D521EFD4BDC226343350F6401D3A6E86.png)
    

### 页面生命周期

Navigation作为路由容器，其生命周期承载在NavDestination组件上，以组件事件的形式开放。

其生命周期大致可分为三类，自定义组件生命周期、通用组件生命周期和自有生命周期。其中，[aboutToAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear)和[aboutToDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttodisappear)是自定义组件的生命周期(NavDestination外层包含的自定义组件)，[OnAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-show-hide#onappear)和[OnDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-show-hide#ondisappear)是组件的通用生命周期。剩下的生命周期为NavDestination独有。

生命周期时序如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.71014053475673058396905454101583:50001231000000:2800:2E7A765B6F0E13E37F64EA39C86F41B0C6FD73A0946A0B1D7B98F3744C840BB3.png)

- **aboutToAppear**：在创建自定义组件后，执行其build()函数之前执行（NavDestination创建之前），允许在该方法中改变状态变量，更改将在后续执行build()函数中生效。
- **onWillAppear**：NavDestination创建后，挂载到组件树之前执行，在该方法中更改状态变量会在当前帧显示生效。
- **onAppear**：通用生命周期事件，NavDestination组件挂载到组件树时执行。
- **onWillShow**：NavDestination组件布局显示之前执行，此时页面不可见（应用切换到前台不会触发）。
- **onShown**：NavDestination组件布局显示之后执行，此时页面已完成布局。
- **onActive**：NavDestination处于激活态（处于栈顶可操作，且上层无特殊组件遮挡）触发。
- **onWillHide**：NavDestination组件触发隐藏之前执行（应用切换到后台不会触发）。
- **onInactive**：NavDestination组件处于非激活态（处于非栈顶不可操作，或处于栈顶时上层有特殊组件遮挡）触发。
- **onHidden**：NavDestination组件触发隐藏后执行（非栈顶页面push进栈，栈顶页面pop出栈或应用切换到后台）。
- **onWillDisappear**：NavDestination组件即将销毁之前执行，如果有转场动画，会在动画前触发（栈顶页面pop出栈）。
- **onDisappear**：通用生命周期事件，NavDestination组件从组件树上卸载销毁时执行。
- **aboutToDisappear**：自定义组件析构销毁之前执行，不允许在该方法中改变状态变量。

### 页面监听和查询

为了方便组件跟页面解耦，在NavDestination子页面内部的自定义组件可以通过全局方法监听或查询到页面的一些状态信息。

- 页面信息查询
    
    自定义组件提供[queryNavDestinationInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-api#querynavdestinationinfo)方法，可以在NavDestination内部查询到当前所属页面的信息，返回值为[NavDestinationInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#navdestinationinfo)，若查询不到则返回undefined。
    
    1.  import { uiObserver } from '@kit.ArkUI';
    
    2.  // NavDestination内的自定义组件
    3.  @Component
    4.  struct MyComponent {
    5.    navDesInfo: uiObserver.NavDestinationInfo | undefined;
    
    6.    aboutToAppear(): void {
    7.      this.navDesInfo = this.queryNavDestinationInfo();
    8.    }
    
    9.    build() {
    10.        Column() {
    11.          Text("所属页面Name: " + this.navDesInfo?.name)
    12.        }.width('100%').height('100%')
    13.    }
    14.  }
    
- 页面状态监听
    
    通过[observer.on('navDestinationUpdate')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#uiobserveronnavdestinationupdate)提供的注册接口可以注册NavDestination生命周期变化的监听，使用方式如下：
    
    1. uiObserver.on('navDestinationUpdate', (info) => {
    2.      console.info('NavDestination state update', JSON.stringify(info));
    3.  });
    
    也可以注册页面切换的状态回调，能在页面发生路由切换的时候拿到对应的页面信息[NavDestinationSwitchInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#navdestinationswitchinfo12)，并且提供了UIAbilityContext和UIContext不同范围的监听：
    
    4.  // 在UIAbility中使用
    5.  import { UIContext, uiObserver } from '@kit.ArkUI';
    
    6.  // callbackFunc是开发者定义的监听回调函数
    7.  function callbackFunc(info: uiObserver.NavDestinationSwitchInfo) {}
    8.  uiObserver.on('navDestinationSwitch', this.context, callbackFunc);
    
    9.  // 可以通过窗口的getUIContext()方法获取对应的UIContent
    10.  uiContext: UIContext | null = null;
    11.  uiObserver.on('navDestinationSwitch', this.uiContext, callbackFunc);
    

## 页面转场

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)默认提供了页面切换的转场动画，通过导航控制器操作时，会触发不同的转场效果（API version 13之前，[Dialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview)类型的页面默认无转场动画。从API version13开始，Dialog类型的页面支持系统转场动画。），Navigation也提供了关闭系统转场、自定义转场以及共享元素转场的能力。系统默认动画时长由物理曲线参数决定，不同设备上动画时长存在差异。

### 关闭转场

- 全局关闭
    
    Navigation通过NavPathStack中提供的[disableAnimation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#disableanimation11)方法可以在当前Navigation中关闭或打开所有转场动画。
    
    1. pageStack: NavPathStack = new NavPathStack();
    
    2. aboutToAppear(): void {
    3.   this.pageStack.disableAnimation(true);
    4. }
    
- 单次关闭
    
    NavPathStack中提供的Push、Pop、Replace等接口中可以设置animated参数，默认为true表示有转场动画，需要单次关闭转场动画可以置为false，不影响下次转场动画。
    
    1. pageStack: NavPathStack = new NavPathStack();
    
    2. this.pageStack.pushPath({ name: "PageOne" }, false);
    3. this.pageStack.pop(false);
    

### 自定义转场

- Navigation自定义转场
    
    Navigation自定义转场动画能力通过[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)事件提供，可以通过以下三步定义自定义转场动画：
    
    1. 构建一个自定义转场动画工具类CustomNavigationUtils，通过一个Map管理各页面的自定义动画对象CustomTransition。页面在创建时注册其自定义转场动画对象，在销毁时取消注册。
    2. 实现一个转场协议对象[NavigationAnimatedTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationanimatedtransition11)。其中，timeout属性表示转场结束的超时时间，默认为1000ms，transition属性为自定义的转场动画方法。开发者需在此实现自己的转场动画逻辑，系统在转场开始时会调用此方法，onTransitionEnd为转场结束时的回调。
    3. 调用customNavContentTransition方法并返回实现的转场协议对象，若返回undefined，则使用系统默认转场。
    
    具体示例代码可参考[Navigation自定义转场示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B3%E8%AE%BE%E7%BD%AE%E5%8F%AF%E4%BA%A4%E4%BA%92%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB)。
    
- NavDestination自定义转场
    
    [NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)支持自定义转场动画，通过设置[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)属性即可实现单个页面的自定义转场效果。要实现这一功能，需完成以下步骤：
    
    1. 实现[NavDestination的转场代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#navdestinationtransitiondelegate15)，针对不同的堆栈操作类型返回自定义的转场协议对象[NavDestinationTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#navdestinationtransition15)。其中，event是必填参数，需在此处编写自定义转场动画的逻辑；而onTransitionEnd、duration、curve与delay为可选参数，分别对应动画结束后的回调、动画持续时间、动画曲线类型与开始前的延时。若在转场代理中返回多个转场协议对象，这些动画效果将逐层叠加。
    2. 通过调用NavDestination组件的customTransition属性，并传入上述实现的转场代理，完成自定义转场的设置。
    
    具体示例代码可以参考[NavDestination自定义转场示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#%E7%A4%BA%E4%BE%8B2%E8%AE%BE%E7%BD%AEnavdestination%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA)。
    
- 使用建议
    
    1. Navigation自定义转场[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)适用于控制Navigation内所有页面，统一转场动画效果。
    2. NavDestination自定义转场[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)适用于控制单个页面的转场效果。
    3. 在同时使用[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)和[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)时，customNavContentTransition优先级更高。

### 共享元素转场

NavDestination之间切换时可以通过[geometryTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-geometrytransition#geometrytransition)实现共享元素转场。配置了共享元素转场的页面同时需要关闭系统默认的转场动画。

1. 为需要实现共享元素转场的组件添加geometryTransition属性，id参数必须在两个NavDestination之间保持一致。
    
    1. // 起始页配置共享元素id
    2. NavDestination() {
    3.   Column() {
    4.     // ...
    5.     // $r('app.media.startIcon')需要替换为开发者所需的资源文件
    6.     Image($r('app.media.startIcon'))
    7.     .geometryTransition('sharedId')
    8.     .width(100)
    9.     .height(100)
    10.   }
    11. }
    12. .title('FromPage')
    
    13. // 目的页配置共享元素id
    14. NavDestination() {
    15.   Column() {
    16.     // ...
    17.     // $r('app.media.startIcon')需要替换为开发者所需的资源文件
    18.     Image($r('app.media.startIcon'))
    19.     .geometryTransition('sharedId')
    20.     .width(200)
    21.     .height(200)
    22.   }
    23. }
    24. .title('ToPage')
    
2. 将页面路由的操作，放到animateTo动画闭包中，配置对应的动画参数以及关闭系统默认的转场。
    
    1. NavDestination() {
    2.   Column() {
    3.     Button('跳转目的页')
    4.     .width('80%')
    5.     .height(40)
    6.     .margin(20)
    7.     .onClick(() => {
    8.         this.getUIContext()?.animateTo({ duration: 1000 }, () => {
    9.           this.pageStack.pushPath({ name: 'ToPage' }, false)
    10.         });
    11.     })
    12.   }
    13. }
    14. .title('FromPage')
    

## 跨包路由

系统提供[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)和[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)两种实现方式。

- 系统路由表相对自定义路由表，使用更简单，只需要添加对应页面跳转配置项，即可实现页面跳转。
    
- 自定义路由表使用起来更复杂，但是可以根据应用业务进行定制处理。
    

支持自定义路由表和系统路由表混用。

### 路由表能力对比

不同路由方式适用于不同需求，易用性或可扩展性需根据项目特点权衡选择。

|路由方式|跨包跳转能力|可扩展性|易用性|
|:--|:--|:--|:--|
|[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)|跳转前无需import页面文件，页面按需动态加载。|可扩展性一般。|易用性更强，系统自动维护路由表。|
|[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)|跳转前需要import页面文件。|可扩展性更强。|易用性一般，需要开发者自行维护路由表。|

### 系统路由表

系统路由表是动态路由的一种实现方式。从API version 12开始，[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)支持使用系统路由表的方式进行动态路由。各业务模块（[HSP](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp)/[HAR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package)）中需要独立配置route_map.json文件，在触发路由跳转时，应用只需要通过NavPathStack提供的路由方法，传入需要路由的页面配置名称，此时系统会自动完成路由模块的动态加载、页面组件构建，并完成路由跳转，从而实现了开发层面的模块解耦。系统路由表支持模拟器但不支持预览器。其主要步骤如下：

1. 在跳转目标模块的配置文件[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)添加路由表配置：
    
    1.   {
    2.     "module" : {
    3.       "routerMap": "$profile:route_map"
    4.     }
    5.   }
    
2. 添加完路由配置文件地址后，需要在工程resources/base/profile中创建route_map.json文件。添加如下配置信息：
    
    1.   {
    2.     "routerMap": [
    3.       {
    4.         "name": "PageOne",
    5.         "pageSourceFile": "src/main/ets/pages/PageOne.ets",
    6.         "buildFunction": "PageOneBuilder",
    7.         "data": {
    8.           "description" : "this is PageOne"
    9.         }
    10.       }
    11.     ]
    12.   }
    
    配置说明如下：
    
    |配置项|说明|
    |:--|:--|
    |name|可自定义的跳转页面名称。|
    |pageSourceFile|跳转目标页在包内的路径，相对src目录的相对路径。|
    |buildFunction|跳转目标页的入口函数名称，必须以@Builder修饰。|
    |data|应用自定义字段。可以通过配置项读取接口getConfigInRouteMap获取。|
    
3. 在跳转目标页面中，需要配置入口Builder函数，函数名称需要和route_map.json配置文件中的buildFunction保持一致，否则在编译时会报错。
    
    1.   // 跳转页面入口函数
    2.   @Builder
    3.   export function PageOneBuilder() {
    4.     PageOne();
    5.   }
    
    6.   @Component
    7.   struct PageOne {
    8.     pathStack: NavPathStack = new NavPathStack();
    
    9.     build() {
    10.       NavDestination() {
    11.       }
    12.       .title('PageOne')
    13.       .onReady((context: NavDestinationContext) => {
    14.          this.pathStack = context.pathStack;
    15.       })
    16.     }
    17.   }
    
4. 通过[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)等路由接口进行页面跳转。(注意：此时Navigation中可以不用配置[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性。)
    
    1.   @Entry
    2.   @Component
    3.   struct Index {
    4.     pageStack : NavPathStack = new NavPathStack();
    
    5.     build() {
    6.       Navigation(this.pageStack){
    7.       }.onAppear(() => {
    8.         this.pageStack.pushPathByName("PageOne", null, false);
    9.       })
    10.       .hideNavBar(true)
    11.     }
    12.   }
    

### 自定义路由表

自定义路由表通过给Navigation的[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性设置Builder函数实现，其特点是需要import页面。有两种import页面的方式，静态import和动态import，二者的区别在于：

|import方式|模块间耦合度|实现复杂度|性能|
|:--|:--|:--|:--|
|动态import|模块间解耦。|复杂度高。|性能好，按需加载，跳转前再加载对应页面。|
|静态import|模块间耦合。|复杂度低。|性能一般，初始化时一次性加载所有依赖的页面。|

**动态import（推荐）**

动态import旨在解决多个模块（HAR/HSP）能够复用相同的业务逻辑，实现各业务模块间的解耦，同时支持路由功能的扩展与整合，可以按需import，具体实现方法请参考[Navigation自定义动态路由](https://gitcode.com/harmonyos-cases/cases/blob/master/CommonAppDevelopment/common/routermodule/README_AUTO_GENERATE.md)示例。

动态import的优势：

- 路由定义除了跳转的URL以外，可以配置丰富的扩展信息，如横竖屏默认模式、是否需要鉴权等等，做路由跳转时统一处理。
- 给每个路由页面设置一个名字，按照名称进行跳转而不是文件路径。
- 页面的加载可以使用动态import（按需加载），防止首个页面加载大量代码导致卡顿。

实现方案：

1. 定义页面跳转配置项。
    - 使用资源文件进行定义，通过资源管理[@ohos.resourceManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resource-manager)在运行时对资源文件解析。
    - 在ets文件中配置路由加载配置项，一般包括路由页面名称（即pushPath等接口中页面的别名），文件所在模块名称（hsp/har的模块名），加载页面在模块内的路径（相对src目录的路径）。
2. 加载目标跳转页面，通过[动态import](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dynamic-import)将跳转目标页面所在的模块在运行时加载，在模块加载完成后，调用模块中的方法，通过import在模块的方法中加载模块中显示的目标页面，并返回页面加载完成后定义的Builder函数。
3. 触发页面跳转，在Navigation的[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性执行步骤2中加载的Builder函数，即可跳转到目标页面。

**静态import**

静态import实现方式简单，但通过静态import页面进行路由跳转会导致不同模块之间的依赖耦合，并增加首页加载时间长等问题。建议使用[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)的动态import或[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)。

实现方案：

1. import { hilog } from '@kit.PerformanceAnalysisKit';
2. const DOMAIN = 0x0000;
3. @Entry
4. @Component
5. struct NavigationExample {
6.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
7.   private arr: number[] = [1, 2];

8.   @Builder
9.   pageMap(name: string) {
10.     if (name === "NavDestinationTitle1") {
11.       pageOneTmp();
12.     } else if (name === "NavDestinationTitle2") {
13.       pageTwoTmp();
14.     }
15.   }

16.   build() {
17.     Column() {
18.       Navigation(this.navPathStack) {
19.         TextInput({ placeholder: 'search...' })
20.           .width("90%")
21.           .height(40)

22.         List({ space: 12 }) {
23.           ForEach(this.arr, (item: number) => {
24.             ListItem() {
25.               Text("Page" + item)
26.                 .width("100%")
27.                 .height(72)
28.                 .borderRadius(24)
29.                 .fontSize(16)
30.                 .fontWeight(500)
31.                 .textAlign(TextAlign.Center)
32.                 .onClick(() => {
33.                   this.navPathStack.pushPath({ name: 'NavDestinationTitle' + item });
34.                 })
35.             }
36.           }, (item: number) => item.toString())
37.         }
38.         .width("90%")
39.         .margin({ top: 12 })
40.       }
41.       // $r('app.string.mainTitle')需要替换为开发者所需的字符串资源文件
42.       .title($r('app.string.mainTitle'))
43.       .navDestination(this.pageMap)
44.       .mode(NavigationMode.Split)
45.     }
46.     .height('100%')
47.     .width('100%')
48.   }
49. }

50. @Component
51. export struct pageTwoTmp {
52.   @Consume('navPathStack') navPathStack: NavPathStack;
53.   context = this.getUIContext().getHostContext();
54.   build() {
55.     NavDestination() {
56.       Column() {
57.         Text("NavDestinationContent2")
58.       }.width('100%').height('100%')
59.     }.title("NavDestinationTitle2")
60.     .onBackPressed(() => {
61.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈的栈顶元素
62.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
63.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
64.         JSON.stringify(popDestinationInfo));
65.       return true;
66.     })
67.   }
68. }

69. // pageOne.ets
70. @Component
71. export struct pageOneTmp {
72.   @Consume('navPathStack') navPathStack: NavPathStack;
73.   context = this.getUIContext().getHostContext();
74.   build() {
75.     NavDestination() {
76.       Column() {
77.         Text("NavDestinationContent1")
78.       }.width('100%').height('100%')
79.     }.title("NavDestinationTitle1")
80.     .onBackPressed(() => {
81.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈的栈顶元素
82.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
83.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
84.         JSON.stringify(popDestinationInfo));
85.       return true;
86.     })
87.   }
88. }

## 导航示例

### 创建导航首页

实现步骤为：

1.使用[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)创建导航主页，并创建导航控制器NavPathStack以此来实现不同页面之间的跳转。

2.在Navigation中增加[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)组件，来定义导航主页中不同的一级界面。

3.在List内的组件添加onClick方法，并在其中使用导航控制器NavPathStack的[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。

1. @Entry
2. @Component
3. struct NavigationDemo {
4.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
5.   private listArray: Array<string> = ['WLAN', 'Bluetooth', 'Personal Hotspot', 'Connect & Share'];

6.   build() {
7.     Column() {
8.       Navigation(this.navPathStack) {
9.         TextInput({ placeholder: '输入关键字搜索' })
10.           .width('90%')
11.           .height(40)
12.           .margin({ bottom: 10 })

13.         // 通过List定义导航的一级界面
14.         List({ space: 12, initialIndex: 0 }) {
15.           ForEach(this.listArray, (item: string) => {
16.             ListItem() {
17.               Row() {
18.                 Row() {
19.                   Text(`${item.slice(0, 1)}`)
20.                     .fontColor(Color.White)
21.                     .fontSize(14)
22.                     .fontWeight(FontWeight.Bold)
23.                 }
24.                 .width(30)
25.                 .height(30)
26.                 .backgroundColor('#a8a8a8')
27.                 .margin({ right: 20 })
28.                 .borderRadius(20)
29.                 .justifyContent(FlexAlign.Center)

30.                 Column() {
31.                   Text(item)
32.                     .fontSize(16)
33.                     .margin({ bottom: 5 })
34.                 }
35.                 .alignItems(HorizontalAlign.Start)

36.                 Blank()

37.                 Row()
38.                   .width(12)
39.                   .height(12)
40.                   .margin({ right: 15 })
41.                   .border({
42.                     width: { top: 2, right: 2 },
43.                     color: 0xcccccc
44.                   })
45.                   .rotate({ angle: 45 })
46.               }
47.               .borderRadius(15)
48.               .shadow({ radius: 100, color: '#ededed' })
49.               .width('90%')
50.               .alignItems(VerticalAlign.Center)
51.               .padding({ left: 15, top: 15, bottom: 15 })
52.               .backgroundColor(Color.White)
53.             }
54.             .width('100%')
55.             .onClick(() => {
56.               this.navPathStack.pushPathByName(`${item}`, '详情页面参数'); // 将name指定的NaviDestination页面信息入栈,传递的参数为param
57.             })
58.           }, (item: string): string => item)
59.         }
60.         .listDirection(Axis.Vertical)
61.         .edgeEffect(EdgeEffect.Spring)
62.         .sticky(StickyStyle.Header)
63.         .chainAnimation(false)
64.         .width('100%')
65.       }
66.       .width('100%')
67.       .mode(NavigationMode.Auto)
68.       .title('设置') // 设置标题文字
69.     }
70.     .size({ width: '100%', height: '100%' })
71.     .backgroundColor(0xf4f4f5)
72.   }
73. }

### 创建导航子页

导航子页1实现步骤为：

1.使用[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)，来创建导航子页PageOne。

2.创建导航控制器[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)并在[onReady](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onready11)时进行初始化，获取当前所在的导航控制器，以此来实现不同页面之间的跳转。

3.在子页面内的组件添加onClick，并在其中使用导航控制器NavPathStack的[pop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pop10)方法，使组件可以在点击之后弹出路由栈栈顶元素实现页面的返回。

1. //PageOne.ets
2. @Builder
3. export function PageOneBuilder(name: string, param: string) {
4.   PageOne({ name: name, value: param });
5. }

6. @Component
7. export struct PageOne {
8.   navPathStack: NavPathStack = new NavPathStack();
9.   name: string = '';
10.   @State value: string = '';

11.   build() {
12.     NavDestination() {
13.       Column() {
14.         Text(`${this.name}设置页面`)
15.           .width('100%')
16.           .fontSize(20)
17.           .fontColor(0x333333)
18.           .textAlign(TextAlign.Center)
19.           .textShadow({
20.             radius: 2,
21.             offsetX: 4,
22.             offsetY: 4,
23.             color: 0x909399
24.           })
25.           .padding({ top: 30 })
26.         Text(`${JSON.stringify(this.value)}`)
27.           .width('100%')
28.           .fontSize(18)
29.           .fontColor(0x666666)
30.           .textAlign(TextAlign.Center)
31.           .padding({ top: 45 })
32.         Button('返回')
33.           .width('50%')
34.           .height(40)
35.           .margin({ top: 50 })
36.           .onClick(() => {
37.             //弹出路由栈栈顶元素，返回上个页面
38.             this.navPathStack.pop();
39.           })
40.       }
41.       .size({ width: '100%', height: '100%' })
42.     }.title(`${this.name}`)
43.     .onReady((ctx: NavDestinationContext) => {
44.       // NavDestinationContext获取当前所在的导航控制器
45.       this.navPathStack = ctx.pathStack;
46.     })
47.   }
48. }

导航子页2实现步骤为：

1.使用NavDestination，来创建导航子页PageTwo。

2.创建导航控制器NavPathStack并在onReady时进行初始化，获取当前所在的导航控制器，以此来实现不同页面之间的跳转。

3.在子页面内的组件添加onClick，并在其中使用导航控制器NavPathStack的[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。

1. //PageTwo.ets
2. @Builder
3. export function PageTwoBuilder(name: string) {
4.   PageTwo({ name: name });
5. }

6. @Component
7. export struct PageTwo {
8.   navPathStack: NavPathStack = new NavPathStack();
9.   name: string = '';
10.   private listArray: Array<string> = ['Projection', 'Print', 'VPN', 'Private DNS', 'NFC'];

11.   build() {
12.     NavDestination() {
13.       Column() {
14.         List({ space: 12, initialIndex: 0 }) {
15.           ForEach(this.listArray, (item: string) => {
16.             ListItem() {
17.               Row() {
18.                 Row() {
19.                   Text(`${item.slice(0, 1)}`)
20.                     .fontColor(Color.White)
21.                     .fontSize(14)
22.                     .fontWeight(FontWeight.Bold)
23.                 }
24.                 .width(30)
25.                 .height(30)
26.                 .backgroundColor('#a8a8a8')
27.                 .margin({ right: 20 })
28.                 .borderRadius(20)
29.                 .justifyContent(FlexAlign.Center)

30.                 Column() {
31.                   Text(item)
32.                     .fontSize(16)
33.                     .margin({ bottom: 5 })
34.                 }
35.                 .alignItems(HorizontalAlign.Start)

36.                 Blank()

37.                 Row()
38.                   .width(12)
39.                   .height(12)
40.                   .margin({ right: 15 })
41.                   .border({
42.                     width: { top: 2, right: 2 },
43.                     color: 0xcccccc
44.                   })
45.                   .rotate({ angle: 45 })
46.               }
47.               .borderRadius(15)
48.               .shadow({ radius: 100, color: '#ededed' })
49.               .width('90%')
50.               .alignItems(VerticalAlign.Center)
51.               .padding({ left: 15, top: 15, bottom: 15 })
52.               .backgroundColor(Color.White)
53.             }
54.             .width('100%')
55.             .onClick(() => {
56.               this.navPathStack.pushPathByName(`${item}`, '页面设置参数');
57.             })
58.           }, (item: string): string => item)
59.         }
60.         .listDirection(Axis.Vertical)
61.         .edgeEffect(EdgeEffect.Spring)
62.         .sticky(StickyStyle.Header)
63.         .width('100%')
64.       }
65.       .size({ width: '100%', height: '100%' })
66.     }.title(`${this.name}`)
67.     .onReady((ctx: NavDestinationContext) => {
68.       // NavDestinationContext获取当前所在的导航控制器
69.       this.navPathStack = ctx.pathStack;
70.     })
71.   }
72. }

### 创建路由跳转

实现步骤为：

1.工程配置文件[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中配置 {"routerMap": "$profile:router_map"}。

2.router_map.json中配置全局路由表，导航控制器NavPathStack可根据路由表中的name将对应页面信息入栈。

1. {
2.   "routerMap" : [
3.     {
4.       "name" : "WLAN",
5.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
6.       "buildFunction" : "PageOneBuilder"
7.     },
8.     {
9.       "name" : "Bluetooth",
10.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
11.       "buildFunction" : "PageOneBuilder"
12.     },
13.     {
14.       "name" : "Personal Hotspot",
15.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
16.       "buildFunction" : "PageOneBuilder"
17.     },
18.     {
19.       "name" : "Connect & Share",
20.       "pageSourceFile"  : "src/main/ets/pages/PageTwo.ets",
21.       "buildFunction" : "PageTwoBuilder"
22.     },
23.     {
24.       "name" : "Projection",
25.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
26.       "buildFunction" : "PageOneBuilder"
27.     },
28.     {
29.       "name" : "Print",
30.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
31.       "buildFunction" : "PageOneBuilder"
32.     },
33.     {
34.       "name" : "VPN",
35.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
36.       "buildFunction" : "PageOneBuilder"
37.     },
38.     {
39.       "name" : "Private DNS",
40.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
41.       "buildFunction" : "PageOneBuilder"
42.     },
43.     {
44.       "name" : "NFC",
45.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
46.       "buildFunction" : "PageOneBuilder"
47.     }
48.   ]
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.30221763759141194730167703387201:50001231000000:2800:EB5B03A9F555626B4E13396CEDB9352183B61BA8917A1A339930A3837013D609.gif)

## 示例代码

- [Navigation系统路由](https://gitcode.com/harmonyos_samples/system-router-map)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-introduction "组件导航和页面路由概述")
# 组件导航(Navigation) (推荐)

更新时间: 2025-12-16 16:39

组件导航（[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)）主要用于实现Navigation页面（[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)）间的跳转，支持在不同Navigation页面间传递参数，提供灵活的跳转栈操作，从而更便捷地实现对不同页面的访问和复用。本文将从组件导航（Navigation）的显示模式、路由操作、子页面管理、跨包跳转以及跳转动效等几个方面进行详细介绍。

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)是路由导航的根视图容器，一般作为页面（@Entry）的根容器，包括单栏（Stack）、分栏（Split）和自适应（Auto）三种显示模式。Navigation组件适用于模块内和跨模块的路由切换，通过组件级路由能力实现更加自然流畅的转场体验，并提供多种标题栏样式来呈现更好的标题和内容联动效果。一次开发，多端部署场景下，Navigation组件能够自动适配窗口显示大小，在窗口较大的场景下自动切换分栏展示效果。

Navigation组件主要包含​导航页和子页。导航页由标题栏（包含菜单栏）、内容区和工具栏组成，可以通过[hideNavBar](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#hidenavbar9)属性进行隐藏，导航页不存在[路由栈](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)中，与子页，以及子页之间可以通过路由操作进行切换。

在API version 9上，Navigation需要配合[NavRouter](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navrouter)组件实现页面路由。从API version 10开始，更推荐使用[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)实现页面路由。

## 设置页面显示模式

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)组件通过[mode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#mode9)属性设置页面的显示模式。

- 自适应模式
    
    Navigation组件默认为自适应模式，此时mode属性为NavigationMode.Auto。自适应模式下，当页面宽度大于等于一定阈值( API version 9及以前：520vp，API version 10及以后：600vp )时，Navigation组件采用分栏模式，反之采用单栏模式。
    
    收起
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .mode(NavigationMode.Auto)
    
- 单栏模式
    
    单栏模式适用于窄屏设备，发生路由跳转时，整个页面都会被替换。
    
    **图1** 单栏布局示意图
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.39247956913604846372315161784606:50001231000000:2800:925B5823D0F65790083C974E6538E7DE423A4CD226690DE88CA88D854F7E3F88.png)
    
    将mode属性设置为NavigationMode.Stack，Navigation组件即可设置为单栏显示模式。
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .mode(NavigationMode.Stack)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.94781536402667387449603288907682:50001231000000:2800:5E623CF9E47772521FAF0D79441B418D1FBF0ED5B16BADE1E1FC081CCAEFACA4.jpg)
    
- 分栏模式
    
    分栏模式适用于宽屏设备，分为左右两部分，发生路由跳转时，只有右边子页会被替换。
    
    **图2** 分栏布局示意图
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163913.44635127908442444956882181138608:50001231000000:2800:29D142503D371ED20B0604DA5CCCBD05F9767952FCC5D5CE19B49743361AF01D.png)
    
    将mode属性设置为NavigationMode.Split，Navigation组件即可设置为分栏显示模式。
    
    1. import { hilog } from '@kit.PerformanceAnalysisKit';
    2. const DOMAIN = 0x0000;
    3. @Entry
    4. @Component
    5. struct NavigationExample {
    6.   @State toolTmp: ToolbarItem = {
    7.     'value': "func",
    8.     'icon': "./image/ic_public_highlights.svg",  // 当前目录image文件夹下的图标资源
    9.     'action': () => {}
    10.   };
    11.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
    12.   private arr: number[] = [1, 2, 3];
    
    13.   @Builder
    14.   pageMap(name: string) {
    15.     if (name === "NavDestinationTitle1") {
    16.       pageOneTmp();
    17.     } else if (name === "NavDestinationTitle2") {
    18.       pageTwoTmp();
    19.     } else if (name === "NavDestinationTitle3") {
    20.       pageThreeTmp();
    21.     }
    22.   }
    
    23.   build() {
    24.     Column() {
    25.       Navigation(this.navPathStack) {
    26.         TextInput({ placeholder: 'search...' })
    27.           .width("90%")
    28.           .height(40)
    29.           .backgroundColor('#FFFFFF')
    
    30.         List({ space: 12 }) {
    31.           ForEach(this.arr, (item: number) => {
    32.             ListItem() {
    33.               Text("Page" + item)
    34.                 .width("100%")
    35.                 .height(72)
    36.                 .backgroundColor('#FFFFFF')
    37.                 .borderRadius(24)
    38.                 .fontSize(16)
    39.                 .fontWeight(500)
    40.                 .textAlign(TextAlign.Center)
    41.                 .onClick(() => {
    42.                   this.navPathStack.pushPath({ name: 'NavDestinationTitle' + item });
    43.                 })
    44.             }
    45.           }, (item: number) => item.toString())
    46.         }
    47.         .width("90%")
    48.         .margin({ top: 12 })
    49.       }
    50.       .title("主标题")
    51.       .mode(NavigationMode.Split)
    52.       .navDestination(this.pageMap)
    53.       .menus([
    54.         {
    55.           value: "", icon: "./image/ic_public_search.svg", action: () => {
    56.           }
    57.         },
    58.         {
    59.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    60.           }
    61.         },
    62.         {
    63.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    64.           }
    65.         },
    66.         {
    67.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    68.           }
    69.         },
    70.         {
    71.           value: "", icon: "./image/ic_public_add.svg", action: () => {
    72.           }
    73.         }
    74.       ])
    75.       .toolbarConfiguration([this.toolTmp, this.toolTmp, this.toolTmp])
    76.     }
    77.     .height('100%')
    78.     .width('100%')
    79.     .backgroundColor('#F1F3F5')
    80.   }
    81. }
    
    82. // PageOne.ets
    83. @Component
    84. export struct pageOneTmp {
    85.   @Consume('navPathStack') navPathStack: NavPathStack;
    86.   context = this.getUIContext().getHostContext();
    87.   build() {
    88.     NavDestination() {
    89.       Column() {
    90.         Text("NavDestinationContent1")
    91.       }.width('100%').height('100%')
    92.     }.title("NavDestinationTitle1")
    93.     .onBackPressed(() => {
    94.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    95.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    96.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    97.         JSON.stringify(popDestinationInfo));
    98.       return true;
    99.     })
    100.   }
    101. }
    
    102. // PageTwo.ets
    103. @Component
    104. export struct pageTwoTmp {
    105.   @Consume('navPathStack') navPathStack: NavPathStack;
    106.   context = this.getUIContext().getHostContext();
    107.   build() {
    108.     NavDestination() {
    109.       Column() {
    110.         Text("NavDestinationContent2")
    111.       }.width('100%').height('100%')
    112.     }.title("NavDestinationTitle2")
    113.     .onBackPressed(() => {
    114.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    115.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    116.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    117.         JSON.stringify(popDestinationInfo));
    118.       return true;
    119.     })
    120.   }
    121. }
    
    122. // PageThree.ets
    123. @Component
    124. export struct pageThreeTmp {
    125.   @Consume('navPathStack') navPathStack: NavPathStack;
    126.   context = this.getUIContext().getHostContext();
    127.   build() {
    128.     NavDestination() {
    129.       Column() {
    130.         Text("NavDestinationContent3")
    131.       }.width('100%').height('100%')
    132.     }.title("NavDestinationTitle3")
    133.     .onBackPressed(() => {
    134.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈栈顶元素
    135.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
    136.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
    137.         JSON.stringify(popDestinationInfo));
    138.       return true;
    139.     })
    140.   }
    141. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.38522712307407973042152555339603:50001231000000:2800:210862FB40488CA357496A333F8C814C3375FF85E9C6EC2074FEB76A3517DB98.jpg)
    

## 设置标题栏模式

标题栏在界面顶部，用于呈现界面名称和操作入口，Navigation组件通过[titleMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#titlemode)属性设置标题栏模式。

说明

Navigation或NavDestination未设置主副标题并且没有返回键时，不显示标题栏。

- Mini模式
    
    普通型标题栏，用于一级页面不需要突出标题的场景。
    
    **图3** Mini模式标题栏
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.88917640640829362862283509704068:50001231000000:2800:A6899C99862B2B677DC35E58E135729F02D8AFC91611D3785F415702713E36CA.jpg)
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .titleMode(NavigationTitleMode.Mini)
    
- Full模式
    
    强调型标题栏，用于一级页面需要突出标题的场景。
    
    **图4** Full模式标题栏
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.76716253096362819389528325214830:50001231000000:2800:4F8C50DC6DC180EEDFCCD3B4029968E2FF19618370ED06D5B688BD572BCFB1EA.jpg)
    
    1. Navigation() {
    2.   // ...
    3. }
    4. .titleMode(NavigationTitleMode.Full)
    

## 设置菜单栏

菜单栏位于Navigation组件的右上角，开发者可以通过[menus](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#menus)属性进行设置。menus支持Array<[NavigationMenuItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationmenuitem)>和[CustomBuilder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types#custombuilder8)两种参数类型。使用Array<NavigationMenuItem>类型时，竖屏最多支持显示3个图标，横屏最多支持显示5个图标，多余的图标会被放入自动生成的更多图标。

**图5** 设置了3个图标的菜单栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.73673441631946749215245150548418:50001231000000:2800:807E87EF7E5ADFFA9A9A846ED20101AC4AB9A0643F48CF41A0150795BC65B0DD.jpg)

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       .menus([toolTmp, toolTmp, toolTmp])

图片也可以引用resources中的资源。

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'resources/base/media/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       .menus([toolTmp, toolTmp, toolTmp])

**图6** 设置了4个图标的菜单栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.50787801697064920089908207920699:50001231000000:2800:E62E892050408B63ACDFEA78F71C670DAD4153B291E146916FEB0AD290D16B77.jpg)

1. let toolTmp: NavigationMenuItem  = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_add.svg',
4.   'action': () => {}
5. };
6. // ...
7.       Navigation(this.navPathStack) {
8.         // ...
9.       }
10.       // 竖屏最多支持显示3个图标，多余的图标会被放入自动生成的更多图标
11.       .menus([toolTmp, toolTmp, toolTmp, toolTmp])

## 设置工具栏

工具栏位于Navigation组件的底部，开发者可以通过[toolbarConfiguration](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#toolbarconfiguration10)属性进行设置。

**图7** 工具栏

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.17051218093016793180970087149026:50001231000000:2800:99FD7107F1BDE63C8614828B7CB573E786230469AEF4242386295E47BECFC7B5.jpg)

1. let toolTmp: ToolbarItem = {
2.   'value': 'func',
3.   'icon': 'ets/pages/navigation/template1/image/ic_public_highlights.svg',
4.   'action': () => {}
5. };
6. let tooBar: ToolbarItem[] = [toolTmp,toolTmp,toolTmp];
7. // ...
8.       Navigation(this.navPathStack) {
9.         // ...
10.       }
11.       .toolbarConfiguration(tooBar)

## 路由操作

Navigation路由相关的操作都是基于导航控制器[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)提供的方法进行，每个Navigation都需要创建并传入一个NavPathStack对象，用于管理页面。主要涉及页面跳转、页面返回、页面替换、页面删除、参数获取、路由拦截等功能。

从API version 12开始，导航控制器允许被继承。开发者可以在派生类中自定义属性和方法，也可以重写父类的方法。派生类对象可以替代基类NavPathStack对象使用。Navigation中的[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)页面存在于NavPathStack中，以栈的结构管理，我们称为路由栈。具体示例代码参见：[导航控制器继承示例代码](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B10%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B4%BE%E7%94%9F%E7%B1%BB)。

说明

1.不建议开发者通过监听生命周期的方式管理自己的路由栈。

2.在应用处于后台状态下，调用NavPathStack的栈操作方法，会在应用再次回到前台状态时触发刷新。

1. @Entry
2. @Component
3. struct Index {
4.   // 创建一个导航控制器对象并传入Navigation
5.   pageStack: NavPathStack = new NavPathStack();

6.   build() {
7.     Navigation(this.pageStack) {
8.     }
9.     .title('Main')
10.   }
11. }

### 页面跳转

NavPathStack通过Push相关的接口（如[pushPath](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpath10)、[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)、[pushDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushdestination11)、[pushDestinationByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushdestinationbyname11)）去实现页面跳转的功能，主要分为以下三类：

1. 普通跳转，通过页面的name去跳转，并可以携带param。
    
    1. this.pageStack.pushPath({ name: "PageOne", param: "PageOne Param" });
    2. this.pageStack.pushPathByName("PageOne", "PageOne Param");
    
2. 带返回回调的跳转，跳转时添加onPop回调，能在页面出栈时获取返回信息，并进行处理。
    
    1. this.pageStack.pushPathByName('PageOne', "PageOne Param", (popInfo) => {
    2.   console.info('Pop page name is: ' + popInfo.info.name + ', result: ' + JSON.stringify(popInfo.result));
    3. });
    
3. 带错误码的跳转，跳转结束会触发异步回调，返回错误码信息。
    
    1. this.pageStack.pushDestination({name: "PageOne", param: "PageOne Param"})
    2.   .catch((error: BusinessError) => {
    3.     console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
    4.   }).then(() => {
    5.     console.info('Push destination succeed.');
    6.   });
    7. this.pageStack.pushDestinationByName("PageOne", "PageOne Param")
    8.   .catch((error: BusinessError) => {
    9.     console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
    10.   }).then(() => {
    11.     console.info('Push destination succeed.');
    12.   });
    

### 页面返回

NavPathStack通过pop相关接口（如[pop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pop10)、[popToName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#poptoname10)、[popToIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#poptoindex10)、[clear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#clear10)）去实现页面返回功能。

1. // 返回到上一页
2. this.pageStack.pop();
3. // 返回到上一个PageOne页面
4. this.pageStack.popToName("PageOne");
5. // 返回到索引为1的页面
6. this.pageStack.popToIndex(1);
7. // 返回到根首页（清除栈中所有页面）
8. this.pageStack.clear();

### 页面替换

NavPathStack通过Replace相关接口（如[replacePath](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacepath11)、[replacePathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacepathbyname11)、[replaceDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#replacedestination18)）去实现页面替换功能。

1. // 将栈顶页面替换为PageOne
2. this.pageStack.replacePath({ name: "PageOne", param: "PageOne Param" });
3. this.pageStack.replacePathByName("PageOne", "PageOne Param");
4. // 带错误码的替换，跳转结束会触发异步回调，返回错误码信息
5. this.pageStack.replaceDestination({name: "PageOne", param: "PageOne Param"})
6.   .catch((error: BusinessError) => {
7.     console.error(`Replace destination failed, error code = ${error.code}, error.message = ${error.message}.`);
8.   }).then(() => {
9.     console.info('Replace destination succeed.');
10.   })

### 页面删除

NavPathStack通过Remove相关接口（如[removeByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebyname11)、[removeByIndexes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebyindexes11)、[removeByNavDestinationId](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#removebynavdestinationid12)）去实现删除路由栈中特定页面的功能。

1. // 删除栈中name为PageOne的所有页面
2. this.pageStack.removeByName("PageOne");
3. // 删除指定索引的页面
4. this.pageStack.removeByIndexes([1, 3, 5]);
5. // 删除指定id的页面
6. this.pageStack.removeByNavDestinationId("1");

### 移动页面

NavPathStack通过Move相关接口（如[moveToTop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#movetotop10)、[moveIndexToTop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#moveindextotop10)）去实现移动路由栈中特定页面到栈顶的功能。

1. // 移动栈中name为PageOne的页面到栈顶
2. this.pageStack.moveToTop("PageOne");
3. // 移动栈中索引为1的页面到栈顶
4. this.pageStack.moveIndexToTop(1);

### 参数获取

[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)子页第一次创建时会触发[onReady](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onready11)回调，可以获取此页面对应的参数。

1. @Component
2. struct Page01 {
3.   pathStack: NavPathStack | undefined = undefined;
4.   pageParam: string = '';

5.   build() {
6.     NavDestination() {
7.       // ...
8.     }.title('Page01')
9.     .onReady((context: NavDestinationContext) => {
10.       this.pathStack = context.pathStack;
11.       this.pageParam = context.pathInfo.param as string;
12.     })
13.   }
14. }

NavDestination组件中可以通过设置[onResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onresult15)接口，接收返回时传递的路由参数。

1. class NavParam {
2.   desc: string = 'navigation-param'
3. }

4. @Component
5. struct DemoNavDestination {
6.   // ...
7.   build() {
8.     NavDestination() {
9.       // ...
10.     }
11.     .onResult((param: Object) => {
12.       if (param instanceof NavParam) {
13.         console.info('TestTag', 'get NavParam, its desc: ' + (param as NavParam).desc);
14.         return;
15.       }
16.       console.info('TestTag', 'param not instance of NavParam');
17.     })
18.   }
19. }

其他业务场景，可以通过主动调用NavPathStack的Get相关接口（如[getAllPathName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getallpathname10)、[getParamByIndex](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getparambyindex10)、[getParamByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getparambyname10)、[getIndexByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#getindexbyname10)）去获取指定页面的参数。

1. // 获取栈中所有页面name集合
2. this.pageStack.getAllPathName();
3. // 获取索引为1的页面参数
4. this.pageStack.getParamByIndex(1);
5. // 获取PageOne页面的参数
6. this.pageStack.getParamByName("PageOne");
7. // 获取PageOne页面的索引集合
8. this.pageStack.getIndexByName("PageOne");

### 路由拦截

NavPathStack提供了[setInterception](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#setinterception12)方法，用于设置Navigation页面跳转拦截回调。该方法需要传入一个[NavigationInterception](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationinterception12)对象，该对象包含三个回调函数：

|名称|描述|
|:--|:--|
|willShow|页面跳转前回调，允许操作栈，在当前跳转生效。|
|didShow|页面跳转后回调，在该回调中操作栈会在下一次跳转生效。|
|modeChange|Navigation单双栏显示状态发生变更时触发该回调。|

说明

无论是哪个回调，在进入回调时路由栈都已经发生了变化。

开发者可以在willShow回调中通过修改路由栈来实现路由拦截重定向的能力。

1. this.pageStack.setInterception({
2.   willShow: (from: NavDestinationContext | "navBar", to: NavDestinationContext | "navBar",
3.     operation: NavigationOperation, animated: boolean) => {
4.     if (typeof to === "string") {
5.       console.info("target page is navigation home page.");
6.       return;
7.     }
8.     // 将跳转到PageTwo的路由重定向到PageOne
9.     let target: NavDestinationContext = to as NavDestinationContext;
10.     if (target.pathInfo.name === 'PageTwo') {
11.       target.pathStack.pop();
12.       target.pathStack.pushPathByName('PageOne', null);
13.     }
14.   }
15. })

### 单例跳转

通过设置[LaunchMode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#launchmode12%E6%9E%9A%E4%B8%BE%E8%AF%B4%E6%98%8E)为LaunchMode.MOVE_TO_TOP_SINGLETON或LaunchMode.POP_TO_SINGLETON，可以实现Navigation路由栈的单实例跳转。单实例跳转的规则如下：

1. 当指定为LaunchMode.MOVE_TO_TOP_SINGLETON时，系统会从栈底到栈顶查找具有指定名称的NavDestination。找到后，该页面将被移动到栈顶（replace操作会用指定的NavDestination替换当前栈顶）。
2. 若指定为LaunchMode.POP_TO_SINGLETON，系统同样会从栈底到栈顶查找具有指定名称的NavDestination。找到后，便会移除该NavDestination上方的所有页面（replace操作会用指定的NavDestination替换当前栈顶）。

当栈中存在的NavDestination页面通过单实例方式移动到栈顶时，将触发[onNewParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onnewparam19)回调。

有关单实例跳转的示例代码，可以参考[Navigation单例跳转示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B2%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95)。

## 子页面

[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)是[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)子页面的根容器，用于承载子页面的一些特殊属性以及生命周期等。NavDestination可以设置独立的标题栏和菜单栏等属性，使用方法与Navigation相同。NavDestination也可以通过[mode](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#mode11)属性设置不同的显示类型，用于满足不同页面的诉求。

### 页面显示类型

- 标准类型
    
    NavDestination组件默认为标准类型，此时mode属性为NavDestinationMode.STANDARD。标准类型的NavDestination的生命周期跟随其在NavPathStack路由栈中的位置变化而改变。
    
- 弹窗类型
    
    NavDestination设置mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination默认透明显示。弹窗类型的NavDestination显示和消失时不会影响下层标准类型的NavDestination的显示和生命周期，两者可以同时显示。
    
    1. // Dialog NavDestination
    2. @Entry
    3. @Component
    4.  struct Index {
    5.    @Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack();
    
    6.    @Builder
    7.    PagesMap(name: string) {
    8.      if (name == 'DialogPage') {
    9.        DialogPage();
    10.      }
    11.    }
    
    12.    build() {
    13.      Navigation(this.pageStack) {
    14.        Button('Push DialogPage')
    15.          .margin(20)
    16.          .width('80%')
    17.          .onClick(() => {
    18.            this.pageStack.pushPathByName('DialogPage', '');
    19.          })
    20.      }
    21.      .mode(NavigationMode.Stack)
    22.      .title('Main')
    23.      .navDestination(this.PagesMap)
    24.    }
    25.  }
    
    26.  @Component
    27.  export struct DialogPage {
    28.    @Consume('NavPathStack') pageStack: NavPathStack;
    
    29.    build() {
    30.      NavDestination() {
    31.        Stack({ alignContent: Alignment.Center }) {
    32.          Column() {
    33.            Text("Dialog NavDestination")
    34.              .fontSize(20)
    35.              .margin({ bottom: 100 })
    36.            Button("Close").onClick(() => {
    37.              this.pageStack.pop();
    38.            }).width('30%')
    39.          }
    40.          .justifyContent(FlexAlign.Center)
    41.          .backgroundColor(Color.White)
    42.          .borderRadius(10)
    43.          .height('30%')
    44.          .width('80%')
    45.        }.height("100%").width('100%')
    46.      }
    47.      .backgroundColor('rgba(0,0,0,0.5)')
    48.      .hideTitleBar(true)
    49.      .mode(NavDestinationMode.DIALOG)
    50.    }
    51.  }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.54044996889160545821333494615153:50001231000000:2800:1C6F64946E20589F1ADDBC055027E949D521EFD4BDC226343350F6401D3A6E86.png)
    

### 页面生命周期

Navigation作为路由容器，其生命周期承载在NavDestination组件上，以组件事件的形式开放。

其生命周期大致可分为三类，自定义组件生命周期、通用组件生命周期和自有生命周期。其中，[aboutToAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear)和[aboutToDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttodisappear)是自定义组件的生命周期(NavDestination外层包含的自定义组件)，[OnAppear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-show-hide#onappear)和[OnDisappear](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-show-hide#ondisappear)是组件的通用生命周期。剩下的生命周期为NavDestination独有。

生命周期时序如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.71014053475673058396905454101583:50001231000000:2800:2E7A765B6F0E13E37F64EA39C86F41B0C6FD73A0946A0B1D7B98F3744C840BB3.png)

- **aboutToAppear**：在创建自定义组件后，执行其build()函数之前执行（NavDestination创建之前），允许在该方法中改变状态变量，更改将在后续执行build()函数中生效。
- **onWillAppear**：NavDestination创建后，挂载到组件树之前执行，在该方法中更改状态变量会在当前帧显示生效。
- **onAppear**：通用生命周期事件，NavDestination组件挂载到组件树时执行。
- **onWillShow**：NavDestination组件布局显示之前执行，此时页面不可见（应用切换到前台不会触发）。
- **onShown**：NavDestination组件布局显示之后执行，此时页面已完成布局。
- **onActive**：NavDestination处于激活态（处于栈顶可操作，且上层无特殊组件遮挡）触发。
- **onWillHide**：NavDestination组件触发隐藏之前执行（应用切换到后台不会触发）。
- **onInactive**：NavDestination组件处于非激活态（处于非栈顶不可操作，或处于栈顶时上层有特殊组件遮挡）触发。
- **onHidden**：NavDestination组件触发隐藏后执行（非栈顶页面push进栈，栈顶页面pop出栈或应用切换到后台）。
- **onWillDisappear**：NavDestination组件即将销毁之前执行，如果有转场动画，会在动画前触发（栈顶页面pop出栈）。
- **onDisappear**：通用生命周期事件，NavDestination组件从组件树上卸载销毁时执行。
- **aboutToDisappear**：自定义组件析构销毁之前执行，不允许在该方法中改变状态变量。

### 页面监听和查询

为了方便组件跟页面解耦，在NavDestination子页面内部的自定义组件可以通过全局方法监听或查询到页面的一些状态信息。

- 页面信息查询
    
    自定义组件提供[queryNavDestinationInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-api#querynavdestinationinfo)方法，可以在NavDestination内部查询到当前所属页面的信息，返回值为[NavDestinationInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#navdestinationinfo)，若查询不到则返回undefined。
    
    1.  import { uiObserver } from '@kit.ArkUI';
    
    2.  // NavDestination内的自定义组件
    3.  @Component
    4.  struct MyComponent {
    5.    navDesInfo: uiObserver.NavDestinationInfo | undefined;
    
    6.    aboutToAppear(): void {
    7.      this.navDesInfo = this.queryNavDestinationInfo();
    8.    }
    
    9.    build() {
    10.        Column() {
    11.          Text("所属页面Name: " + this.navDesInfo?.name)
    12.        }.width('100%').height('100%')
    13.    }
    14.  }
    
- 页面状态监听
    
    通过[observer.on('navDestinationUpdate')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#uiobserveronnavdestinationupdate)提供的注册接口可以注册NavDestination生命周期变化的监听，使用方式如下：
    
    1. uiObserver.on('navDestinationUpdate', (info) => {
    2.      console.info('NavDestination state update', JSON.stringify(info));
    3.  });
    
    也可以注册页面切换的状态回调，能在页面发生路由切换的时候拿到对应的页面信息[NavDestinationSwitchInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-observer#navdestinationswitchinfo12)，并且提供了UIAbilityContext和UIContext不同范围的监听：
    
    4.  // 在UIAbility中使用
    5.  import { UIContext, uiObserver } from '@kit.ArkUI';
    
    6.  // callbackFunc是开发者定义的监听回调函数
    7.  function callbackFunc(info: uiObserver.NavDestinationSwitchInfo) {}
    8.  uiObserver.on('navDestinationSwitch', this.context, callbackFunc);
    
    9.  // 可以通过窗口的getUIContext()方法获取对应的UIContent
    10.  uiContext: UIContext | null = null;
    11.  uiObserver.on('navDestinationSwitch', this.uiContext, callbackFunc);
    

## 页面转场

[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)默认提供了页面切换的转场动画，通过导航控制器操作时，会触发不同的转场效果（API version 13之前，[Dialog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-base-dialog-overview)类型的页面默认无转场动画。从API version13开始，Dialog类型的页面支持系统转场动画。），Navigation也提供了关闭系统转场、自定义转场以及共享元素转场的能力。系统默认动画时长由物理曲线参数决定，不同设备上动画时长存在差异。

### 关闭转场

- 全局关闭
    
    Navigation通过NavPathStack中提供的[disableAnimation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#disableanimation11)方法可以在当前Navigation中关闭或打开所有转场动画。
    
    1. pageStack: NavPathStack = new NavPathStack();
    
    2. aboutToAppear(): void {
    3.   this.pageStack.disableAnimation(true);
    4. }
    
- 单次关闭
    
    NavPathStack中提供的Push、Pop、Replace等接口中可以设置animated参数，默认为true表示有转场动画，需要单次关闭转场动画可以置为false，不影响下次转场动画。
    
    1. pageStack: NavPathStack = new NavPathStack();
    
    2. this.pageStack.pushPath({ name: "PageOne" }, false);
    3. this.pageStack.pop(false);
    

### 自定义转场

- Navigation自定义转场
    
    Navigation自定义转场动画能力通过[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)事件提供，可以通过以下三步定义自定义转场动画：
    
    1. 构建一个自定义转场动画工具类CustomNavigationUtils，通过一个Map管理各页面的自定义动画对象CustomTransition。页面在创建时注册其自定义转场动画对象，在销毁时取消注册。
    2. 实现一个转场协议对象[NavigationAnimatedTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navigationanimatedtransition11)。其中，timeout属性表示转场结束的超时时间，默认为1000ms，transition属性为自定义的转场动画方法。开发者需在此实现自己的转场动画逻辑，系统在转场开始时会调用此方法，onTransitionEnd为转场结束时的回调。
    3. 调用customNavContentTransition方法并返回实现的转场协议对象，若返回undefined，则使用系统默认转场。
    
    具体示例代码可参考[Navigation自定义转场示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#%E7%A4%BA%E4%BE%8B3%E8%AE%BE%E7%BD%AE%E5%8F%AF%E4%BA%A4%E4%BA%92%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB)。
    
- NavDestination自定义转场
    
    [NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)支持自定义转场动画，通过设置[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)属性即可实现单个页面的自定义转场效果。要实现这一功能，需完成以下步骤：
    
    1. 实现[NavDestination的转场代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#navdestinationtransitiondelegate15)，针对不同的堆栈操作类型返回自定义的转场协议对象[NavDestinationTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#navdestinationtransition15)。其中，event是必填参数，需在此处编写自定义转场动画的逻辑；而onTransitionEnd、duration、curve与delay为可选参数，分别对应动画结束后的回调、动画持续时间、动画曲线类型与开始前的延时。若在转场代理中返回多个转场协议对象，这些动画效果将逐层叠加。
    2. 通过调用NavDestination组件的customTransition属性，并传入上述实现的转场代理，完成自定义转场的设置。
    
    具体示例代码可以参考[NavDestination自定义转场示例](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#%E7%A4%BA%E4%BE%8B2%E8%AE%BE%E7%BD%AEnavdestination%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA)。
    
- 使用建议
    
    1. Navigation自定义转场[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)适用于控制Navigation内所有页面，统一转场动画效果。
    2. NavDestination自定义转场[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)适用于控制单个页面的转场效果。
    3. 在同时使用[customNavContentTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#customnavcontenttransition11)和[customTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#customtransition15)时，customNavContentTransition优先级更高。

### 共享元素转场

NavDestination之间切换时可以通过[geometryTransition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-transition-animation-geometrytransition#geometrytransition)实现共享元素转场。配置了共享元素转场的页面同时需要关闭系统默认的转场动画。

1. 为需要实现共享元素转场的组件添加geometryTransition属性，id参数必须在两个NavDestination之间保持一致。
    
    1. // 起始页配置共享元素id
    2. NavDestination() {
    3.   Column() {
    4.     // ...
    5.     // $r('app.media.startIcon')需要替换为开发者所需的资源文件
    6.     Image($r('app.media.startIcon'))
    7.     .geometryTransition('sharedId')
    8.     .width(100)
    9.     .height(100)
    10.   }
    11. }
    12. .title('FromPage')
    
    13. // 目的页配置共享元素id
    14. NavDestination() {
    15.   Column() {
    16.     // ...
    17.     // $r('app.media.startIcon')需要替换为开发者所需的资源文件
    18.     Image($r('app.media.startIcon'))
    19.     .geometryTransition('sharedId')
    20.     .width(200)
    21.     .height(200)
    22.   }
    23. }
    24. .title('ToPage')
    
2. 将页面路由的操作，放到animateTo动画闭包中，配置对应的动画参数以及关闭系统默认的转场。
    
    1. NavDestination() {
    2.   Column() {
    3.     Button('跳转目的页')
    4.     .width('80%')
    5.     .height(40)
    6.     .margin(20)
    7.     .onClick(() => {
    8.         this.getUIContext()?.animateTo({ duration: 1000 }, () => {
    9.           this.pageStack.pushPath({ name: 'ToPage' }, false)
    10.         });
    11.     })
    12.   }
    13. }
    14. .title('FromPage')
    

## 跨包路由

系统提供[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)和[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)两种实现方式。

- 系统路由表相对自定义路由表，使用更简单，只需要添加对应页面跳转配置项，即可实现页面跳转。
    
- 自定义路由表使用起来更复杂，但是可以根据应用业务进行定制处理。
    

支持自定义路由表和系统路由表混用。

### 路由表能力对比

不同路由方式适用于不同需求，易用性或可扩展性需根据项目特点权衡选择。

|路由方式|跨包跳转能力|可扩展性|易用性|
|:--|:--|:--|:--|
|[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)|跳转前无需import页面文件，页面按需动态加载。|可扩展性一般。|易用性更强，系统自动维护路由表。|
|[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)|跳转前需要import页面文件。|可扩展性更强。|易用性一般，需要开发者自行维护路由表。|

### 系统路由表

系统路由表是动态路由的一种实现方式。从API version 12开始，[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)支持使用系统路由表的方式进行动态路由。各业务模块（[HSP](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp)/[HAR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package)）中需要独立配置route_map.json文件，在触发路由跳转时，应用只需要通过NavPathStack提供的路由方法，传入需要路由的页面配置名称，此时系统会自动完成路由模块的动态加载、页面组件构建，并完成路由跳转，从而实现了开发层面的模块解耦。系统路由表支持模拟器但不支持预览器。其主要步骤如下：

1. 在跳转目标模块的配置文件[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)添加路由表配置：
    
    1.   {
    2.     "module" : {
    3.       "routerMap": "$profile:route_map"
    4.     }
    5.   }
    
2. 添加完路由配置文件地址后，需要在工程resources/base/profile中创建route_map.json文件。添加如下配置信息：
    
    1.   {
    2.     "routerMap": [
    3.       {
    4.         "name": "PageOne",
    5.         "pageSourceFile": "src/main/ets/pages/PageOne.ets",
    6.         "buildFunction": "PageOneBuilder",
    7.         "data": {
    8.           "description" : "this is PageOne"
    9.         }
    10.       }
    11.     ]
    12.   }
    
    配置说明如下：
    
    |配置项|说明|
    |:--|:--|
    |name|可自定义的跳转页面名称。|
    |pageSourceFile|跳转目标页在包内的路径，相对src目录的相对路径。|
    |buildFunction|跳转目标页的入口函数名称，必须以@Builder修饰。|
    |data|应用自定义字段。可以通过配置项读取接口getConfigInRouteMap获取。|
    
3. 在跳转目标页面中，需要配置入口Builder函数，函数名称需要和route_map.json配置文件中的buildFunction保持一致，否则在编译时会报错。
    
    1.   // 跳转页面入口函数
    2.   @Builder
    3.   export function PageOneBuilder() {
    4.     PageOne();
    5.   }
    
    6.   @Component
    7.   struct PageOne {
    8.     pathStack: NavPathStack = new NavPathStack();
    
    9.     build() {
    10.       NavDestination() {
    11.       }
    12.       .title('PageOne')
    13.       .onReady((context: NavDestinationContext) => {
    14.          this.pathStack = context.pathStack;
    15.       })
    16.     }
    17.   }
    
4. 通过[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)等路由接口进行页面跳转。(注意：此时Navigation中可以不用配置[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性。)
    
    1.   @Entry
    2.   @Component
    3.   struct Index {
    4.     pageStack : NavPathStack = new NavPathStack();
    
    5.     build() {
    6.       Navigation(this.pageStack){
    7.       }.onAppear(() => {
    8.         this.pageStack.pushPathByName("PageOne", null, false);
    9.       })
    10.       .hideNavBar(true)
    11.     }
    12.   }
    

### 自定义路由表

自定义路由表通过给Navigation的[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性设置Builder函数实现，其特点是需要import页面。有两种import页面的方式，静态import和动态import，二者的区别在于：

|import方式|模块间耦合度|实现复杂度|性能|
|:--|:--|:--|:--|
|动态import|模块间解耦。|复杂度高。|性能好，按需加载，跳转前再加载对应页面。|
|静态import|模块间耦合。|复杂度低。|性能一般，初始化时一次性加载所有依赖的页面。|

**动态import（推荐）**

动态import旨在解决多个模块（HAR/HSP）能够复用相同的业务逻辑，实现各业务模块间的解耦，同时支持路由功能的扩展与整合，可以按需import，具体实现方法请参考[Navigation自定义动态路由](https://gitcode.com/harmonyos-cases/cases/blob/master/CommonAppDevelopment/common/routermodule/README_AUTO_GENERATE.md)示例。

动态import的优势：

- 路由定义除了跳转的URL以外，可以配置丰富的扩展信息，如横竖屏默认模式、是否需要鉴权等等，做路由跳转时统一处理。
- 给每个路由页面设置一个名字，按照名称进行跳转而不是文件路径。
- 页面的加载可以使用动态import（按需加载），防止首个页面加载大量代码导致卡顿。

实现方案：

1. 定义页面跳转配置项。
    - 使用资源文件进行定义，通过资源管理[@ohos.resourceManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resource-manager)在运行时对资源文件解析。
    - 在ets文件中配置路由加载配置项，一般包括路由页面名称（即pushPath等接口中页面的别名），文件所在模块名称（hsp/har的模块名），加载页面在模块内的路径（相对src目录的路径）。
2. 加载目标跳转页面，通过[动态import](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dynamic-import)将跳转目标页面所在的模块在运行时加载，在模块加载完成后，调用模块中的方法，通过import在模块的方法中加载模块中显示的目标页面，并返回页面加载完成后定义的Builder函数。
3. 触发页面跳转，在Navigation的[navDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navdestination10)属性执行步骤2中加载的Builder函数，即可跳转到目标页面。

**静态import**

静态import实现方式简单，但通过静态import页面进行路由跳转会导致不同模块之间的依赖耦合，并增加首页加载时间长等问题。建议使用[自定义路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A1%A8)的动态import或[系统路由表](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1%E8%A1%A8)。

实现方案：

1. import { hilog } from '@kit.PerformanceAnalysisKit';
2. const DOMAIN = 0x0000;
3. @Entry
4. @Component
5. struct NavigationExample {
6.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
7.   private arr: number[] = [1, 2];

8.   @Builder
9.   pageMap(name: string) {
10.     if (name === "NavDestinationTitle1") {
11.       pageOneTmp();
12.     } else if (name === "NavDestinationTitle2") {
13.       pageTwoTmp();
14.     }
15.   }

16.   build() {
17.     Column() {
18.       Navigation(this.navPathStack) {
19.         TextInput({ placeholder: 'search...' })
20.           .width("90%")
21.           .height(40)

22.         List({ space: 12 }) {
23.           ForEach(this.arr, (item: number) => {
24.             ListItem() {
25.               Text("Page" + item)
26.                 .width("100%")
27.                 .height(72)
28.                 .borderRadius(24)
29.                 .fontSize(16)
30.                 .fontWeight(500)
31.                 .textAlign(TextAlign.Center)
32.                 .onClick(() => {
33.                   this.navPathStack.pushPath({ name: 'NavDestinationTitle' + item });
34.                 })
35.             }
36.           }, (item: number) => item.toString())
37.         }
38.         .width("90%")
39.         .margin({ top: 12 })
40.       }
41.       // $r('app.string.mainTitle')需要替换为开发者所需的字符串资源文件
42.       .title($r('app.string.mainTitle'))
43.       .navDestination(this.pageMap)
44.       .mode(NavigationMode.Split)
45.     }
46.     .height('100%')
47.     .width('100%')
48.   }
49. }

50. @Component
51. export struct pageTwoTmp {
52.   @Consume('navPathStack') navPathStack: NavPathStack;
53.   context = this.getUIContext().getHostContext();
54.   build() {
55.     NavDestination() {
56.       Column() {
57.         Text("NavDestinationContent2")
58.       }.width('100%').height('100%')
59.     }.title("NavDestinationTitle2")
60.     .onBackPressed(() => {
61.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈的栈顶元素
62.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
63.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
64.         JSON.stringify(popDestinationInfo));
65.       return true;
66.     })
67.   }
68. }

69. // pageOne.ets
70. @Component
71. export struct pageOneTmp {
72.   @Consume('navPathStack') navPathStack: NavPathStack;
73.   context = this.getUIContext().getHostContext();
74.   build() {
75.     NavDestination() {
76.       Column() {
77.         Text("NavDestinationContent1")
78.       }.width('100%').height('100%')
79.     }.title("NavDestinationTitle1")
80.     .onBackPressed(() => {
81.       const popDestinationInfo = this.navPathStack.pop(); // 弹出路由栈的栈顶元素
82.       // $r('app.string.returnValue')需要替换为开发者所需的字符串资源文件
83.       hilog.info(DOMAIN, 'testTag', 'pop', this.context!.resourceManager.getStringSync($r('app.string.returnValue').id),
84.         JSON.stringify(popDestinationInfo));
85.       return true;
86.     })
87.   }
88. }

## 导航示例

### 创建导航首页

实现步骤为：

1.使用[Navigation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation)创建导航主页，并创建导航控制器NavPathStack以此来实现不同页面之间的跳转。

2.在Navigation中增加[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list)组件，来定义导航主页中不同的一级界面。

3.在List内的组件添加onClick方法，并在其中使用导航控制器NavPathStack的[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。

1. @Entry
2. @Component
3. struct NavigationDemo {
4.   @Provide('navPathStack') navPathStack: NavPathStack = new NavPathStack();
5.   private listArray: Array<string> = ['WLAN', 'Bluetooth', 'Personal Hotspot', 'Connect & Share'];

6.   build() {
7.     Column() {
8.       Navigation(this.navPathStack) {
9.         TextInput({ placeholder: '输入关键字搜索' })
10.           .width('90%')
11.           .height(40)
12.           .margin({ bottom: 10 })

13.         // 通过List定义导航的一级界面
14.         List({ space: 12, initialIndex: 0 }) {
15.           ForEach(this.listArray, (item: string) => {
16.             ListItem() {
17.               Row() {
18.                 Row() {
19.                   Text(`${item.slice(0, 1)}`)
20.                     .fontColor(Color.White)
21.                     .fontSize(14)
22.                     .fontWeight(FontWeight.Bold)
23.                 }
24.                 .width(30)
25.                 .height(30)
26.                 .backgroundColor('#a8a8a8')
27.                 .margin({ right: 20 })
28.                 .borderRadius(20)
29.                 .justifyContent(FlexAlign.Center)

30.                 Column() {
31.                   Text(item)
32.                     .fontSize(16)
33.                     .margin({ bottom: 5 })
34.                 }
35.                 .alignItems(HorizontalAlign.Start)

36.                 Blank()

37.                 Row()
38.                   .width(12)
39.                   .height(12)
40.                   .margin({ right: 15 })
41.                   .border({
42.                     width: { top: 2, right: 2 },
43.                     color: 0xcccccc
44.                   })
45.                   .rotate({ angle: 45 })
46.               }
47.               .borderRadius(15)
48.               .shadow({ radius: 100, color: '#ededed' })
49.               .width('90%')
50.               .alignItems(VerticalAlign.Center)
51.               .padding({ left: 15, top: 15, bottom: 15 })
52.               .backgroundColor(Color.White)
53.             }
54.             .width('100%')
55.             .onClick(() => {
56.               this.navPathStack.pushPathByName(`${item}`, '详情页面参数'); // 将name指定的NaviDestination页面信息入栈,传递的参数为param
57.             })
58.           }, (item: string): string => item)
59.         }
60.         .listDirection(Axis.Vertical)
61.         .edgeEffect(EdgeEffect.Spring)
62.         .sticky(StickyStyle.Header)
63.         .chainAnimation(false)
64.         .width('100%')
65.       }
66.       .width('100%')
67.       .mode(NavigationMode.Auto)
68.       .title('设置') // 设置标题文字
69.     }
70.     .size({ width: '100%', height: '100%' })
71.     .backgroundColor(0xf4f4f5)
72.   }
73. }

### 创建导航子页

导航子页1实现步骤为：

1.使用[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination)，来创建导航子页PageOne。

2.创建导航控制器[NavPathStack](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#navpathstack10)并在[onReady](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onready11)时进行初始化，获取当前所在的导航控制器，以此来实现不同页面之间的跳转。

3.在子页面内的组件添加onClick，并在其中使用导航控制器NavPathStack的[pop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pop10)方法，使组件可以在点击之后弹出路由栈栈顶元素实现页面的返回。

1. //PageOne.ets
2. @Builder
3. export function PageOneBuilder(name: string, param: string) {
4.   PageOne({ name: name, value: param });
5. }

6. @Component
7. export struct PageOne {
8.   navPathStack: NavPathStack = new NavPathStack();
9.   name: string = '';
10.   @State value: string = '';

11.   build() {
12.     NavDestination() {
13.       Column() {
14.         Text(`${this.name}设置页面`)
15.           .width('100%')
16.           .fontSize(20)
17.           .fontColor(0x333333)
18.           .textAlign(TextAlign.Center)
19.           .textShadow({
20.             radius: 2,
21.             offsetX: 4,
22.             offsetY: 4,
23.             color: 0x909399
24.           })
25.           .padding({ top: 30 })
26.         Text(`${JSON.stringify(this.value)}`)
27.           .width('100%')
28.           .fontSize(18)
29.           .fontColor(0x666666)
30.           .textAlign(TextAlign.Center)
31.           .padding({ top: 45 })
32.         Button('返回')
33.           .width('50%')
34.           .height(40)
35.           .margin({ top: 50 })
36.           .onClick(() => {
37.             //弹出路由栈栈顶元素，返回上个页面
38.             this.navPathStack.pop();
39.           })
40.       }
41.       .size({ width: '100%', height: '100%' })
42.     }.title(`${this.name}`)
43.     .onReady((ctx: NavDestinationContext) => {
44.       // NavDestinationContext获取当前所在的导航控制器
45.       this.navPathStack = ctx.pathStack;
46.     })
47.   }
48. }

导航子页2实现步骤为：

1.使用NavDestination，来创建导航子页PageTwo。

2.创建导航控制器NavPathStack并在onReady时进行初始化，获取当前所在的导航控制器，以此来实现不同页面之间的跳转。

3.在子页面内的组件添加onClick，并在其中使用导航控制器NavPathStack的[pushPathByName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation#pushpathbyname10)方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。

1. //PageTwo.ets
2. @Builder
3. export function PageTwoBuilder(name: string) {
4.   PageTwo({ name: name });
5. }

6. @Component
7. export struct PageTwo {
8.   navPathStack: NavPathStack = new NavPathStack();
9.   name: string = '';
10.   private listArray: Array<string> = ['Projection', 'Print', 'VPN', 'Private DNS', 'NFC'];

11.   build() {
12.     NavDestination() {
13.       Column() {
14.         List({ space: 12, initialIndex: 0 }) {
15.           ForEach(this.listArray, (item: string) => {
16.             ListItem() {
17.               Row() {
18.                 Row() {
19.                   Text(`${item.slice(0, 1)}`)
20.                     .fontColor(Color.White)
21.                     .fontSize(14)
22.                     .fontWeight(FontWeight.Bold)
23.                 }
24.                 .width(30)
25.                 .height(30)
26.                 .backgroundColor('#a8a8a8')
27.                 .margin({ right: 20 })
28.                 .borderRadius(20)
29.                 .justifyContent(FlexAlign.Center)

30.                 Column() {
31.                   Text(item)
32.                     .fontSize(16)
33.                     .margin({ bottom: 5 })
34.                 }
35.                 .alignItems(HorizontalAlign.Start)

36.                 Blank()

37.                 Row()
38.                   .width(12)
39.                   .height(12)
40.                   .margin({ right: 15 })
41.                   .border({
42.                     width: { top: 2, right: 2 },
43.                     color: 0xcccccc
44.                   })
45.                   .rotate({ angle: 45 })
46.               }
47.               .borderRadius(15)
48.               .shadow({ radius: 100, color: '#ededed' })
49.               .width('90%')
50.               .alignItems(VerticalAlign.Center)
51.               .padding({ left: 15, top: 15, bottom: 15 })
52.               .backgroundColor(Color.White)
53.             }
54.             .width('100%')
55.             .onClick(() => {
56.               this.navPathStack.pushPathByName(`${item}`, '页面设置参数');
57.             })
58.           }, (item: string): string => item)
59.         }
60.         .listDirection(Axis.Vertical)
61.         .edgeEffect(EdgeEffect.Spring)
62.         .sticky(StickyStyle.Header)
63.         .width('100%')
64.       }
65.       .size({ width: '100%', height: '100%' })
66.     }.title(`${this.name}`)
67.     .onReady((ctx: NavDestinationContext) => {
68.       // NavDestinationContext获取当前所在的导航控制器
69.       this.navPathStack = ctx.pathStack;
70.     })
71.   }
72. }

### 创建路由跳转

实现步骤为：

1.工程配置文件[module.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中配置 {"routerMap": "$profile:router_map"}。

2.router_map.json中配置全局路由表，导航控制器NavPathStack可根据路由表中的name将对应页面信息入栈。

1. {
2.   "routerMap" : [
3.     {
4.       "name" : "WLAN",
5.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
6.       "buildFunction" : "PageOneBuilder"
7.     },
8.     {
9.       "name" : "Bluetooth",
10.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
11.       "buildFunction" : "PageOneBuilder"
12.     },
13.     {
14.       "name" : "Personal Hotspot",
15.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
16.       "buildFunction" : "PageOneBuilder"
17.     },
18.     {
19.       "name" : "Connect & Share",
20.       "pageSourceFile"  : "src/main/ets/pages/PageTwo.ets",
21.       "buildFunction" : "PageTwoBuilder"
22.     },
23.     {
24.       "name" : "Projection",
25.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
26.       "buildFunction" : "PageOneBuilder"
27.     },
28.     {
29.       "name" : "Print",
30.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
31.       "buildFunction" : "PageOneBuilder"
32.     },
33.     {
34.       "name" : "VPN",
35.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
36.       "buildFunction" : "PageOneBuilder"
37.     },
38.     {
39.       "name" : "Private DNS",
40.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
41.       "buildFunction" : "PageOneBuilder"
42.     },
43.     {
44.       "name" : "NFC",
45.       "pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
46.       "buildFunction" : "PageOneBuilder"
47.     }
48.   ]
49. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163914.30221763759141194730167703387201:50001231000000:2800:EB5B03A9F555626B4E13396CEDB9352183B61BA8917A1A339930A3837013D609.gif)

## 示例代码

- [Navigation系统路由](https://gitcode.com/harmonyos_samples/system-router-map)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-introduction "组件导航和页面路由概述")
# 开发应用沉浸式效果

更新时间: 2025-12-16 16:39

## 概述

典型应用全屏窗口UI元素包括顶部[状态栏](https://developer.huawei.com/consumer/cn/doc/design-guides/status-bar-0000001776775568)、应用界面和底部导航区域（根据用户设置可表现为[导航条](https://developer.huawei.com/consumer/cn/doc/design-guides/navigation-0000001957075737)或三键导航），其中状态栏和导航区域，通常在沉浸式布局下称为避让区；避让区之外的区域称为安全区。开发应用沉浸式效果主要指通过调整状态栏、应用界面和底部导航区域的显示效果来减少状态栏、导航条或三键导航等系统界面的突兀感，从而使用户获得最佳的UI体验。

**图1** 界面元素示意图（此处以导航区域表现为导航条为例给出示意）  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.66183599372440285502873852231614:50001231000000:2800:7913E74432ECA76CC08C129FF68240BE3F1A235F53DBAC59530E070D48BD1C50.png "点击放大")

开发应用沉浸式效果主要要考虑如下几个设计要素：

- UI元素避让处理：底部导航区域可以响应点击事件，除此之外的可交互UI元素和应用关键信息不建议放到导航区域。状态栏显示系统信息，如果与界面元素有冲突，需要考虑避让状态栏。
- 沉浸式效果处理：设置状态栏的颜色和导航区域的显隐与界面元素颜色相匹配，不出现明显的突兀感。

针对上面的设计要求，可以通过如下两种方式实现应用沉浸式效果：

- [窗口全屏布局方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section15671730447)：调整布局系统为全屏布局，界面元素延伸到状态栏和导航区域实现沉浸式效果。当不隐藏避让区时，可通过接口查询状态栏和导航区域进行可交互元素避让处理，并设置状态栏或导航区域的颜色或显隐等属性与界面元素匹配。当隐藏避让区时，通过对应接口设置全屏布局即可。
- [组件安全区方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202081847174413)：布局系统保持安全区内布局，然后通过接口延伸绘制内容（如背景色，背景图）到状态栏和导航区域实现沉浸式效果。
    
    该方案下，界面元素仅做绘制延伸，无法单独布局到状态栏和导航区域，针对需要单独布局UI元素到状态栏和导航区域的场景建议使用窗口全屏布局方案处理。
    

## 窗口全屏布局方案

窗口全屏布局方案主要涉及以下[应用扩展布局，全屏显示，不隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section171801550301)和[应用扩展布局，隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202484117114)两个应用场景。

### 应用扩展布局，全屏显示，不隐藏避让区

可以通过调用窗口强制全屏布局接口[setWindowLayoutFullScreen()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)实现界面元素延伸到状态栏和导航区域；然后通过接口[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)和[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)获取并动态监听避让区域的变更信息，页面布局根据避让区域信息进行动态调整；设置状态栏或导航区域的颜色或显隐等属性与界面元素进行匹配。

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2-3中的操作
    21.     });
    22.   }
    23. }
    
2. 使用[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口获取当前布局遮挡区域（此处以状态栏、导航区域为例）。
    
    1. // EntryAbility.ets
    2. // 2. 获取布局避让遮挡的区域
    3. let type = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; // 此处以导航条避让为例
    4. let avoidArea = windowClass.getWindowAvoidArea(type);
    5. let bottomRectHeight = avoidArea.bottomRect.height; // 获取到导航区域的高度
    6. AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    
    7. type = window.AvoidAreaType.TYPE_SYSTEM; // 以状态栏避让为例
    8. avoidArea = windowClass.getWindowAvoidArea(type);
    9. let topRectHeight = avoidArea.topRect.height; // 获取状态栏区域高度     
    10. AppStorage.setOrCreate('topRectHeight', topRectHeight);
    
3. 注册监听函数，动态获取避让区域的实时数据。常见的触发避让区回调的场景如下：应用窗口在全屏模式、悬浮模式、分屏模式之间的切换；应用窗口旋转；多折叠设备在屏幕折叠态和展开态之间的切换；应用窗口在多设备之间的流转。
    
    1. // EntryAbility.ets
    2. // 3. 注册监听函数，动态获取避让区域数据
    3. windowClass.on('avoidAreaChange', (data) => {
    4.   if (data.type === window.AvoidAreaType.TYPE_SYSTEM) {
    5.     let topRectHeight = data.area.topRect.height;
    6.     AppStorage.setOrCreate('topRectHeight', topRectHeight);
    7.   } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
    8.     let bottomRectHeight = data.area.bottomRect.height;
    9.     AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    10.   }
    11. });
    
4. 布局中的UI元素需要避让状态栏和导航区域，否则可能产生UI元素重叠等情况。
    
    说明
    
    避让区域存在大小为0的情况，当获取到的避让区域为0时，开发者需注意针对性处理适配此时的页面区域和布局，避免贴边、内容裁剪等问题，影响应用界面正常显示或美观性。
    
    如下例子中，对控件顶部设置padding（具体数值与状态栏高度一致），实现对状态栏的避让；对底部设置padding（具体数值与底部导航区域高度一致），实现对导航条的避让。如果去掉顶部和底部的padding设置，即不避让状态栏和导航条，UI元素就会发生重叠。具体可见下文步骤中图2和图3的效果对比。
    
    1. // Index.ets
    2. @Entry
    3. @Component
    4. struct Index {
    5.   @StorageProp('bottomRectHeight')
    6.   bottomRectHeight: number = 0;
    7.   @StorageProp('topRectHeight')
    8.   topRectHeight: number = 0;
    
    9.   build() {
    10.     Column() {
    11.       Row() {
    12.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    13.       }.backgroundColor('#2786d9')
    
    14.       Row() {
    15.         Text('Display Content 2').fontSize(30)
    16.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.       Row() {
    18.         Text('Display Content 3').fontSize(30)
    19.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.       Row() {
    21.         Text('Display Content 4').fontSize(30)
    22.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.       Row() {
    24.         Text('Display Content 5').fontSize(30)
    25.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    26.       Row() {
    27.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    28.       }.backgroundColor('#96dffa')
    29.     }
    30.     .width('100%')
    31.     .height('100%')
    32.     .alignItems(HorizontalAlign.Center)
    33.     .backgroundColor('#d5d5d5')
    34.     .justifyContent(FlexAlign.SpaceBetween)
    35.     // top数值与状态栏区域高度保持一致；bottom数值与导航区域高度保持一致
    36.     .padding({
    37.       top: this.getUIContext().px2vp(this.topRectHeight),
    38.       bottom: this.getUIContext().px2vp(this.bottomRectHeight)
    39.     })
    40.   }
    41. }
    
5. 根据实际的UI界面显示或相关UI元素背景颜色等，还可以按需设置状态栏的文字颜色、背景色或设置导航区域的显示或隐藏，以使UI界面效果呈现和谐。状态栏和导航区域默认是透明的，透传的是应用界面的背景色。
    
    此例中UI颜色主要有两种，比较简单，故未对状态栏文字颜色、背景色进行设置，未对导航区域进行隐藏。
    
    **图2** 布局避让状态栏和导航区域（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.87006013163778539261709498662392:50001231000000:2800:A746E4D652D3D20AA672A5BF165B3699C55DC9456E44001D102D538ACD77E72B.jpg "点击放大")
    
    **图3** 布局未避让状态栏和导航区域，UI元素重叠（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.57353412750221239108308721929172:50001231000000:2800:648A1F02A8BC0F5532422C2B618955F93999C9C2477489BA8D5714D235BF32FC.jpg "点击放大")
    

### 应用扩展布局，隐藏避让区

此场景下状态栏和导航区域需要隐藏，适用于游戏、电影等应用场景。用户可以通过从底部上滑唤出导航条或三键导航。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.99837954210435397706545783363927:50001231000000:2800:E0DDA552D6BF528E237CF861592011D02174A684C85AF203C34ACA45490F2C88.png "点击放大")

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2中的状态栏和导航区域的隐藏操作
    21.     });
    22.   }
    23. }
    
2. 调用[setSpecificSystemBarEnabled()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setspecificsystembarenabled11)接口设置状态栏和导航区域的具体显隐状态，此场景下将其设置为隐藏。
    
    1. // EntryAbility.ets
    2. // 2. 设置状态栏隐藏
    3. windowClass.setSpecificSystemBarEnabled('status', false).then(() => {
    4.   console.info('Succeeded in setting the status bar to be invisible.');
    5. }).catch((err: BusinessError) => {
    6.   console.error(`Failed to set the status bar to be invisible. Code is ${err.code}, message is ${err.message}`);
    7. });
    8. // 2. 设置导航区域隐藏
    9. windowClass.setSpecificSystemBarEnabled('navigationIndicator', false).then(() => {
    10.   console.info('Succeeded in setting the navigation indicator to be invisible.');
    11. }).catch((err: BusinessError) => {
    12.   console.error(`Failed to set the navigation indicator to be invisible. Code is ${err.code}, message is ${err.message}`);
    13. });
    
3. 在界面中无需进行导航区域避让操作。
    
    1. // Index.ets
    2. @Entry()
    3. @Component
    4. struct Index {
    5.   build() {
    6.     Row() {
    7.       Column() {
    8.         Row() {
    9.           Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    10.         }.backgroundColor('#2786d9')
    
    11.         Row() {
    12.           Text('Display Content 2').fontSize(30)
    13.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    14.         Row() {
    15.           Text('Display Content 3').fontSize(30)
    16.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.         Row() {
    18.           Text('Display Content 4').fontSize(30)
    19.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.         Row() {
    21.           Text('Display Content 5').fontSize(30)
    22.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.         Row() {
    24.           Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    25.         }.backgroundColor('#96dffa')
    26.       }
    27.       .width('100%')
    28.       .height('100%')
    29.       .alignItems(HorizontalAlign.Center)
    30.       .justifyContent(FlexAlign.SpaceBetween)
    31.       .backgroundColor('#d5d5d5')
    32.     }
    33.   }
    34. }
    

## 组件安全区方案

应用未使用setWindowLayoutFullScreen()接口设置窗口全屏布局时，默认采取组件安全区布局方案。

应用在默认情况下窗口背景绘制范围是全屏，但UI元素被限制在安全区内（自动排除状态栏和导航区域）进行布局，来避免界面元素被状态栏和导航区域遮盖。

**图4** 界面元素自动避让状态栏和导航区域示意图  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.49785881633116705159423116990391:50001231000000:2800:B33C69BC76D51355EC3CAE2413AEFC2778B11EF1DE34BF763C3215C43D52EEA0.png "点击放大")

针对状态栏和导航区域颜色与界面元素颜色不匹配问题，可以通过如下两种方式实现沉浸式效果：

- 状态栏和导航区域颜色相同场景，可以通过设置窗口的背景色来实现沉浸式效果。窗口背景色可通过[setWindowBackgroundColor()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowbackgroundcolor9)进行设置。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    
    3. export default class EntryAbility extends UIAbility {
    4.   //...
    
    5.   onWindowStageCreate(windowStage: window.WindowStage): void {
    6.     windowStage.loadContent('pages/Index', (err) => {
    7.       if (err.code) {
    8.         return;
    9.       }
    
    10.       // 设置全窗颜色和应用元素颜色一致
    11.       windowStage.getMainWindowSync().setWindowBackgroundColor('#d5d5d5');
    12.     });
    13.   }
    14. }
    
    界面状态栏和导航区域颜色相同场景。
    
    15. // xxx.ets
    16. @Entry
    17. @Component
    18. struct Example {
    19.   build() {
    20.     Column() {
    21.       Row() {
    22.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    23.       }.backgroundColor('#2786d9')
    
    24.       Row() {
    25.         Text('Display Content 2').fontSize(30)
    26.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    27.       Row() {
    28.         Text('Display Content 3').fontSize(30)
    29.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    30.       Row() {
    31.         Text('Display Content 4').fontSize(30)
    32.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    33.       Row() {
    34.         Text('Display Content 5').fontSize(30)
    35.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    36.       Row() {
    37.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    38.       }.backgroundColor('#96dffa')
    39.     }
    40.     .width('100%').height('100%')
    41.     .alignItems(HorizontalAlign.Center)
    42.     .backgroundColor('#d5d5d5')
    43.     .justifyContent(FlexAlign.SpaceBetween)
    44.   }
    45. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.48684961595489300477977200533131:50001231000000:2800:4DB5CDA0E0D7958CB4FB8E8AEC3D5128DD0539822614E9C3C8FD853148872890.png)
    
- 状态栏和导航区域颜色不同时，可以使用[expandSafeArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea)属性扩展安全区域属性进行调整。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct Example {
    5.   build() {
    6.     Column() {
    7.       Row() {
    8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    9.       }.backgroundColor('#2786d9')
    10.       // 设置顶部绘制延伸到状态栏
    11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
    
    12.       Row() {
    13.         Text('Display Content 2').fontSize(30)
    14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    15.       Row() {
    16.         Text('Display Content 3').fontSize(30)
    17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    18.       Row() {
    19.         Text('Display Content 4').fontSize(30)
    20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    21.       Row() {
    22.         Text('Display Content 5').fontSize(30)
    23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    24.       Row() {
    25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    26.       }.backgroundColor('#96dffa')
    27.       // 设置底部绘制延伸到导航区域
    28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
    29.     }
    30.     .width('100%').height('100%')
    31.     .alignItems(HorizontalAlign.Center)
    32.     .backgroundColor('#d5d5d5')
    33.     .justifyContent(FlexAlign.SpaceBetween)
    34.   }
    35. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.75061394560447074198529736772042:50001231000000:2800:902E75D5CF9C4DD79174E234EDE65E52140DEE800228E4183BD6AB6FD0CFA27E.png)
    

### 扩展安全区域属性原理

- 布局阶段按照安全区范围大小进行UI元素布局。
- 布局完成后查看设置了expandSafeArea的组件边界（不包括margin）是否和安全区边界相交。
- 如果设置了expandSafeArea的组件和安全区边界相交，根据expandSafeArea传递的属性则进一步扩大组件绘制区域大小覆盖状态栏、导航区域这些非安全区域。
- 上述过程仅改变组件自身绘制大小，不进行二次布局，不影响子节点和兄弟节点的大小和位置。
- 子节点可以单独设置该属性，只需要自身边界和安全区域重合就可以延伸自身大小至非安全区域内，需要确保父组件未设置clip等裁切属性。
- 配置expandSafeArea属性组件进行绘制扩展时，需要关注组件不能配置固定宽高尺寸，百分比除外。
- 组件可以设置通用属性safeAreaPadding，给自身添加组件级安全区域。该属性作为一种特殊边距，在提供布局约束的同时作为安全区可以被一些系统组件利用。
    - safeAreaPadding位于原有的padding内侧。容器自外向内各层分别为border、padding、safeAreaPadding、内容区。当border和padding确定后，若容器可用空间不足以满足safeAreaPadding的设置，则优先分配给左侧和上侧safeAreaPadding、其次分配给右侧和下侧safeAreaPadding。safeAreaPadding实际尺寸确定后，余下空间为内容区。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.40814739523074922976450985656583:50001231000000:2800:3069DA8848E75088A5E18CA4DEFE8D5B560459053EC369BEE936096F37485126.png "点击放大")
        
    - 系统组件如Navigation、List、Scroll、Tabs等可以利用外层或容器自身safeAreaPadding实现扩大裁剪范围等能力。

### 背景图和视频场景

设置背景图、视频组件大小为安全区域大小并配置expandSafeArea属性。

说明

Video组件在使用expandSafeArea扩展到安全区域时，组件视频显示内容区域不支持扩展。

1. // xxx.ets
2. @Entry
3. @Component
4. struct SafeAreaExample1 {
5.   build() {
6.     Stack() {
7.       Image($r('app.media.bg'))
8.         .height('100%').width('100%')
9.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]) // 图片组件的绘制区域扩展至状态栏和导航区域。
10.     }.height('100%').width('100%')
11.   }
12. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.43327826020269771674865794312820:50001231000000:2800:1022E21DA063B1509DB723CB9C69FDA61F3F93D6E7581D7C47F6EA7DAE310B6F.png)

### 滚动类场景

滚动容器设置expandSafeArea属性生效，但当父组件是滚动容器时，子组件设置expandSafeArea属性不生效。对于滚动容器的子组件，有两种方法实现沉浸式效果：

1. 设置父组件滚动容器和子组件相同的背景色，给父组件设置expandSafeArea属性扩展安全区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    20.     }.width('100%').height('100%')
    21.     .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    22.   }
    23. }
    
    **图5** 滚动类容器设置expandSafeArea属性实现沉浸式效果  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.36343620665340982594714223798161:50001231000000:2800:AD6E0F7C59190801230E58A4FFAF23D4F65F1FDE15A3D82DCDAE08D5214E16FC.png)
    
2. 设置父组件滚动容器和子组件相同的背景色，设置滚动容器的内容裁剪属性clipContent(ContentClipMode.SAFE_AREA)，将内容层裁剪区域扩展至避让区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .clipContent(ContentClipMode.SAFE_AREA)
    20.     }.width('100%').height('100%')
    21.   }
    22. }
    

**图6** 滚动类容器设置clipContent属性实现沉浸式效果  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.72942034796131303316500546979165:50001231000000:2800:F0FEA17F4AD3FF502D702340C369F02EFCC501694E07893050822DC1F2ADAEA3.png "点击放大")

### 底部页签场景

要求页签背景色能够延伸到导航区域（此处以导航区域表现为导航条为例给出示意），但页签内部可操作元素需要在导航区域之上。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.37246522656942551464504700503566:50001231000000:2800:F55E4980F4B7D0B0006E3960732E793DA44500BA6386C295E62801FCCCC9C579.png "点击放大")

针对底部的页签部分，Navigation组件和Tabs组件默认实现了页签的延伸处理，开发者只需要保证Navigation和Tabs组件的底部边界和底部导航区域重合即可。若开发者显式调用expandSafeArea接口，则安全区效果由expandSafeArea参数指定。

如果未使用上述组件而是采用自定义方式实现页签的场景，可以针对底部元素设置expandSafeArea属性实现底部元素的背景扩展。

**图7** 顶部和底部UI元素未设置和设置expandSafeArea属性效果对比

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.41747390740743659941506414504724:50001231000000:2800:E50527CF67161602DF8FD0C190F67F7D0B4B3B04CF45C3A0446CC37FE90CC51F.png)

1. // xxx.ets
2. @Entry
3. @Component
4. struct Example {
5.   build() {
6.     Column() {
7.       Row() {
8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
9.       }.backgroundColor('#2786d9')
10.       // 设置顶部绘制延伸到状态栏
11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])

12.       Row() {
13.         Text('Display Content 2').fontSize(30)
14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

15.       Row() {
16.         Text('Display Content 3').fontSize(30)
17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

18.       Row() {
19.         Text('Display Content 4').fontSize(30)
20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

21.       Row() {
22.         Text('Display Content 5').fontSize(30)
23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

24.       Row() {
25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
26.       }.backgroundColor('#96dffa')
27.       // 设置底部绘制延伸到导航区域
28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
29.     }
30.     .width('100%').height('100%')
31.     .alignItems(HorizontalAlign.Center)
32.     .backgroundColor('#d5d5d5')
33.     .justifyContent(FlexAlign.SpaceBetween)
34.   }
35. }

### 图文场景

当状态栏元素和底部导航区域元素不同时，无法单纯通过窗口背景色或者背景图组件延伸实现，此时需要对顶部元素和底部元素分别配置expandSafeArea属性，顶部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.TOP])，底部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.BOTTOM])。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.28582942626334677493417993476880:50001231000000:2800:70849062F759622A69E9F0C2E65D297CE52324158491314B545F1CF41A4F9041.png "点击放大")

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Swiper() {
6.       Column() {
7.         Image($r('app.media.start'))
8.           .height('50%').width('100%')
9.           // 设置图片延伸到状态栏
10.           .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
11.         Column() {
12.           Text('HarmonyOS 第一课')
13.             .fontSize(32)
14.             .margin(30)
15.           Text('通过循序渐进的学习路径，无经验和有经验的开发者都可以掌握ArkTS语言声明式开发范式，体验更简洁、更友好的HarmonyOS应用开发旅程。')
16.             .fontSize(20).margin(20)
17.         }.height('50%').width('100%')
18.         .backgroundColor(Color.White)
19.         // 设置文本内容区背景延伸到导航栏
20.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
21.       }
22.     }
23.     .width('100%')
24.     .height('100%')
25.     // 关闭Swiper组件默认的裁切效果以便子节点可以绘制在Swiper外。
26.     .clip(false)
27.   }
28. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-tabs "选项卡 (Tabs)")
# 开发应用沉浸式效果

更新时间: 2025-12-16 16:39

## 概述

典型应用全屏窗口UI元素包括顶部[状态栏](https://developer.huawei.com/consumer/cn/doc/design-guides/status-bar-0000001776775568)、应用界面和底部导航区域（根据用户设置可表现为[导航条](https://developer.huawei.com/consumer/cn/doc/design-guides/navigation-0000001957075737)或三键导航），其中状态栏和导航区域，通常在沉浸式布局下称为避让区；避让区之外的区域称为安全区。开发应用沉浸式效果主要指通过调整状态栏、应用界面和底部导航区域的显示效果来减少状态栏、导航条或三键导航等系统界面的突兀感，从而使用户获得最佳的UI体验。

**图1** 界面元素示意图（此处以导航区域表现为导航条为例给出示意）  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.66183599372440285502873852231614:50001231000000:2800:7913E74432ECA76CC08C129FF68240BE3F1A235F53DBAC59530E070D48BD1C50.png "点击放大")

开发应用沉浸式效果主要要考虑如下几个设计要素：

- UI元素避让处理：底部导航区域可以响应点击事件，除此之外的可交互UI元素和应用关键信息不建议放到导航区域。状态栏显示系统信息，如果与界面元素有冲突，需要考虑避让状态栏。
- 沉浸式效果处理：设置状态栏的颜色和导航区域的显隐与界面元素颜色相匹配，不出现明显的突兀感。

针对上面的设计要求，可以通过如下两种方式实现应用沉浸式效果：

- [窗口全屏布局方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section15671730447)：调整布局系统为全屏布局，界面元素延伸到状态栏和导航区域实现沉浸式效果。当不隐藏避让区时，可通过接口查询状态栏和导航区域进行可交互元素避让处理，并设置状态栏或导航区域的颜色或显隐等属性与界面元素匹配。当隐藏避让区时，通过对应接口设置全屏布局即可。
- [组件安全区方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202081847174413)：布局系统保持安全区内布局，然后通过接口延伸绘制内容（如背景色，背景图）到状态栏和导航区域实现沉浸式效果。
    
    该方案下，界面元素仅做绘制延伸，无法单独布局到状态栏和导航区域，针对需要单独布局UI元素到状态栏和导航区域的场景建议使用窗口全屏布局方案处理。
    

## 窗口全屏布局方案

窗口全屏布局方案主要涉及以下[应用扩展布局，全屏显示，不隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section171801550301)和[应用扩展布局，隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202484117114)两个应用场景。

### 应用扩展布局，全屏显示，不隐藏避让区

可以通过调用窗口强制全屏布局接口[setWindowLayoutFullScreen()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)实现界面元素延伸到状态栏和导航区域；然后通过接口[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)和[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)获取并动态监听避让区域的变更信息，页面布局根据避让区域信息进行动态调整；设置状态栏或导航区域的颜色或显隐等属性与界面元素进行匹配。

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2-3中的操作
    21.     });
    22.   }
    23. }
    
2. 使用[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口获取当前布局遮挡区域（此处以状态栏、导航区域为例）。
    
    1. // EntryAbility.ets
    2. // 2. 获取布局避让遮挡的区域
    3. let type = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; // 此处以导航条避让为例
    4. let avoidArea = windowClass.getWindowAvoidArea(type);
    5. let bottomRectHeight = avoidArea.bottomRect.height; // 获取到导航区域的高度
    6. AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    
    7. type = window.AvoidAreaType.TYPE_SYSTEM; // 以状态栏避让为例
    8. avoidArea = windowClass.getWindowAvoidArea(type);
    9. let topRectHeight = avoidArea.topRect.height; // 获取状态栏区域高度     
    10. AppStorage.setOrCreate('topRectHeight', topRectHeight);
    
3. 注册监听函数，动态获取避让区域的实时数据。常见的触发避让区回调的场景如下：应用窗口在全屏模式、悬浮模式、分屏模式之间的切换；应用窗口旋转；多折叠设备在屏幕折叠态和展开态之间的切换；应用窗口在多设备之间的流转。
    
    1. // EntryAbility.ets
    2. // 3. 注册监听函数，动态获取避让区域数据
    3. windowClass.on('avoidAreaChange', (data) => {
    4.   if (data.type === window.AvoidAreaType.TYPE_SYSTEM) {
    5.     let topRectHeight = data.area.topRect.height;
    6.     AppStorage.setOrCreate('topRectHeight', topRectHeight);
    7.   } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
    8.     let bottomRectHeight = data.area.bottomRect.height;
    9.     AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    10.   }
    11. });
    
4. 布局中的UI元素需要避让状态栏和导航区域，否则可能产生UI元素重叠等情况。
    
    说明
    
    避让区域存在大小为0的情况，当获取到的避让区域为0时，开发者需注意针对性处理适配此时的页面区域和布局，避免贴边、内容裁剪等问题，影响应用界面正常显示或美观性。
    
    如下例子中，对控件顶部设置padding（具体数值与状态栏高度一致），实现对状态栏的避让；对底部设置padding（具体数值与底部导航区域高度一致），实现对导航条的避让。如果去掉顶部和底部的padding设置，即不避让状态栏和导航条，UI元素就会发生重叠。具体可见下文步骤中图2和图3的效果对比。
    
    1. // Index.ets
    2. @Entry
    3. @Component
    4. struct Index {
    5.   @StorageProp('bottomRectHeight')
    6.   bottomRectHeight: number = 0;
    7.   @StorageProp('topRectHeight')
    8.   topRectHeight: number = 0;
    
    9.   build() {
    10.     Column() {
    11.       Row() {
    12.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    13.       }.backgroundColor('#2786d9')
    
    14.       Row() {
    15.         Text('Display Content 2').fontSize(30)
    16.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.       Row() {
    18.         Text('Display Content 3').fontSize(30)
    19.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.       Row() {
    21.         Text('Display Content 4').fontSize(30)
    22.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.       Row() {
    24.         Text('Display Content 5').fontSize(30)
    25.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    26.       Row() {
    27.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    28.       }.backgroundColor('#96dffa')
    29.     }
    30.     .width('100%')
    31.     .height('100%')
    32.     .alignItems(HorizontalAlign.Center)
    33.     .backgroundColor('#d5d5d5')
    34.     .justifyContent(FlexAlign.SpaceBetween)
    35.     // top数值与状态栏区域高度保持一致；bottom数值与导航区域高度保持一致
    36.     .padding({
    37.       top: this.getUIContext().px2vp(this.topRectHeight),
    38.       bottom: this.getUIContext().px2vp(this.bottomRectHeight)
    39.     })
    40.   }
    41. }
    
5. 根据实际的UI界面显示或相关UI元素背景颜色等，还可以按需设置状态栏的文字颜色、背景色或设置导航区域的显示或隐藏，以使UI界面效果呈现和谐。状态栏和导航区域默认是透明的，透传的是应用界面的背景色。
    
    此例中UI颜色主要有两种，比较简单，故未对状态栏文字颜色、背景色进行设置，未对导航区域进行隐藏。
    
    **图2** 布局避让状态栏和导航区域（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.87006013163778539261709498662392:50001231000000:2800:A746E4D652D3D20AA672A5BF165B3699C55DC9456E44001D102D538ACD77E72B.jpg "点击放大")
    
    **图3** 布局未避让状态栏和导航区域，UI元素重叠（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.57353412750221239108308721929172:50001231000000:2800:648A1F02A8BC0F5532422C2B618955F93999C9C2477489BA8D5714D235BF32FC.jpg "点击放大")
    

### 应用扩展布局，隐藏避让区

此场景下状态栏和导航区域需要隐藏，适用于游戏、电影等应用场景。用户可以通过从底部上滑唤出导航条或三键导航。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.99837954210435397706545783363927:50001231000000:2800:E0DDA552D6BF528E237CF861592011D02174A684C85AF203C34ACA45490F2C88.png "点击放大")

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2中的状态栏和导航区域的隐藏操作
    21.     });
    22.   }
    23. }
    
2. 调用[setSpecificSystemBarEnabled()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setspecificsystembarenabled11)接口设置状态栏和导航区域的具体显隐状态，此场景下将其设置为隐藏。
    
    1. // EntryAbility.ets
    2. // 2. 设置状态栏隐藏
    3. windowClass.setSpecificSystemBarEnabled('status', false).then(() => {
    4.   console.info('Succeeded in setting the status bar to be invisible.');
    5. }).catch((err: BusinessError) => {
    6.   console.error(`Failed to set the status bar to be invisible. Code is ${err.code}, message is ${err.message}`);
    7. });
    8. // 2. 设置导航区域隐藏
    9. windowClass.setSpecificSystemBarEnabled('navigationIndicator', false).then(() => {
    10.   console.info('Succeeded in setting the navigation indicator to be invisible.');
    11. }).catch((err: BusinessError) => {
    12.   console.error(`Failed to set the navigation indicator to be invisible. Code is ${err.code}, message is ${err.message}`);
    13. });
    
3. 在界面中无需进行导航区域避让操作。
    
    1. // Index.ets
    2. @Entry()
    3. @Component
    4. struct Index {
    5.   build() {
    6.     Row() {
    7.       Column() {
    8.         Row() {
    9.           Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    10.         }.backgroundColor('#2786d9')
    
    11.         Row() {
    12.           Text('Display Content 2').fontSize(30)
    13.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    14.         Row() {
    15.           Text('Display Content 3').fontSize(30)
    16.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.         Row() {
    18.           Text('Display Content 4').fontSize(30)
    19.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.         Row() {
    21.           Text('Display Content 5').fontSize(30)
    22.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.         Row() {
    24.           Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    25.         }.backgroundColor('#96dffa')
    26.       }
    27.       .width('100%')
    28.       .height('100%')
    29.       .alignItems(HorizontalAlign.Center)
    30.       .justifyContent(FlexAlign.SpaceBetween)
    31.       .backgroundColor('#d5d5d5')
    32.     }
    33.   }
    34. }
    

## 组件安全区方案

应用未使用setWindowLayoutFullScreen()接口设置窗口全屏布局时，默认采取组件安全区布局方案。

应用在默认情况下窗口背景绘制范围是全屏，但UI元素被限制在安全区内（自动排除状态栏和导航区域）进行布局，来避免界面元素被状态栏和导航区域遮盖。

**图4** 界面元素自动避让状态栏和导航区域示意图  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.49785881633116705159423116990391:50001231000000:2800:B33C69BC76D51355EC3CAE2413AEFC2778B11EF1DE34BF763C3215C43D52EEA0.png "点击放大")

针对状态栏和导航区域颜色与界面元素颜色不匹配问题，可以通过如下两种方式实现沉浸式效果：

- 状态栏和导航区域颜色相同场景，可以通过设置窗口的背景色来实现沉浸式效果。窗口背景色可通过[setWindowBackgroundColor()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowbackgroundcolor9)进行设置。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    
    3. export default class EntryAbility extends UIAbility {
    4.   //...
    
    5.   onWindowStageCreate(windowStage: window.WindowStage): void {
    6.     windowStage.loadContent('pages/Index', (err) => {
    7.       if (err.code) {
    8.         return;
    9.       }
    
    10.       // 设置全窗颜色和应用元素颜色一致
    11.       windowStage.getMainWindowSync().setWindowBackgroundColor('#d5d5d5');
    12.     });
    13.   }
    14. }
    
    界面状态栏和导航区域颜色相同场景。
    
    15. // xxx.ets
    16. @Entry
    17. @Component
    18. struct Example {
    19.   build() {
    20.     Column() {
    21.       Row() {
    22.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    23.       }.backgroundColor('#2786d9')
    
    24.       Row() {
    25.         Text('Display Content 2').fontSize(30)
    26.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    27.       Row() {
    28.         Text('Display Content 3').fontSize(30)
    29.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    30.       Row() {
    31.         Text('Display Content 4').fontSize(30)
    32.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    33.       Row() {
    34.         Text('Display Content 5').fontSize(30)
    35.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    36.       Row() {
    37.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    38.       }.backgroundColor('#96dffa')
    39.     }
    40.     .width('100%').height('100%')
    41.     .alignItems(HorizontalAlign.Center)
    42.     .backgroundColor('#d5d5d5')
    43.     .justifyContent(FlexAlign.SpaceBetween)
    44.   }
    45. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.48684961595489300477977200533131:50001231000000:2800:4DB5CDA0E0D7958CB4FB8E8AEC3D5128DD0539822614E9C3C8FD853148872890.png)
    
- 状态栏和导航区域颜色不同时，可以使用[expandSafeArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea)属性扩展安全区域属性进行调整。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct Example {
    5.   build() {
    6.     Column() {
    7.       Row() {
    8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    9.       }.backgroundColor('#2786d9')
    10.       // 设置顶部绘制延伸到状态栏
    11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
    
    12.       Row() {
    13.         Text('Display Content 2').fontSize(30)
    14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    15.       Row() {
    16.         Text('Display Content 3').fontSize(30)
    17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    18.       Row() {
    19.         Text('Display Content 4').fontSize(30)
    20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    21.       Row() {
    22.         Text('Display Content 5').fontSize(30)
    23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    24.       Row() {
    25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    26.       }.backgroundColor('#96dffa')
    27.       // 设置底部绘制延伸到导航区域
    28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
    29.     }
    30.     .width('100%').height('100%')
    31.     .alignItems(HorizontalAlign.Center)
    32.     .backgroundColor('#d5d5d5')
    33.     .justifyContent(FlexAlign.SpaceBetween)
    34.   }
    35. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.75061394560447074198529736772042:50001231000000:2800:902E75D5CF9C4DD79174E234EDE65E52140DEE800228E4183BD6AB6FD0CFA27E.png)
    

### 扩展安全区域属性原理

- 布局阶段按照安全区范围大小进行UI元素布局。
- 布局完成后查看设置了expandSafeArea的组件边界（不包括margin）是否和安全区边界相交。
- 如果设置了expandSafeArea的组件和安全区边界相交，根据expandSafeArea传递的属性则进一步扩大组件绘制区域大小覆盖状态栏、导航区域这些非安全区域。
- 上述过程仅改变组件自身绘制大小，不进行二次布局，不影响子节点和兄弟节点的大小和位置。
- 子节点可以单独设置该属性，只需要自身边界和安全区域重合就可以延伸自身大小至非安全区域内，需要确保父组件未设置clip等裁切属性。
- 配置expandSafeArea属性组件进行绘制扩展时，需要关注组件不能配置固定宽高尺寸，百分比除外。
- 组件可以设置通用属性safeAreaPadding，给自身添加组件级安全区域。该属性作为一种特殊边距，在提供布局约束的同时作为安全区可以被一些系统组件利用。
    - safeAreaPadding位于原有的padding内侧。容器自外向内各层分别为border、padding、safeAreaPadding、内容区。当border和padding确定后，若容器可用空间不足以满足safeAreaPadding的设置，则优先分配给左侧和上侧safeAreaPadding、其次分配给右侧和下侧safeAreaPadding。safeAreaPadding实际尺寸确定后，余下空间为内容区。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.40814739523074922976450985656583:50001231000000:2800:3069DA8848E75088A5E18CA4DEFE8D5B560459053EC369BEE936096F37485126.png "点击放大")
        
    - 系统组件如Navigation、List、Scroll、Tabs等可以利用外层或容器自身safeAreaPadding实现扩大裁剪范围等能力。

### 背景图和视频场景

设置背景图、视频组件大小为安全区域大小并配置expandSafeArea属性。

说明

Video组件在使用expandSafeArea扩展到安全区域时，组件视频显示内容区域不支持扩展。

1. // xxx.ets
2. @Entry
3. @Component
4. struct SafeAreaExample1 {
5.   build() {
6.     Stack() {
7.       Image($r('app.media.bg'))
8.         .height('100%').width('100%')
9.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]) // 图片组件的绘制区域扩展至状态栏和导航区域。
10.     }.height('100%').width('100%')
11.   }
12. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.43327826020269771674865794312820:50001231000000:2800:1022E21DA063B1509DB723CB9C69FDA61F3F93D6E7581D7C47F6EA7DAE310B6F.png)

### 滚动类场景

滚动容器设置expandSafeArea属性生效，但当父组件是滚动容器时，子组件设置expandSafeArea属性不生效。对于滚动容器的子组件，有两种方法实现沉浸式效果：

1. 设置父组件滚动容器和子组件相同的背景色，给父组件设置expandSafeArea属性扩展安全区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    20.     }.width('100%').height('100%')
    21.     .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    22.   }
    23. }
    
    **图5** 滚动类容器设置expandSafeArea属性实现沉浸式效果  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.36343620665340982594714223798161:50001231000000:2800:AD6E0F7C59190801230E58A4FFAF23D4F65F1FDE15A3D82DCDAE08D5214E16FC.png)
    
2. 设置父组件滚动容器和子组件相同的背景色，设置滚动容器的内容裁剪属性clipContent(ContentClipMode.SAFE_AREA)，将内容层裁剪区域扩展至避让区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .clipContent(ContentClipMode.SAFE_AREA)
    20.     }.width('100%').height('100%')
    21.   }
    22. }
    

**图6** 滚动类容器设置clipContent属性实现沉浸式效果  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.72942034796131303316500546979165:50001231000000:2800:F0FEA17F4AD3FF502D702340C369F02EFCC501694E07893050822DC1F2ADAEA3.png "点击放大")

### 底部页签场景

要求页签背景色能够延伸到导航区域（此处以导航区域表现为导航条为例给出示意），但页签内部可操作元素需要在导航区域之上。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.37246522656942551464504700503566:50001231000000:2800:F55E4980F4B7D0B0006E3960732E793DA44500BA6386C295E62801FCCCC9C579.png "点击放大")

针对底部的页签部分，Navigation组件和Tabs组件默认实现了页签的延伸处理，开发者只需要保证Navigation和Tabs组件的底部边界和底部导航区域重合即可。若开发者显式调用expandSafeArea接口，则安全区效果由expandSafeArea参数指定。

如果未使用上述组件而是采用自定义方式实现页签的场景，可以针对底部元素设置expandSafeArea属性实现底部元素的背景扩展。

**图7** 顶部和底部UI元素未设置和设置expandSafeArea属性效果对比

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.41747390740743659941506414504724:50001231000000:2800:E50527CF67161602DF8FD0C190F67F7D0B4B3B04CF45C3A0446CC37FE90CC51F.png)

1. // xxx.ets
2. @Entry
3. @Component
4. struct Example {
5.   build() {
6.     Column() {
7.       Row() {
8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
9.       }.backgroundColor('#2786d9')
10.       // 设置顶部绘制延伸到状态栏
11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])

12.       Row() {
13.         Text('Display Content 2').fontSize(30)
14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

15.       Row() {
16.         Text('Display Content 3').fontSize(30)
17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

18.       Row() {
19.         Text('Display Content 4').fontSize(30)
20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

21.       Row() {
22.         Text('Display Content 5').fontSize(30)
23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

24.       Row() {
25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
26.       }.backgroundColor('#96dffa')
27.       // 设置底部绘制延伸到导航区域
28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
29.     }
30.     .width('100%').height('100%')
31.     .alignItems(HorizontalAlign.Center)
32.     .backgroundColor('#d5d5d5')
33.     .justifyContent(FlexAlign.SpaceBetween)
34.   }
35. }

### 图文场景

当状态栏元素和底部导航区域元素不同时，无法单纯通过窗口背景色或者背景图组件延伸实现，此时需要对顶部元素和底部元素分别配置expandSafeArea属性，顶部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.TOP])，底部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.BOTTOM])。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.28582942626334677493417993476880:50001231000000:2800:70849062F759622A69E9F0C2E65D297CE52324158491314B545F1CF41A4F9041.png "点击放大")

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Swiper() {
6.       Column() {
7.         Image($r('app.media.start'))
8.           .height('50%').width('100%')
9.           // 设置图片延伸到状态栏
10.           .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
11.         Column() {
12.           Text('HarmonyOS 第一课')
13.             .fontSize(32)
14.             .margin(30)
15.           Text('通过循序渐进的学习路径，无经验和有经验的开发者都可以掌握ArkTS语言声明式开发范式，体验更简洁、更友好的HarmonyOS应用开发旅程。')
16.             .fontSize(20).margin(20)
17.         }.height('50%').width('100%')
18.         .backgroundColor(Color.White)
19.         // 设置文本内容区背景延伸到导航栏
20.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
21.       }
22.     }
23.     .width('100%')
24.     .height('100%')
25.     // 关闭Swiper组件默认的裁切效果以便子节点可以绘制在Swiper外。
26.     .clip(false)
27.   }
28. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-tabs "选项卡 (Tabs)")
# 开发应用沉浸式效果

更新时间: 2025-12-16 16:39

## 概述

典型应用全屏窗口UI元素包括顶部[状态栏](https://developer.huawei.com/consumer/cn/doc/design-guides/status-bar-0000001776775568)、应用界面和底部导航区域（根据用户设置可表现为[导航条](https://developer.huawei.com/consumer/cn/doc/design-guides/navigation-0000001957075737)或三键导航），其中状态栏和导航区域，通常在沉浸式布局下称为避让区；避让区之外的区域称为安全区。开发应用沉浸式效果主要指通过调整状态栏、应用界面和底部导航区域的显示效果来减少状态栏、导航条或三键导航等系统界面的突兀感，从而使用户获得最佳的UI体验。

**图1** 界面元素示意图（此处以导航区域表现为导航条为例给出示意）  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.66183599372440285502873852231614:50001231000000:2800:7913E74432ECA76CC08C129FF68240BE3F1A235F53DBAC59530E070D48BD1C50.png "点击放大")

开发应用沉浸式效果主要要考虑如下几个设计要素：

- UI元素避让处理：底部导航区域可以响应点击事件，除此之外的可交互UI元素和应用关键信息不建议放到导航区域。状态栏显示系统信息，如果与界面元素有冲突，需要考虑避让状态栏。
- 沉浸式效果处理：设置状态栏的颜色和导航区域的显隐与界面元素颜色相匹配，不出现明显的突兀感。

针对上面的设计要求，可以通过如下两种方式实现应用沉浸式效果：

- [窗口全屏布局方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section15671730447)：调整布局系统为全屏布局，界面元素延伸到状态栏和导航区域实现沉浸式效果。当不隐藏避让区时，可通过接口查询状态栏和导航区域进行可交互元素避让处理，并设置状态栏或导航区域的颜色或显隐等属性与界面元素匹配。当隐藏避让区时，通过对应接口设置全屏布局即可。
- [组件安全区方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202081847174413)：布局系统保持安全区内布局，然后通过接口延伸绘制内容（如背景色，背景图）到状态栏和导航区域实现沉浸式效果。
    
    该方案下，界面元素仅做绘制延伸，无法单独布局到状态栏和导航区域，针对需要单独布局UI元素到状态栏和导航区域的场景建议使用窗口全屏布局方案处理。
    

## 窗口全屏布局方案

窗口全屏布局方案主要涉及以下[应用扩展布局，全屏显示，不隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section171801550301)和[应用扩展布局，隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202484117114)两个应用场景。

### 应用扩展布局，全屏显示，不隐藏避让区

可以通过调用窗口强制全屏布局接口[setWindowLayoutFullScreen()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)实现界面元素延伸到状态栏和导航区域；然后通过接口[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)和[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)获取并动态监听避让区域的变更信息，页面布局根据避让区域信息进行动态调整；设置状态栏或导航区域的颜色或显隐等属性与界面元素进行匹配。

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2-3中的操作
    21.     });
    22.   }
    23. }
    
2. 使用[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口获取当前布局遮挡区域（此处以状态栏、导航区域为例）。
    
    1. // EntryAbility.ets
    2. // 2. 获取布局避让遮挡的区域
    3. let type = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; // 此处以导航条避让为例
    4. let avoidArea = windowClass.getWindowAvoidArea(type);
    5. let bottomRectHeight = avoidArea.bottomRect.height; // 获取到导航区域的高度
    6. AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    
    7. type = window.AvoidAreaType.TYPE_SYSTEM; // 以状态栏避让为例
    8. avoidArea = windowClass.getWindowAvoidArea(type);
    9. let topRectHeight = avoidArea.topRect.height; // 获取状态栏区域高度     
    10. AppStorage.setOrCreate('topRectHeight', topRectHeight);
    
3. 注册监听函数，动态获取避让区域的实时数据。常见的触发避让区回调的场景如下：应用窗口在全屏模式、悬浮模式、分屏模式之间的切换；应用窗口旋转；多折叠设备在屏幕折叠态和展开态之间的切换；应用窗口在多设备之间的流转。
    
    1. // EntryAbility.ets
    2. // 3. 注册监听函数，动态获取避让区域数据
    3. windowClass.on('avoidAreaChange', (data) => {
    4.   if (data.type === window.AvoidAreaType.TYPE_SYSTEM) {
    5.     let topRectHeight = data.area.topRect.height;
    6.     AppStorage.setOrCreate('topRectHeight', topRectHeight);
    7.   } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
    8.     let bottomRectHeight = data.area.bottomRect.height;
    9.     AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    10.   }
    11. });
    
4. 布局中的UI元素需要避让状态栏和导航区域，否则可能产生UI元素重叠等情况。
    
    说明
    
    避让区域存在大小为0的情况，当获取到的避让区域为0时，开发者需注意针对性处理适配此时的页面区域和布局，避免贴边、内容裁剪等问题，影响应用界面正常显示或美观性。
    
    如下例子中，对控件顶部设置padding（具体数值与状态栏高度一致），实现对状态栏的避让；对底部设置padding（具体数值与底部导航区域高度一致），实现对导航条的避让。如果去掉顶部和底部的padding设置，即不避让状态栏和导航条，UI元素就会发生重叠。具体可见下文步骤中图2和图3的效果对比。
    
    1. // Index.ets
    2. @Entry
    3. @Component
    4. struct Index {
    5.   @StorageProp('bottomRectHeight')
    6.   bottomRectHeight: number = 0;
    7.   @StorageProp('topRectHeight')
    8.   topRectHeight: number = 0;
    
    9.   build() {
    10.     Column() {
    11.       Row() {
    12.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    13.       }.backgroundColor('#2786d9')
    
    14.       Row() {
    15.         Text('Display Content 2').fontSize(30)
    16.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.       Row() {
    18.         Text('Display Content 3').fontSize(30)
    19.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.       Row() {
    21.         Text('Display Content 4').fontSize(30)
    22.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.       Row() {
    24.         Text('Display Content 5').fontSize(30)
    25.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    26.       Row() {
    27.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    28.       }.backgroundColor('#96dffa')
    29.     }
    30.     .width('100%')
    31.     .height('100%')
    32.     .alignItems(HorizontalAlign.Center)
    33.     .backgroundColor('#d5d5d5')
    34.     .justifyContent(FlexAlign.SpaceBetween)
    35.     // top数值与状态栏区域高度保持一致；bottom数值与导航区域高度保持一致
    36.     .padding({
    37.       top: this.getUIContext().px2vp(this.topRectHeight),
    38.       bottom: this.getUIContext().px2vp(this.bottomRectHeight)
    39.     })
    40.   }
    41. }
    
5. 根据实际的UI界面显示或相关UI元素背景颜色等，还可以按需设置状态栏的文字颜色、背景色或设置导航区域的显示或隐藏，以使UI界面效果呈现和谐。状态栏和导航区域默认是透明的，透传的是应用界面的背景色。
    
    此例中UI颜色主要有两种，比较简单，故未对状态栏文字颜色、背景色进行设置，未对导航区域进行隐藏。
    
    **图2** 布局避让状态栏和导航区域（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.87006013163778539261709498662392:50001231000000:2800:A746E4D652D3D20AA672A5BF165B3699C55DC9456E44001D102D538ACD77E72B.jpg "点击放大")
    
    **图3** 布局未避让状态栏和导航区域，UI元素重叠（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.57353412750221239108308721929172:50001231000000:2800:648A1F02A8BC0F5532422C2B618955F93999C9C2477489BA8D5714D235BF32FC.jpg "点击放大")
    

### 应用扩展布局，隐藏避让区

此场景下状态栏和导航区域需要隐藏，适用于游戏、电影等应用场景。用户可以通过从底部上滑唤出导航条或三键导航。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.99837954210435397706545783363927:50001231000000:2800:E0DDA552D6BF528E237CF861592011D02174A684C85AF203C34ACA45490F2C88.png "点击放大")

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2中的状态栏和导航区域的隐藏操作
    21.     });
    22.   }
    23. }
    
2. 调用[setSpecificSystemBarEnabled()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setspecificsystembarenabled11)接口设置状态栏和导航区域的具体显隐状态，此场景下将其设置为隐藏。
    
    1. // EntryAbility.ets
    2. // 2. 设置状态栏隐藏
    3. windowClass.setSpecificSystemBarEnabled('status', false).then(() => {
    4.   console.info('Succeeded in setting the status bar to be invisible.');
    5. }).catch((err: BusinessError) => {
    6.   console.error(`Failed to set the status bar to be invisible. Code is ${err.code}, message is ${err.message}`);
    7. });
    8. // 2. 设置导航区域隐藏
    9. windowClass.setSpecificSystemBarEnabled('navigationIndicator', false).then(() => {
    10.   console.info('Succeeded in setting the navigation indicator to be invisible.');
    11. }).catch((err: BusinessError) => {
    12.   console.error(`Failed to set the navigation indicator to be invisible. Code is ${err.code}, message is ${err.message}`);
    13. });
    
3. 在界面中无需进行导航区域避让操作。
    
    1. // Index.ets
    2. @Entry()
    3. @Component
    4. struct Index {
    5.   build() {
    6.     Row() {
    7.       Column() {
    8.         Row() {
    9.           Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    10.         }.backgroundColor('#2786d9')
    
    11.         Row() {
    12.           Text('Display Content 2').fontSize(30)
    13.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    14.         Row() {
    15.           Text('Display Content 3').fontSize(30)
    16.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.         Row() {
    18.           Text('Display Content 4').fontSize(30)
    19.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.         Row() {
    21.           Text('Display Content 5').fontSize(30)
    22.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.         Row() {
    24.           Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    25.         }.backgroundColor('#96dffa')
    26.       }
    27.       .width('100%')
    28.       .height('100%')
    29.       .alignItems(HorizontalAlign.Center)
    30.       .justifyContent(FlexAlign.SpaceBetween)
    31.       .backgroundColor('#d5d5d5')
    32.     }
    33.   }
    34. }
    

## 组件安全区方案

应用未使用setWindowLayoutFullScreen()接口设置窗口全屏布局时，默认采取组件安全区布局方案。

应用在默认情况下窗口背景绘制范围是全屏，但UI元素被限制在安全区内（自动排除状态栏和导航区域）进行布局，来避免界面元素被状态栏和导航区域遮盖。

**图4** 界面元素自动避让状态栏和导航区域示意图  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.49785881633116705159423116990391:50001231000000:2800:B33C69BC76D51355EC3CAE2413AEFC2778B11EF1DE34BF763C3215C43D52EEA0.png "点击放大")

针对状态栏和导航区域颜色与界面元素颜色不匹配问题，可以通过如下两种方式实现沉浸式效果：

- 状态栏和导航区域颜色相同场景，可以通过设置窗口的背景色来实现沉浸式效果。窗口背景色可通过[setWindowBackgroundColor()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowbackgroundcolor9)进行设置。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    
    3. export default class EntryAbility extends UIAbility {
    4.   //...
    
    5.   onWindowStageCreate(windowStage: window.WindowStage): void {
    6.     windowStage.loadContent('pages/Index', (err) => {
    7.       if (err.code) {
    8.         return;
    9.       }
    
    10.       // 设置全窗颜色和应用元素颜色一致
    11.       windowStage.getMainWindowSync().setWindowBackgroundColor('#d5d5d5');
    12.     });
    13.   }
    14. }
    
    界面状态栏和导航区域颜色相同场景。
    
    15. // xxx.ets
    16. @Entry
    17. @Component
    18. struct Example {
    19.   build() {
    20.     Column() {
    21.       Row() {
    22.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    23.       }.backgroundColor('#2786d9')
    
    24.       Row() {
    25.         Text('Display Content 2').fontSize(30)
    26.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    27.       Row() {
    28.         Text('Display Content 3').fontSize(30)
    29.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    30.       Row() {
    31.         Text('Display Content 4').fontSize(30)
    32.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    33.       Row() {
    34.         Text('Display Content 5').fontSize(30)
    35.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    36.       Row() {
    37.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    38.       }.backgroundColor('#96dffa')
    39.     }
    40.     .width('100%').height('100%')
    41.     .alignItems(HorizontalAlign.Center)
    42.     .backgroundColor('#d5d5d5')
    43.     .justifyContent(FlexAlign.SpaceBetween)
    44.   }
    45. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.48684961595489300477977200533131:50001231000000:2800:4DB5CDA0E0D7958CB4FB8E8AEC3D5128DD0539822614E9C3C8FD853148872890.png)
    
- 状态栏和导航区域颜色不同时，可以使用[expandSafeArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea)属性扩展安全区域属性进行调整。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct Example {
    5.   build() {
    6.     Column() {
    7.       Row() {
    8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    9.       }.backgroundColor('#2786d9')
    10.       // 设置顶部绘制延伸到状态栏
    11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
    
    12.       Row() {
    13.         Text('Display Content 2').fontSize(30)
    14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    15.       Row() {
    16.         Text('Display Content 3').fontSize(30)
    17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    18.       Row() {
    19.         Text('Display Content 4').fontSize(30)
    20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    21.       Row() {
    22.         Text('Display Content 5').fontSize(30)
    23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    24.       Row() {
    25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    26.       }.backgroundColor('#96dffa')
    27.       // 设置底部绘制延伸到导航区域
    28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
    29.     }
    30.     .width('100%').height('100%')
    31.     .alignItems(HorizontalAlign.Center)
    32.     .backgroundColor('#d5d5d5')
    33.     .justifyContent(FlexAlign.SpaceBetween)
    34.   }
    35. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.75061394560447074198529736772042:50001231000000:2800:902E75D5CF9C4DD79174E234EDE65E52140DEE800228E4183BD6AB6FD0CFA27E.png)
    

### 扩展安全区域属性原理

- 布局阶段按照安全区范围大小进行UI元素布局。
- 布局完成后查看设置了expandSafeArea的组件边界（不包括margin）是否和安全区边界相交。
- 如果设置了expandSafeArea的组件和安全区边界相交，根据expandSafeArea传递的属性则进一步扩大组件绘制区域大小覆盖状态栏、导航区域这些非安全区域。
- 上述过程仅改变组件自身绘制大小，不进行二次布局，不影响子节点和兄弟节点的大小和位置。
- 子节点可以单独设置该属性，只需要自身边界和安全区域重合就可以延伸自身大小至非安全区域内，需要确保父组件未设置clip等裁切属性。
- 配置expandSafeArea属性组件进行绘制扩展时，需要关注组件不能配置固定宽高尺寸，百分比除外。
- 组件可以设置通用属性safeAreaPadding，给自身添加组件级安全区域。该属性作为一种特殊边距，在提供布局约束的同时作为安全区可以被一些系统组件利用。
    - safeAreaPadding位于原有的padding内侧。容器自外向内各层分别为border、padding、safeAreaPadding、内容区。当border和padding确定后，若容器可用空间不足以满足safeAreaPadding的设置，则优先分配给左侧和上侧safeAreaPadding、其次分配给右侧和下侧safeAreaPadding。safeAreaPadding实际尺寸确定后，余下空间为内容区。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.40814739523074922976450985656583:50001231000000:2800:3069DA8848E75088A5E18CA4DEFE8D5B560459053EC369BEE936096F37485126.png "点击放大")
        
    - 系统组件如Navigation、List、Scroll、Tabs等可以利用外层或容器自身safeAreaPadding实现扩大裁剪范围等能力。

### 背景图和视频场景

设置背景图、视频组件大小为安全区域大小并配置expandSafeArea属性。

说明

Video组件在使用expandSafeArea扩展到安全区域时，组件视频显示内容区域不支持扩展。

1. // xxx.ets
2. @Entry
3. @Component
4. struct SafeAreaExample1 {
5.   build() {
6.     Stack() {
7.       Image($r('app.media.bg'))
8.         .height('100%').width('100%')
9.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]) // 图片组件的绘制区域扩展至状态栏和导航区域。
10.     }.height('100%').width('100%')
11.   }
12. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.43327826020269771674865794312820:50001231000000:2800:1022E21DA063B1509DB723CB9C69FDA61F3F93D6E7581D7C47F6EA7DAE310B6F.png)

### 滚动类场景

滚动容器设置expandSafeArea属性生效，但当父组件是滚动容器时，子组件设置expandSafeArea属性不生效。对于滚动容器的子组件，有两种方法实现沉浸式效果：

1. 设置父组件滚动容器和子组件相同的背景色，给父组件设置expandSafeArea属性扩展安全区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    20.     }.width('100%').height('100%')
    21.     .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    22.   }
    23. }
    
    **图5** 滚动类容器设置expandSafeArea属性实现沉浸式效果  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.36343620665340982594714223798161:50001231000000:2800:AD6E0F7C59190801230E58A4FFAF23D4F65F1FDE15A3D82DCDAE08D5214E16FC.png)
    
2. 设置父组件滚动容器和子组件相同的背景色，设置滚动容器的内容裁剪属性clipContent(ContentClipMode.SAFE_AREA)，将内容层裁剪区域扩展至避让区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .clipContent(ContentClipMode.SAFE_AREA)
    20.     }.width('100%').height('100%')
    21.   }
    22. }
    

**图6** 滚动类容器设置clipContent属性实现沉浸式效果  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.72942034796131303316500546979165:50001231000000:2800:F0FEA17F4AD3FF502D702340C369F02EFCC501694E07893050822DC1F2ADAEA3.png "点击放大")

### 底部页签场景

要求页签背景色能够延伸到导航区域（此处以导航区域表现为导航条为例给出示意），但页签内部可操作元素需要在导航区域之上。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.37246522656942551464504700503566:50001231000000:2800:F55E4980F4B7D0B0006E3960732E793DA44500BA6386C295E62801FCCCC9C579.png "点击放大")

针对底部的页签部分，Navigation组件和Tabs组件默认实现了页签的延伸处理，开发者只需要保证Navigation和Tabs组件的底部边界和底部导航区域重合即可。若开发者显式调用expandSafeArea接口，则安全区效果由expandSafeArea参数指定。

如果未使用上述组件而是采用自定义方式实现页签的场景，可以针对底部元素设置expandSafeArea属性实现底部元素的背景扩展。

**图7** 顶部和底部UI元素未设置和设置expandSafeArea属性效果对比

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.41747390740743659941506414504724:50001231000000:2800:E50527CF67161602DF8FD0C190F67F7D0B4B3B04CF45C3A0446CC37FE90CC51F.png)

1. // xxx.ets
2. @Entry
3. @Component
4. struct Example {
5.   build() {
6.     Column() {
7.       Row() {
8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
9.       }.backgroundColor('#2786d9')
10.       // 设置顶部绘制延伸到状态栏
11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])

12.       Row() {
13.         Text('Display Content 2').fontSize(30)
14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

15.       Row() {
16.         Text('Display Content 3').fontSize(30)
17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

18.       Row() {
19.         Text('Display Content 4').fontSize(30)
20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

21.       Row() {
22.         Text('Display Content 5').fontSize(30)
23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

24.       Row() {
25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
26.       }.backgroundColor('#96dffa')
27.       // 设置底部绘制延伸到导航区域
28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
29.     }
30.     .width('100%').height('100%')
31.     .alignItems(HorizontalAlign.Center)
32.     .backgroundColor('#d5d5d5')
33.     .justifyContent(FlexAlign.SpaceBetween)
34.   }
35. }

### 图文场景

当状态栏元素和底部导航区域元素不同时，无法单纯通过窗口背景色或者背景图组件延伸实现，此时需要对顶部元素和底部元素分别配置expandSafeArea属性，顶部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.TOP])，底部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.BOTTOM])。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.28582942626334677493417993476880:50001231000000:2800:70849062F759622A69E9F0C2E65D297CE52324158491314B545F1CF41A4F9041.png "点击放大")

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Swiper() {
6.       Column() {
7.         Image($r('app.media.start'))
8.           .height('50%').width('100%')
9.           // 设置图片延伸到状态栏
10.           .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
11.         Column() {
12.           Text('HarmonyOS 第一课')
13.             .fontSize(32)
14.             .margin(30)
15.           Text('通过循序渐进的学习路径，无经验和有经验的开发者都可以掌握ArkTS语言声明式开发范式，体验更简洁、更友好的HarmonyOS应用开发旅程。')
16.             .fontSize(20).margin(20)
17.         }.height('50%').width('100%')
18.         .backgroundColor(Color.White)
19.         // 设置文本内容区背景延伸到导航栏
20.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
21.       }
22.     }
23.     .width('100%')
24.     .height('100%')
25.     // 关闭Swiper组件默认的裁切效果以便子节点可以绘制在Swiper外。
26.     .clip(false)
27.   }
28. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-tabs "选项卡 (Tabs)")
# 开发应用沉浸式效果

更新时间: 2025-12-16 16:39

## 概述

典型应用全屏窗口UI元素包括顶部[状态栏](https://developer.huawei.com/consumer/cn/doc/design-guides/status-bar-0000001776775568)、应用界面和底部导航区域（根据用户设置可表现为[导航条](https://developer.huawei.com/consumer/cn/doc/design-guides/navigation-0000001957075737)或三键导航），其中状态栏和导航区域，通常在沉浸式布局下称为避让区；避让区之外的区域称为安全区。开发应用沉浸式效果主要指通过调整状态栏、应用界面和底部导航区域的显示效果来减少状态栏、导航条或三键导航等系统界面的突兀感，从而使用户获得最佳的UI体验。

**图1** 界面元素示意图（此处以导航区域表现为导航条为例给出示意）  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.66183599372440285502873852231614:50001231000000:2800:7913E74432ECA76CC08C129FF68240BE3F1A235F53DBAC59530E070D48BD1C50.png "点击放大")

开发应用沉浸式效果主要要考虑如下几个设计要素：

- UI元素避让处理：底部导航区域可以响应点击事件，除此之外的可交互UI元素和应用关键信息不建议放到导航区域。状态栏显示系统信息，如果与界面元素有冲突，需要考虑避让状态栏。
- 沉浸式效果处理：设置状态栏的颜色和导航区域的显隐与界面元素颜色相匹配，不出现明显的突兀感。

针对上面的设计要求，可以通过如下两种方式实现应用沉浸式效果：

- [窗口全屏布局方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section15671730447)：调整布局系统为全屏布局，界面元素延伸到状态栏和导航区域实现沉浸式效果。当不隐藏避让区时，可通过接口查询状态栏和导航区域进行可交互元素避让处理，并设置状态栏或导航区域的颜色或显隐等属性与界面元素匹配。当隐藏避让区时，通过对应接口设置全屏布局即可。
- [组件安全区方案](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202081847174413)：布局系统保持安全区内布局，然后通过接口延伸绘制内容（如背景色，背景图）到状态栏和导航区域实现沉浸式效果。
    
    该方案下，界面元素仅做绘制延伸，无法单独布局到状态栏和导航区域，针对需要单独布局UI元素到状态栏和导航区域的场景建议使用窗口全屏布局方案处理。
    

## 窗口全屏布局方案

窗口全屏布局方案主要涉及以下[应用扩展布局，全屏显示，不隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section171801550301)和[应用扩展布局，隐藏避让区](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects#section202484117114)两个应用场景。

### 应用扩展布局，全屏显示，不隐藏避让区

可以通过调用窗口强制全屏布局接口[setWindowLayoutFullScreen()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)实现界面元素延伸到状态栏和导航区域；然后通过接口[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)和[on('avoidAreaChange')](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowlayoutfullscreen9)获取并动态监听避让区域的变更信息，页面布局根据避让区域信息进行动态调整；设置状态栏或导航区域的颜色或显隐等属性与界面元素进行匹配。

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2-3中的操作
    21.     });
    22.   }
    23. }
    
2. 使用[getWindowAvoidArea()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#getwindowavoidarea9)接口获取当前布局遮挡区域（此处以状态栏、导航区域为例）。
    
    1. // EntryAbility.ets
    2. // 2. 获取布局避让遮挡的区域
    3. let type = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; // 此处以导航条避让为例
    4. let avoidArea = windowClass.getWindowAvoidArea(type);
    5. let bottomRectHeight = avoidArea.bottomRect.height; // 获取到导航区域的高度
    6. AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    
    7. type = window.AvoidAreaType.TYPE_SYSTEM; // 以状态栏避让为例
    8. avoidArea = windowClass.getWindowAvoidArea(type);
    9. let topRectHeight = avoidArea.topRect.height; // 获取状态栏区域高度     
    10. AppStorage.setOrCreate('topRectHeight', topRectHeight);
    
3. 注册监听函数，动态获取避让区域的实时数据。常见的触发避让区回调的场景如下：应用窗口在全屏模式、悬浮模式、分屏模式之间的切换；应用窗口旋转；多折叠设备在屏幕折叠态和展开态之间的切换；应用窗口在多设备之间的流转。
    
    1. // EntryAbility.ets
    2. // 3. 注册监听函数，动态获取避让区域数据
    3. windowClass.on('avoidAreaChange', (data) => {
    4.   if (data.type === window.AvoidAreaType.TYPE_SYSTEM) {
    5.     let topRectHeight = data.area.topRect.height;
    6.     AppStorage.setOrCreate('topRectHeight', topRectHeight);
    7.   } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
    8.     let bottomRectHeight = data.area.bottomRect.height;
    9.     AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
    10.   }
    11. });
    
4. 布局中的UI元素需要避让状态栏和导航区域，否则可能产生UI元素重叠等情况。
    
    说明
    
    避让区域存在大小为0的情况，当获取到的避让区域为0时，开发者需注意针对性处理适配此时的页面区域和布局，避免贴边、内容裁剪等问题，影响应用界面正常显示或美观性。
    
    如下例子中，对控件顶部设置padding（具体数值与状态栏高度一致），实现对状态栏的避让；对底部设置padding（具体数值与底部导航区域高度一致），实现对导航条的避让。如果去掉顶部和底部的padding设置，即不避让状态栏和导航条，UI元素就会发生重叠。具体可见下文步骤中图2和图3的效果对比。
    
    1. // Index.ets
    2. @Entry
    3. @Component
    4. struct Index {
    5.   @StorageProp('bottomRectHeight')
    6.   bottomRectHeight: number = 0;
    7.   @StorageProp('topRectHeight')
    8.   topRectHeight: number = 0;
    
    9.   build() {
    10.     Column() {
    11.       Row() {
    12.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    13.       }.backgroundColor('#2786d9')
    
    14.       Row() {
    15.         Text('Display Content 2').fontSize(30)
    16.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.       Row() {
    18.         Text('Display Content 3').fontSize(30)
    19.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.       Row() {
    21.         Text('Display Content 4').fontSize(30)
    22.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.       Row() {
    24.         Text('Display Content 5').fontSize(30)
    25.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    26.       Row() {
    27.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    28.       }.backgroundColor('#96dffa')
    29.     }
    30.     .width('100%')
    31.     .height('100%')
    32.     .alignItems(HorizontalAlign.Center)
    33.     .backgroundColor('#d5d5d5')
    34.     .justifyContent(FlexAlign.SpaceBetween)
    35.     // top数值与状态栏区域高度保持一致；bottom数值与导航区域高度保持一致
    36.     .padding({
    37.       top: this.getUIContext().px2vp(this.topRectHeight),
    38.       bottom: this.getUIContext().px2vp(this.bottomRectHeight)
    39.     })
    40.   }
    41. }
    
5. 根据实际的UI界面显示或相关UI元素背景颜色等，还可以按需设置状态栏的文字颜色、背景色或设置导航区域的显示或隐藏，以使UI界面效果呈现和谐。状态栏和导航区域默认是透明的，透传的是应用界面的背景色。
    
    此例中UI颜色主要有两种，比较简单，故未对状态栏文字颜色、背景色进行设置，未对导航区域进行隐藏。
    
    **图2** 布局避让状态栏和导航区域（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.87006013163778539261709498662392:50001231000000:2800:A746E4D652D3D20AA672A5BF165B3699C55DC9456E44001D102D538ACD77E72B.jpg "点击放大")
    
    **图3** 布局未避让状态栏和导航区域，UI元素重叠（此处以导航区域表现为导航条为例给出示意）  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.57353412750221239108308721929172:50001231000000:2800:648A1F02A8BC0F5532422C2B618955F93999C9C2477489BA8D5714D235BF32FC.jpg "点击放大")
    

### 应用扩展布局，隐藏避让区

此场景下状态栏和导航区域需要隐藏，适用于游戏、电影等应用场景。用户可以通过从底部上滑唤出导航条或三键导航。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.99837954210435397706545783363927:50001231000000:2800:E0DDA552D6BF528E237CF861592011D02174A684C85AF203C34ACA45490F2C88.png "点击放大")

1. 调用setWindowLayoutFullScreen()接口设置窗口全屏。
    
    1. // EntryAbility.ets
    2. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    3. import { window } from '@kit.ArkUI';
    4. import { BusinessError } from '@kit.BasicServicesKit';
    
    5. export default class EntryAbility extends UIAbility {
    6.   // ...
    
    7.   onWindowStageCreate(windowStage: window.WindowStage): void {
    8.     windowStage.loadContent('pages/Index', (err, data) => {
    9.       if (err.code) {
    10.         return;
    11.       }
    
    12.       let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    13.       // 1. 设置窗口全屏
    14.       let isLayoutFullScreen = true;
    15.       windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {
    16.         console.info('Succeeded in setting the window layout to full-screen mode.');
    17.       }).catch((err: BusinessError) => {
    18.         console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);
    19.       });
    20.       // 进行后续步骤2中的状态栏和导航区域的隐藏操作
    21.     });
    22.   }
    23. }
    
2. 调用[setSpecificSystemBarEnabled()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setspecificsystembarenabled11)接口设置状态栏和导航区域的具体显隐状态，此场景下将其设置为隐藏。
    
    1. // EntryAbility.ets
    2. // 2. 设置状态栏隐藏
    3. windowClass.setSpecificSystemBarEnabled('status', false).then(() => {
    4.   console.info('Succeeded in setting the status bar to be invisible.');
    5. }).catch((err: BusinessError) => {
    6.   console.error(`Failed to set the status bar to be invisible. Code is ${err.code}, message is ${err.message}`);
    7. });
    8. // 2. 设置导航区域隐藏
    9. windowClass.setSpecificSystemBarEnabled('navigationIndicator', false).then(() => {
    10.   console.info('Succeeded in setting the navigation indicator to be invisible.');
    11. }).catch((err: BusinessError) => {
    12.   console.error(`Failed to set the navigation indicator to be invisible. Code is ${err.code}, message is ${err.message}`);
    13. });
    
3. 在界面中无需进行导航区域避让操作。
    
    1. // Index.ets
    2. @Entry()
    3. @Component
    4. struct Index {
    5.   build() {
    6.     Row() {
    7.       Column() {
    8.         Row() {
    9.           Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    10.         }.backgroundColor('#2786d9')
    
    11.         Row() {
    12.           Text('Display Content 2').fontSize(30)
    13.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    14.         Row() {
    15.           Text('Display Content 3').fontSize(30)
    16.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    17.         Row() {
    18.           Text('Display Content 4').fontSize(30)
    19.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    20.         Row() {
    21.           Text('Display Content 5').fontSize(30)
    22.         }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    23.         Row() {
    24.           Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    25.         }.backgroundColor('#96dffa')
    26.       }
    27.       .width('100%')
    28.       .height('100%')
    29.       .alignItems(HorizontalAlign.Center)
    30.       .justifyContent(FlexAlign.SpaceBetween)
    31.       .backgroundColor('#d5d5d5')
    32.     }
    33.   }
    34. }
    

## 组件安全区方案

应用未使用setWindowLayoutFullScreen()接口设置窗口全屏布局时，默认采取组件安全区布局方案。

应用在默认情况下窗口背景绘制范围是全屏，但UI元素被限制在安全区内（自动排除状态栏和导航区域）进行布局，来避免界面元素被状态栏和导航区域遮盖。

**图4** 界面元素自动避让状态栏和导航区域示意图  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.49785881633116705159423116990391:50001231000000:2800:B33C69BC76D51355EC3CAE2413AEFC2778B11EF1DE34BF763C3215C43D52EEA0.png "点击放大")

针对状态栏和导航区域颜色与界面元素颜色不匹配问题，可以通过如下两种方式实现沉浸式效果：

- 状态栏和导航区域颜色相同场景，可以通过设置窗口的背景色来实现沉浸式效果。窗口背景色可通过[setWindowBackgroundColor()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-window-window#setwindowbackgroundcolor9)进行设置。
    
    1. import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
    2. import { window } from '@kit.ArkUI';
    
    3. export default class EntryAbility extends UIAbility {
    4.   //...
    
    5.   onWindowStageCreate(windowStage: window.WindowStage): void {
    6.     windowStage.loadContent('pages/Index', (err) => {
    7.       if (err.code) {
    8.         return;
    9.       }
    
    10.       // 设置全窗颜色和应用元素颜色一致
    11.       windowStage.getMainWindowSync().setWindowBackgroundColor('#d5d5d5');
    12.     });
    13.   }
    14. }
    
    界面状态栏和导航区域颜色相同场景。
    
    15. // xxx.ets
    16. @Entry
    17. @Component
    18. struct Example {
    19.   build() {
    20.     Column() {
    21.       Row() {
    22.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    23.       }.backgroundColor('#2786d9')
    
    24.       Row() {
    25.         Text('Display Content 2').fontSize(30)
    26.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    27.       Row() {
    28.         Text('Display Content 3').fontSize(30)
    29.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    30.       Row() {
    31.         Text('Display Content 4').fontSize(30)
    32.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    33.       Row() {
    34.         Text('Display Content 5').fontSize(30)
    35.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    36.       Row() {
    37.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    38.       }.backgroundColor('#96dffa')
    39.     }
    40.     .width('100%').height('100%')
    41.     .alignItems(HorizontalAlign.Center)
    42.     .backgroundColor('#d5d5d5')
    43.     .justifyContent(FlexAlign.SpaceBetween)
    44.   }
    45. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163937.48684961595489300477977200533131:50001231000000:2800:4DB5CDA0E0D7958CB4FB8E8AEC3D5128DD0539822614E9C3C8FD853148872890.png)
    
- 状态栏和导航区域颜色不同时，可以使用[expandSafeArea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea)属性扩展安全区域属性进行调整。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct Example {
    5.   build() {
    6.     Column() {
    7.       Row() {
    8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    9.       }.backgroundColor('#2786d9')
    10.       // 设置顶部绘制延伸到状态栏
    11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
    
    12.       Row() {
    13.         Text('Display Content 2').fontSize(30)
    14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    15.       Row() {
    16.         Text('Display Content 3').fontSize(30)
    17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    18.       Row() {
    19.         Text('Display Content 4').fontSize(30)
    20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    21.       Row() {
    22.         Text('Display Content 5').fontSize(30)
    23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')
    
    24.       Row() {
    25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
    26.       }.backgroundColor('#96dffa')
    27.       // 设置底部绘制延伸到导航区域
    28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
    29.     }
    30.     .width('100%').height('100%')
    31.     .alignItems(HorizontalAlign.Center)
    32.     .backgroundColor('#d5d5d5')
    33.     .justifyContent(FlexAlign.SpaceBetween)
    34.   }
    35. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.75061394560447074198529736772042:50001231000000:2800:902E75D5CF9C4DD79174E234EDE65E52140DEE800228E4183BD6AB6FD0CFA27E.png)
    

### 扩展安全区域属性原理

- 布局阶段按照安全区范围大小进行UI元素布局。
- 布局完成后查看设置了expandSafeArea的组件边界（不包括margin）是否和安全区边界相交。
- 如果设置了expandSafeArea的组件和安全区边界相交，根据expandSafeArea传递的属性则进一步扩大组件绘制区域大小覆盖状态栏、导航区域这些非安全区域。
- 上述过程仅改变组件自身绘制大小，不进行二次布局，不影响子节点和兄弟节点的大小和位置。
- 子节点可以单独设置该属性，只需要自身边界和安全区域重合就可以延伸自身大小至非安全区域内，需要确保父组件未设置clip等裁切属性。
- 配置expandSafeArea属性组件进行绘制扩展时，需要关注组件不能配置固定宽高尺寸，百分比除外。
- 组件可以设置通用属性safeAreaPadding，给自身添加组件级安全区域。该属性作为一种特殊边距，在提供布局约束的同时作为安全区可以被一些系统组件利用。
    - safeAreaPadding位于原有的padding内侧。容器自外向内各层分别为border、padding、safeAreaPadding、内容区。当border和padding确定后，若容器可用空间不足以满足safeAreaPadding的设置，则优先分配给左侧和上侧safeAreaPadding、其次分配给右侧和下侧safeAreaPadding。safeAreaPadding实际尺寸确定后，余下空间为内容区。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.40814739523074922976450985656583:50001231000000:2800:3069DA8848E75088A5E18CA4DEFE8D5B560459053EC369BEE936096F37485126.png "点击放大")
        
    - 系统组件如Navigation、List、Scroll、Tabs等可以利用外层或容器自身safeAreaPadding实现扩大裁剪范围等能力。

### 背景图和视频场景

设置背景图、视频组件大小为安全区域大小并配置expandSafeArea属性。

说明

Video组件在使用expandSafeArea扩展到安全区域时，组件视频显示内容区域不支持扩展。

1. // xxx.ets
2. @Entry
3. @Component
4. struct SafeAreaExample1 {
5.   build() {
6.     Stack() {
7.       Image($r('app.media.bg'))
8.         .height('100%').width('100%')
9.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]) // 图片组件的绘制区域扩展至状态栏和导航区域。
10.     }.height('100%').width('100%')
11.   }
12. }

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.43327826020269771674865794312820:50001231000000:2800:1022E21DA063B1509DB723CB9C69FDA61F3F93D6E7581D7C47F6EA7DAE310B6F.png)

### 滚动类场景

滚动容器设置expandSafeArea属性生效，但当父组件是滚动容器时，子组件设置expandSafeArea属性不生效。对于滚动容器的子组件，有两种方法实现沉浸式效果：

1. 设置父组件滚动容器和子组件相同的背景色，给父组件设置expandSafeArea属性扩展安全区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    20.     }.width('100%').height('100%')
    21.     .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    22.   }
    23. }
    
    **图5** 滚动类容器设置expandSafeArea属性实现沉浸式效果  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.36343620665340982594714223798161:50001231000000:2800:AD6E0F7C59190801230E58A4FFAF23D4F65F1FDE15A3D82DCDAE08D5214E16FC.png)
    
2. 设置父组件滚动容器和子组件相同的背景色，设置滚动容器的内容裁剪属性clipContent(ContentClipMode.SAFE_AREA)，将内容层裁剪区域扩展至避让区。
    
    1. // xxx.ets
    2. @Entry
    3. @Component
    4. struct ScrollExample {
    5.   scroller: Scroller = new Scroller()
    6.   private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    7.   build() {
    8.     Stack({ alignContent: Alignment.TopStart }) {
    9.       Scroll(this.scroller) {
    10.         Column() {
    11.           ForEach(this.arr, (item: number) => {
    12.             Stack() {
    13.               Text('Display Content ' + item.toString()).fontSize(30)
    14.             }
    15.             .width('80%').padding(20).borderRadius(15).backgroundColor(Color.White).margin({ top:30, bottom:30 })
    16.           }, (item: string) => item)
    17.         }.width('100%').backgroundColor('rgb(213,213,213)')
    18.       }.backgroundColor('rgb(213,213,213)')
    19.       .clipContent(ContentClipMode.SAFE_AREA)
    20.     }.width('100%').height('100%')
    21.   }
    22. }
    

**图6** 滚动类容器设置clipContent属性实现沉浸式效果  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.72942034796131303316500546979165:50001231000000:2800:F0FEA17F4AD3FF502D702340C369F02EFCC501694E07893050822DC1F2ADAEA3.png "点击放大")

### 底部页签场景

要求页签背景色能够延伸到导航区域（此处以导航区域表现为导航条为例给出示意），但页签内部可操作元素需要在导航区域之上。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.37246522656942551464504700503566:50001231000000:2800:F55E4980F4B7D0B0006E3960732E793DA44500BA6386C295E62801FCCCC9C579.png "点击放大")

针对底部的页签部分，Navigation组件和Tabs组件默认实现了页签的延伸处理，开发者只需要保证Navigation和Tabs组件的底部边界和底部导航区域重合即可。若开发者显式调用expandSafeArea接口，则安全区效果由expandSafeArea参数指定。

如果未使用上述组件而是采用自定义方式实现页签的场景，可以针对底部元素设置expandSafeArea属性实现底部元素的背景扩展。

**图7** 顶部和底部UI元素未设置和设置expandSafeArea属性效果对比

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.41747390740743659941506414504724:50001231000000:2800:E50527CF67161602DF8FD0C190F67F7D0B4B3B04CF45C3A0446CC37FE90CC51F.png)

1. // xxx.ets
2. @Entry
3. @Component
4. struct Example {
5.   build() {
6.     Column() {
7.       Row() {
8.         Text('Top Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
9.       }.backgroundColor('#2786d9')
10.       // 设置顶部绘制延伸到状态栏
11.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])

12.       Row() {
13.         Text('Display Content 2').fontSize(30)
14.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

15.       Row() {
16.         Text('Display Content 3').fontSize(30)
17.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

18.       Row() {
19.         Text('Display Content 4').fontSize(30)
20.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

21.       Row() {
22.         Text('Display Content 5').fontSize(30)
23.       }.backgroundColor(Color.White).padding(20).borderRadius(15).width('80%')

24.       Row() {
25.         Text('Bottom Content').fontSize(40).textAlign(TextAlign.Center).width('100%')
26.       }.backgroundColor('#96dffa')
27.       // 设置底部绘制延伸到导航区域
28.       .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
29.     }
30.     .width('100%').height('100%')
31.     .alignItems(HorizontalAlign.Center)
32.     .backgroundColor('#d5d5d5')
33.     .justifyContent(FlexAlign.SpaceBetween)
34.   }
35. }

### 图文场景

当状态栏元素和底部导航区域元素不同时，无法单纯通过窗口背景色或者背景图组件延伸实现，此时需要对顶部元素和底部元素分别配置expandSafeArea属性，顶部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.TOP])，底部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.BOTTOM])。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216163938.28582942626334677493417993476880:50001231000000:2800:70849062F759622A69E9F0C2E65D297CE52324158491314B545F1CF41A4F9041.png "点击放大")

1. @Entry
2. @Component
3. struct Index {
4.   build() {
5.     Swiper() {
6.       Column() {
7.         Image($r('app.media.start'))
8.           .height('50%').width('100%')
9.           // 设置图片延伸到状态栏
10.           .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
11.         Column() {
12.           Text('HarmonyOS 第一课')
13.             .fontSize(32)
14.             .margin(30)
15.           Text('通过循序渐进的学习路径，无经验和有经验的开发者都可以掌握ArkTS语言声明式开发范式，体验更简洁、更友好的HarmonyOS应用开发旅程。')
16.             .fontSize(20).margin(20)
17.         }.height('50%').width('100%')
18.         .backgroundColor(Color.White)
19.         // 设置文本内容区背景延伸到导航栏
20.         .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
21.       }
22.     }
23.     .width('100%')
24.     .height('100%')
25.     // 关闭Swiper组件默认的裁切效果以便子节点可以绘制在Swiper外。
26.     .clip(false)
27.   }
28. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-tabs "选项卡 (Tabs)")

Weather Service Kit简介

更新时间: 2025-12-16 16:35

Weather Service Kit（天气服务）是鸿蒙生态下的一个数据提供服务，Weather Service Kit融合了多家气象行业TOPs供应商，提供专业、精准、稳定的超本地化天气预报服务，帮助开发者为用户提供更贴心的本地生活服务，支撑行业客户防灾减灾、降本增效。开发者可以轻松地在HarmonyOS应用/元服务中获取天气数据。

## 场景介绍

Weather Service Kit可以返回以下天气数据，满足开发者的天气数据使用需求：

- 天气预报：开发者可以通过Weather Service Kit获取城市级和POI级的天气预报，包括实况天气、48小时逐小时天气预报（海外城市24小时逐小时天气预报）、10日天气预报，包含天气状况、温度、风力、风向、湿度等全面的预报数据。
- 分钟级降水预报：为您提供附近方圆5km范围内、未来2小时的分钟级降雨态势预报，包含降水形态、降水强度等。
- 天气预警：为您提供气象局实时发布的天气和环境预警信息。
- 天气指数：为您提供未来3天的晾晒指数、穿衣指数、紫外线指数、路况指数、钓鱼指数等生活指数 。
- 天文数据：为您提供日出时间、日落时间、月出时间、月落时间、以及月相等数据。
- 潮汐：为您提供全国主要港口和城市的潮汐数据。

## 约束与限制

- 使用限制：Weather Service Kit当前仅面向系统应用开放，暂不对外开放。
- 设备限制：本kit仅适用于Phone、Tablet、PC/2in1、Wearable设备。

## 模拟器支持范围

本kit暂不支持模拟器。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-kit-guide "Weather Service Kit（天气服务）")
# 开发准备

更新时间: 2025-12-16 16:36

在阅读本章节前，请先参考“[应用开发准备](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-dev-overview)”完成基本准备工作及指纹配置，再继续进行以下开发活动。

## 开通天气服务

说明

Weather Service Kit当前仅面向系统应用开放，暂不对外开放。

1. 登录[AppGallery Connect](https://developer.huawei.com/consumer/cn/service/josp/agc/index.html#/)。
2. 选择“开发与服务”，找到您的项目，选择您创建的HarmonyOS应用。
3. 选择“开放能力管理”标签，勾选“天气服务”能力开关，点击保存按钮。

## 配置Profile文件

在接口调用过程中，天气服务会对您的Profile文件进行鉴权。因此，您需要在开通天气服务后，按照[配置签名信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-dev-overview#section42841246144813)的流程，申请并配置签名信息。

## （可选）申请位置权限

获取用户当前位置的天气数据，需要调用Location Kit（位置服务）获取当前位置经纬度信息，使用前参考[申请权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-geolocationmanager#%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-introduction "Weather Service Kit简介")
# 获取天气数据

更新时间: 2025-12-16 16:36

通过开发者提供的经纬度数据，获取天气数据，比如：实况数据、预警数据。

## 约束与限制

本kit支持Phone、Tablet、PC/2in1设备，并且从5.1.0(18)版本开始，新增支持Wearable设备。

## （可选）获取当前位置经纬度

当开发者需要查询当前位置的天气数据时，需要先[申请位置权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-geolocationmanager#%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90)，并且获取当前位置的经纬度信息。获取当前位置的经纬度信息方法如下：

1. 导入模块。
    
    1. import { geoLocationManager } from '@kit.LocationKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
2. 调用[getCurrentLocation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-geolocationmanager#geolocationmanagergetcurrentlocation-2)，获取经纬度。
    
    1. geoLocationManager.getCurrentLocation().then((result) => {
    2.   console.info('current location latitude: ' + result.latitude);
    3.   console.info('current location longitude: ' + result.longitude);
    4. }).catch((err: BusinessError ) => {
    5.   console.error(`getCurrentLocation failed. Code: ${err.code}, message: ${err.message}`);
    6. });
    

## 查询天气数据

Weather Service Kit依赖开发者提供的经纬度数据（精确到小数点后2位），返回格点天气数据。

1. 导入模块。
    
    1. import { weatherService } from '@kit.WeatherServiceKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
2. 创建请求对象。
    
    - location：使用[当前位置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-getweather#section546501255)的数据，或者填入查询目的地的经纬度。
    - limitedDatasets：为可选字段，传入一个数组，表示请求有限的数据集，取值范围参考weatherService.[Dataset](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/weather-service-weatherservice#section83091727192814)。
    
    1. let request: weatherService.WeatherRequest = {
    2.   location: {
    3.     latitude: 22.62,
    4.     longitude: 114.07
    5.   },
    6.   limitedDatasets: [weatherService.Dataset.CURRENT, weatherService.Dataset.ALERTS]
    7. }
    
    说明
    
    如果limitedDatasets参数不传值，或者传入的数组为空，则默认返回Weather Service Kit支持的所有数据。根据实际需要的天气数据设置limitedDatasets，可以大幅降低接口请求时延。
    
3. 请求数据。
    
    1. try {
    2.   let weather = await weatherService.getWeather(request);
    3.   if (weather.current) {
    4.     console.info('getWeather current temperature: ' + weather.current.temperature);
    5.   }
    6.   if (weather.alerts?.length) {
    7.     console.info('getWeather alert: ' + weather.alerts[0].title);
    8.   }
    9. } catch (err) {
    10.   err = err as BusinessError;
    11.   console.error(`getWeather failed. Code: ${err.code}, message: ${err.message}`);
    12. }
    
    说明
    
    getWeather接口的使用依赖当前Ability的Context，如果开发者在无法通过[getHostContext()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-uicontext-uicontext#gethostcontext12)接口获取到Context的环境中请求天气数据，例如使用worker或者taskpool的子线程场景，请使用[weatherService.getWeatherWithContext(context, request)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/weather-service-weatherservice#section25641843201511)方法并提供Ability的Context信息。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-preparations "开发准备")
# 如何获取指定城市的天气数据？

更新时间: 2025-12-16 16:36

先调用[getAddressesFromLocationName](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-geolocationmanager#geolocationmanagergetaddressesfromlocationname-1)方法获取指定城市的经纬度信息，然后根据返回的经纬度数据调用[getWeather](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/weather-service-weatherservice#section78181857767)方法获取天气数据。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-faq "Weather Service Kit 常见问题")
# Weather Service Kit接口有定位功能吗？

更新时间: 2025-12-16 16:36

没有，获取当前位置的经纬度可参考[获取当前位置经纬度](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-getweather#section546501255)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-faq-1 "如何获取指定城市的天气数据？")
# 请求了分钟级降水预报/天气预警/潮汐，未返回任何数据。

更新时间: 2025-12-16 16:37

如果查询区域当时无短时降水、无天气预警发布或预警已经解除、无潮汐站点时，没有数据返回属于正常现象。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/weather-service-faq-2 "Weather Service Kit接口有定位功能吗？")

# Core Speech Kit简介

更新时间: 2025-12-16 16:27

Core Speech Kit（基础语音服务）集成了语音类基础AI能力，包括文本转语音（TextToSpeech）及语音识别（SpeechRecognizer）能力，便于用户与设备进行互动，实现将实时输入的语音与文本之间相互转换。

## 场景介绍

- 文本转语音：将一段不超过10000字数的文本合成为语音并进行播报。
- 语音识别：将一段音频信息（短语音模式不超过60s，长语音模式不超过8h）转换为文本，可以将pcm音频文件或者实时语音转换为文字。

## 约束与限制

### 支持的设备

Phone、Tablet、PC/2in1。

### 支持的国家/地区

仅适用于中国境内（不包含中国香港、中国澳门、中国台湾）。

### 能力限制

|AI能力|约束|
|:--|:--|
|文本转语音（中国境内版本）|- 支持的语种类型：中文、英文。（简体中文、繁体中文、中文语境下的英文）<br>- 支持的音色类型：聆小珊女声音色、英语（美国）劳拉女声音色、凌飞哲男声音色。<br>- 文本长度：不超过10000字数。|
|语音识别|- 支持的语种类型：中文普通话。<br>- 支持的模型类型：离线。<br>- 语音时长：短语音模式不超过60s，长语音模式不超过8h。|

## 模拟器支持情况

本Kit能力从6.0.0(20)版本开始支持模拟器。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/core-speech-kit-guide "Core Speech Kit（基础语音服务）")
# 文本转语音

更新时间: 2025-12-16 16:27

Core Speech Kit支持将一篇不超过10000字数的中英文文本（简体中文、繁体中文、数字、英文）合成为语音，并以选定音色进行播报。

开发者可对播报的策略进行设置，包括单词播报、数字播报、静音停顿、汉字发音策略。

## 场景介绍

手机/平板等设备在无网状态下，系统应用无障碍（屏幕朗读）接入文本转语音能力，为视障人士或不方便阅读场景提供播报能力。

## 约束与限制

|AI能力|约束|
|:--|:--|
|文本转语音（中国境内版本）|- 支持的语种类型：中文、英文。（简体中文、繁体中文、中文语境下的英文）<br>- 支持的音色类型：聆小珊女声音色、英语（美国）劳拉女声音色、凌飞哲男声音色。<br>- 文本长度：不超过10000字数。|

## 开发步骤

1. 在使用文本转语音时，将实现文本转语音相关的类添加至工程。
    
    1. import { textToSpeech } from '@kit.CoreSpeechKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
2. 调用createEngine接口，创建[TextToSpeechEngine](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section185526396124)实例。
    
    createEngine接口提供了两种调用形式，当前以其中一种作为示例，其他方式可参考[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech)。
    
    1. let ttsEngine: textToSpeech.TextToSpeechEngine;
    
    2. // 设置创建引擎参数
    3. let extraParam: Record<string, Object> = {"style": 'interaction-broadcast', "locate": 'CN', "name": 'EngineName'};
    4. let initParamsInfo: textToSpeech.CreateEngineParams = {
    5.   language: 'zh-CN',
    6.   person: 0,
    7.   online: 1,
    8.   extraParams: extraParam
    9. };
    
    10. // 调用createEngine方法
    11. textToSpeech.createEngine(initParamsInfo, (err: BusinessError, textToSpeechEngine: textToSpeech.TextToSpeechEngine) => {
    12.   if (!err) {
    13.     console.info('Succeeded in creating engine');
    14.     // 接收创建引擎的实例
    15.     ttsEngine = textToSpeechEngine;
    16.   } else {
    17.     console.error(`Failed to create engine. Code: ${err.code}, message: ${err.message}.`);
    18.   }
    19. });
    
3. 得到[TextToSpeechEngine](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section185526396124)实例对象后，实例化[SpeakParams](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section7843122735210)对象、[SpeakListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section115395631614)对象，并传入待合成及播报的文本originalText，调用[speak](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section140216144119)接口进行播报。
    
    1. // 设置speak的回调信息
    2. let speakListener: textToSpeech.SpeakListener = {
    3.   // 开始播报回调
    4.   onStart(requestId: string, response: textToSpeech.StartResponse) {
    5.     console.info(`onStart, requestId: ${requestId} response: ${JSON.stringify(response)}`);
    6.   },
    7.   // 合成完成及播报完成回调
    8.   onComplete(requestId: string, response: textToSpeech.CompleteResponse) {
    9.     console.info(`onComplete, requestId: ${requestId} response: ${JSON.stringify(response)}`);
    10.   },
    11.   // 停止播报回调
    12.   onStop(requestId: string, response: textToSpeech.StopResponse) {
    13.     console.info(`onStop, requestId: ${requestId} response: ${JSON.stringify(response)}`);
    14.   },
    15.   // 返回音频流
    16.   onData(requestId: string, audio: ArrayBuffer, response: textToSpeech.SynthesisResponse) {
    17.     console.info(`onData, requestId: ${requestId} sequence: ${JSON.stringify(response)} audio: ${JSON.stringify(audio)}`);
    18.   },
    19.   // 错误回调
    20.   onError(requestId: string, errorCode: number, errorMessage: string) {
    21.     console.error(`onError, requestId: ${requestId} errorCode: ${errorCode} errorMessage: ${errorMessage}`);
    22.   }
    23. };
    24. // 设置回调
    25. ttsEngine.setListener(speakListener);
    26. let originalText: string = 'Hello HarmonyOS';
    27. // 设置播报相关参数
    28. let extraParam: Record<string, Object> = {"queueMode": 0, "speed": 1, "volume": 2, "pitch": 1, "languageContext": 'zh-CN',  
    29. "audioType": "pcm", "soundChannel": 3, "playType": 1 };
    30. let speakParams: textToSpeech.SpeakParams = {
    31.   requestId: '123456', // requestId在同一实例内仅能用一次，请勿重复设置
    32.   extraParams: extraParam
    33. };
    34. // 调用播报方法
    35. // 开发者可以通过修改speakParams主动[设置播报策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/texttospeech-guide#section137481719163910)
    36. ttsEngine.speak(originalText, speakParams);
    
4. （可选）当需要停止合成及播报时，可调用[stop](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section14433919171116)接口。
    
    1. ttsEngine.stop();
    
5. （可选）当需要查询文本转语音服务是否处于忙碌状态时，可调用[isBusy](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section35361720111113)接口。
    
    1. ttsEngine.isBusy();
    
6. （可选）当需要查询支持的语种音色信息时，可调用[listVoices](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech#section813761871119)接口。
    
    listVoices接口提供了两种调用形式，当前以其中一种作为示例，其他方式可参考[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-texttospeech)。
    
    1. // 在组件中声明并初始化字符串voiceInfo
    2. @State voiceInfo: string = "";
    
    3. // 设置查询相关参数
    4. let voicesQuery: textToSpeech.VoiceQuery = {
    5.   requestId: '12345678', // requestId在同一实例内仅能用一次，请勿重复设置
    6.   online: 1
    7. };
    8. // 调用listVoices方法，以callback返回
    9. ttsEngine.listVoices(voicesQuery, (err: BusinessError, voiceInfo: textToSpeech.VoiceInfo[]) => {
    10.   if (!err) {
    11.     // 接收目前支持的语种音色等信息
    12.     this.voiceInfo = JSON.stringify(voiceInfo);
    13.     console.info(`Succeeded in listing voices, voiceInfo is ${this.voiceInfo}`);
    14.   } else {
    15.     console.error(`Failed to list voices. Code: ${err.code}, message: ${err.message}`);
    16.   }
    17. });
    

## 设置播报策略

由于不同场景下，模型自动判断所选择的播报策略可能与实际需求不同，此章节提供对于播报策略进行主动设置的方法。

说明

以下取值说明均为有效取值，若所使用的数值在有效取值之外则播报结果可能与预期不符，并产生错误的播报结果。

### 设置单词播报方式

文本格式：[hN] (N=0/1/2)

N取值说明：

|取值|说明|
|:--|:--|
|0|智能判断单词播放方式。默认值为0。|
|1|逐个字母进行播报。|
|2|以单词方式进行播报。|

文本示例：

1. "hello[h1] world"

hello使用单词发音，world及后续单词将会逐个字母进行发音。

### 设置数字播报策略

格式：[nN] (N=0/1/2)

N取值说明：

|取值|说明|
|:--|:--|
|0|智能判断数字处理策略。默认值为0。|
|1|作为号码逐个数字播报。|
|2|作为数值播报。超过18位数字不支持，自动按逐个数字进行播报。|

文本示例：

1. "[n2]123[n1]456[n0]"

其中，123将会按照数值播报，456则会按照号码播报，而后的文本中的数字，均会自动判断。

### 插入静音停顿

格式：[pN]

描述：N为无符号整数，单位为ms。

文本示例：

1. "你好[p500]小艺"

该句播报时，将会在“你好”后插入500ms的静音停顿。

### 指定汉字发音

汉字的声调，通过在拼音后接一位数字1~5分别表示阴平、阳平、上声、去声和轻声5个声调。

格式：[=MN]

描述：M表示拼音，N表示声调。

N取值说明：

|取值|说明|
|:--|:--|
|1|阴平|
|2|阳平|
|3|上声|
|4|去声|
|5|轻声|

文本示例：

1. "着[=zhuo2]手"

“着”字将读作“zhuó”。

## 开发实例

点击按钮，播报一段文本。

### Index.ets

1. import { textToSpeech } from '@kit.CoreSpeechKit';
2. import { BusinessError } from '@kit.BasicServicesKit';
3. import { PromptAction } from '@kit.ArkUI';
4. import { UIContext } from '@kit.ArkUI';
5. import { TreeMap } from '@kit.ArkTS';
6. import { fileIo as fs } from '@kit.CoreFileKit';
7. import PcmPlayer from './PcmPlayer';
8. import { audio } from '@kit.AudioKit';
9. import { Context } from '@kit.AbilityKit';

10. const TAG: string = 'TtsDemo';
11. let ttsEngine: textToSpeech.TextToSpeechEngine;
12. let bufferLength: number = 0;
13. let engineCreated: boolean = false;

14. // 定义一个函数来拼接ArrayBuffer
15. function concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {
16.   const totalLength = buffers.reduce((sum, buffer) => sum + buffer.byteLength, 0);
17.   const concatenatedBuffer = new ArrayBuffer(totalLength);
18.   let offset = 0;
19.   for (const buffer of buffers) {
20.     const uint8Array = new Uint8Array(buffer);
21.     new Uint8Array(concatenatedBuffer, offset, uint8Array.length).set(uint8Array);
22.     offset += uint8Array.length;
23.   }
24.   return concatenatedBuffer;
25. }

26. @Entry
27. @Component
28. struct Index {
29.   @State createCount: number = 0;
30.   @State originalText: string = "\n\t\t古人学问无遗力，少壮工夫老始成；\n\t\t" + "纸上得来终觉浅，绝知此事要躬行。\n\t\t";
31.   @State uiContext: UIContext = this.getUIContext()
32.   @State promptAction: PromptAction = this.uiContext.getPromptAction();
33.   private pcmData: TreeMap<number, Uint8Array> = new TreeMap();
34.   private pcmPlayer: PcmPlayer = new PcmPlayer();

35.   build() {
36.     Column() {
37.       Scroll() {
38.         Column() {
39.           TextArea({ placeholder: 'Please enter tts original text', text: `${this.originalText}` })
40.             .margin(20)
41.             .focusable(false)
42.             .border({ width: 5, color: 0x317AE7, radius: 10, style: BorderStyle.Dotted })
43.             .onChange((value: string) => {
44.               this.originalText = value;
45.               console.info(TAG, "original text: " + this.originalText);
46.             })

47.           Button() {
48.             Text("CreateEngine")
49.               .fontColor(Color.White)
50.               .fontSize(20)
51.           }
52.           .type(ButtonType.Capsule)
53.           .backgroundColor("#0x317AE7")
54.           .width("80%")
55.           .height(50)
56.           .margin(10)
57.           .onClick(() => {
58.             engineCreated = true
59.             this.createCount++;
60.             console.info(`createByCallback：createCount:${this.createCount}`);
61.             this.createByCallback();
62.             this.promptAction.showToast({
63.               message: 'CreateEngine success!',
64.               duration: 2000
65.             });
66.           })

67.           Button() {
68.             Text("speak")
69.               .fontColor(Color.White)
70.               .fontSize(20)
71.           }
72.           .type(ButtonType.Capsule)
73.           .backgroundColor("#0x317AE7")
74.           .width("80%")
75.           .height(50)
76.           .margin(10)
77.           .onClick(() => {
78.             if (engineCreated) {
79.               try {
80.                 this.speak();
81.                 this.promptAction.showToast({
82.                   message: 'start speaking',
83.                   duration: 2000
84.                 });
85.               } catch (err)  {
86.                   this.promptAction.showToast({
87.                     message: 'start speaking failed',
88.                     duration: 2000
89.                   });
90.                 }
91.             } else {
92.               this.promptAction.showToast({
93.                 message: 'The engine has not been created',
94.                 duration: 2000
95.               });
96.             }
97.           })

98.           Button() {
99.             Text("speakOnData")
100.               .fontColor(Color.White)
101.               .fontSize(20)
102.           }
103.           .type(ButtonType.Capsule)
104.           .backgroundColor("#0x317AE7")
105.           .width("80%")
106.           .height(50)
107.           .margin(10)
108.           .onClick(() => {
109.             if (engineCreated) {
110.               try {
111.                 this.speakOnData();
112.                 this.promptAction.showToast({
113.                   message: 'start speakOnData',
114.                   duration: 2000
115.                 });
116.               } catch (err) {
117.                 this.promptAction.showToast({
118.                   message: 'start speakOnData failed',
119.                   duration: 2000
120.                 });
121.               }
122.             } else {
123.               this.promptAction.showToast({
124.                 message: 'The engine has not been created',
125.                 duration: 2000
126.               });
127.             }
128.           })

129.           Button() {
130.             Text("stop")
131.               .fontColor(Color.White)
132.               .fontSize(20)
133.           }
134.           .type(ButtonType.Capsule)
135.           .backgroundColor("#0x317AE7")
136.           .width("80%")
137.           .height(50)
138.           .margin(10)
139.           .onClick(() => {
140.             try {
141.               let isBusy: boolean = ttsEngine.isBusy();
142.               let isPlaying: boolean = this.pcmPlayer.isPlaying();
143.               if (isBusy) {
144.                 ttsEngine.stop();
145.               }
146.               if (isPlaying) {
147.                 this.pcmPlayer.stop()
148.               }
149.               this.promptAction.showToast({
150.                 message: 'stop!',
151.                 duration: 2000
152.               });
153.             } catch (err) {
154.               this.promptAction.showToast({
155.                 message: 'stop failed',
156.                 duration: 2000
157.               });
158.             }
159.           })

160.           Button() {
161.             Text("isBusy")
162.               .fontColor(Color.White)
163.               .fontSize(20)
164.           }
165.           .type(ButtonType.Capsule)
166.           .backgroundColor("#0x317AE7")
167.           .width("80%")
168.           .height(50)
169.           .margin(10)
170.           .onClick(() => {
171.             try {
172.               let isBusy: boolean = ttsEngine.isBusy();
173.               let isPlaying: boolean = this.pcmPlayer.isPlaying();
174.               console.info('isBusy :' + isBusy);
175.               console.info('isPlaying :' + isPlaying);
176.               this.promptAction.showToast({
177.                 message: 'speak isBusy :' + isBusy + '\nspeakOnData isBusy :' + isPlaying,
178.                 duration: 2000
179.               });
180.             } catch (err) {
181.               this.promptAction.showToast({
182.                 message: 'isBusy failed',
183.                 duration: 2000
184.               });
185.             }
186.           })

187.           Button() {
188.             Text("shutdown")
189.               .fontColor(Color.White)
190.               .fontSize(20)
191.           }
192.           .type(ButtonType.Capsule)
193.           .backgroundColor("#0x317AA7")
194.           .width("80%")
195.           .height(50)
196.           .margin(10)
197.           .onClick(() => {
198.             try {
199.               this.pcmPlayer.release()
200.               ttsEngine.shutdown();
201.               engineCreated = false
202.               this.promptAction.showToast({
203.                 message: 'shutdown success!',
204.                 duration: 2000
205.               });
206.             } catch (err) {
207.               this.promptAction.showToast({
208.                 message: 'shutdown failed',
209.                 duration: 2000
210.               });
211.             }
212.           })

213.         }
214.         .layoutWeight(1)
215.       }
216.       .width('100%')
217.       .height('100%')

218.     }
219.   }

220.   // 创建引擎，通过callback形式返回
221.   // 当引擎不存在、引擎资源不存在、初始化超时，返回错误码1002300005，引擎创建失败
222.   private createByCallback() {
223.     // 设置创建引擎参数
224.     let extraParam: Record<string, Object> = { "style": 'interaction-broadcast', "locate": 'CN', "name": 'EngineName' }
225.     let initParamsInfo: textToSpeech.CreateEngineParams = {
226.       language: 'zh-CN',
227.       person: 0,
228.       online: 1,
229.       extraParams: extraParam
230.     };
231.     try {
232.       // 调用createEngine方法
233.       textToSpeech.createEngine(initParamsInfo, (err: BusinessError, textToSpeechEngine: textToSpeech.TextToSpeechEngine) => {
234.         if (!err) {
235.           console.info('createEngine is success');
236.           // 接收创建引擎的实例
237.           ttsEngine = textToSpeechEngine;
238.         } else {
239.           console.error(`error code: ${err.code}, message: ${err.message}.`)
240.         }
241.       });
242.     } catch (error) {
243.       let message = (error as BusinessError).message;
244.       let code = (error as BusinessError).code;
245.       console.error(`createEngine failed, error code: ${code}, message: ${message}.`)
246.     }
247.   }

248.   // 调用speak播报方法
249.   private speak() {
250.     let speakListener: textToSpeech.SpeakListener = {
251.       // 开始播报回调
252.       onStart(requestId: string, response: textToSpeech.StartResponse) {
253.         console.info(`onStart, requestId: ${requestId} response: ${JSON.stringify(response)}`);
254.       },
255.       // 完成播报回调
256.       onComplete(requestId: string, response: textToSpeech.CompleteResponse) {
257.         console.info(`onComplete, requestId: ${requestId} response: ${JSON.stringify(response)}`);
258.       },
259.       // 停止播报完成回调，调用stop方法并完成时会触发此回调
260.       onStop(requestId: string, response: textToSpeech.StopResponse) {
261.         console.info(`onStop, requestId: ${requestId} response: ${JSON.stringify(response)}`);
262.       },
263.       // 返回音频流
264.       onData(requestId: string, audio: ArrayBuffer, response: textToSpeech.SynthesisResponse) {
265.         console.info(`onData, requestId: ${requestId} sequence: ${JSON.stringify(response)} audio: ${JSON.stringify(audio)}`);
266.       },
267.       // 错误回调，播报过程发生错误时触发此回调
268.       onError(requestId: string, errorCode: number, errorMessage: string) {
269.         if (errorCode === 1002300007) {
270.           engineCreated = false
271.         }
272.         console.error(`onError, requestId: ${requestId} errorCode: ${errorCode} errorMessage: ${errorMessage}`);
273.       }
274.     };
275.     // 设置回调
276.     ttsEngine.setListener(speakListener);
277.     // 设置播报相关参数
278.     let extraParam: Record<string, Object> = {"queueMode": 0, "speed": 1, "volume": 2, "pitch": 1, "languageContext": 'zh-CN', "audioType": "pcm", "soundChannel": 3, "playType":1}
279.     let speakParams: textToSpeech.SpeakParams = {
280.       requestId: '123456' + Date.now(), // requestId在同一实例内仅能用一次，请勿重复设置
281.       extraParams: extraParam
282.     };
283.     // 调用speak播报方法
284.     ttsEngine.speak(this.originalText, speakParams);
285.   };

286.   private onStart = async (utteranceId: string, response: textToSpeech.StartResponse) => {
287.     bufferLength = 0;
288.     // 初始化音频数据映射
289.     console.info(TAG, `onStart | utteranceId: ${ utteranceId }, response: ${JSON.stringify(response)}`);
290.   }

291.   private onData = async (utteranceId: string, audio: ArrayBuffer, response: textToSpeech.SynthesisResponse) => {
292.     // 将ArrayBuffer转换为Uint8Array
293.     let uint8Array: Uint8Array = new Uint8Array(audio);
294.     this.pcmData.set(response.sequence, uint8Array)
295.     bufferLength += 1
296.     let str = ""
297.     // 或者使用循环打印每个元素
298.     for (let i = 0; i < uint8Array.length; i++) {
299.       str = str + (","+uint8Array[i]);
300.     }
301.     console.info(TAG, `onData | utteranceId: ${utteranceId}, sequence: ${JSON.stringify(response.sequence)}, length: ${uint8Array.length}, audio: ${JSON.stringify(str)}`);
302.   }

303.   private onComplete = async (utteranceId: string, response: textToSpeech.CompleteResponse) => {
304.     let buffers: ArrayBuffer[] = new Array();

305.     console.info(TAG, `pcmData len: ${this.pcmData.length}`)
306.     // 遍历Map，将ArrayBuffer添加到数组中
307.     this.pcmData.forEach((value: Uint8Array, key: number) => {
308.       buffers.push(value.buffer.slice(0))
309.     })
310.     console.info(TAG, `buffers len: ${buffers.length}`)

311.     // 按照顺序拼接所有的ArrayBuffer
312.     let audioData = concatenateArrayBuffers(buffers);
313.     console.info(TAG, `audioData len: ${audioData.byteLength}`)

314.     let context = this.uiContext.getHostContext() as Context
315.     let path = context.filesDir
316.     let filePath: string = `${path}/my.pcm`
317.     let os = await fs.createStream(filePath, "w+")
318.     await os.write(audioData)
319.     this.pcmPlayer.file = fs.openSync(filePath, fs.OpenMode.READ_ONLY);
320.     // 播放音频流
321.     console.info(TAG, `playAudio start`)
322.     await this.pcmPlayer.prepare(audio.AudioSamplingRate.SAMPLE_RATE_16000)
323.     await this.pcmPlayer.play(audioData)
324.     console.info(TAG, `playAudio end`)

325.     console.info(TAG, `onComplete | utteranceId: ${utteranceId}, response: ${JSON.stringify(response)}`);
326.   }

327.   // 调用speakOnData播报方法
328.   // 未初始化引擎时调用speak方法，返回错误码1002300007，合成及播报失败
329.   private async speakOnData() {
330.     // 设置播报相关参数
331.     let extraParam: Record<string, Object> = {"queueMode": 0, "speed": 1.2, "volume": 2, "pitch": 1, "languageContext": 'zh-CN', "audioType": "pcm", "soundChannel": 1, "playType":0}
332.     let speakParams: textToSpeech.SpeakParams = {
333.       requestId: '1234567' + Date.now(),
334.       extraParams: extraParam
335.     }

336.     try{
337.       // 创建回调对象
338.       let speakListener: textToSpeech.SpeakListener = {
339.         // 开始识别成功回调
340.         onStart: this.onStart,
341.         // 识别完成回调
342.         onComplete: this.onComplete,
343.         // 停止播报回调
344.         onStop(utteranceId: string, response: textToSpeech.StopResponse) {
345.           console.info('speakListener onStop: ' + ' utteranceId: ' + utteranceId + ' response: ' + JSON.stringify(response));
346.         },
347.         // 返回音频流
348.         onData: this.onData,
349.         // 错误回调
350.         onError(utteranceId: string, errorCode: number, errorMessage: string) {
351.           if (errorCode === 1002300007) {
352.             engineCreated = false
353.           }
354.           console.error('speakListener onError: ' + ' utteranceId: ' + utteranceId + ' errorCode: ' + errorCode + ' errorMessage: ' + errorMessage);
355.         }
356.       };
357.       // 设置回调
358.       ttsEngine.setListener(speakListener);
359.       try{
360.         console.info(`speakListener before speak`)
361.         // 调用speak播报方法
362.         for (let i = 0; i < 1; i++) {
363.           ttsEngine?.speak(this.originalText, speakParams);
364.         }
365.         console.info(`speakListener after speak`)
366.       }catch (error) {
367.         let message = (error as BusinessError).message;
368.         let code = (error as BusinessError).code;
369.         console.error(`speakListener speak failed, error code: ${code}, message: ${message}.`)
370.       }
371.     }catch (error) {
372.       let message = (error as BusinessError).message;
373.       let code = (error as BusinessError).code;
374.       console.error(`speakListener setListener failed, error code: ${code}, message: ${message}.`)
375.     }
376.   }
377. }

### PcmPlayer.ets

1. import { audio } from '@kit.AudioKit';
2. import { fileIo as fs } from '@kit.CoreFileKit';

3. const TAG = 'PCM_audio';

4. class Options {
5.   offset?: number;
6.   length?: number;
7. }

8. export default class PcmPlayer {

9.   public file: fs.File | undefined;
10.   private writeDataCallback = (buffer: ArrayBuffer) => {
11.     let options: Options = {
12.       offset: this.bufferSize,
13.       length: buffer.byteLength
14.     };

15.     try {
16.       fs.readSync(this.file?.fd, buffer, options);
17.       this.bufferSize += buffer.byteLength;
18.       if (this.audioDataSize < this.bufferSize) {
19.         this.renderModel?.off('writeData');
20.         this.stop()
21.       }
22.       console.info(TAG, 'reading file success');
23.       // 系统会判定buffer有效，正常播放。
24.       return audio.AudioDataCallbackResult.VALID;
25.     } catch (error) {
26.       console.error(TAG, `Reading file failed, error code: ${error.code}, message: ${error.message}.`)
27.       // 系统会判定buffer无效，不播放。
28.       return audio.AudioDataCallbackResult.INVALID;
29.     }
30.   };
31.   /**
32.    * 缓存大小
33.    */
34.   private bufferSize: number = 0;
35.   /**
36.    * 音频总大小
37.    */
38.   private audioDataSize: number = 0;
39.   /**
40.    * 播放器
41.    */
42.   private renderModel: audio.AudioRenderer | null = null;
43.   /**
44.    * 播放状态
45.    */
46.   private audioStreamInfo: audio.AudioStreamInfo = {
47.     samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_16000, // 采样率
48.     channels: audio.AudioChannel.CHANNEL_1, // 通道
49.     sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式
50.     encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式
51.   }
52.   private audioRendererInfo: audio.AudioRendererInfo = {
53.     usage: audio.StreamUsage.STREAM_USAGE_ACCESSIBILITY, // 音频流使用类型
54.     rendererFlags: 0 // 音频渲染器标志
55.   }
56.   private audioRendererOptions: audio.AudioRendererOptions = {
57.     streamInfo: this.audioStreamInfo,
58.     rendererInfo: this.audioRendererInfo
59.   }

60.   public async prepare(sampleRate: number) {
61.     this.audioRendererOptions.streamInfo.samplingRate = sampleRate;
62.     this.audioRendererOptions.rendererInfo.usage = audio.StreamUsage.STREAM_USAGE_MUSIC;
63.     if (this.renderModel != null) {
64.       await this.renderModel.release();
65.     }
66.     let renderModel = await audio.createAudioRenderer(this.audioRendererOptions);
67.     if (!renderModel) {
68.       console.error(TAG, `failed to create audio renderer`);
69.     }
70.     console.info(TAG, "creating AudioRenderer success");
71.     this.renderModel = renderModel;
72.     this.bufferSize = await this.renderModel.getBufferSize();
73.   }

74.   public async play(data: ArrayBuffer): Promise<number> {
75.     this.audioDataSize = data.byteLength
76.     if (this.renderModel != null) {
77.       this.renderModel.on('writeData', this.writeDataCallback);
78.       // 启动渲染
79.       await this.renderModel.start();
80.       console.info(TAG, "start AudioRenderer success");
81.     }
82.     return -1;
83.   }

84.   public async stop() {
85.     console.info(TAG, 'Renderer begin stop');
86.     if (this.renderModel == null) {
87.       return;
88.     }

89.     // 只有渲染器状态为running或paused的时候才可以停止
90.     if (this.renderModel.state !== audio.AudioState.STATE_RUNNING
91.       && this.renderModel.state !== audio.AudioState.STATE_PAUSED) {
92.       console.error(TAG, 'Renderer is not running or paused');
93.       return;
94.     }
95.     await this.renderModel.stop(); // 停止渲染
96.     console.info(TAG, 'Renderer stopped');
97.   }

98.   public async release() {
99.     // 渲染器状态不是released状态，才能release
100.     if (this.renderModel != null) {
101.       if (this.renderModel.state === audio.AudioState.STATE_RELEASED) {
102.         console.error(TAG, 'Renderer already released');
103.         return;
104.       }
105.       await this.renderModel.release(); // 释放资源
106.       this.renderModel = null;
107.       console.info(TAG, 'Renderer released');
108.     }
109.   }

110.   /**
111.    * 判断当前渲染状态
112.    *
113.    * @returns running返回true，否则返回false
114.    */
115.   public isPlaying() {
116.     if (this.renderModel != null) {
117.       console.info(TAG, "player.state:" + this.renderModel.state);
118.       return this.renderModel.state == audio.AudioState.STATE_RUNNING;
119.     } else {
120.       return false;
121.     }
122.   }

123.   /**
124.    * 获取当前渲染状态
125.    *
126.    * @returns running返回true，否则返回false
127.    */
128.   public getRenderState(): number {
129.     if (this.renderModel != null) {
130.       console.info(TAG, "player.state:" + this.renderModel.state);
131.       return this.renderModel.state;
132.     } else {
133.       return audio.AudioState.STATE_INVALID;
134.     }
135.   }

136.   /**
137.    * 获取音频渲染器的最小缓冲区大小
138.    */
139.   public getBufferSize(): number {
140.     return this.bufferSize;
141.   }
142. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/core-speech-introduction "Core Speech Kit简介")
# 语音识别

更新时间: 2025-12-16 16:27

将一段中文音频信息（中文、中文语境下的英文；短语音模式不超过60s，长语音模式不超过8h）转换为文本，音频信息可以为PCM音频文件或者实时语音。

## 场景介绍

手机/平板等设备在无网状态下，为听障人士或不方便收听音频场景提供音频转文本能力。

## 约束与限制

|AI能力|约束|
|:--|:--|
|语音识别|- 支持的语种类型：中文普通话。<br>- 支持的模型类型：离线。<br>- 语音时长：短语音模式不超过60s，长语音模式不超过8h。|

## 开发步骤

1. 在使用语音识别时，将实现语音识别相关的类添加至工程。
    
    1. import { speechRecognizer } from '@kit.CoreSpeechKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
2. 调用[createEngine](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section53411946183318)方法，对引擎进行初始化，并创建[SpeechRecognitionEngine](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section153101728203110)实例。
    
    createEngine方法提供了两种调用形式，当前以其中一种作为示例，其他方式可参考[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer)。
    
    1. let asrEngine: speechRecognizer.SpeechRecognitionEngine;
    2. let sessionId: string = '123456';
    3. // 创建引擎，通过callback形式返回
    4. // 设置创建引擎参数
    5. let extraParam: Record<string, Object> = {"locate": "CN", "recognizerMode": "short"};
    6. let initParamsInfo: speechRecognizer.CreateEngineParams = {
    7.   language: 'zh-CN',
    8.   online: 1,
    9.   extraParams: extraParam
    10. };
    11. // 调用createEngine方法
    12. speechRecognizer.createEngine(initParamsInfo, (err: BusinessError, speechRecognitionEngine: speechRecognizer.SpeechRecognitionEngine) => {
    13.   if (!err) {
    14.     console.info('Succeeded in creating engine.');
    15.     // 接收创建引擎的实例
    16.     asrEngine = speechRecognitionEngine;
    17.   } else {
    18.     console.error(`Failed to create engine. Code: ${err.code}, message: ${err.message}.`);
    19.   }
    20. });
    
3. 得到[SpeechRecognitionEngine](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section153101728203110)实例对象后，实例化[RecognitionListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section845815011389)对象，调用[setListener](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section1745872517348)方法设置回调，用来接收语音识别相关的回调信息。
    
    1. // 创建回调对象
    2. let setListener: speechRecognizer.RecognitionListener = {
    3.   // 开始识别成功回调
    4.   onStart(sessionId: string, eventMessage: string) {
    5.     console.info(`onStart, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
    6.   },
    7.   // 事件回调
    8.   onEvent(sessionId: string, eventCode: number, eventMessage: string) {
    9.     console.info(`onEvent, sessionId: ${sessionId} eventCode: ${eventCode} eventMessage: ${eventMessage}`);
    10.   },
    11.   // 识别结果回调，包括中间结果和最终结果
    12.   onResult(sessionId: string, result: speechRecognizer.SpeechRecognitionResult) {
    13.     console.info(`onResult, sessionId: ${sessionId} result: ${JSON.stringify(result)}`);
    14.   },
    15.   // 识别完成回调
    16.   onComplete(sessionId: string, eventMessage: string) {
    17.     console.info(`onComplete, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
    18.   },
    19.   // 错误回调，错误码通过本方法返回
    20.   // 返回错误码1002200002，开始识别失败，重复启动startListening方法时触发
    21.   // 更多错误码请参考[错误码参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/errorcode-corespeech)
    22.   onError(sessionId: string, errorCode: number, errorMessage: string) {
    23.     console.error(`onError, sessionId: ${sessionId} errorCode: ${errorCode} errorMessage: ${errorMessage}`);
    24.   },
    25. }
    26. // 设置回调
    27. asrEngine.setListener(setListener);
    
4. 分别为音频文件转文字和麦克风转文字功能设置开始识别的相关参数，调用[startListening](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section140216144119)方法，开始识别。
    
    1. private startListeningForRecording() {
    2.   let audioParam: speechRecognizer.AudioInfo = { audioType: 'pcm', sampleRate: 16000, soundChannel: 1, sampleBit: 16 }// audioInfo参数配置请参考[AudioInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section85771521101910)
    3.   let extraParam: Record<string, Object> = {
    4.     "recognitionMode": 0,
    5.     "vadBegin": 2000,
    6.     "vadEnd": 3000,
    7.     "maxAudioDuration": 20000
    8.   }
    9.   let recognizerParams: speechRecognizer.StartParams = {
    10.     sessionId: this.sessionId,
    11.     audioInfo: audioParam,
    12.     extraParams: extraParam
    13.   }
    14.   console.info('startListening start');
    15.   asrEngine.startListening(recognizerParams);
    16. };
    
5. 传入音频流，调用[writeAudio](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section72131731149)方法，开始写入音频流。读取音频文件时，开发者需预先准备一个pcm格式音频文件。
    
    1. let uint8Array: Uint8Array = new Uint8Array();
    2. // 可以通过如下方式获取音频流：1、通过录音获取音频流；2、从音频文件中读取音频流
    3. // 两种方式示例均已实现:[demo参考](https://developer.huawei.com/consumer/cn/doc/#section56481271497)
    4. // 写入音频流，音频流长度仅支持640或1280
    5. asrEngine.writeAudio(sessionId, uint8Array);
    
    注意
    
    6. 如需通过录音获取音频流，请打开麦克风权限，参考[步骤10](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/speechrecognizer-guide#li1723555443715)配置相关权限。
    
    7. 如需从音频文件中读取音频流，请在项目中的main\resources\resfile路径下存放pcm文件。
    
6. （可选）当需要查询语音识别服务支持的语种信息，可调用[listLanguages](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section813761871119)方法。
    
    listLanguages方法提供了两种调用形式，当前以其中一种作为示例，其他方式可参考[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer)。
    
    1. // 设置查询相关的参数
    2. let languageQuery: speechRecognizer.LanguageQuery = {
    3.   sessionId: sessionId
    4. };
    5. // 调用listLanguages方法
    6. asrEngine.listLanguages(languageQuery).then((res: Array<string>) => {
    7.   console.info(`Succeeded in listing languages.`);
    8. }).catch((err: BusinessError) => {
    9.   console.error(`Failed to list languages. Code: ${err.code}, message: ${err.message}.`);
    10. });
    
7. （可选）当需要结束识别时，可调用[finish](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section14433919171116)方法。
    
    1. // 结束识别
    2. asrEngine.finish(sessionId);
    
8. （可选）当需要取消识别时，可调用[cancel](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section3235541759)方法。
    
    1. // 取消识别
    2. asrEngine.cancel(sessionId);
    
9. （可选）当需要释放语音识别引擎资源时，可调用[shutdown](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section444415855615)方法。
    
    1. // 释放识别引擎资源
    2. asrEngine.shutdown();
    
10. 需要在[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中添加ohos.permission.MICROPHONE权限，确保麦克风使用正常。详细步骤可查看[声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions)章节。
    
    1. // ...
    2. "requestPermissions": [
    3.   {
    4.     "name" : "ohos.permission.MICROPHONE",
    5.     "reason": "$string:reason",
    6.     "usedScene": {
    7.       "abilities": [
    8.         "EntryAbility"
    9.       ],
    10.       "when":"inuse"
    11.     }
    12.   }
    13. ],
    14. // ...
    

## 开发实例

点击按钮，将一段音频信息转换为文本。

### Index.ets

1. import { speechRecognizer } from '@kit.CoreSpeechKit';
2. import { BusinessError } from '@kit.BasicServicesKit';
3. import { fileIo } from '@kit.CoreFileKit';
4. import { PromptAction } from '@kit.ArkUI';
5. import FileCapturer from './FileCapturer';

6. const TAG = 'AsrDemo';

7. let asrEngine: speechRecognizer.SpeechRecognitionEngine;

8. @Entry
9. @Component
10. struct Index {
11.   @State createCount: number = 0;
12.   @State result: boolean = false;
13.   @State voiceInfo: string = "";
14.   @State sessionId: string = "123456";
15.   @State sessionId2: string = "1234567";
16.   @State generatedText: string = "Default Text";
17.   @State uiContext: UIContext = this.getUIContext()
18.   @State promptAction: PromptAction = this.uiContext.getPromptAction();

19.   private mFileCapturer: FileCapturer = new FileCapturer();

20.   build() {
21.     Column() {
22.       Scroll() {
23.         Column() {
24.           Row() {
25.             Column() {
26.               Text(this.generatedText)
27.                 .fontColor($r('sys.color.ohos_id_color_text_secondary'))
28.             }
29.             .width('100%')
30.             .constraintSize({ minHeight: 100 })
31.             .border({ width: 1, radius: 5 })
32.             .backgroundColor('#d3d3d3')
33.             .padding(20)
34.             .alignItems(HorizontalAlign.Start)
35.           }
36.           .width('100%')
37.           .padding({ left: 20, right: 20, top: 20, bottom: 20 })

38.           Button() {
39.             Text("CreateEngineByCallback")
40.               .fontColor(Color.White)
41.               .fontSize(20)
42.           }
43.           .type(ButtonType.Capsule)
44.           .backgroundColor("#0x317AE7")
45.           .width("80%")
46.           .height(50)
47.           .margin(10)
48.           .onClick(async () => {
49.             this.createByCallback();
50.             this.createCount++;
51.             console.info(TAG, `CreateAsrEngine：createCount:${this.createCount}`);
52.             await this.sleep(500);
53.             this.setListener();
54.             this.promptAction.showToast({
55.               message: 'CreateEngine succeeded!',
56.               duration: 2000
57.             });
58.           })

59.           Button() {
60.             Text("startRecording")
61.               .fontColor(Color.White)
62.               .fontSize(20)
63.           }
64.           .type(ButtonType.Capsule)
65.           .backgroundColor("#0x317AE7")
66.           .width("80%")
67.           .height(50)
68.           .margin(10)
69.           .onClick(() => {
70.             this.startRecording();
71.             this.promptAction.showToast({
72.               message: 'start Recording',
73.               duration: 2000
74.             });
75.           })

76.           Button() {
77.             Text("audioToText")
78.               .fontColor(Color.White)
79.               .fontSize(20)
80.           }
81.           .type(ButtonType.Capsule)
82.           .backgroundColor("#0x317AE7")
83.           .width("80%")
84.           .height(50)
85.           .margin(10)
86.           .onClick(() => {
87.             this.audioToText();
88.             this.promptAction.showToast({
89.               message: 'start audioToText',
90.               duration: 2000
91.             });
92.           })

93.           Button() {
94.             Text("queryLanguagesCallback")
95.               .fontColor(Color.White)
96.               .fontSize(20)
97.           }
98.           .type(ButtonType.Capsule)
99.           .backgroundColor("#0x317AE7")
100.           .width("80%")
101.           .height(50)
102.           .margin(10)
103.           .onClick(() => {
104.             try{
105.               this.queryLanguagesCallback();
106.               this.promptAction.showToast({
107.                 message: 'queryLanguages succeeded!',
108.                 duration: 2000
109.               });
110.             } catch (err) {
111.               this.generatedText = `Failed to query language information. message: ${err.message}.`
112.               this.promptAction.showToast({
113.                 message: 'queryLanguages failed!',
114.                 duration: 2000
115.               });
116.             }
117.           })

118.           Button() {
119.             Text("shutdown")
120.               .fontColor(Color.White)
121.               .fontSize(20)
122.           }
123.           .type(ButtonType.Capsule)
124.           .backgroundColor("#0x317AA7")
125.           .width("80%")
126.           .height(50)
127.           .margin(10)
128.           .onClick(() => {
129.             // 释放引擎
130.             try{
131.               asrEngine.shutdown();
132.               this.generatedText = `The engine has been released.`
133.               this.promptAction.showToast({
134.                 message: 'shutdown succeeded!',
135.                 duration: 2000
136.               });
137.             } catch (err) {
138.               this.generatedText = `Failed to release engine. message: ${err.message}.`
139.               this.promptAction.showToast({
140.                 message: 'shutdown failed!',
141.                 duration: 2000
142.               });
143.             }
144.           })
145.         }
146.         .layoutWeight(1)
147.       }
148.       .width('100%')
149.       .height('100%')

150.     }
151.   }

152.   // 创建引擎，通过callback形式返回
153.   private createByCallback() {
154.     // 设置创建引擎参数
155.     let extraParam: Record<string, Object> = {"locate": "CN", "recognizerMode": "short"};
156.     let initParamsInfo: speechRecognizer.CreateEngineParams = {
157.       language: 'zh-CN',
158.       online: 1,
159.       extraParams: extraParam
160.     };

161.     // 调用createEngine方法
162.     speechRecognizer.createEngine(initParamsInfo, (err: BusinessError, speechRecognitionEngine:
163.       speechRecognizer.SpeechRecognitionEngine) => {
164.       if (!err) {
165.         console.info(TAG, 'succeeded in creating engine.');
166.         // 接收创建引擎的实例
167.         asrEngine = speechRecognitionEngine;
168.       } else {
169.         // 无法创建引擎时返回错误码1002200001，原因：语种不支持、模式不支持、初始化超时、资源不存在等导致创建引擎失败
170.         // 无法创建引擎时返回错误码1002200006，原因：引擎正在忙碌中，一般多个应用同时调用语音识别引擎时触发
171.         // 无法创建引擎时返回错误码1002200008，原因：引擎已被销毁
172.         console.error(TAG, `Failed to create engine. Message: ${err.message}.`);
173.       }
174.     });
175.   }

176.   // 查询语种信息，以callback形式返回
177.   private queryLanguagesCallback() {
178.     // 设置查询相关参数
179.     let languageQuery: speechRecognizer.LanguageQuery = {
180.       sessionId: this.sessionId
181.     };
182.     // 调用listLanguages方法
183.     asrEngine.listLanguages(languageQuery, (err: BusinessError, languages: Array<string>) => {
184.       if (!err) {
185.         // 接收目前支持的语种信息
186.         console.info(TAG, `succeeded in listing languages, result: ${JSON.stringify(languages)}`);
187.         this.generatedText = `languages result: ${JSON.stringify(languages)}`
188.       } else {
189.         console.error(TAG, `Failed to create engine. Message: ${err.message}.`);
190.         this.generatedText = `Failed to create engine. Message: ${err.message}.`
191.       }
192.     });
193.   };

194.   private startListeningForRecording() {
195.     let audioParam: speechRecognizer.AudioInfo = { audioType: 'pcm', sampleRate: 16000, soundChannel: 1, sampleBit: 16 } // audioInfo参数配置请参考[AudioInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/hms-ai-speechrecognizer#section85771521101910)
196.     let extraParam: Record<string, Object> = {
197.       "recognitionMode": 0,
198.       "vadBegin": 2000,
199.       "vadEnd": 3000,
200.       "maxAudioDuration": 20000
201.     }
202.     let recognizerParams: speechRecognizer.StartParams = {
203.       sessionId: this.sessionId,
204.       audioInfo: audioParam,
205.       extraParams: extraParam
206.     }
207.     console.info(TAG, 'startListening start');
208.     asrEngine.startListening(recognizerParams);
209.   };

210.   // 写音频流
211.   private async audioToText() {
212.     try {
213.       this.setListener();
214.       // Set the parameters related to the start of identification.
215.       let audioParam: speechRecognizer.AudioInfo = { audioType: 'pcm', sampleRate: 16000, soundChannel: 1, sampleBit: 16 }
216.       let recognizerParams: speechRecognizer.StartParams = {
217.         sessionId: this.sessionId2,
218.         audioInfo: audioParam
219.       }
220.       // Invoke the start recognition method.
221.       asrEngine.startListening(recognizerParams);

222.       // Get Audio from File
223.       let data: ArrayBuffer;
224.       let ctx = this.getUIContext().getHostContext() as Context;
225.       let filenames: string[] = fileIo.listFileSync(ctx.resourceDir);
226.       if (filenames.length <= 0) {
227.         console.error('length is null');
228.         return;
229.       }
230.       let filePath: string = ctx.resourceDir + '/' + filenames[0];
231.       (this.mFileCapturer as FileCapturer).setFilePath(filePath);
232.       this.mFileCapturer.init((dataBuffer: ArrayBuffer) => {
233.         data = dataBuffer
234.         let uint8Array: Uint8Array = new Uint8Array(data);
235.         asrEngine.writeAudio(this.sessionId2, uint8Array);
236.       });
237.       await this.mFileCapturer.start();
238.       asrEngine?.finish(this.sessionId);
239.       this.mFileCapturer.release();
240.     } catch (err) {
241.       this.generatedText = `Message: ${err.message}.`
242.     }
243.   }

244.   // 麦克风语音转文本
245.   private async startRecording() {
246.     try {
247.       this.startListeningForRecording();
248.     } catch (err) {
249.       this.generatedText = `Message: ${err.message}.`;
250.     }
251.   };

252.   // 睡眠
253.   private sleep(ms: number):Promise<void> {
254.     return new Promise(resolve => setTimeout(resolve, ms));
255.   }

256.   // 设置回调
257.   private setListener() {
258.     // 创建回调对象
259.     let setListener: speechRecognizer.RecognitionListener = {
260.       // 开始识别成功回调
261.       onStart: (sessionId: string, eventMessage: string) => {
262.         this.generatedText = '';
263.         console.info(TAG, `onStart, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
264.       },
265.       // 事件回调
266.       onEvent(sessionId: string, eventCode: number, eventMessage: string) {
267.         console.info(TAG, `onEvent, sessionId: ${sessionId} eventCode: ${eventCode} eventMessage: ${eventMessage}`);
268.       },
269.       // 识别结果回调，包括中间结果和最终结果
270.       onResult: (sessionId: string, result: speechRecognizer.SpeechRecognitionResult) => {
271.         console.info(TAG, `onResult, sessionId: ${sessionId} result: ${JSON.stringify(result)}`);
272.         this.generatedText = result.result;
273.       },
274.       // 识别完成回调
275.       onComplete(sessionId: string, eventMessage: string) {
276.         console.info(TAG, `onComplete, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
277.       },
278.       // 错误回调，错误码通过本方法返回
279.       // 返回错误码1002200002，开始识别失败，重复启动startListening方法时触发
280.       // 更多错误码请参考[错误码参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/errorcode-corespeech)
281.       onError(sessionId: string, errorCode: number, errorMessage: string) {
282.         console.error(TAG, `onError, sessionId: ${sessionId} errorCode: ${errorCode} errorMessage: ${errorMessage}`);
283.       },
284.     }
285.     // 设置回调
286.     asrEngine.setListener(setListener);
287.   };
288. }

### FileCapturer.ets

添加FileCapturer.ets文件用于pcm文件音频流。

1. import { fileIo } from '@kit.CoreFileKit';

2. const TAG = 'FileCapturer';
3. const SEND_SIZE: number = 1280;

4. /**
5.  * File collector tool
6.  */
7. export default class FileCapturer {
8.   /**
9.    * Whether the audio is being written
10.    */
11.   private mIsWriting: boolean = false;

12.   /**
13.    * File Path
14.    */
15.   private mFilePath: string = '';

16.   /**
17.    * Open File Object
18.    */
19.   private mFile: fileIo.File | null = null;

20.   /**
21.    * Indicates whether the file can be read.
22.    */
23.   private mIsReadFile: boolean = true;

24.   /**
25.    * Audio Data Callback Method
26.    */
27.   private mDataCallBack: ((data: ArrayBuffer) => void ) | null = null;

28.   /**
29.    * Setting the File Path
30.    * @param filePath
31.    */
32.   public setFilePath(filePath: string) {
33.     this.mFilePath = filePath;
34.   }

35.   async init(dataCallBack: (data: ArrayBuffer) => void): Promise<void> {
36.     if (null != this.mDataCallBack) {
37.       return;
38.     }
39.     this.mDataCallBack = dataCallBack;
40.     if (!fileIo.accessSync(this.mFilePath)) {
41.       return
42.     }
43.     console.error(TAG, "init start ");
44.   }

45.   async start(): Promise<void> {
46.     try {
47.       if (this.mIsWriting || null == this.mDataCallBack) {
48.         return;
49.       }
50.       this.mIsWriting = true;
51.       this.mIsReadFile = true;
52.       this.mFile = fileIo.openSync(this.mFilePath, fileIo.OpenMode.READ_ONLY);
53.       let buf: ArrayBuffer = new ArrayBuffer(SEND_SIZE);
54.       let offset: number = 0;
55.       let count = 0;
56.       while (SEND_SIZE == fileIo.readSync(this.mFile.fd, buf, {
57.         offset: offset
58.       }) && this.mIsReadFile) {
59.         this.mDataCallBack(buf);
60.         ++count;
61.         await sleep(40);
62.         offset = offset + SEND_SIZE;
63.       }
64.     } catch (e) {
65.       console.error(TAG, "read file error " + e);
66.     } finally {
67.       if (null != this.mFile) {
68.         fileIo.closeSync(this.mFile);
69.       }
70.       this.mIsWriting = false;
71.     }
72.   }

73.   stop() {
74.     if (null == this.mDataCallBack) {
75.       return;
76.     }
77.     try {
78.       this.mIsReadFile = false;
79.     } catch (e) {
80.       console.error(TAG, "read file error " + e);
81.     }
82.   }

83.   release() {
84.     if (null == this.mDataCallBack) {
85.       return;
86.     }
87.     try {
88.       this.mDataCallBack = null;
89.       this.mIsReadFile = false;
90.     } catch (e) {
91.       console.error(TAG, "read file error " + e);
92.     }
93.   }
94. }

95. function sleep(ms: number): Promise<void> {
96.   return new Promise<void>(resolve => setTimeout(resolve, ms));
97. }

### EntryAbility.ets

在EntryAbility.ets文件中添加麦克风权限。

1. import { abilityAccessCtrl, AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
2. import { hilog } from '@kit.PerformanceAnalysisKit';
3. import { window } from '@kit.ArkUI';
4. import { BusinessError } from '@kit.BasicServicesKit';

5. export default class EntryAbility extends UIAbility {
6.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
7.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
8.   }

9.   onDestroy(): void {
10.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
11.   }

12.   onWindowStageCreate(windowStage: window.WindowStage): void {
13.     // Main window is created, set main page for this ability
14.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

15.     let atManager = abilityAccessCtrl.createAtManager();
16.     atManager.requestPermissionsFromUser(this.context, ['ohos.permission.MICROPHONE']).then((data) => {
17.       hilog.info(0x0000, 'testTag', 'data:' + JSON.stringify(data));
18.       hilog.info(0x0000, 'testTag', 'data permissions:' + data.permissions);
19.       hilog.info(0x0000, 'testTag', 'data authResults:' + data.authResults);
20.     }).catch((err: BusinessError) => {
21.       hilog.error(0x0000, 'testTag', 'errCode: ' + err.code + 'errMessage: ' + err.message);
22.     });

23.     windowStage.loadContent('pages/Index', (err, data) => {
24.       if (err.code) {
25.         hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
26.         return;
27.       }
28.       hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
29.     });
30.   }

31.   onWindowStageDestroy(): void {
32.     // Main window is destroyed, release UI related resources
33.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
34.   }

35.   onForeground(): void {
36.     // Ability has brought to foreground
37.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
38.   }

39.   onBackground(): void {
40.     // Ability has back to background
41.     hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
42.   }
43. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/texttospeech-guide "文本转语音")

该错误是由于`build-profile.json5`配置文件中存在不合法的字段名称导致的Schema校验失败。以下是具体分析和解决方案：

**错误原因分析**
1. **字段名非法**：错误日志显示`app`节点下存在未在允许值列表中的字段（allowedValues列举了合法字段：signingConfigs/products/buildModeSet/multiProjects/capabilities）
2. **属性命名错误**：报错位置`build-profile.json5:3:11`可能存在非法属性名`buildOption`，该字段未被Schema允许

### 解决方案
**步骤1：检查配置文件**
打开`Application/build-profile.json5`文件，检查第三行附近的配置结构。正确的应用级配置应遵循以下格式：
```json5
app {
  signingConfigs {...}  // 签名配置
  products {...}       // 产品配置
  buildModeSet {...}   // 构建模式
  multiProjects {...}  // 多工程配置
  capabilities {...}   // 能力配置
}
```

**步骤2：修正非法字段**
重点排查以下两种典型错误：
1. **字段拼写错误**：如将`buildModeSet`误写为`buildOptionSet`
2. **非法字段插入**：删除或替换`buildOption`等未在允许列表中的字段

#### 步骤3：验证Hvigor版本
根据搜索结果中Hvigor 4.3.0+的配置要求，执行以下命令确认版本兼容性：
```bash
hvigorw -v
```
建议使用DevEco Studio自带的Hvigor工具链（路径：`DevEco Studio/tools/hvigor`）

**补充建议**
- 执行构建命令时添加`--debug`参数获取详细日志：
```bash
hvigorw assembleHap --debug
```
- 确认Node.js版本不低于v18.0.0（使用`node -v`验证）
- 检查环境变量配置是否正确，特别关注`HDC_HOME`和`PATH`设置

该错误属于典型的配置文件Schema校验失败问题，通过规范字段名称即可解决。若问题仍然存在，建议清理构建缓存后重新编译。
# Speech Kit简介

更新时间: 2025-12-16 16:27

Speech Kit（场景化语音服务）集成了语音类AI能力，包括朗读控件（TextReader）和AI字幕控件（AICaptionComponent）能力，便于用户与设备进行互动，为用户实现朗读文章。

## 场景介绍

- 朗读控件应用广泛，例如在用户不方便或者无法查看屏幕文字时，为用户朗读新闻，提供资讯。
- AI字幕控件应用广泛，例如在用户不熟悉音频源语言或者静音时，为用户提供字幕服务。

## 约束与限制

- 设备限制
    
    本Kit仅适用于Phone、Tablet、和2in1设备，暂不支持模拟器。
    
- 地区限制
    
    本Kit仅支持中国境内（不包含中国香港、中国澳门、中国台湾）提供服务。
    
- 能力限制

|AI能力|约束|
|:--|:--|
|朗读控件|支持的语种类型：中文。|
|AI字幕控件|支持的语种类型：中英文。<br><br>支持的音频流：<br><br>- 音频类型：当前仅支持 "pcm"编码。<br>- 音频采样率：当前仅支持16000采样率。<br>- 音频声道：当前仅支持1个通道。<br>- 音频采样位深：当前仅支持16位。<br><br>部分机型暂不支持，调用失败返回对应错误码[初始化失败](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-errorcode#section1989336165612)。|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/speech-kit-guide "Speech Kit（场景化语音服务）")
# 朗读控件

更新时间: 2025-12-16 16:27

## 适用场景

朗读控件应用广泛，例如在用户不方便或者无法查看屏幕文字的时候，为用户朗读新闻，提供资讯。

本章节将向您介绍如何使用朗读组件，效果如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216162747.95345178436513255428745818609401:50001231000000:2800:B4991AD0819FEF11249E9E8A8F447F7CCB618DBC6ED0DC919BD14822584AF184.png)

## 接口说明

以下仅列出demo中调用的部分主要接口，具体API说明详见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api)。

|接口名|描述|
|:--|:--|
|[init](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api#section173751154134515)(context: [common.BaseContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-basecontext), readParams: [ReaderParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api#section6129163245310)): Promise<void>|初始化TextReader。|
|[start](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api#section143611912403)(readInfoList: [ReadInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api#section129918404172)[], articleId?: string): Promise<void>|启动TextReader。|
|on(type: string, callback: function): void|注册所有事件回调，具体事件类型详见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api)。|
|[ReaderParam](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api#section6129163245310)(isVoiceBrandVisible: boolean, businessBrandInfo?: [BusinessBrandInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-textreader-api#section472059101210), isFastForward?: boolean, keepBackgroundRunning?: boolean, online?: number)|朗读参数。|

## 开发步骤

1. 首先从项目根目录进入/src/main/ets/entryability/EntryAbility.ets文件，将WindowManager添加至工程。
    
    1. import { WindowManager } from '@kit.SpeechKit';
    2. import { ConfigurationConstant } from '@kit.AbilityKit';
    
2. （可选）在onWindowStageCreate(windowStage: window.WindowStage)生命周期方法中，添加setWindowStage方法设置窗口管理器。
    
    1. onWindowStageCreate(windowStage: window.WindowStage): void {
    2.   console.info('Ability onWindowStageCreate');
    3.   WindowManager.setWindowStage(windowStage);
    
    4.   windowStage.loadContent('pages/Index', (err, data) => {
    5.     if (err) {
    6.       console.error(`Failed to load the content. Code: ${err.code}, message: ${err.message}`);
    7.       return;
    8.     }
    9.     console.info(`Succeeded in loading the content. Data: ${JSON.stringify(data)}.` );
    10.   });
    11. }
    
3. 在onCreate()生命周期方法中，设置应用的颜色模式，使控件颜色模式跟应用的颜色模式保持一致。
    
    - 如果应用想要跟随系统切换深浅色模式，请将颜色模式设置为COLOR_MODE_NOT_SET。
    - 如果应用想要主动配置颜色模式，请将颜色模式设置为COLOR_MODE_LIGHT（浅色）或者COLOR_MODE_DARK（深色）。
    
    下面以自动跟随系统切换为例。
    
    1. onCreate(): void {
    2.   this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);
    3. }
    
4. 从项目根目录进入/src/main/ets/pages/Index.ets文件，在使用朗读控件前，将实现朗读控件和其他相关的类添加至工程。
    
    1. import { TextReader, TextReaderIcon, ReadStateCode } from '@kit.SpeechKit';
    
5. 简单配置页面的布局，加入听筒图标，并且设置onClick点击事件。
    
    1. /**
    2.  * 播放状态
    3.  */
    4. @State readState: ReadStateCode = ReadStateCode.WAITING;
    
    5. build() {
    6.     Column() {
    7.       TextReaderIcon({ readState: this.readState })
    8.         .margin({ right: 20 })
    9.         .width(32)
    10.         .height(32)
    11.         .onClick(async () => {
    12.             // 设置点击事件
    13.             // ...
    14.         })
    15.     }
    16. }
    
6. 初始化朗读控件。
    
    1. // 用于显示当前页的按钮状态
    2. @State isInit: boolean = false;
    3. /**
    4. * 待加载的文章
    5. */
    6. @State readInfoList: TextReader.ReadInfo[] = [];
    7. @State selectedReadInfo: TextReader.ReadInfo = this.readInfoList[0];
    
    8. async aboutToAppear() {
    9.   // ...
    10.   this.init();
    11.   /**
    12.    * 加载数据
    13.    */
    14.   let readInfoList: TextReader.ReadInfo[] = [{
    15.     id: '001',
    16.     title: {
    17.       text:'水调歌头.明月几时有',
    18.       isClickable:true
    19.     },
    20.     author:{
    21.       text:'宋.苏轼',
    22.       isClickable:true
    23.     },
    24.     date: {
    25.       text:'2024/01/01',
    26.       isClickable:false
    27.     },
    28.     bodyInfo: '明月几时有？把酒问青天。'
    29.   }];
    30.   this.readInfoList = readInfoList;
    31.   this.selectedReadInfo = this.readInfoList[0];
    32.   // ...
    33. }
    
    34. /**
    35.  * 初始化
    36.  */
    37. async init() {
    38.   const readerParam: TextReader.ReaderParam = {
    39.     isVoiceBrandVisible: true,
    40.     businessBrandInfo: {
    41.       panelName: '小艺朗读',
    42.       panelIcon: $r('app.media.startIcon')
    43.     }
    44.   }
    45.   try {
    46.     let context: Context | undefined = this.getUIContext().getHostContext()
    47.     if (context) {
    48.       await TextReader.init(context, readerParam);
    49.       this.isInit = true;
    50.       this.setActionListener();
    51.     }
    52.   } catch (err) {
    53.     console.error(`TextReader failed to init. Code: ${err.code}, message: ${err.message}`);
    54.   }
    55. }
    
    56. onStateChanged = (state: TextReader.ReadState) => {
    57.   if (this.selectedReadInfo?.id === state.id) {
    58.     this.readState = state.state;
    59.   } else {
    60.     this.readState = ReadStateCode.WAITING;
    61.   }
    62. }
    
    63. // 设置操作监听
    64. setActionListener() {
    65.   TextReader.on('stateChange', (state: TextReader.ReadState) => {
    66.     this.onStateChanged(state);
    67.   });
    68.   // 在列表页无更多内容时，会显示加载失败，需要设置requestMore监听，调用loadMore函数以获得正确的显示信息。
    69.   TextReader.on('requestMore', () => {
    70.     TextReader.loadMore([], true);
    71.   })
    72. }
    
    73. // 注销监听，根据业务情况在合适的时机调用
    74. releaseActionListener() {
    75.   TextReader.off('stateChange');
    76.   TextReader.off('requestMore');
    77. }
    
7. （可选）在setActionListener方法中设置更多监听，在用户与控件进行交互时触发回调通知开发者。注销监听，监听结束后进行释放。
    
    1. // 设置监听
    2. setActionListener() {
    3.   TextReader.on('setArticle', async (id: string) => { console.info(`setArticle ${id}`) });
    4.   TextReader.on('clickArticle', (id: string) => {console.info(`onClickArticle ${id}`) });
    5.   TextReader.on('clickAuthor', (id: string) => { console.info(`onClickAuthor ${id}`) });
    6.   TextReader.on('clickNotification',  (id: string) => { console.info(`onClickNotification ${id}`) });
    7.   TextReader.on('showPanel', () => { console.info(`onShowPanel`) });
    8.   TextReader.on('hidePanel', () => { console.info(`onHidePanel`) });
    9.   // ...
    10. }
    11. // 注销监听
    12. releaseActionListener() {
    13.   TextReader.off('setArticle');
    14.   TextReader.off('clickArticle');
    15.   TextReader.off('clickAuthor');
    16.   TextReader.off('clickNotification');
    17.   TextReader.off('showPanel');
    18.   TextReader.off('hidePanel');
    19.   // ...
    20. }
    
8. 启动朗读控件。
    
    1. build() {
    2.   Column() {
    3.     TextReaderIcon({ readState: this.readState })
    4.       // ...
    5.       .onClick(async () => {
    6.         try {
    7.           await TextReader.start(this.readInfoList, this.selectedReadInfo?.id);
    8.         } catch (err) {
    9.           console.error(`TextReader failed to start. Code: ${err.code}, message: ${err.message}`);
    10.         }
    11.       })
    12.   }
    13. }
    
9. （可选）若要配置长时任务，需要在[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中添加ohos.permission.KEEP_BACKGROUND_RUNNING权限，并且加入backgroundModes选项，然后在readerParam中将keepBackgroundRunning配置为true，确保朗读控件后台播报正常。
    
    1. // module.json5
    2. {
    3.   "module": {
    4.     // ...
    5.     "requestPermissions": [
    6.       {
    7.         "name": "ohos.permission.KEEP_BACKGROUND_RUNNING",
    8.         "usedScene": {
    9.           "abilities": [
    10.             "FormAbility"
    11.           ],
    12.           "when": "inuse"
    13.         }
    14.       },
    15.     ],
    16.     "abilities": [
    17.       {
    18.         // ...
    19.         "backgroundModes": [
    20.           "audioPlayback"
    21.         ],
    22.         // ...
    23.       }
    24.     ]
    25.   }
    26. }
    
    27. // Index.ets
    28. async init() {
    29.   const readerParam: TextReader.ReaderParam = {
    30.     // ...
    31.     keepBackgroundRunning: true
    32.   }
    33. }
    
10. （可选）若要在控件使用功能时切换音色，需要在[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)中添加ohos.permission.INTERNET和ohos.permission.GET_NETWORK_INFO权限，确保朗读控件可以正常切换音色。
    
    1. // module.json5
    2. {
    3.   "module": {
    4.     // ...
    5.     "requestPermissions": [
    6.       {
    7.         "name": "ohos.permission.INTERNET",
    8.         "reason": "$string:reason",
    9.         "usedScene": {"abilities": []}
    10.       },
    11.       {
    12.         "name": "ohos.permission.GET_NETWORK_INFO",
    13.         "reason": "$string:reason",
    14.         "usedScene": {"abilities": []}
    15.       },
    16.     ],
    17.   }
    18. }
    

## 开发实例

EntryAbility.ets

1. import { AbilityConstant, ConfigurationConstant, UIAbility, Want } from '@kit.AbilityKit';
2. import { window } from '@kit.ArkUI';
3. import { WindowManager } from '@kit.SpeechKit';

4. export default class EntryAbility extends UIAbility {
5.   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
6.     this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);
7.     console.info('Ability onCreate');
8.   }

9.   onDestroy(): void {
10.     console.info('Ability onDestroy');
11.   }

12.   onWindowStageCreate(windowStage: window.WindowStage): void {
13.     console.info('Ability onWindowStageCreate');
14.     WindowManager.setWindowStage(windowStage);

15.     windowStage.loadContent('pages/Index', (err, data) => {
16.       if (err.code) {
17.         console.error(`Failed to load the content. Code: ${err.code}, message: ${err.message}`);
18.         return;
19.       }
20.       console.info(`Succeeded in loading the content. Data: ${JSON.stringify(data)}.` );
21.     });
22.   }

23.   onWindowStageDestroy(): void {
24.     console.info('Ability onWindowStageDestroy');
25.   }

26.   onForeground(): void {
27.     console.info('Ability onForeground');
28.   }

29.   onBackground(): void {
30.     console.info('Ability onBackground');
31.   }
32. }

Index.ets

1. import { TextReader, TextReaderIcon, ReadStateCode } from '@kit.SpeechKit';

2. @Entry
3. @Component
4. struct Index {

5.   /**
6.    * 待加载的文章
7.    */
8.   @State readInfoList: TextReader.ReadInfo[] = [];
9.   @State selectedReadInfo: TextReader.ReadInfo = this.readInfoList[0];

10.   /**
11.    * 播放状态
12.    */
13.   @State readState: ReadStateCode = ReadStateCode.WAITING;

14.   /**
15.    * 用于显示当前页的按钮状态
16.    */
17.   @State isInit: boolean = false;

18.   async aboutToAppear(){
19.     /**
20.      * 加载数据
21.      */
22.     let readInfoList: TextReader.ReadInfo[] = [{
23.       id: '001',
24.       title: {
25.         text:'水调歌头.明月几时有',
26.         isClickable:true
27.       },
28.       author:{
29.         text:'宋.苏轼',
30.         isClickable:true
31.       },
32.       date: {
33.         text:'2024/01/01',
34.         isClickable:false
35.       },
36.       bodyInfo: '明月几时有？把酒问青天。'
37.     }];
38.     this.readInfoList = readInfoList;
39.     this.selectedReadInfo = this.readInfoList[0];
40.     this.init();
41.   }

42.   /**
43.    * 初始化
44.    */
45.   async init() {
46.     const readerParam: TextReader.ReaderParam = {
47.       isVoiceBrandVisible: true,
48.       businessBrandInfo: {
49.         panelName: '小艺朗读',
50.         panelIcon: $r('app.media.startIcon')
51.       }
52.     }
53.     try {
54.       let context: Context | undefined = this.getUIContext().getHostContext()
55.       if (context) {
56.         await TextReader.init(context, readerParam);
57.         this.isInit = true;
58.         this.setActionListener();
59.       }
60.     } catch (err) {
61.       console.error(`TextReader failed to init. Code: ${err.code}, message: ${err.message}`);
62.     }
63.   }

64.   // 设置操作监听
65.   setActionListener() {
66.     TextReader.on('stateChange', (state: TextReader.ReadState) => {
67.       this.onStateChanged(state);
68.     });

69.     TextReader.on('requestMore', () => {
70.       TextReader.loadMore([], true);
71.     })
72.   }

73.   onStateChanged = (state: TextReader.ReadState) => {
74.     if (this.selectedReadInfo?.id === state.id) {
75.       this.readState = state.state;
76.     } else {
77.       this.readState = ReadStateCode.WAITING;
78.     }
79.   }

80.   build() {
81.     Column() {
82.       TextReaderIcon({ readState: this.readState })
83.         .margin({ right: 20 })
84.         .width(32)
85.         .height(32)
86.         .onClick(async () => {
87.           try {
88.             await TextReader.start(this.readInfoList, this.selectedReadInfo?.id);
89.           } catch (err) {
90.             console.error(`TextReader failed to start. Code: ${err.code}, message: ${err.message}`);
91.           }
92.         })
93.     }
94.     .height('100%')
95.   }
96. }

## 2in1适配步骤

2in1设备除了适配[开发步骤](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/speech-textreader-guide#section1418318341804)，还需执行以下步骤。如果开发者按照上述开发步骤来适配2in1，将会出现无法拉起播放面板的情况。

1. 在/src/main/ets/entryability下新建一个ability，用来承载2in1主窗，导入相关依赖。
    
    1. import { TextReader, WindowManager } from '@kit.SpeechKit';
    2. import { commonEventManager } from '@kit.BasicServicesKit';
    
2. 在新ability中声明一个应用全局的状态变量isReadyToStart，并且通过AppStorage管理此状态变量。
    
    1. private link: SubscribedAbstractProperty<boolean>= AppStorage.link('isReadyToStart');
    
3. 在Index.ets的aboutToAppear生命周期方法中，创建全局的状态变量isReadyToStart。
    
    1. aboutToAppear() {
    2.   AppStorage.setOrCreate('isReadyToStart', false);
    3.   // ...其他配置
    4. }
    
4. 配置WindowStage。说明：从6.0.0(20)开始使用以下逻辑实现。对于5.1.1(19)及之前版本，使用getContext(this)接口实现。
    
    - 在新ability的onWindowStageCreate生命周期方法中，发送onLoadSubAbility事件。
    - 通过WindowManager.setWindowStage(windowStage)来设置新ability的windowStage。
    - 在onWindowStageCreate中将isReadyToStart设为true。
    
    1. onWindowStageCreate(windowStage: window.WindowStage): void {
    2.   // Main window is created, set main page for this ability
    3.   WindowManager.setWindowStage(windowStage)
    4.   let eventData: emitter.EventData = {
    5.     data: {
    6.       'state': 'publish'
    7.     }
    8.   }
    9.   emitter.emit("onLoadSubAbility", eventData);
    10.   this.link.set(true);
    11. }
    
5. 在新ability的onWindowStageDestroy生命周期方法中，将isReadyToStart设为false，同时隐藏面板并停止播放。
    
    1. async onWindowStageDestroy(): Promise<void> {
    2.   try {
    3.     TextReader.hidePanel();
    4.     await TextReader.stop();
    5.     this.link.set(false);
    6.   }catch (e) {
    7.     console.error(`onWindowStageDestroy fail , msg: ${e}`)
    8.   }
    9. }
    
6. 在entryability中，onCreate方法需要用eventHub设置'onShowPanel'回调，用来创造新的ability；onShowPanel回调中，首先构造want，然后通过context.startAbility接口创建新的ability。
    
    1. import { AbilityConstant, Want } from '@kit.AbilityKit';
    2. import { common } from "@kit.AbilityKit";
    3. import { BusinessError } from "@kit.BasicServicesKit";
    
    4. onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    5.   // ...其他配置
    6.   let eventHub = this.context.eventHub;
    7.   eventHub.on('onShowPanel', this.onShowPanel);
    8. }
    
    9. onShowPanel = () => {
    10.   let context: common.UIAbilityContext = this.context;
    11.   let want: Want = {
    12.     deviceId: '',
    13.     bundleName: 'com.example.speechkit', // 需替换成实际应用包名
    14.     abilityName: 'SubAbility',
    15.     parameters: {
    16.       info: 'From EntryAbility onShowPanel'
    17.     }
    18.   }
    19.   context?.startAbility(want).then(() => {
    20.     console.info('Succeeded in starting ability');
    21.   }).catch((e: BusinessError) => {
    22.     console.error(`Failed to start ability. Code is ${e.code}, message is ${e.message}`);
    23.   })
    24. }
    
7. 在调用start之前根据设备类型进行判断，如果是2in1需要首先发送'onShowPanel'事件构造ability。
    
    1. import { deviceInfo } from '@kit.BasicServicesKit';
    
    2. if (deviceInfo.deviceType === '2in1') {
    3.   let context = this.getUIContext().getHostContext();
    4.   context?.eventHub.emit('onShowPanel');
    5. }
    6. TextReader.showPanel();
    
8. 在module.json5中添加ability配置项，max和min的值需要保持一致，固定窗口的大小。
    
    1. {
    2.   "name": "SubAbility", // UIAbility组件的名称
    3.   "srcEntry": "./ets/entryability/SubAbility.ets", // UIAbility组件的代码路径
    4.   "description": "$string:SubAbility_desc", // UIAbility组件的描述信息
    5.   "icon": "$media:icon", // UIAbility组件的图标
    6.   "label": "$string:EntryAbility_label", // UIAbility组件的标签
    7.   "startWindowIcon": "$media:icon", // UIAbility组件启动页面图标资源文件的索引
    8.   "startWindowBackground": "$color:start_window_background", // UIAbility组件启动页面背景颜色资源文件的索引
    9.   "supportWindowMode": ['floating'], // 窗口支持悬浮窗显示
    10.   "maxWindowWidth": 1158,  // 最大窗口宽度
    11.   "minWindowWidth": 1158,  // 最小窗口宽度
    12.   "maxWindowHeight": 772,  // 最大窗口高度
    13.   "minWindowHeight": 772,  // 最小窗口高度
    14.  }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/speech-production "Speech Kit简介")
# AI字幕控件

更新时间: 2025-12-16 16:27

## 适用场景

AI字幕控件应用广泛，例如在用户不熟悉音频源语言或者静音的时候，为用户提供字幕服务。

本章节将向您介绍如何使用AI字幕组件[AICaptionComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-aicaptioncomponent)和[AICaptionController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-aicaptioncomponent#section816451553012)展示AI字幕，效果如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216162748.13034644834190899635309030256756:50001231000000:2800:A330E23D0F5D004766412C02D1727C2606A29F245F5E20977F4AA305041BA07C.jpg "点击放大")

## 接口说明

AI字幕功能主要由[AICaptionComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-aicaptioncomponent)提供，更多接口及使用方法请参见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-aicaptioncomponent)。

|接口|描述|
|:--|:--|
|[AICaptionComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-aicaptioncomponent)|AI字幕组件。|
|[AICaptionOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-aicaptioncomponent#section15787428226)|AI字幕初始化参数。|
|[AICaptionController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/speech-aicaptioncomponent#section816451553012)|AI字幕组件的控制器，是AI字幕组件的主要功能入口类，用来操作AI字幕。它所承载的工作包括：写音频数据、获取音频流信息等。|

## 开发步骤

1. 从项目根目录进入/src/main/ets/pages/Index.ets文件，在使用AI字幕控件前，将实现AI字幕控件和其他相关的类添加至工程。
    
    1. import { AICaptionComponent, AICaptionController, AICaptionOptions } from '@kit.SpeechKit';
    
2. 简单配置页面的布局，加入AI字幕组件，并在aboutToAppear中设置AI字幕组件的传入参数。
    
    1. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    2. const TAG = 'AI_CAPTION_DEMO'
    
    3. class Logger {
    4.   static info(...msg: string[]) {
    5.     hilog.info(0x0000, TAG, msg.join())
    6.   }
    
    7.   static error(...msg: string[]) {
    8.     hilog.error(0x0000, TAG, msg.join())
    9.   }
    10. }
    
    11. @Entry
    12. @Component
    13. struct Index {
    14.   private captionOption ?: AICaptionOptions;
    15.   private controller = new AICaptionController();
    16.   @State isShown: boolean = false;
    
    17.   aboutToAppear(): void {
    18.     // AI字幕初始化参数，设置字幕的不透明度和回调函数
    19.     this.captionOption = {
    20.       initialOpacity: 1,
    21.       onPrepared: () => {
    22.         Logger.info('onPrepared')
    23.       },
    24.       onError: (error) => {
    25.         Logger.error(`onError, code: ${error.code}, msg: ${error.message}`)
    26.       }
    27.     }
    28.   }
    
    29.   build() {
    30.     Column({ space: 20 }) {
    31.       // 调用AICaptionComponent组件初始化字幕
    32.       AICaptionComponent({
    33.         isShown: this.isShown,
    34.         controller: this.controller,
    35.         options: this.captionOption
    36.       })
    37.         .width('100%')
    38.         .height(100)
    39.       Divider()
    40.       if (this.isShown) {
    41.         Text('上面是字幕区域')
    42.           .fontColor(Color.White)
    43.       }
    44.     }
    45.     .width('100%')
    46.     .height('100%')
    47.     .padding(10)
    48.     .backgroundColor('#7A7D6A')
    49.   }
    50. }
    
3. 在布局中加入两个按钮以及点击事件的回调函数。
    
    - 第一个按钮的回调函数负责控制AI字幕组件的显示状态。
    - 第二个按钮的回调函数负责读取资源目录中的音频文件，将音频数据传给AI字幕组件。
    
    1. import { AudioData } from '@kit.SpeechKit';
    
    2. @Entry
    3. @Component
    4. struct Index {
    
    5.   isReading: boolean = false;
    
    6.   async readPcmAudio() {
    7.     this.isReading = true;
    8.     let fileData: Uint8Array | undefined;
    9.     try {
    10.       fileData =
    11.         await this.getUIContext()?.getHostContext()?.resourceManager.getMediaContent($r('app.media.chineseAudio').id);
    12.     } catch (e) {
    13.       Logger.info(`get fileData fail , msg ${e} `)
    14.     }
    15.     if (fileData === undefined) {
    16.       return;
    17.     }
    18.     const bufferSize = 640;
    19.     const byteLength = fileData.byteLength;
    20.     let offset = 0;
    21.     Logger.info('byteLength', byteLength.toString())
    22.     let startTime = new Date().getTime();
    23.     while (offset < byteLength) {
    24.       // 模拟实际情况，读文件比录音机返回流快，所以要等待一段时间
    25.       let nextOffset = offset + bufferSize
    26.       if (offset > byteLength) {
    27.         this.isReading = false;
    28.         return
    29.       }
    30.       const arrayBuffer = fileData.buffer.slice(offset, nextOffset);
    31.       let data = new Uint8Array(arrayBuffer);
    32.       Logger.info('data byteLength', data.byteLength.toString())
    33.       const audioData: AudioData = {
    34.         data: data
    35.       }
    36.       Logger.info(`offset: ${offset} | byteLength: ${byteLength} | bufferSize: ${bufferSize}`)
    
    37.       if (this.controller) {
    38.         Logger.info(`writeAudio： ${audioData.data.byteLength}`)
    39.        try {
    40.           this.controller.writeAudio(audioData)
    41.         } catch (e) {
    42.           Logger.error(`writeAudio exception`)
    43.         }
    44.       }
    45.       offset = offset + bufferSize;
    46.       const waitTime = bufferSize / 32
    47.       await this.sleep(waitTime)
    48.     }
    49.     let endTime = new Date().getTime()
    50.     this.isReading = false;
    51.     Logger.info('playtime', JSON.stringify(endTime - startTime))
    52.   }
    
    53.   sleep(time: number): Promise<void> {
    54.     return new Promise(resolve => setTimeout(resolve, time))
    55.   }
    
    56.   build() {
    57.     Column({ space: 20 }) {
    58.      // ...
    59.       Button('切换字幕显示状态:' + (this.isShown ? '显示' : '隐藏'))
    60.         .backgroundColor('#B8BDA0')
    61.         .width(200)
    62.         .onClick(() => {
    63.           this.isShown = !this.isShown;
    64.         })
    65.       Button('读取PCM音频')
    66.         .backgroundColor('#B8BDA0')
    67.         .width(200)
    68.         .onClick(() => {
    69.           if (!this.isReading) {
    70.             this.readPcmAudio()
    71.           }
    72.         })
    73.      // ...
    74.     }
    75.   }
    76. }
    

## 开发实例

Index.ets

1. import { AICaptionComponent, AICaptionOptions, AICaptionController, AudioData } from '@kit.SpeechKit';
2. import { BusinessError } from '@kit.BasicServicesKit';
3. import { hilog } from '@kit.PerformanceAnalysisKit';

4. const TAG = 'AI_CAPTION_DEMO'

5. class Logger {
6.   static info(...msg: string[]) {
7.     hilog.info(0x0000, TAG, msg.join())
8.   }

9.   static error(...msg: string[]) {
10.     hilog.error(0x0000, TAG, msg.join())
11.   }
12. }

13. @Entry
14. @Component
15. struct Index {
16.   private captionOption?: AICaptionOptions;
17.   private controller: AICaptionController = new AICaptionController();
18.   @State isShown: boolean = false;
19.   isReading: boolean = false;

20.   aboutToAppear(): void {
21.     // AI字幕初始化参数，设置字幕的不透明度和回调函数
22.     this.captionOption = {
23.       initialOpacity: 1,
24.       onPrepared: () => {
25.         Logger.info('onPrepared')
26.       },
27.       onError: (error: BusinessError) => {
28.         Logger.error(`AICaption component error. Error code: ${error.code}, message: ${error.message}`)
29.       }
30.     }
31.   }

32.   async readPcmAudio() {
33.     this.isReading = true;
34.     // chineseAudio.pcm文件放在entry\src\main\resources\base\media路径下
35.     let fileData: Uint8Array | undefined;
36.     try {
37.       fileData =
38.         await this.getUIContext()?.getHostContext()?.resourceManager.getMediaContent($r('app.media.chineseAudio').id);
39.     } catch (e) {
40.       Logger.info(`get fileData fail , msg ${e} `)
41.     }
42.     if (fileData === undefined) {
43.       return;
44.     }
45.     const bufferSize = 640;
46.     const byteLength = fileData.byteLength;
47.     let offset = 0;
48.     Logger.info(`Pcm data total bytes: ${byteLength.toString()}`)
49.     let startTime = new Date().getTime();
50.     while (offset < byteLength) {
51.       // 模拟实际情况，读文件比录音机返回流快，所以要等待一段时间
52.       let nextOffset = offset + bufferSize
53.       if (offset > byteLength) {
54.         this.isReading = false;
55.         return
56.       }
57.       const arrayBuffer = fileData.buffer.slice(offset, nextOffset);
58.       let data = new Uint8Array(arrayBuffer);
59.       const audioData: AudioData = {
60.         data: data
61.       }

62.       if (this.controller) {
63.         try {
64.           this.controller.writeAudio(audioData)
65.         } catch (e) {
66.           Logger.error(`writeAudio exception`)
67.         }
68.       }
69.       offset = offset + bufferSize;
70.       const waitTime = bufferSize / 32
71.       await this.sleep(waitTime)
72.     }
73.     let endTime = new Date().getTime()
74.     this.isReading = false;
75.     Logger.info(`Audio play time: ${JSON.stringify(endTime - startTime)}`)
76.   }

77.   sleep(time: number): Promise<void> {
78.     return new Promise(resolve => setTimeout(resolve, time))
79.   }

80.   build() {
81.     Column({ space: 20 }) {
82.       Button('切换字幕显示状态:' + (this.isShown ? '显示' : '隐藏'))
83.         .backgroundColor('#B8BDA0')
84.         .width(200)
85.         .onClick(() => {
86.           this.isShown = !this.isShown;
87.         })
88.       Button('读取PCM音频')
89.         .backgroundColor('#B8BDA0')
90.         .width(200)
91.         .onClick(() => {
92.           if (!this.isReading) {
93.             this.readPcmAudio()
94.           }
95.         })
96.       Divider()
97.       // 调用AICaptionComponent组件初始化字幕
98.       AICaptionComponent({
99.         isShown: this.isShown,
100.         controller: this.controller,
101.         options: this.captionOption
102.       })
103.         .width('100%')
104.         .height(100)
105.       Divider()
106.       if (this.isShown) {
107.         Text('上面是字幕区域')
108.           .fontColor(Color.White)
109.       }
110.     }
111.     .width('100%')
112.     .height('100%')
113.     .padding(10)
114.     .backgroundColor('#7A7D6A')
115.   }
116. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/speech-textreader-guide "朗读控件")
# Vision Kit简介

更新时间: 2025-12-16 16:27

Vision Kit（场景化视觉服务）集成了视觉类AI能力，包括人脸活体检测（interactiveLiveness）能力、卡证识别（CardRecognition）能力、文档扫描（DocumentScanner）能力、AI识图控件（visionImageAnalyzer）能力。人脸活体检测能力便于用户与设备进行互动，验证用户是否为真实活体；卡证识别能力可提供身份证、行驶证、驾驶证、护照、银行卡等证件的结构化识别服务；文档扫描控件可提供拍摄文档并转换为高清扫描件的服务；AI识图控件可提供场景化的文本识别、主体分割、识图搜索功能。其中动作活体检测能力、卡证识别能力实施试用期免费的计费政策，试用期至2026年12月31日。开始正式收费前，华为将会提前通过正式途径发布计费调整通告。

## 场景介绍

Vision Kit提供了人脸活体检测能力、卡证识别能力、文档扫描能力和AI识图能力，具体如下：

- [人脸活体检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-interactiveliveness)：通过动作活体检测，验证用户是否为真实活体。
- [卡证识别](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-cardrecognition)：多证件的结构化识别服务。
- [文档扫描](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-documentscanner)：提供拍摄文档并转换为高清扫描件的服务。
- [AI识图](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-imageanalyzer)：提供场景化的文本识别、主体分割、识图搜索功能。

## 约束与限制

### 支持的设备

|能力|支持的设备|
|:--|:--|
|人脸活体检测|Phone、Tablet。|
|卡证识别|Phone、Tablet。|
|文档扫描|Phone、Tablet。|
|AI识图|Phone、Tablet、PC/2in1。|

### 支持的国家/地区

仅适用于中国境内（不包含中国香港、中国澳门、中国台湾）。

### 能力限制

|AI能力|约束|
|:--|:--|
|人脸活体检测|- 支持的文本语种类型：简体中文、繁体中文、英文、维吾尔文、藏文。<br>- 支持的播报语种类型：简体中文、英文。<br>- 人脸活体检测服务暂不支持横屏、分屏进行检测。|
|卡证识别|- 支持的语种类型：简体中文、英文。<br>- 卡证识别暂时只支持身份证、行驶证、驾驶证、护照、银行卡5种卡证。<br>- 不允许被其他组件或窗口遮挡。|
|文档扫描|- 支持的语种类型：简体中文、英文。<br>- 文档扫描暂时只支持phone、tablet设备。<br>- 不允许被其他组件或窗口遮挡。|
|AI识图|- 支持的文本语种类型：简体中文、繁体中文、英文、维吾尔文、藏文。<br>- 支持图片最小规格100*100分辨率。<br>- 分析图像要求是静态非矢量图，即svg、gif等图像类型不支持分析，支持传入[PixelMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-image-pixelmap)进行分析，目前仅支持[RGBA_8888](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-image-e#pixelmapformat7)类型。<br>- 支持翻译的图片宽高最小比例为1:3（高度小于宽度的3倍），支持文本识别的图片宽高最小比例为1:7（高度小于宽度的7倍）。<br>- 支持的设备情况请参见[约束与限制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-imageanalyzer#section2020122517405)。|

## 模拟器支持情况

本kit暂不支持模拟器。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-kit-guide "Vision Kit（场景化视觉服务）")
# 人脸活体检测

更新时间: 2025-12-16 16:27

## 场景介绍

人脸活体检测支持动作活体检测模式。

动作活体检测支持实时捕捉人脸，需要用户配合做指定动作就可以判断是真实活体，还是非活体攻击（比如：打印图片、人脸翻拍视频以及人脸面具等）。

注意

活体检测是一项纯端侧算法、试用期免费的系统基础服务，推荐开发者使用在考勤打卡、辅助登录和实名认证等低危业务场景中。

端侧算法在HarmonyOS NEXT/5.0.x已完成权威机构（CFCA）检测认证。鉴于支付和金融应用的高风险性，建议开发者基于现有的安全性，针对不同的功能场景进行风险评估和风控策略评估，并采取必要的安全措施。

**图1** 权威认证**增强级**检测报告  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216162747.08153058506732242218850520175855:50001231000000:2800:4E42E5ECCAA3AEC4FA161944071FF8F3DA52609180923AB9A024D86A593E9E1B.png "点击放大")

**图2** 活体检测示意图  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216162747.06731897092860592271151877672823:50001231000000:2800:F34D314644EC33725648231171168D9A77D756F653731E3626660425352AC79B.png "点击放大")

## 约束与限制

- 平板仅支持竖屏检测，大折叠屏仅支持折叠时使用，小折叠屏仅支持展开时使用。
- 支持的文本语种类型：简体中文、繁体中文、英文、维吾尔文、藏文。
- 支持的播报语种类型：简体中文、英文。
- 人脸活体检测服务暂不支持横屏、分屏进行检测。

## 接口说明

以下仅列出demo中调用的部分主要接口，具体API说明详见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-interactive-liveness)。

|接口名|描述|
|:--|:--|
|[startLivenessDetection](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-interactive-liveness#section68501963545)(config: InteractiveLivenessConfig): Promise<boolean>;|跳转到人脸活体检测页面的入口|
|[getInteractiveLivenessResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-interactive-liveness#section19136935154313)(): Promise<InteractiveLivenessResult>|获取人脸活体检测的结果。使用Promise异步回调|

## 开发步骤

1. 将实现人脸活体检测相关的类添加至工程。
    
    1. import { common, abilityAccessCtrl, Permissions } from '@kit.AbilityKit';
    2. import { interactiveLiveness } from '@kit.VisionKit';
    3. import { BusinessError } from '@kit.BasicServicesKit';
    4. import { hilog } from '@kit.PerformanceAnalysisKit';
    
2. 在module.json5文件中添加CAMERA权限，其中reason，abilities标签必填，配置方式参见[requestPermissions标签说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/declare-permissions#%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A3%B0%E6%98%8E%E6%9D%83%E9%99%90)。
    
    1. "requestPermissions":[
    2.   {
    3.     "name": "ohos.permission.CAMERA",
    4.     "reason": "$string:camera_desc",
    5.     "usedScene": {"abilities": []}
    6.   }
    7. ]
    
3. 简单配置页面的布局，选择人脸活体检测验证完后的跳转模式。如果使用back跳转模式，表示人脸活体检测完成后返回到上一页。如果使用replace跳转模式，表示人脸活体检测完跳转到成功或失败页面。默认选择的是replace跳转模式。
    
    1. Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {
    2.   Text("验证完的跳转模式：")
    3.     .fontSize(18)
    4.     .width("25%")
    5.   Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {
    6.     Row() {
    7.       Radio({ value: "replace", group: "routeMode" }).checked(true)
    8.         .height(24)
    9.         .width(24)
    10.         .onChange((isChecked: boolean) => {
    11.           this.routeMode = "replace"
    12.         })
    13.       Text("replace")
    14.         .fontSize(16)
    15.     }
    16.     .margin({ right: 15 })
    
    17.     Row() {
    18.       Radio({ value: "back", group: "routeMode" }).checked(false)
    19.         .height(24)
    20.         .width(24)
    21.         .onChange((isChecked: boolean) => {
    22.           this.routeMode = "back";
    23.         })
    24.       Text("back")
    25.         .fontSize(16)
    26.     }
    27.   }
    28.   .width("75%")
    29. }
    
4. 如果选择动作活体模式，可填写验证的动作个数。
    
    1. Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {
    2.   Text("动作数量：")
    3.     .fontSize(18)
    4.     .width("25%")
    5.   TextInput({
    6.     placeholder: this.actionsNum != 0 ? this.actionsNum.toString() : "动作数量为3或4个"
    7.   })
    8.     .type(InputType.Number)
    9.     .placeholderFont({
    10.       size: 18,
    11.       weight: FontWeight.Normal,
    12.       family: "HarmonyHeiTi",
    13.       style: FontStyle.Normal
    14.     })
    15.     .fontSize(18)
    16.     .fontWeight(FontWeight.Bold)
    17.     .fontFamily("HarmonyHeiTi")
    18.     .fontStyle(FontStyle.Normal)
    19.     .width("65%")
    20.     .onChange((value: string) => {
    21.       this.actionsNum = Number(value) as interactiveLiveness.ActionsNumber;
    22.     })
    23. }
    
5. 点击“开始检测“按钮，触发点击事件。
    
    1. Button("开始检测", { type: ButtonType.Normal, stateEffect: true })
    2.   .width(192)
    3.   .height(40)
    4.   .fontSize(16)
    5.   .backgroundColor(0x317aff)
    6.   .borderRadius(20)
    7.   .margin({
    8.     bottom: 56
    9.   })
    10.   .onClick(() => {
    11.     this.startDetection();
    12.   })
    
6. 触发CAMERA权限校验。
    
    1. private context: common.UIAbilityContext = this.getUIContext()?.getHostContext() as common.UIAbilityContext;
    2. private array: Array<Permissions> = ["ohos.permission.CAMERA"];
    3. // 校验CAMERA权限
    4. private startDetection() {
    5.   abilityAccessCtrl.createAtManager().requestPermissionsFromUser(this.context, this.array).then((res) => {
    6.     for (let i = 0; i < res.permissions.length; i++) {
    7.       if (res.permissions[i] === "ohos.permission.CAMERA" && res.authResults[i] === 0) {
    8.         this.routerLibrary();
    9.       }
    10.     }
    11.   }).catch((err: BusinessError) => {
    12.     hilog.error(0x0001, "LivenessCollectionIndex", `Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);
    13.   })
    14. }
    
7. 配置人脸活体检测控件的配置项[InteractiveLivenessConfig](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-interactive-liveness#section16532153115517)，用于跳转到人脸活体检测控件。
    
    配置中具体的参数可参考[API文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-interactive-liveness)。
    
    1. let routerOptions: interactiveLiveness.InteractiveLivenessConfig = {
    2.   isSilentMode: this.isSilentMode as interactiveLiveness.DetectionMode,
    3.   routeMode: this.routeMode as interactiveLiveness.RouteRedirectionMode,
    4.   actionsNum: this.actionsNum
    5. };
    
8. 调用interactiveLiveness的[startLivenessDetection](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-interactive-liveness#section68501963545)接口，判断跳转到人脸活体检测控件是否成功。
    
    1. // 跳转到人脸活体检测控件
    2. private routerLibrary() {
    3.   if (canIUse("SystemCapability.AI.Component.LivenessDetect")) {
    4.     interactiveLiveness.startLivenessDetection(routerOptions).then((DetectState: boolean) => {
    5.       hilog.info(0x0001, "LivenessCollectionIndex", `Succeeded in jumping.`);
    6.     }).catch((err: BusinessError) => {
    7.       hilog.error(0x0001, "LivenessCollectionIndex", `Failed to jump. Code：${err.code}，message：${err.message}`);
    8.     })
    9.   } else {
    10.     hilog.error(0x0001, "LivenessCollectionIndex", 'this api is not supported on this device');
    11.   }
    12. }
    
9. 检测结束后回到当前界面，可调用interactiveLiveness的[getInteractiveLivenessResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-interactive-liveness#section19136935154313)接口，验证人脸活体检测的结果。
    
    1. // 获取验证结果
    2. private getDetectionResultInfo() {
    3.   // getInteractiveLivenessResult接口调用完会释放资源
    4.   if (canIUse("SystemCapability.AI.Component.LivenessDetect")) {
    5.     let resultInfo = interactiveLiveness.getInteractiveLivenessResult();
    6.     resultInfo.then(data => {
    7.       this.resultInfo = data;
    8.     }).catch((err: BusinessError) => {
    9.       this.failResult = {
    10.         "code": err.code,
    11.         "message": err.message
    12.       }
    13.     })
    14.   } else {
    15.     hilog.error(0x0001, "LivenessCollectionIndex", 'this api is not supported on this device');
    16.   }
    17. }
    

## 开发实例

### Index.ets

1. import { common, abilityAccessCtrl, Permissions } from '@kit.AbilityKit';
2. import { interactiveLiveness } from '@kit.VisionKit';
3. import { BusinessError } from '@kit.BasicServicesKit';
4. import { hilog } from '@kit.PerformanceAnalysisKit';

5. @Entry
6. @Component
7. struct LivenessCollectionIndex{
8.   private context: common.UIAbilityContext = this.getUIContext().getHostContext() as common.UIAbilityContext;
9.   private array: Array<Permissions> = ["ohos.permission.CAMERA"];
10.   @State actionsNum: number = 0;
11.   @State isSilentMode: string = "INTERACTIVE_MODE";
12.   @State routeMode: string = "replace";
13.   @State resultInfo: interactiveLiveness.InteractiveLivenessResult = {
14.     livenessType: 0
15.   };
16.   @State failResult: Record<string, number | string> = {
17.     "code": 1008302000,
18.     "message": ""
19.   };

20.   build() {
21.     Stack({
22.       alignContent: Alignment.Top
23.     }) {
24.       Column() {
25.         Row() {
26.           Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {
27.             Text("验证完的跳转模式：")
28.               .fontSize(18)
29.               .width("25%")
30.             Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {
31.               Row() {
32.                 Radio({ value: "replace", group: "routeMode" }).checked(true)
33.                   .height(24)
34.                   .width(24)
35.                   .onChange(() => {
36.                     this.routeMode = "replace"
37.                   })
38.                 Text("replace")
39.                   .fontSize(16)
40.               }
41.               .margin({ right: 15 })

42.               Row() {
43.                 Radio({ value: "back", group: "routeMode" }).checked(false)
44.                   .height(24)
45.                   .width(24)
46.                   .onChange(() => {
47.                     this.routeMode = "back";
48.                   })
49.                 Text("back")
50.                   .fontSize(16)
51.               }
52.             }
53.             .width("75%")
54.           }
55.         }
56.         .margin({ bottom: 30 })

57.           Row() {
58.             Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {
59.               Text("动作数量：")
60.                 .fontSize(18)
61.                 .width("25%")
62.               TextInput({
63.                 placeholder: this.actionsNum != 0 ? this.actionsNum.toString() : "动作数量为3或4个"
64.               })
65.                 .type(InputType.Number)
66.                 .placeholderFont({
67.                   size: 18,
68.                   weight: FontWeight.Normal,
69.                   family: "HarmonyHeiTi",
70.                   style: FontStyle.Normal
71.                 })
72.                 .fontSize(18)
73.                 .fontWeight(FontWeight.Bold)
74.                 .fontFamily("HarmonyHeiTi")
75.                 .fontStyle(FontStyle.Normal)
76.                 .width("65%")
77.                 .onChange((value: string) => {
78.                   this.actionsNum = Number(value) as interactiveLiveness.ActionsNumber;
79.                 })
80.             }
81.           }
82.       }
83.       .margin({ left: 24, top: 80 })
84.       .zIndex(1)

85.       Stack({
86.         alignContent: Alignment.Bottom
87.       }) {
88.         if (this.resultInfo?.mPixelMap) {
89.           Image(this.resultInfo?.mPixelMap)
90.             .width(260)
91.             .height(260)
92.             .align(Alignment.Center)
93.             .margin({ bottom: 260 })
94.           Circle()
95.             .width(300)
96.             .height(300)
97.             .fillOpacity(0)
98.             .strokeWidth(60)
99.             .stroke(Color.White)
100.             .margin({ bottom: 250, left: 0 })
101.         }

102.         Text(this.resultInfo.mPixelMap ?
103.           "检测成功" :
104.           this.failResult.code != 1008302000 ?
105.             "检测失败" :
106.             "")
107.           .width("100%")
108.           .height(26)
109.           .fontSize(20)
110.           .fontColor("#000000")
111.           .fontFamily("HarmonyHeiTi")
112.           .margin({ top: 50 })
113.           .textAlign(TextAlign.Center)
114.           .fontWeight("Medium")
115.           .margin({ bottom: 240 })

116.         if(this.failResult.code != 1008302000) {
117.           Text(this.failResult.message as string)
118.             .width("100%")
119.             .height(26)
120.             .fontSize(16)
121.             .fontColor(Color.Gray)
122.             .textAlign(TextAlign.Center)
123.             .fontFamily("HarmonyHeiTi")
124.             .fontWeight("Medium")
125.             .margin({ bottom: 200 })
126.         }

127.         Button("开始检测", { type: ButtonType.Normal, stateEffect: true })
128.           .width(192)
129.           .height(40)
130.           .fontSize(16)
131.           .backgroundColor(0x317aff)
132.           .borderRadius(20)
133.           .margin({
134.             bottom: 56
135.           })
136.           .onClick(() => {
137.             this.startDetection();
138.           })
139.       }
140.       .height("100%")
141.     }
142.   }

143.   onPageShow() {
144.     this.resultRelease();
145.     this.getDetectionResultInfo();
146.   }

147.   // 跳转到人脸活体检测控件
148.   private routerLibrary() {
149.     let routerOptions: interactiveLiveness.InteractiveLivenessConfig = {
150.       isSilentMode: this.isSilentMode as interactiveLiveness.DetectionMode,
151.       routeMode: this.routeMode as interactiveLiveness.RouteRedirectionMode,
152.       actionsNum: this.actionsNum
153.     }

154.     if (canIUse("SystemCapability.AI.Component.LivenessDetect")) {
155.       interactiveLiveness.startLivenessDetection(routerOptions).then((DetectState: boolean) => {
156.         hilog.info(0x0001, "LivenessCollectionIndex", `Succeeded in jumping.`);
157.       }).catch((err: BusinessError) => {
158.         hilog.error(0x0001, "LivenessCollectionIndex", `Failed to jump. Code：${err.code}，message：${err.message}`);
159.       })
160.     } else {
161.       hilog.error(0x0001, "LivenessCollectionIndex", 'this api is not supported on this device');
162.     }
163.   }

164.   // 校验CAMERA权限
165.   private startDetection() {
166.     abilityAccessCtrl.createAtManager().requestPermissionsFromUser(this.context, this.array).then((res) => {
167.       for (let i = 0; i < res.permissions.length; i++) {
168.         if (res.permissions[i] === "ohos.permission.CAMERA" && res.authResults[i] === 0) {
169.         this.routerLibrary();
170.       }
171.      }
172.     }).catch((err: BusinessError) => {
173.       hilog.error(0x0001, "LivenessCollectionIndex", `Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);
174.     })
175.   }

176.   // 获取验证结果
177.   private getDetectionResultInfo() {
178.     // getInteractiveLivenessResult接口调用完会释放资源
179.     if (canIUse("SystemCapability.AI.Component.LivenessDetect")) {
180.       interactiveLiveness.getInteractiveLivenessResult().then(data => {
181.         this.resultInfo = data;
182.       }).catch((err: BusinessError) => {
183.         this.failResult = {
184.           "code": err.code,
185.           "message": err.message
186.         }
187.       })
188.     } else {
189.       hilog.error(0x0001, "LivenessCollectionIndex", 'this api is not supported on this device');
190.     }
191.   }

192.   // result release
193.   private resultRelease() {
194.     this.resultInfo = {
195.       livenessType: 0
196.     }
197.     this.failResult = {
198.       "code": 1008302000,
199.       "message": ""
200.     }
201.   }
202. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-introduction "Vision Kit简介")
# 卡证识别

更新时间: 2025-12-16 16:27

从5.1.1(19)开始，[CardRecognition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-card-recognition#section143611912403)接口中的callback参数废弃，请使用onResult代替。

## 场景介绍

卡证识别控件提供身份证（目前仅支持中国大陆二代身份证，且不包含民汉双文身份证）、行驶证、驾驶证、护照、银行卡的结构化识别服务，满足卡证的自动分类功能，系统可自动判断所属卡证类型并返回结构化信息和卡证图片信息。

对于需要填充卡证信息的场景，如身份证、银行卡信息等，可使用卡证识别控件读取OCR（Optical Character Recognition）信息，将结果信息返回后进行填充。支持单独识别正面、反面，或同时进行双面识别。

**图1** 银行卡识别示意图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216162748.13469380655189781268947624313441:50001231000000:2800:D364AC7DAC3266480EEFAC0FBE7DFFF7785BA5DFCEA8ABBF7EECB8A353E4A289.png "点击放大")

## 约束与限制

- 支持的语种类型：简体中文、英文。
- 卡证识别暂时只支持身份证、行驶证、驾驶证、护照、银行卡5种卡证。
- 不允许被其他组件或窗口遮挡。

## 接口说明

以下仅列出demo中调用的部分主要接口，具体API说明详见[API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-card-recognition)。

|接口名|描述|
|:--|:--|
|[CardRecognition](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-card-recognition#section143611912403)|卡证识别控件|
|[CardRecognitionResult](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-card-recognition#section161551745133610)|卡证识别结果|

## 开发步骤

1. 将卡证识别控件相关的类添加至工程。
    
    1. import { CardRecognition, CardRecognitionResult, CardType, CardSide, CardRecognitionConfig, ShootingMode, CardContentConfig, BankCardConfig } from "@kit.VisionKit";
    
2. 配置页面的布局，选择需要识别的卡证类型和需要识别的卡证页面，配置对应设置项，在回调中获取结果返回值。
    
    以下分别为身份证、银行卡、护照、驾驶证和行驶证的示例代码。
    
    1. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    2. const TAG = 'CardRecognition'
    
    3. @Entry
    4. @Component
    5. struct Index {
    6.   build() {
    7.     Column() {
    8.       // 身份证
    9.       CardRecognition({
    10.         supportType: CardType.CARD_ID,
    11.         // 身份证可双面识别
    12.         cardSide: CardSide.DEFAULT,
    13.         cardRecognitionConfig: {
    14.           defaultShootingMode: ShootingMode.MANUAL,
    15.           isPhotoSelectionSupported: true
    16.         },
    17.         onResult: ((params: CardRecognitionResult) => {
    18.           hilog.info(0x0001, TAG, `params code: ${params.code}`)
    19.           hilog.info(0x0001, TAG, `params cardType: ${params.cardType}`)
    20.           hilog.info(0x0001, TAG, `params cardInfo front: ${JSON.stringify(params.cardInfo?.front)}`)
    21.           hilog.info(0x0001, TAG, `params cardInfo back: ${JSON.stringify(params.cardInfo?.back)}`)
    22.         })
    23.       })
    24.     }
    25.     .height('100%')
    26.     .width('100%')
    27.   }
    28. }
    
    29. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    30. const TAG = 'CardRecognition'
    
    31. @Entry
    32. @Component
    33. struct Index {
    34.   build() {
    35.     Column() {
    36.       // 银行卡
    37.       CardRecognition({
    38.         supportType: CardType.CARD_BANK,
    39.         // 银行卡为单面识别
    40.         cardSide: CardSide.FRONT,
    41.         cardRecognitionConfig: {
    42.           defaultShootingMode: ShootingMode.MANUAL,
    43.           isPhotoSelectionSupported: true,
    44.           cardContentConfig: { bankCard: { isBankNumberDialogShown: true} }
    45.         },
    46.         onResult: ((params: CardRecognitionResult) => {
    47.           hilog.info(0x0001, TAG, `params code: ${params.code}`)
    48.           hilog.info(0x0001, TAG, `params cardType: ${params.cardType}`)
    49.           hilog.info(0x0001, TAG, `params cardInfo: ${JSON.stringify(params.cardInfo?.main)}`)
    50.         })})
    51.     }
    52.     .height('100%')
    53.     .width('100%')
    54.   }
    55. }
    
    56. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    57. const TAG = 'CardRecognition'
    
    58. @Entry
    59. @Component
    60. struct Index {
    61.   build() {
    62.     Column() {
    63.       // 护照
    64.       CardRecognition({
    65.         supportType: CardType.CARD_PASSPORT,
    66.         // 护照为单面识别
    67.         cardSide: CardSide.FRONT,
    68.         cardRecognitionConfig: {
    69.           defaultShootingMode: ShootingMode.MANUAL,
    70.           isPhotoSelectionSupported: true
    71.         },
    72.         onResult: ((params: CardRecognitionResult) => {
    73.           hilog.info(0x0001, TAG, `params code: ${params.code}`)
    74.           hilog.info(0x0001, TAG, `params cardType: ${params.cardType}`)
    75.           hilog.info(0x0001, TAG, `params cardInfo: ${JSON.stringify(params.cardInfo?.main)}`)
    76.         })})
    77.     }
    78.     .height('100%')
    79.     .width('100%')
    80.   }
    81. }
    
    82. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    83. const TAG = 'CardRecognition'
    
    84. @Entry
    85. @Component
    86. struct Index {
    87.   build() {
    88.     Column() {
    89.       // 驾驶证
    90.       CardRecognition({
    91.         supportType: CardType.CARD_DRIVER_LICENSE,
    92.         // 驾驶证可双面识别
    93.         cardSide: CardSide.DEFAULT,
    94.         cardRecognitionConfig: {
    95.           defaultShootingMode: ShootingMode.MANUAL,
    96.           isPhotoSelectionSupported: true
    97.         },
    98.         onResult: ((params: CardRecognitionResult) => {
    99.           hilog.info(0x0001, TAG, `params code: ${params.code}`)
    100.           hilog.info(0x0001, TAG, `params cardType: ${params.cardType}`)
    101.           hilog.info(0x0001, TAG, `params cardInfo front: ${JSON.stringify(params.cardInfo?.front)}`)
    102.           hilog.info(0x0001, TAG, `params cardInfo back: ${JSON.stringify(params.cardInfo?.back)}`)
    103.         })
    104.       })
    105.     }
    106.     .height('100%')
    107.     .width('100%')
    108.   }
    109. }
    
    110. import { hilog } from '@kit.PerformanceAnalysisKit';
    
    111. const TAG = 'CardRecognition'
    
    112. @Entry
    113. @Component
    114. struct Index {
    115.   build() {
    116.     Column() {
    117.       // 行驶证
    118.       CardRecognition({
    119.         supportType: CardType.CARD_VEHICLE_LICENSE,
    120.         // 行驶证可双面识别
    121.         cardSide: CardSide.DEFAULT,
    122.         cardRecognitionConfig: {
    123.           defaultShootingMode: ShootingMode.MANUAL,
    124.           isPhotoSelectionSupported: true
    125.         },
    126.         onResult: ((params: CardRecognitionResult) => {
    127.           hilog.info(0x0001, TAG, `params code: ${params.code}`)
    128.           hilog.info(0x0001, TAG, `params cardType: ${params.cardType}`)
    129.           hilog.info(0x0001, TAG, `params cardInfo front: ${JSON.stringify(params.cardInfo?.front)}`)
    130.           hilog.info(0x0001, TAG, `params cardInfo back: ${JSON.stringify(params.cardInfo?.back)}`)
    131.         })
    132.       })
    133.     }
    134.     .height('100%')
    135.     .width('100%')
    136.   }
    137. }
    

## 开发实例

### Index.ets

1. // 卡证识别开发实例分两页实现，一页为卡证识别入口页，一页为卡证识别实现页
2. // 卡证识别入口页，需引入卡证识别实现页，以下文实例为例，实现页文件名为CardDemoPage
3. import { CardDemoPage } from './CardDemoPage'

4. @Entry
5. @Component
6. struct MainPage {
7.   @Provide('pathStack') pathStack: NavPathStack = new NavPathStack()

8.   @Builder
9.   PageMap(name: string) {
10.     if (name === 'cardRecognition') {
11.       CardDemoPage()
12.     }
13.   }

14.   // 卡证识别入口按钮
15.   build() {
16.     Navigation(this.pathStack) {
17.       Button('CardRecognition', { stateEffect: true, type: ButtonType.Capsule })
18.         .width('50%')
19.         .height(40)
20.         .onClick(() => {
21.           this.pathStack.pushPath({ name: 'cardRecognition' })
22.         })
23.     }.title('卡证识别控件demo').navDestination(this.PageMap)
24.     .mode(NavigationMode.Stack)
25.   }
26. }

### CardDemoPage.ets

1. // 卡证识别实现页，文件名为CardDemoPage，需被引入至入口页
2. import { CardRecognition, CardRecognitionResult, CardType, CardSide, ShootingMode } from "@kit.VisionKit"
3. import { hilog } from '@kit.PerformanceAnalysisKit';

4. const TAG: string = 'CardRecognitionPage'

5. // 卡证识别页，用于加载uiExtensionAbility
6. @Component
7. export struct CardDemoPage {
8.   @State cardDataSource: Record<string, string>[] = []
9.   @Consume('pathStack') pathStack: NavPathStack

10.   build() {
11.     NavDestination() {
12.       Stack({ alignContent: Alignment.Top }) {
13.         Stack() {
14.           this.cardDataShowBuilder()
15.         }
16.         .width('80%')
17.         .height('80%')

18.         CardRecognition({
19.           // 此处选择身份证类型作为示例
20.           supportType: CardType.CARD_ID,
21.           cardSide: CardSide.DEFAULT,
22.           cardRecognitionConfig: {
23.             defaultShootingMode: ShootingMode.MANUAL,
24.             isPhotoSelectionSupported: true
25.           },
26.           onResult: ((params: CardRecognitionResult) => {
27.             hilog.info(0x0001, TAG, `params code: ${params.code}`)
28.             if (params.code !== 200) {
29.               this.pathStack.pop()
30.             }
31.             hilog.info(0x0001, TAG, `params cardType: ${params.cardType}`)
32.             if (params.cardInfo?.front !== undefined) {
33.               this.cardDataSource.push(params.cardInfo?.front)
34.             }

35.             if (params.cardInfo?.back !== undefined) {
36.               this.cardDataSource.push(params.cardInfo?.back)
37.             }

38.             if (params.cardInfo?.main !== undefined) {
39.               this.cardDataSource.push(params.cardInfo?.main)
40.             }
41.             hilog.info(0x0001, TAG, `params cardInfo front: ${JSON.stringify(params.cardInfo?.front)}`)
42.             hilog.info(0x0001, TAG, `params cardInfo back: ${JSON.stringify(params.cardInfo?.back)}`)
43.           })
44.         })
45.       }
46.       .width('100%')
47.       .height('100%')
48.     }
49.     .width('100%')
50.     .height('100%')
51.     .hideTitleBar(true)
52.   }

53.   @Builder
54.   cardDataShowBuilder() {
55.     List() {
56.       ForEach(this.cardDataSource, (cardData: Record<string, string>) => {
57.         ListItem() {
58.           Column() {
59.             Image(cardData.cardImageUri)
60.               .objectFit(ImageFit.Contain)
61.               .width(100)
62.               .height(100)

63.             Text(JSON.stringify(cardData))
64.               .width('100%')
65.               .fontSize(12)
66.           }
67.         }
68.       })
69.     }
70.     .listDirection(Axis.Vertical)
71.     .alignListItem(ListItemAlign.Center)
72.     .margin({
73.       top: 50
74.     })
75.     .width('100%')
76.     .height('100%')
77.   }
78. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-interactiveliveness "人脸活体检测")
# AI识图

更新时间: 2025-12-16 16:27

## 场景介绍

AI识图是通过聚合OCR（Optical Character Recognition）、主体分割、实体识别、多目标识别等AI能力，提供场景化的文本识别、主体分割、识图搜索功能。AI识图功能主开关入口在基础控件API列表中，如果您接受AI识图默认的交互和功能，仅需使用基础控件提供的相关使能接口打开功能开关即可。该文档配套的API配合基础控件使用，主要满足您的定制诉求，帮助您完成AI识图功能交互上的细粒度控制，获取文本识别、图像分割等分析结果以便您进行扩展业务的开发，目前支持的基础控件范围包括[Image](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image#enableanalyzer11)、[Video](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-media-components-video#enableanalyzer12)、[XComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent#enableanalyzer12)。其中，配合Image控件可完成静态图片上的识图功能，配合Video控件可完成视频播放暂停帧的识图功能，配合XComponent可完成自定义渲染等场景下的图像的识图功能。

识图功能提供如下能力：

- 识别文字。
    
    用户长按文本选取文字或持续长按文本中的电话号码、邮箱、网址、地址、时间等实体，可触发对应实体的快捷操作，如持续长按文本中的时间，可触发"新建日程"快捷操作入口。
    
- 识图搜索。
    
    用户抠图后可基于抠出的主体进行识图搜索，开发者也可以主动触发目标标识，触发后会识别图中的动物、植物、建筑物等目标并用相应的ICON标识，用户点击ICON也可以进行识图搜索，搜索结果会以模态窗的方式为用户呈现。
    
- 主体分割。
    
    用户长按主体分割，分割后用户可以完成复制，分享，全选，识图搜索等功能。
    
- AIButton。
    
    AIButton承载了电话号码、邮箱、网址、地址、时间等实体的显性下划线标识（点击后出现快捷操作菜单），原图翻译（系统设置语种与图片上文本语种不一致且能将图中文本翻译为系统当前设置的语种时出现），表格提取（图片中存在表格时出现）等功能特性。配置AIButton属性可见后，会对图片进行预分析，当图片中存在文本且文本区域大于图片区域的5%时AIButton才会显示。
    

识图功能提供如下建议：

- AI识图特性可帮助消费者从图片上获取更多的信息（长按抠图，长按选取文本，长按实体识别等）。建议在大图预览场景都打开此能力，大图预览场景下用户对图片中的内容会更感兴趣，此时适时的提供识图服务契合用户体验场景，同时为用户提供最佳的识图交互体验。
- AI识图特性中的AIButton与图片中是否有文本存在关联，显性的提醒用户操作文本。开启AIButton会触发图片的预分析从而导致一定的功耗开销，建议开发者充分理解自身业务场景，预估目标用户图片内容分布，兼顾用户图片浏览体验和提供更高阶AI识图功能体验的情况下按需提供AIButton露出。例如，业务本身是辅助用户高效提取图片中的文本内容，开启AIButton将会提升用户文本提取的体验。业务本身更偏向于图片编辑，也可隐藏AIButton。

**图1** AI识图示意图  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216162749.19315385489373374942173618742941:50001231000000:2800:C5D70BDBB1D22658357FD591617E8222ABEA45FACE91B751B78710287C783D1F.png "点击放大")

## 约束与限制

- 支持的文本语种类型：简体中文、繁体中文、英文、维吾尔文、藏文。
- 支持图片最小规格100*100分辨率。
- 分析图像要求是静态非矢量图，即svg、gif等图像类型不支持分析，支持传入[PixelMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-image-pixelmap)进行分析，目前仅支持[RGBA_8888](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-image-e#pixelmapformat7)类型。
- 支持翻译的图片宽高最小比例为1:3（高度小于宽度的3倍），支持文本识别的图片宽高最小比例为1:7（高度小于宽度的7倍）。
- 当前设备支持本能力可以通过[getImageAnalyzerSupportTypes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-image-common#getimageanalyzersupporttypes12)进行判断。
    
    日志返回格式为“SupportTypes: [_主体识别功能枚举值_,_文字识别功能枚举值_,_对象查找功能枚举值_]”，具体枚举值可参见[ImageAnalyzerType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-image-common#imageanalyzertype12)。
    
    若返回“SupportTypes: []”，则说明当前设备不支持AI识图能力；若返回其他值，则说明当前设备支持AI识图能力。
    
    1. import { visionImageAnalyzer } from '@kit.VisionKit';
    
    2. @Entry
    3. @Component
    4. struct Index {
    5.   private aiController: visionImageAnalyzer.VisionImageAnalyzerController = new visionImageAnalyzer.VisionImageAnalyzerController()
    
    6.   build() {
    7.     Row() {
    8.       Button('getTypes')
    9.         .onClick(() => {
    10.           let SupportTypes = this.aiController.getImageAnalyzerSupportTypes()
    11.           console.info(`SupportTypes: ${JSON.stringify(SupportTypes)}`)
    12.         })
    13.     }
    14.   }
    15. }
    

## 开发步骤

1. 将AI识图控件相关的类添加。
    
    1. import { visionImageAnalyzer } from '@kit.VisionKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
2. 初始化[VisionImageAnalyzerController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-image-analyzer#section37192953318)对象。
    
    1. private visionImageAnalyzerController: visionImageAnalyzer.VisionImageAnalyzerController = new visionImageAnalyzer.VisionImageAnalyzerController();
    
3. 添加订阅事件。
    
    1. aboutToAppear(): void {
    2.   this.visionImageAnalyzerController.on('imageAnalyzerVisibilityChange', (visibility: visionImageAnalyzer.ImageAnalyzerVisibility) => {
    3.     console.info("DEMO_TAG", `imageAnalyzerVisibilityChange result: ${JSON.stringify(visibility)}`)
    4.   })
    5.   this.visionImageAnalyzerController.on('textAnalysis', (text: string) => {
    6.     console.info("DEMO_TAG", `textAnalysis result: ${JSON.stringify(text)}`)
    7.   })
    8.   this.visionImageAnalyzerController.on('selectedTextChange', (selectedText: string) => {
    9.     console.info("DEMO_TAG", `selectedTextChange result: ${JSON.stringify(selectedText)}`)
    10.   })
    11.   this.visionImageAnalyzerController.on('subjectAnalysis', (subjects: visionImageAnalyzer.Subject[]) => {
    12.     console.info("DEMO_TAG", `subjectAnalysis result: ${JSON.stringify(subjects)}`)
    13.   })
    14.   this.visionImageAnalyzerController.on('selectedSubjectsChange', (subjects: visionImageAnalyzer.Subject[]) => {
    15.     console.info("DEMO_TAG", `selectedSubjectsChange result: ${JSON.stringify(subjects)}`)
    16.   })
    17.   this.visionImageAnalyzerController.on('analyzerFailed', (error: BusinessError) => {
    18.     console.error("DEMO_TAG", `analyzerFailed result: ${JSON.stringify(error)}`)
    19.   })
    20. }
    
4. 绑定[VisionImageAnalyzerController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-image-analyzer#section37192953318)对象，可以控制识图相关的交互。
    
    1. build() {
    2.   Stack() {
    3.     // 需要替换您自己的资源图片，存放在resources/base/media目录下
    4.     Image($r('app.media.img'), {
    5.       types: [ImageAnalyzerType.TEXT, ImageAnalyzerType.SUBJECT, ImageAnalyzerType.OBJECT_LOOKUP],
    6.       aiController: this.visionImageAnalyzerController
    7.     })
    8.       .width('100%')
    9.       .height('100%')
    10.       .enableAnalyzer(true)
    11.       .objectFit(ImageFit.Contain)
    12.   }.width('100%').height('100%')
    13. }
    
5. 取消订阅事件。
    
    1. aboutToDisappear(): void {
    2.   this.visionImageAnalyzerController.off('imageAnalyzerVisibilityChange')
    3.   this.visionImageAnalyzerController.off('textAnalysis')
    4.   this.visionImageAnalyzerController.off('selectedTextChange')
    5.   this.visionImageAnalyzerController.off('subjectAnalysis')
    6.   this.visionImageAnalyzerController.off('selectedSubjectsChange')
    7.   this.visionImageAnalyzerController.off('analyzerFailed')
    8. }
    

## 开发实例

### Index.ets

1. import { visionImageAnalyzer } from '@kit.VisionKit';
2. import { BusinessError } from '@kit.BasicServicesKit'
3. @Entry
4. @Component
5. struct ImageDemo {
6.   private visionImageAnalyzerController: visionImageAnalyzer.VisionImageAnalyzerController = new visionImageAnalyzer.VisionImageAnalyzerController()
7.   aboutToAppear(): void {
8.     this.visionImageAnalyzerController.on('imageAnalyzerVisibilityChange', (visibility: visionImageAnalyzer.ImageAnalyzerVisibility) => {
9.       console.info("DEMO_TAG", `imageAnalyzerVisibilityChange result: ${JSON.stringify(visibility)}`)
10.     })
11.     this.visionImageAnalyzerController.on('textAnalysis', (text: string) => {
12.       console.info("DEMO_TAG", `textAnalysis result: ${JSON.stringify(text)}`)
13.     })
14.     this.visionImageAnalyzerController.on('selectedTextChange', (selectedText: string) => {
15.       console.info("DEMO_TAG", `selectedTextChange result: ${JSON.stringify(selectedText)}`)
16.     })
17.     this.visionImageAnalyzerController.on('subjectAnalysis', (subjects: visionImageAnalyzer.Subject[]) => {
18.       console.info("DEMO_TAG", `subjectAnalysis result: ${JSON.stringify(subjects)}`)
19.     })
20.     this.visionImageAnalyzerController.on('selectedSubjectsChange', (subjects: visionImageAnalyzer.Subject[]) => {
21.       console.info("DEMO_TAG", `selectedSubjectsChange result: ${JSON.stringify(subjects)}`)
22.     })
23.     this.visionImageAnalyzerController.on('analyzerFailed', (error: BusinessError) => {
24.       console.error("DEMO_TAG", `analyzerFailed result: ${JSON.stringify(error)}`)
25.     })
26.   }
27.   build() {
28.     Stack() {
29.       Image($r('app.media.img'), {
30.         types: [ImageAnalyzerType.TEXT, ImageAnalyzerType.SUBJECT, ImageAnalyzerType.OBJECT_LOOKUP],
31.         aiController: this.visionImageAnalyzerController
32.       })
33.         .width('100%')
34.         .height('100%')
35.         .enableAnalyzer(true)
36.         .objectFit(ImageFit.Contain)
37.     }.width('100%').height('100%')
38.   }
39.     aboutToDisappear(): void {
40.       this.visionImageAnalyzerController.off('imageAnalyzerVisibilityChange')
41.       this.visionImageAnalyzerController.off('textAnalysis')
42.       this.visionImageAnalyzerController.off('selectedTextChange')
43.       this.visionImageAnalyzerController.off('subjectAnalysis')
44.       this.visionImageAnalyzerController.off('selectedSubjectsChange')
45.       this.visionImageAnalyzerController.off('analyzerFailed')
46.     }
47. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-documentscanner "文档扫描")
# AI识图

更新时间: 2025-12-16 16:27

## 场景介绍

AI识图是通过聚合OCR（Optical Character Recognition）、主体分割、实体识别、多目标识别等AI能力，提供场景化的文本识别、主体分割、识图搜索功能。AI识图功能主开关入口在基础控件API列表中，如果您接受AI识图默认的交互和功能，仅需使用基础控件提供的相关使能接口打开功能开关即可。该文档配套的API配合基础控件使用，主要满足您的定制诉求，帮助您完成AI识图功能交互上的细粒度控制，获取文本识别、图像分割等分析结果以便您进行扩展业务的开发，目前支持的基础控件范围包括[Image](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image#enableanalyzer11)、[Video](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-media-components-video#enableanalyzer12)、[XComponent](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent#enableanalyzer12)。其中，配合Image控件可完成静态图片上的识图功能，配合Video控件可完成视频播放暂停帧的识图功能，配合XComponent可完成自定义渲染等场景下的图像的识图功能。

识图功能提供如下能力：

- 识别文字。
    
    用户长按文本选取文字或持续长按文本中的电话号码、邮箱、网址、地址、时间等实体，可触发对应实体的快捷操作，如持续长按文本中的时间，可触发"新建日程"快捷操作入口。
    
- 识图搜索。
    
    用户抠图后可基于抠出的主体进行识图搜索，开发者也可以主动触发目标标识，触发后会识别图中的动物、植物、建筑物等目标并用相应的ICON标识，用户点击ICON也可以进行识图搜索，搜索结果会以模态窗的方式为用户呈现。
    
- 主体分割。
    
    用户长按主体分割，分割后用户可以完成复制，分享，全选，识图搜索等功能。
    
- AIButton。
    
    AIButton承载了电话号码、邮箱、网址、地址、时间等实体的显性下划线标识（点击后出现快捷操作菜单），原图翻译（系统设置语种与图片上文本语种不一致且能将图中文本翻译为系统当前设置的语种时出现），表格提取（图片中存在表格时出现）等功能特性。配置AIButton属性可见后，会对图片进行预分析，当图片中存在文本且文本区域大于图片区域的5%时AIButton才会显示。
    

识图功能提供如下建议：

- AI识图特性可帮助消费者从图片上获取更多的信息（长按抠图，长按选取文本，长按实体识别等）。建议在大图预览场景都打开此能力，大图预览场景下用户对图片中的内容会更感兴趣，此时适时的提供识图服务契合用户体验场景，同时为用户提供最佳的识图交互体验。
- AI识图特性中的AIButton与图片中是否有文本存在关联，显性的提醒用户操作文本。开启AIButton会触发图片的预分析从而导致一定的功耗开销，建议开发者充分理解自身业务场景，预估目标用户图片内容分布，兼顾用户图片浏览体验和提供更高阶AI识图功能体验的情况下按需提供AIButton露出。例如，业务本身是辅助用户高效提取图片中的文本内容，开启AIButton将会提升用户文本提取的体验。业务本身更偏向于图片编辑，也可隐藏AIButton。

**图1** AI识图示意图  
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216162749.19315385489373374942173618742941:50001231000000:2800:C5D70BDBB1D22658357FD591617E8222ABEA45FACE91B751B78710287C783D1F.png "点击放大")

## 约束与限制

- 支持的文本语种类型：简体中文、繁体中文、英文、维吾尔文、藏文。
- 支持图片最小规格100*100分辨率。
- 分析图像要求是静态非矢量图，即svg、gif等图像类型不支持分析，支持传入[PixelMap](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-image-pixelmap)进行分析，目前仅支持[RGBA_8888](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-image-e#pixelmapformat7)类型。
- 支持翻译的图片宽高最小比例为1:3（高度小于宽度的3倍），支持文本识别的图片宽高最小比例为1:7（高度小于宽度的7倍）。
- 当前设备支持本能力可以通过[getImageAnalyzerSupportTypes](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-image-common#getimageanalyzersupporttypes12)进行判断。
    
    日志返回格式为“SupportTypes: [_主体识别功能枚举值_,_文字识别功能枚举值_,_对象查找功能枚举值_]”，具体枚举值可参见[ImageAnalyzerType](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-image-common#imageanalyzertype12)。
    
    若返回“SupportTypes: []”，则说明当前设备不支持AI识图能力；若返回其他值，则说明当前设备支持AI识图能力。
    
    1. import { visionImageAnalyzer } from '@kit.VisionKit';
    
    2. @Entry
    3. @Component
    4. struct Index {
    5.   private aiController: visionImageAnalyzer.VisionImageAnalyzerController = new visionImageAnalyzer.VisionImageAnalyzerController()
    
    6.   build() {
    7.     Row() {
    8.       Button('getTypes')
    9.         .onClick(() => {
    10.           let SupportTypes = this.aiController.getImageAnalyzerSupportTypes()
    11.           console.info(`SupportTypes: ${JSON.stringify(SupportTypes)}`)
    12.         })
    13.     }
    14.   }
    15. }
    

## 开发步骤

1. 将AI识图控件相关的类添加。
    
    1. import { visionImageAnalyzer } from '@kit.VisionKit';
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
2. 初始化[VisionImageAnalyzerController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-image-analyzer#section37192953318)对象。
    
    1. private visionImageAnalyzerController: visionImageAnalyzer.VisionImageAnalyzerController = new visionImageAnalyzer.VisionImageAnalyzerController();
    
3. 添加订阅事件。
    
    1. aboutToAppear(): void {
    2.   this.visionImageAnalyzerController.on('imageAnalyzerVisibilityChange', (visibility: visionImageAnalyzer.ImageAnalyzerVisibility) => {
    3.     console.info("DEMO_TAG", `imageAnalyzerVisibilityChange result: ${JSON.stringify(visibility)}`)
    4.   })
    5.   this.visionImageAnalyzerController.on('textAnalysis', (text: string) => {
    6.     console.info("DEMO_TAG", `textAnalysis result: ${JSON.stringify(text)}`)
    7.   })
    8.   this.visionImageAnalyzerController.on('selectedTextChange', (selectedText: string) => {
    9.     console.info("DEMO_TAG", `selectedTextChange result: ${JSON.stringify(selectedText)}`)
    10.   })
    11.   this.visionImageAnalyzerController.on('subjectAnalysis', (subjects: visionImageAnalyzer.Subject[]) => {
    12.     console.info("DEMO_TAG", `subjectAnalysis result: ${JSON.stringify(subjects)}`)
    13.   })
    14.   this.visionImageAnalyzerController.on('selectedSubjectsChange', (subjects: visionImageAnalyzer.Subject[]) => {
    15.     console.info("DEMO_TAG", `selectedSubjectsChange result: ${JSON.stringify(subjects)}`)
    16.   })
    17.   this.visionImageAnalyzerController.on('analyzerFailed', (error: BusinessError) => {
    18.     console.error("DEMO_TAG", `analyzerFailed result: ${JSON.stringify(error)}`)
    19.   })
    20. }
    
4. 绑定[VisionImageAnalyzerController](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-image-analyzer#section37192953318)对象，可以控制识图相关的交互。
    
    1. build() {
    2.   Stack() {
    3.     // 需要替换您自己的资源图片，存放在resources/base/media目录下
    4.     Image($r('app.media.img'), {
    5.       types: [ImageAnalyzerType.TEXT, ImageAnalyzerType.SUBJECT, ImageAnalyzerType.OBJECT_LOOKUP],
    6.       aiController: this.visionImageAnalyzerController
    7.     })
    8.       .width('100%')
    9.       .height('100%')
    10.       .enableAnalyzer(true)
    11.       .objectFit(ImageFit.Contain)
    12.   }.width('100%').height('100%')
    13. }
    
5. 取消订阅事件。
    
    1. aboutToDisappear(): void {
    2.   this.visionImageAnalyzerController.off('imageAnalyzerVisibilityChange')
    3.   this.visionImageAnalyzerController.off('textAnalysis')
    4.   this.visionImageAnalyzerController.off('selectedTextChange')
    5.   this.visionImageAnalyzerController.off('subjectAnalysis')
    6.   this.visionImageAnalyzerController.off('selectedSubjectsChange')
    7.   this.visionImageAnalyzerController.off('analyzerFailed')
    8. }
    

## 开发实例

### Index.ets

1. import { visionImageAnalyzer } from '@kit.VisionKit';
2. import { BusinessError } from '@kit.BasicServicesKit'
3. @Entry
4. @Component
5. struct ImageDemo {
6.   private visionImageAnalyzerController: visionImageAnalyzer.VisionImageAnalyzerController = new visionImageAnalyzer.VisionImageAnalyzerController()
7.   aboutToAppear(): void {
8.     this.visionImageAnalyzerController.on('imageAnalyzerVisibilityChange', (visibility: visionImageAnalyzer.ImageAnalyzerVisibility) => {
9.       console.info("DEMO_TAG", `imageAnalyzerVisibilityChange result: ${JSON.stringify(visibility)}`)
10.     })
11.     this.visionImageAnalyzerController.on('textAnalysis', (text: string) => {
12.       console.info("DEMO_TAG", `textAnalysis result: ${JSON.stringify(text)}`)
13.     })
14.     this.visionImageAnalyzerController.on('selectedTextChange', (selectedText: string) => {
15.       console.info("DEMO_TAG", `selectedTextChange result: ${JSON.stringify(selectedText)}`)
16.     })
17.     this.visionImageAnalyzerController.on('subjectAnalysis', (subjects: visionImageAnalyzer.Subject[]) => {
18.       console.info("DEMO_TAG", `subjectAnalysis result: ${JSON.stringify(subjects)}`)
19.     })
20.     this.visionImageAnalyzerController.on('selectedSubjectsChange', (subjects: visionImageAnalyzer.Subject[]) => {
21.       console.info("DEMO_TAG", `selectedSubjectsChange result: ${JSON.stringify(subjects)}`)
22.     })
23.     this.visionImageAnalyzerController.on('analyzerFailed', (error: BusinessError) => {
24.       console.error("DEMO_TAG", `analyzerFailed result: ${JSON.stringify(error)}`)
25.     })
26.   }
27.   build() {
28.     Stack() {
29.       Image($r('app.media.img'), {
30.         types: [ImageAnalyzerType.TEXT, ImageAnalyzerType.SUBJECT, ImageAnalyzerType.OBJECT_LOOKUP],
31.         aiController: this.visionImageAnalyzerController
32.       })
33.         .width('100%')
34.         .height('100%')
35.         .enableAnalyzer(true)
36.         .objectFit(ImageFit.Contain)
37.     }.width('100%').height('100%')
38.   }
39.     aboutToDisappear(): void {
40.       this.visionImageAnalyzerController.off('imageAnalyzerVisibilityChange')
41.       this.visionImageAnalyzerController.off('textAnalysis')
42.       this.visionImageAnalyzerController.off('selectedTextChange')
43.       this.visionImageAnalyzerController.off('subjectAnalysis')
44.       this.visionImageAnalyzerController.off('selectedSubjectsChange')
45.       this.visionImageAnalyzerController.off('analyzerFailed')
46.     }
47. }

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/vision-documentscanner "文档扫描")
# 下载与安装DevEco Studio

更新时间: 2025-12-16 15:57

## 下载软件

请前往[下载中心](https://developer.huawei.com/consumer/cn/download/deveco-studio)，登录华为账号后下载DevEco Studio，并根据下载中心页面**工具完整性**指导进行完整性校验。

DevEco Studio支持Windows和macOS系统，下面将针对两种操作系统的软件安装方式分别进行介绍。

## Windows环境

### 运行环境要求

为保证DevEco Studio正常运行，建议电脑配置满足如下要求：

- 操作系统：Windows10 64位、Windows11 64位
- 内存：16GB及以上
- 硬盘：100GB及以上
- 分辨率：1280*800像素及以上

### 安装DevEco Studio

1. 下载完成后，双击下载的“deveco-studio-xxxx.exe”，进入DevEco Studio安装向导。在如下界面选择安装路径，默认安装于C:\Program Files路径下，也可以单击**浏览（B）...**指定其他安装路径，然后单击**下一步**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155720.08899713960309919511675964000288:50001231000000:2800:F464ED060738E4B1EDC2F3CFFF7266D22E1E08822B69327B1489656C35F9032C.png)
    
2. 在如下安装选项界面勾选**DevEco Studio**后，单击**下一步**，直至安装完成。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155720.59137857013160308565079889668641:50001231000000:2800:3E9BD4EC260711BA5CE7DEAD7E98526F20307A51066C99B74439BC0D1B9D6A5F.png)
    
3. 安装完成后，单击**Finish**完成安装。安装完成后，如有需要请根据[配置代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-environment-config)，检查和配置开发环境。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155720.47266238744069313733381321750409:50001231000000:2800:B530A8E0F00CC03BBEAD3E420DCEAC3B2ECC84E0E7C5E30D5F00873E2F323F69.png)
    
    说明
    
    - DevEco Studio提供开箱即用的开发体验，将HarmonyOS SDK、Node.js、Hvigor、OHPM、模拟器平台等进行合一打包，简化DevEco Studio安装配置流程。
    - HarmonyOS SDK已嵌入DevEco Studio中，无需额外下载配置。HarmonyOS SDK可以在DevEco Studio安装位置下DevEco Studio\sdk目录中查看。如需进行OpenHarmony应用开发，可通过File > Settings > OpenHarmony SDK页签下载OpenHarmony SDK。
    

## macOS环境

### 运行环境要求

为保证DevEco Studio正常运行，建议电脑配置满足如下要求：

- 操作系统：macOS(X86) 11/12/13/14/15、 macOS(ARM) 12/13/14/15
- 内存：8GB及以上
- 硬盘：100GB及以上
- 分辨率：1280*800像素及以上

### 安装DevEco Studio

1. 在安装界面中，将“**DevEco-Studio.app**”拖拽到“**Applications**”中，等待安装完成。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155720.37926227343571168699467859990323:50001231000000:2800:8E0739B3DF0C130CB36AE7024B388053924019D3DAE35EA9EA83B8F2D8E68782.png "点击放大")
    
2. 安装完成后，如有需要请根据[配置代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-environment-config)，检查和配置开发环境。
    
    说明
    
    - DevEco Studio提供开箱即用的开发体验，将HarmonyOS SDK、Node.js、Hvigor、OHPM、模拟器平台等进行合一打包，简化DevEco Studio安装配置流程。
    - HarmonyOS SDK已嵌入DevEco Studio中，无需额外下载配置。HarmonyOS SDK可以在DevEco Studio安装位置下DevEco Studio\sdk目录中查看。如需进行OpenHarmony应用开发，可通过DevEco Studio > Preferences/Settings **>** OpenHarmony SDK页签下载OpenHarmony SDK。
    

## 诊断开发环境

为了您开发应用/元服务的良好体验，DevEco Studio提供了开发环境诊断的功能，帮助您识别开发环境是否完备。您可以在欢迎页面单击**Diagnose**进行诊断。如果您已经打开了工程开发界面，也可以在菜单栏单击**Help > Diagnostic Tools > Diagnose Development Environment**进行诊断。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155720.12762000587267149309845943336316:50001231000000:2800:53F7BE8CEDAD08635BADA11B109109F89F26CE54746E827416C752997F752249.png)

DevEco Studio开发环境诊断项包括电脑的配置、网络的连通情况、依赖的工具是否安装等。如果检测结果为未通过，请根据检查项的描述和修复建议进行处理。

## 启用中文化插件

说明

该功能仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。

- 从DevEco Studio 6.0.0 Beta1版本开始，中文化插件默认启用。如需切换为中文显示效果，在菜单栏进入**File > Settings...**（macOS为**DevEco Studio > Preferences/Settings** ） **> Appearance & Behavior > System Settings** > **Language**，语言选择**Chinese**并点击**Apply**，在弹窗中点击**Restart**重启即可完成语言切换。若语言选择时未找到Chinese，请按照[之前版本操作](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-software-install#li1956431816322)启用插件后，再选择。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155720.82344715650021387926980137618851:50001231000000:2800:701FB938A3752198420D403E89E78CE6A4933567BA1EC89985C971031BDE1863.png)
    

- 若使用DevEco Studio 6.0.0 Beta1之前版本，请在菜单栏进入**File > Settings** （macOS为**DevEco Studio > Preferences** ）**> Plugins**，选择**Installed**页签，在搜索框输入“Chinese”，搜索结果里将出现**Chinese(Simplified)**，在右侧单击**Enable**，点击**OK**，在弹窗中单击**Restart**，重启DevEco Studio后即可生效。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.67237622539504458868220309338273:50001231000000:2800:735D53C16912FEDB4727EC853F7CD0322128BCDCDD4220C5EE8F645A2F8E4582.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-tools-overview "工具概述")
# 使用新UI

更新时间: 2025-12-16 15:57

DevEco Studio 6.0.0 Beta1版本适配IntelliJ 2024.3.3底座升级，同时提供全新的用户界面（User Interface，简称UI），简化工具布局，优化图标、窗口等显示效果，带来更简洁的外观及开发体验。

## 开启或关闭新UI

启动DevEco Studio 6.0.0 Beta1版本时，将有弹窗提示是否启用新用户界面。点击**Enable and Restart**，将重启DevEco Studio开始体验新UI。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.84544320888809327659322510011367:50001231000000:2800:C4D9FC7FC1B5DEA4F8F82A38078699AB5115166E1F72D4093A1B4CAE4C62CC6C.png)

此外，可以在菜单栏进入**File > Settings...**（macOS系统为**DevEco Studio > Preferences/Settings...**）**> Appearance & Behavior > New UI**，勾选**Enable new UI**，点击**Apply**，在弹窗中点击**Restart**重启完成后体验新UI。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.51449835235535993506766223136895:50001231000000:2800:D8AE8527BF47CFDD655A99A808D4D37D829E31DC52AB5B5B32B8E9419359D297.png)

如需切换回原有的经典UI，在界面左上角点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.36620405639346416944156411919907:50001231000000:2800:3D4CCB189EEB85DFE03A29A49563A0079D17EF0589B8535E6C25F68AF9F7FF03.png)图标，进入**File > Settings...** （macOS系统为**DevEco Studio > Preferences/Settings...**）**> Appearance & Behavior > New UI**，取消勾选**Enable new UI**，点击**Apply**，在弹窗中点击**Restart**重启即可完成切换。

## 菜单栏体验变化

原有固定于界面上方的菜单栏，在新UI中收起到页面左上角工具栏中Main Menu主菜单![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.99057764037581955084581451702765:50001231000000:2800:D192941B4D6DABC711CD8F3B940C4928D06CBF69EEEAFBCA6D965DA3E23104C0.png)图标内。点击图标即可展开菜单，继续选择需要执行的功能或操作。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.15654531270869400821486042132272:50001231000000:2800:2DBA2394451618A19A045A0B0933B81C22EAF30747C49796BFE633B0E9CE6E77.png)

如需将菜单栏展开并固定在主界面，可以在菜单栏进入**File > Settings... > Appearance & Behavior > Appearance** > **UI Options**中，勾选**Show main menu in a separate toolbar**，点击**Apply**在主界面固定显示菜单栏。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.71677989331504415737501864123111:50001231000000:2800:7AA8AFE47E22E7E8A29308724064EB98429051CA215CD294447B595C263A5486.png)

## 工具窗口优化

主窗口两侧的工具窗口提供更丰富的功能选择。与经典UI相比，ArkUI Inspector、Services、Terminal、Problems、Version Control等功能图标在左侧工具窗口中呈现。点击工具窗口中Project![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.01620344790495678380627665858104:50001231000000:2800:42B1F9E907E3B08CCD1686B236D6C57D14BF411110049AAF02561AAF316EE7D9.png)图标，显示当前工程目录。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.66458829920607467435855931144089:50001231000000:2800:2C4C79731733614878BB3DBF73DFFA5FDEC22459F14DE9C698BF6B37B2360B25.png)

在菜单栏进入**File > Settings... > Appearance & Behavior > Appearance** > **Tool Windows，**勾选**Show tool window names**后点击**Apply**，或将鼠标放置于工具窗口区域右键选择**Show Tool Window Names**，选择在界面中展示各功能图标的名称。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.31838107708525274450741901133898:50001231000000:2800:738F426DB8AF028E99BBC33980A575055316FD7CF1AB6D15FDA81D4333498BDB.png)

## 文件路径展示位置变化

在新UI中，当前编辑的文件所在的工程路径将展示在页面左下方。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155721.50653844873823982112931154187140:50001231000000:2800:54971B55487D171E8566CE39CFA466B32239E70324F0551E21BC3A8F88AF7B4A.png "点击放大")

说明

更多新用户界面变化详情，请参见[new UI](https://www.jetbrains.com.cn/en-us/help/idea/2024.3/new-ui.html)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-software-install "下载与安装DevEco Studio")
# 工程介绍

更新时间: 2025-12-16 15:57

## 应用程序包基础知识

开发应用前，请先了解应用程序包相关基础知识，具体请参考[应用程序包概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-overview)。

## 切换工程视图

DevEco Studio工程目录结构提供工程视图和Ohos视图。工程视图（Project）展示工程中实际的文件结构，Ohos视图会隐藏一些编码中不常用到的文件，并将常用到的文件进行重组展示，方便开发者查询或定位所需编辑的模块或文件。

工程创建或打开后，默认显示工程视图，如果要切换到Ohos视图，在左上角单击**Project** > **Ohos**进行切换**。**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.80293489663028796317413532183697:50001231000000:2800:1AF6D9029A7A250017D35767680AD1C1D3C9FBBA16342630FE4FB9369E4219E1.png)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-project "工程创建")
# 工程目录结构

更新时间: 2025-12-16 15:57

## ArkTS工程目录结构（Stage模型）

ArkTS Stage模型支持API Version 10及以上版本，其工程目录结构如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.99592238482924915337565247591747:50001231000000:2800:FBC8D6D84F5779B09CBC24B4A93A34F71E7DC068F482C9A739C8A51A926E5726.png)

- **AppScope > app.json5**：应用的全局配置信息。
- **entry：**应用/元服务模块，编译构建生成一个HAP。
    - **src > main > ets**：用于存放ArkTS源码。
    - **src > main > ets > entryability**：应用/元服务的入口。
    - **src > main > ets > entrybackupability**：用于提供扩展备份恢复能力。
    - **src > main > ets > pages**：应用/元服务包含的页面。
    - **src > main > resources：**用于存放应用/元服务模块所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考[资源分类与访问](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resource-categories-and-access)。
        
        |资源目录|资源文件说明|
        |:--|:--|
        |base>element|包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如：<br><br>- boolean.json：布尔型<br>- color.json：颜色<br>- float.json：浮点型<br>- intarray.json：整型数组<br>- integer.json：整型<br>- pattern.json：样式<br>- plural.json：复数形式<br>- strarray.json：字符串数组<br>- string.json：字符串值|
        |base>media|多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：**.png**、**.gif**、**.mp3**、**.mp4**等。|
        |rawfile|用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。|
        
    - **src > main > module.json5**：Stage模型模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。具体请参考[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)。
    - **src > main >** **mock****：**配置测试框架的Mock能力。具体请参考[Mock能力](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-test-mock)。
    - **src > main >** **ohosTest：**存放Instrument Test测试类。具体请参考[Instrument Test](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-instrument-test)。
    - **src > main >** **test：**存放Local Test创建测试类。具体请参考[Local Test](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-local-test)。
    - **build-profile.json5：**当前的模块信息、编译信息配置项，包括buildOption、targets配置等。
    - **hvigorfile.ts**：模块级编译构建任务脚本。
    - **obfuscation-rules.txt**：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。详见[混淆加固](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation)。
    - **oh-package.json5**：描述三方包的包名、版本、入口文件（类型声明文件）和依赖项等信息。
- **oh_modules**：用于存放三方库依赖信息，包含应用/元服务所依赖的第三方库文件。
- **build-profile.json5：**应用级配置信息，包括签名、产品配置等。
- **code-linter.json5：**配置代码检查规则，包括代码检查范围、生效的规则等。
- **hvigorfile.ts：**应用级编译构建任务脚本。
- **oh-package.json5：**描述全局配置，如：依赖覆盖（overrides）、依赖关系重写（overrideDependencyMap）和参数化配置（parameterFile）等。
- **oh-package-lock.json5：**用于锁定应用级依赖的版本，以及缓存依赖的元数据信息。

## C++工程目录结构（Stage模型）

C++ Stage模型支持API Version 10以上版本，支持使用ArkTS和C++进行开发，其工程目录结构如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.82712482445929085152979814786937:50001231000000:2800:013FDC1E7F42095C8DE64D2CC0C94F1EE1EC63722FFC11DD6A1FEC597E2FF84C.png)

- **entry**：应用模块，编译构建生成一个HAP。
    - **src > main > cpp > types**：用于存放C++的API接口描述文件
    - **src > main > cpp > types** **> libentry > index.d.ts**：描述C++ API接口行为，如接口名、入参、返回参数等。
    - **src > main > cpp > types** **> libentry> oh-package.json5**：配置.so三方包声明文件的入口及包名。
    - **src > main > cpp > CMakeLists.txt**：CMake配置文件，提供CMake构建脚本。
    - **src > main > cpp > napi_init.cpp：**定义C++ API接口的文件**。**
    - **src > main > ets：**用于存放ArkTS源码。
    - **src > main > resources：**用于存放应用所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考[资源分类与访问](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resource-categories-and-access)。
        
        |资源目录|资源文件说明|
        |:--|:--|
        |base>element|包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如：<br><br>- boolean.json：布尔型<br>- color.json：颜色<br>- float.json：浮点型<br>- intarray.json：整型数组<br>- integer.json：整型<br>- pattern.json：样式<br>- plural.json：复数形式<br>- strarray.json：字符串数组<br>- string.json：字符串值。|
        |base>media|多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：**.png**、**.gif**、**.mp3**、**.mp4**等。|
        |rawfile|用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。|
        
    - **src > main > module.json5：**Stage模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。具体请参考[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)。
    - **build-profile.json5：**当前的模块信息、编译信息配置项，包括buildOption、targets配置等。
    - **hvigorfile.ts：**模块级编译构建任务脚本。
    - **obfuscation-rules.txt**：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。详见[混淆加固](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation)。
    - **oh-package.json5**：描述三方包的包名、版本、入口文件（类型声明文件）和依赖项等信息。
    - **oh-package-lock.json5：**用于锁定当前模块依赖的版本，以及缓存依赖的元数据信息。
- **oh_modules**：用于存放三方库依赖信息，包含应用/元服务所依赖的第三方库文件。
- **hvigorfile.ts**：应用级编译构建任务脚本。
- **build-profile.json5：**应用级配置信息，包括签名、产品配置等。
- **code-linter.json5：**配置代码检查规则，包括代码检查范围、生效的规则等。
- **hvigorfile.ts：**应用级编译构建任务脚本。
- **oh-package.json5：**描述全局配置，如：依赖覆盖（overrides）、依赖关系重写（overrideDependencyMap）和参数化配置（parameterFile）等。
- **oh-package-lock.json5：**用于锁定应用级依赖的版本，以及缓存依赖的元数据信息。

## JS工程目录结构（FA模型）

JS工程只支持FA模型，其工程目录结构如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.46590681877019045670641291632684:50001231000000:2800:C050584D57E60CEDD39A76B2F9F9F6390A0EE4AF1069AF73A83B5D30E23AB9F0.png)

- **entry：**应用/元服务模块，编译构建生成一个HAP。
    - **src > main > js**：用于存放js源码。
    - **src > main > js > MainAbility**：应用/元服务的入口。
    - **src > main > js > MainAbility > i18n**：用于配置不同语言场景资源内容，比如应用文本词条、图片路径等资源。
    - **src > main > js > MainAbility > pages**：MainAbility包含的页面。
    - **src > main > js > MainAbility > app.js**：承载Ability生命周期。
    - **src > main > resources：**用于存放应用/元服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考[资源分类与访问](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resource-categories-and-access)。
        
        |资源目录|资源文件说明|
        |:--|:--|
        |base>element|包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如：<br><br>- boolean.json：布尔型<br>- color.json：颜色<br>- float.json：浮点型<br>- intarray.json：整型数组<br>- integer.json：整型<br>- pattern.json：样式<br>- plural.json：复数形式<br>- strarray.json：字符串数组<br>- string.json：字符串值|
        |base>media|多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：**.png**、**.gif**、**.mp3**、**.mp4**等。|
        |rawfile|用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。|
        
    - **src > main > config.json**：模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。
    - **build-profile.json5：**当前的模块信息、编译信息配置项，包括buildOption、targets配置等。
    - **hvigorfile.ts**：模块级编译构建任务脚本。
    - **oh-package.json5**：配置三方包声明文件的入口及包名。
- **build-profile.json5：**应用级配置信息，包括签名、产品配置等。
- **hvigorfile.ts：**应用级编译构建任务脚本。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-project-overview "工程介绍")
# 工程模板介绍

更新时间: 2025-12-16 15:57

DevEco Studio支持多种品类的应用/元服务开发，预置丰富的工程模板，可以根据工程向导轻松创建适应于各类设备的工程，并自动生成对应的代码和资源模板。同时，DevEco Studio还提供了多种编程语言供开发者进行应用/元服务开发，包括ArkTS、JS和C/C++。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.53633840390243232091130445478893:50001231000000:2800:39A2566EE3E628BBF2045367A2ED9D462AF8E959BB759E2FE4BE73BF24221594.png)

工程模板支持的开发语言及模板说明如下表所示：

|模板名称|说明|
|:--|:--|
|Empty Ability|用于Phone、Tablet、2in1、Car、Wearable、TV设备的模板，展示基础的Hello World功能。|
|Native C++|用于Phone、Tablet、2in1、Car、Wearable、TV设备的模板，作为应用调用C++代码的示例工程，界面显示“Hello World”。|
|[CloudDev]Empty Ability|端云一体化开发通用模板。更多信息请参见[端云一体化开发](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddevguide)。<br><br>**约束与限制**：该功能仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。|
|[Lite]Empty Ability|用于Lite Wearable设备的模板，展示了基础的Hello World功能。可基于此模板，修改设备类型及RuntimeOS，进行小型嵌入式设备开发。|
|Flexible Layout Ability|用于创建跨设备应用开发的三层工程结构模板。三层工程结构包含common（公共能力层）、features（基础特性层）、products（产品定制层）。|
|Embeddable Ability|用于开发支持被其他应用嵌入式运行的元服务的工程模板。|
|[ArkUI-X]Empty Ability|创建一个展示基础的Hello World功能的模板，构建基于HarmonyOS应用的跨平台应用包。更多信息请参见[ArkUI-X概览](https://gitcode.com/arkui-x/docs/blob/master/zh-cn/ArkUI-X-Overview-zh.md#arkui-x%E6%A6%82%E8%A7%88)。|
|[ArkUI-X]Library|用于基于HarmonyOS应用构建跨平台应用的依赖包。依赖包支持添加到已有的应用中。更多信息请参见[ArkUI-X概览](https://gitcode.com/arkui-x/docs/blob/master/zh-cn/ArkUI-X-Overview-zh.md#arkui-x%E6%A6%82%E8%A7%88)。|
|[ArkUI-X]Native C++|创建一个调用C++代码的示例工程，构建基于HarmonyOS应用的跨平台应用包。更多信息请参见[ArkUI-X概览](https://gitcode.com/arkui-x/docs/blob/master/zh-cn/ArkUI-X-Overview-zh.md#arkui-x%E6%A6%82%E8%A7%88)。|

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-project-structure "工程目录结构")
# 创建一个新的工程

更新时间: 2025-12-16 15:57

当您开始开发一个应用/元服务时，首先需要根据工程创建向导，创建一个新的工程，工具会自动生成对应的代码和资源模板。

说明

在运行DevEco Studio工程时，建议每一个运行窗口有2GB以上的可用内存空间。

## 创建和配置新工程

DevEco Studio提供了基础的工程模板资源，不同模板支持的设备类型、API Version可能不同，在创建新工程前，请提前了解各模板的相关信息，具体请参考[工程模板介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-template)。

从DevEco Studio 6.0.1 Beta1开始，创建Native C++工程时支持选择C++版本。

### 创建HarmonyOS工程

1. 通过如下两种方式，打开工程创建向导界面。
    
    - 如果当前未打开任何工程，可以在DevEco Studio的欢迎页，选择**Create Project**开始创建一个新工程。
    - 如果已经打开了工程，可以在菜单栏选择**File > New > Create Project**来创建一个新工程。
    
2. 根据工程创建向导，选择创建Application或[Atomic Service](https://developer.huawei.com/consumer/cn/doc/atomic-guides/atomic-service-create-project)。再选择需要的Ability工程模板，然后单击**Next**。
    
    说明
    
    - 从API 11版本开始支持Atomic Service元服务工程开发。
    - Atomic Service元服务工程暂不支持Native开发。
    - [CloudDev]Empty Ability模板：该功能仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.23195093282326869386588000404613:50001231000000:2800:7281A522D0BB69243E7914B2D6C589164D609D3CB088B31B03F8A13D7CAAF53E.png)
    
3. 在工程配置页面，需要根据向导配置工程的基本信息。
    
    - **Project name**：工程的名称，可以自定义，由大小写字母、数字和下划线组成，必须由大小写字母开头，长度为1~200个字符。
    - **Bundle name**：标识应用的包名，用于标识应用的唯一性。
        
        说明
        
        应用包名要求：
        
        - 必须为以点号（.）分隔的字符串，且至少包含三段，每段中仅允许使用英文字母、数字、下划线（_），如“com.example.myapplication ”。
        - 首段以英文字母开头，非首段以数字或英文字母开头，每一段以数字或者英文字母结尾，如“com.01example.myapplication”。
        - 不允许多个点号（.）连续出现，如“com.example..myapplication ”。
        - 长度为7~128个字符。
        
    - **Save location**：工程文件本地存储路径，由大小写字母、数字和下划线等组成，不能包含中文字符。
    - **Compatible SDK**：兼容的最低API Version。
    - **Module name**： 模块的名称。
    - **Device type：**该工程模板支持的设备类型。设备类型说明请参考[deviceTypes标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#devicetypes%E6%A0%87%E7%AD%BE)。
    - **C++ Standard：**C++标准库，取值包括：Toolchain Default、C++11、C++14。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.42531458612307277013659704246221:50001231000000:2800:284E0F87FE7F52B64F2B62E4F941672FFAD3EE584908C20A8E32925120CE22DC.png)
    
4. 单击**Finish**，工具会自动生成示例代码和相关资源，等待工程创建完成。

### （可选）创建OpenHarmony工程

如需创建OpenHarmony工程进行应用开发，请按照以下步骤操作。

1. 在完成[创建HarmonyOS工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-create-new-project#section11644183711342)后，根据如下操作修改工程级build-profile.json5文件中相关字段：
    
    1. 在工程级build-profile.json5文件添加**compileSdkVersion**字段。
    2. 将**compatibleSdkVersion**、**compileSdkVersion**、**targetSdkVersion**（若有）字段赋值为数值类型。
    3. 将runtimeOS从"HarmonyOS"修改为**"OpenHarmony"**。
    
    4. "products": [
    5.   {
    6.     "name": "default",
    7.     "signingConfig": "default", 
    8.     "compileSdkVersion": 20,    //指定OpenHarmony应用编译时的版本，当前以API 20为例
    9.     "targetSdkVersion": 20,     //指定OpenHarmony应用运行所需的目标SDK版本，当前以API 20为例
    10.     "compatibleSdkVersion": 20, //指定OpenHarmony应用兼容的最低版本，当前以API 20为例
    11.     "runtimeOS": "OpenHarmony",
    12.   }
    13. ],
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.98614772796232544224335863209671:50001231000000:2800:BAA4D665489F09825EC8979D0013275DD9C329AEF3C85BECCF424D0F9667FC70.png)
    
2. 单击Sync Now进行同步。在Sync Check弹窗中点击**Yes**，同意将module.json5/config.json文件中的phone切换为OpenHarmony支持的default类型，并删除在OpenHarmony不适用的其他设备类型，同步成功无其他报错则工程创建完成。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155722.88995959674805879823068836774831:50001231000000:2800:20C6C809C880FEA490E97D43AE34363B22789074325569A968009C0EA3540207.png)
    

说明

若选择Native C++模板创建OpenHarmony应用，且应用需要在RK开发板上运行，则需在对应Native模块的build-profile.json5文件buildOption/externalNativeOptions字段下，新增abiFilters字段并赋值为"armeabi-v7a"。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-template "工程模板介绍")
# 生成单层图标

更新时间: 2025-12-16 15:57

DevEco Studio支持Image Asset功能，帮助开发者生成适应不同设备、不同屏幕密度的图标，并展示图标在目录中的具体位置。

说明

当前Image Asset功能支持为Phone、Tablet、2in1应用生成单层图标。

Image Asset支持生成以下两种类型图标：

- icon：应用图标（设备桌面及设置>应用中出现的应用图标）。
- start window icon：启动页图标。

1. 在工程中选中模块或文件，右键单击**New > Image Asset**，进入图标配置页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.43882226126480418311201579433825:50001231000000:2800:9389A3A420E565D715C5B0F1A8BF159577AFB82262F2084A87C9FB49C932A061.png "点击放大")
    
    说明
    
    若在模块级目录（Entry或其他模块）下新建Image Asset，将创建Icon and start window icon类型图标，用于在module.json5文件中配置icon及startWindowIcon字段；在工程级目录（AppScope或其他目录）下新建Image Asset，将创建Icon类型图标，用于在app.json5文件中配置icon字段。
    
2. 需要根据向导配置图标样式、大小等基本信息。
    
    - **Device**：选择当前配置的图标生效的设备类型。
    - **Icon Type**：展示当前图标的类型。
    - **Name**：配置图标名称。命名支持使用字母、数字、下划线，长度最多128个字符，不支持中文命名。
    - **Foreground Layer**：分层图标资源前景层。可配置下列字段信息：
        - **Path**：选择前景Image存放路径。推荐使用的图标尺寸为1024px*1024px，保证图标整体的清晰性。
        - **Trim**：选择Yes，将调整图标图形与边框之间的距离，同时会去除图片周围多余的透明空间。
        - **Resize**：拖动滑块，设置图形的缩放比例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.32046031362665436336848369114478:50001231000000:2800:0FB97DF60C6C2D2C7CEF6B21CCDBF96EDA2F4323F6491657C99C419327ED5D83.png)
    
    - **Background Layer**：分层图标资源背景层。请配置下列字段信息：
        - **Asset Type**：设置图标背景类型。可以选择颜色（**Color**）或图像（**Image**）。
        - **Color**：点击色块区域，选择适当的背景色。
        - **Path**：选择背景Image路径。推荐使用的图标尺寸为1024px*1024px，保证图标整体的清晰性。
        - **Trim**：选择Yes，将调整图标图形与边框之间的距离，同时会去除图片周围多余的透明空间。
        - **Resize**：拖动滑块，设置图形的缩放比例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.87182526803356028548042096833799:50001231000000:2800:456D4FAD89E511563F954C487BFADBEF5F28E1B7F090A17061727928787E44EE.png)
    
3. 点击**Next**，确认图标相应的尺寸信息，点击**Finish**完成图标生成，图标将默认存放在**resources** 目录下。
    
    icon.png为桌面图标，icon_start window.png为启动页图标，Size为图标的尺寸信息，不同尺寸对照关系如下：
    
    - sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为(0, 120]的设备。
    - mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120, 160]的设备。
    - ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160, 240]的设备。
    - xldpi：表示特大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240, 320]的设备。
    - xxldpi：表示超大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320, 480]的设备。
    - xxxldpi：表示超特大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.30533306650590655748533798046818:50001231000000:2800:ED76343DA2EA74C1842E6A41E52E1B9E9F828E0D4ADA29EE85912CA0B0257645.png)
    
4. 如需配置桌面或设置页面出现的应用图标，可将module.json5文件中icon字段修改为新生成的图标名称；如需修改启动页的icon图标，可将module.json5文件中startWindowIcon字段修改为新生成的图标名称。
    
    说明
    
    - 当上述字段配置了新生成的图标名称后，系统会根据当前设备状态优先从相匹配的限定词目录，即步骤[3](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-apply-generated-icon#zh-cn_topic_0000002166648820_li094548151616)生成的不同尺寸的图标文件中寻找资源。具体请参考[资源匹配](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resource-categories-and-access)。
    - 若module.json5文件中未配置icon字段，系统将使用app.json5中icon字段配置的图标。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-create-new-project "创建一个新的工程")
# 添加/删除模块

更新时间: 2025-12-16 15:57

模块（Module）是应用/元服务的基本功能单元，包含了源代码、资源文件、第三方库及应用/元服务配置文件。一个应用/元服务通常会包含一个或多个模块，因此，可以在工程中创建多个模块。模块支持entry、feature（仅应用工程支持创建）、har、shared四种类型，具体请参考[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%87%E7%AD%BE)。

从DevEco Studio 6.0.1 Beta1开始，创建Native C++模块或Library模板时支持选择C++版本。

## 创建新的模块

1. 通过如下三种方法，在工程中添加新的模块。
    
    - 方法1：鼠标移到工程目录顶部，单击鼠标右键，选择**New > Module**...，开始创建新的Module，此时该模块将创建在工程根目录下。
    - 方法2：选中工程目录中任意文件，然后在菜单栏选择**File > New > Module**...，开始创建新的Module，此时该模块将创建在工程根目录下。
    - 方法3：在工程根目录下创建一个新的Directory，可在该目录下单击鼠标右键，选择**New > Module**...，创建新的模块，此时模块将创建在该文件目录下，方便开发者对模块进行分类管理。
        
        说明
        
        当前暂不支持在AppScope、hvigor、oh_modules、build、以点开头的目录（如：.hvigor、.idea）下通过单击鼠标右键创建模块。
        
    
2. 在**New Project Module**界面中，选择需要创建的模板，单击**Next**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.65766727333323316386109862372930:50001231000000:2800:47355C87D856BAF3F6222041647B896BF2F426AB245461113B55FF88D9DE05B5.png)
    
3. 在模块配置页面，设置新增模块的基本信息，然后单击**Next**。从DevEco Studio 6.0.1 Beta1开始，支持选择C++版本。
    
    - **Module name**：新增模块的名称，**Module name**不可与工程名称/工程中其他模块名称相同。
    - **Module type**：仅在Ability模板存在该字段，可以选择Feature和Entry类型。
        
        说明
        
        - 同一工程通过新增模块仅支持创建一个Entry模块。如需构建Entry类型模块，可在module.json5文件中修改相应module下的type字段。
        - 如果同一类型的设备已经存在Entry模块，出现新的Entry模块后，还需要[配置分发策略](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#distributionfilter%E6%A0%87%E7%AD%BE)。
        
    - **Device type**：选择模块的设备类型，如果新建模块的Module type为feature，则只能选择该工程原有的设备类型；如果Module type为entry，可以选择该模块支持的其他设备类型。
    - **Enable native**：仅Library模板存在，将创建一个可以调用C/C++的共享包。
    - **C++ Standard：**C++标准库，取值包括：Toolchain Default、C++11、C++14。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.36582182613463809921591451403535:50001231000000:2800:9ED0B6693E8605BFD2E33B21903CFF36775A9C6ECD3F17F878F7662F5050C99C.png)
    
4. 若该模块的模板类型为Ability，还需要设置新增Ability的**Ability name**和****E****xported****参数，**E****xported**参数表示该Ability是否可以被其它应用/元服务所调用（FA模型下为Visible参数)。
    
    - 勾选（true）：可以被其它应用/元服务调用。
    - 不勾选（false）：不能被其它应用/元服务调用。
    
5. 单击**Finish**，等待创建完成后，可以在工程目录中查看和编辑新增的模块。工程中所包含模块的信息可以在[build-profile.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-build-profile-app)中modules字段进行配置。

## 导入/引用模块

DevEco Studio支持通过以下两种方式导入其他工程下的模块：

1. 通过[Import Module](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-add-new-module#section13771399184)功能，将其它HarmonyOS模块的功能代码复制到当前工程中；当前仅支持FA模型的模块导入到FA模型，Stage模型的模块导入到Stage模型。不支持FA模型的模块导入到Stage模型，或Stage模型的模块导入到FA模型。
2. 通过在[srcPath字段下配置相对路径](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-add-new-module#section12961144312265)的方式引用其他工程下的模块，该方式仅引用模块相关信息，不会将模块代码完全复制至本地。当前支持引用其他工程下的HAR和HSP模块。

### Import Module

1. 在菜单栏单击**File > New > Import... > Import Module。**
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.66260707689037492787774962457508:50001231000000:2800:AAF201C095334B219E32674F7712296BFC25A6EA91BCEFCCBF440651049B7CEC.png)
    
2. 选择导入的模块。
    
    在指定路径下，选择导入的模块，单击**OK**。导入的模块可以为文件夹，也可以为zip格式。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.95650501753510399377621798914722:50001231000000:2800:94569BA101E2C703655E62025CB11A96881E1FEC91F0DA88C7690708776D2C84.png)
    

### srcPath方式引用模块

在工程级build-profile.json5文件中，如下图所示在modules > srcPath字段下配置工程外模块的相对路径，即可引用模块相关信息，不会将模块代码完全复制至本工程中。当前支持引用其他工程下的HAR和HSP模块。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155723.21542642706618316402339547717156:50001231000000:2800:0ADF876F5B3DED0A03BBAB7EC68C52E24D4CC113A066481A36E3FD02FC19623B.png)

## 删除Module

在工程目录中选中要删除的模块，单击鼠标右键，选中**Delete**，并在弹出的对话框中单击**Delete**。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-module-management "模块管理")
# 开发静态共享包

更新时间: 2025-12-16 15:57

HAR（Harmony Archive）是静态共享包，可以包含代码、C++库、资源和配置文件。通过HAR可以实现多个模块或多个工程共享ArkUI组件、资源等相关代码。HAR不同于HAP，不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。

本文将介绍如何创建HAR模块、如何编译共享包。接下来，将简单介绍HAR模块的工程结构，如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155726.53888491125538640728525782698248:50001231000000:2800:27EE252E1969E5C0387CDE863A5A0B2675CCA54DE37938A4D998755C464588F3.png)

相关字段的描述如下，其余字段与Entry或Feature模块相关字段相同，可参考[工程介绍](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-project-overview)。

- **libs**：用于存放.so文件。
- **src > main > cpp > types**：用于存放C++ API描述文件，子目录按照so维度进行划分。
- **src > main > cpp > types** **> liblibrary > Index.d.ts**：描述C++接口的方法名、入参、返回参数等信息。
- **src > main > cpp > types** **> liblibrary > oh-package.json5**：描述so三方包声明文件入口和so包名信息。
- **src > main > cpp >** **CMakeLists.txt**：CMake配置文件，提供CMake构建脚本。
- **src > main > cpp > napi_init.cpp**：共享包C++代码源文件。
- **Index.ets**：共享包导出声明的入口。

从DevEco Studio 6.0.1 Beta1开始，创建HAR模块时支持选择C++版本。

## 创建HAR模块

1. 鼠标移到工程目录顶部，单击右键，选择**New > Module**，在工程中添加模块。
2. 在**Choose Your Ability Template**界面中，选择**Static Library**，并单击**Next**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155726.43888626788809884100727705803022:50001231000000:2800:6417E7AA3971D363F8C3E0FB84C51E67FB8EB1A99E01C26E605377A0DB89F3A2.png)
    
3. 在**Configure New Module**界面中，设置新添加的模块信息，设置完成后，单击**Finish**完成创建。从DevEco Studio 6.0.1 Beta1开始，支持选择C++版本。
    
    - **Module name**：新增模块的名称。
    - **Device type**：支持的设备类型。
    - **Enable native**：创建用于调用C++代码的模块。
    - **C++ Standard：**C++标准库，取值包括：Toolchain Default、C++11、C++14。仅打开Enable native时需要配置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155726.63661826272151944743839091254914:50001231000000:2800:6C19C16436E30D3F4027584C20833D87F9CF55B0FC4076B08D7666AC20E7DB8A.png)
    
    创建完成后，会在工程目录中生成HAR模块及相关文件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155726.86916347498466778587959822185190:50001231000000:2800:0B14CE2E64C89FEC08C7C2305CEE4A74A0A431B53224EC595BCE87CB3126F313.png)
    

## 编译HAR模块

开发完HAR模块后，选中模块名，然后通过DevEco Studio菜单栏的**Build > Make Module ${libraryName}**进行编译构建，生成HAR。HAR可供工程其他模块引用，或将HAR上传至ohpm仓库，供其他开发者下载使用。若部分源码文件不需要打包至HAR中，可通过[创建.ohpmignore文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-build-har#li5533646204511)，配置打包时要忽略的文件/文件夹。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155727.30102334398676007025061604641539:50001231000000:2800:9AD7FB68092F1F5CBD00C0988BF844FF6D4A13379AF4DD40C851DBB0FBE21911.png)

编译构建的HAR可在模块下的build目录下获取，包格式为*.har。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155727.77942613638863701612370468769143:50001231000000:2800:FE4FD91ABB561A3AD5C8FEE7470C992106368D12F38D5DFECB083AE265C4E22F.png)

在编译构建HAR时，请注意以下事项：

- 编译构建HAR的过程中，不会将模块中的C++代码直接打包进.har文件中，而是将C++代码编译成动态依赖库.so文件放置在.har文件中的libs目录下。
- 在编译构建HAR的过程中，会生成资源文件ResourceTable.txt，以便编辑器可以对HAR中的资源文件进行联想。因此，如果不使用DevEco Studio对HAR进行构建，则DevEco Studio的编辑器会无法联想HAR中的资源。
- 如果使用的Hvigor为2.5.0-s及以上版本，在编译构建HAR的过程中，会将dependencies内处于本模块路径下的本地依赖也打包进.har文件中；如果在打包后发现缺少部分本地依赖（如cpp/types目录），请参见[FAQ](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-23)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-creating-har-api9 "开发及发布共享包")
# 开发动态共享包

更新时间: 2025-12-16 15:57

DevEco Studio支持开发动态共享包[HSP（Harmony Shared Package）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp)。在应用/元服务开发过程中部分功能按需动态下载，或开发元服务场景时需要分包加载，可使用HSP实现相应功能。当有多个安装包需要资源共享时，也可利用HSP减少公共资源和代码重复打包。

说明

- 应用内HSP：在编译过程中与应用包名（bundleName）强耦合，只能给某个特定的应用使用。
- 集成态HSP：构建、发布过程中，不与特定的应用包名耦合；使用时，工具链支持自动将集成态HSP的包名替换成宿主应用包名。

## 使用约束

- HSP及其使用方都必须是API 10及以上版本Stage模型。
- HSP及其使用方都必须使用[模块化编译](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-esmodule-compile)模式。
- 从DevEco Studio 6.0.1 Beta1开始，创建HSP模块时支持选择C++版本。

## 开发动态共享包

### 创建HSP模块

1. 通过如下两种方法，在工程中添加新的Module。
    
    - 方法1：鼠标移到工程目录顶部，单击鼠标右键，选择**New > Module**，开始创建新的Module。
    - 方法2：选中工程目录中任意文件，然后在菜单栏选择**File > New > Module**，开始创建新的Module。
    
2. 模板类型选择**Shared Library**，点击**Next**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155727.29321331877466557204107286596835:50001231000000:2800:9D112F9A528FB74CE4BAC8D5747F969831EA4E79A0ED996988FD72845D2FF3AB.png)
    
3. 在**Configure New Module**界面中，设置新添加的模块信息，设置完成后，单击**Finish**完成创建。从DevEco Studio 6.0.1 Beta1开始，支持选择C++版本。
    
    - **Module name**：新增模块的名称，如设置为sharedlibrary。
    - **Device type**：支持的设备类型。
    - **Enable native**：是否创建一个用于调用C++代码的模块。
    - **C++ Standard：**C++标准库，取值包括：Toolchain Default、C++11、C++14。仅打开Enable native时需要配置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155727.52030045350055057453634883662523:50001231000000:2800:26A1CB098B96E55BB54464F250976C66195F218DE111BC5F35BCA0731867AB35.png)
    
    创建完成后，会在工程目录中生成HSP模块及相关文件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155727.94275457622746112118157284797225:50001231000000:2800:0E226E720CCE80FE5B826CD981CDA19659B3321DC7CE37DFAD8C60C16C3F954E.png)
    

### 编译HSP模块

说明

如果HSP未开启[混淆](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation)，则后续HSP被集成使用时，将不会再对HSP包进行混淆。

参考[应用内HSP开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp)开发完HSP模块后，选中模块名，然后通过DevEco Studio菜单栏的**Build > Make Module ${libraryName}**进行编译构建，生成HSP。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155727.76460645051038157106127146513114:50001231000000:2800:6E90487529D0B3B0344919A78B17E3BE8C11FB1051649F732998C4113C5FEC10.png)

打包HSP时，会同时默认打包出HAR，在模块下build目录下可以看到*.har和*.hsp。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.41401473999412650142586532944341:50001231000000:2800:3D3CE74F1D3EAD518030589CBCAA7E93B0716D974834F1F9B702A7579C47B0AD.png)

如需在应用内共享HSP，请将HSP共享包上传至私仓（请参考[将三方库发布到 ohpm-repo](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-quickstart#zh-cn_topic_0000001792256157_%E4%BB%8Eohpm-repo%E8%8E%B7%E5%8F%96%E4%B8%89%E6%96%B9%E5%BA%93)），请先按以下操作编译生成*.tgz包。

1. 点击工具栏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.64336966592429501619052292234065:50001231000000:2800:D6BE0D373F373E2FF8B89E320E48767A49A04AD5671B6CDE23B5417D02091823.png)图标将编译模式切换成release模式。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.11160360516092993950132194960675:50001231000000:2800:5E51FE52806C93336054FA1AA2A3E666734828FC150E901D54FD12074436187F.png)
    
2. 选中HSP模块的根目录，点击**Build > Make Module ${libraryName}**启动构建。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.78052071422035256789695438163247:50001231000000:2800:2E319C7D75EC0958102A7FC05B48B296EF08C8A8D4C0F0AE579F342B85A89E67.png)
    
    构建完成后，build目录下生成HSP包产物，其中.tgz用来上传至私仓。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.05260775554890008204272618191502:50001231000000:2800:7147196AA827EEA7D269615C5ECCFD7A3F1F51786AD7DB5D4ACE3BE55B4DBF19.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-har "开发静态共享包")
# 发布共享包

更新时间: 2025-12-16 15:57

发布打包的HAR，可供其他开发者安装和引用。接下来将介绍如何发布HAR共享包。

说明

OpenHarmony三方库中心仓仅支持HAR共享包发布，不支持HSP共享包发布。如需在应用内共享HSP，可将HSP共享包发布至私仓使用，请参考[ohpm私仓搭建工具](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-overview)。

1. 在HAR模块中（与src文件夹同一级目录下），添加如下文件：
    
    - 新建README.md文件：在README.md文件中必须包含包的介绍和引用方式，还可以根据包的内容添加更详细介绍。
    - 新建CHANGELOG.md文件：填写HAR的版本更新记录。
    - 添加LICENSE文件：LICENSE许可文件。
    
2. 重新[编译HAR模块](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-har#section7892044183814)，生成*.har文件。
    
    说明
    
    若修改了HAR包模块级oh-package.json5文件中version字段信息，请先执行Build > Clean Project指令，再重新进行Build全量构建。
    
3. 利用工具ssh-keygen生成公、私钥，可执行以下命令：
    
    1. ssh-keygen -m PEM -t RSA -b 4096 -f ~/.ssh_ohpm/mykey 
    
    说明
    
    2. ~/.ssh_ohpm/mykey 为私钥文件 mykey 的文件路径，按照实际情况指定。指定的私钥存储目录必须存在。
    3. 追加了.pub后缀的相应公钥文件会存放在和私钥相同的目录下。
    4. OHPM包管理器只支持加密密钥认证，请在生成公私钥时输入密码。
    
4. 登录[OpenHarmony三方库中心仓](https://ohpm.openharmony.cn/#/cn/home)官网，单击主页右上角的**个人中心，** 新增OHPM公钥，将公钥文件（mykey.pub）的内容粘贴到公钥输入框中。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155729.27883857508334860303298343255009:50001231000000:2800:1AF99267E905A663AE3A8974AFC78F7C0036EBFCFF1E438DDC74870F81FA1B52.png)
    
5. 打开命令行工具，将对应私钥文件路径配置到 .ohpmrc 文件中 key_path 字段上，可执行以下命令进行配置：
    
    1. ohpm config set key_path  ~/.ssh_ohpm/mykey
    
6. 登录[OpenHarmony三方库中心仓](https://ohpm.openharmony.cn/)官网，单击主页右上角的**个人中心**，复制发布码，获取发布码并配置到 .ohpmrc 文件中，可执行如下命令：
    
    1. ohpm config set publish_id your_publish_id
    
7. 执行如下命令发布HAR，<HAR路径>需指定为.har文件的具体路径。
    
    1. ohpm publish <HAR路径>  
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hsp "开发动态共享包")
# 引用及管理共享包

更新时间: 2025-12-16 15:57

引用三方HAR，包括从仓库进行安装、从本地文件夹和本地压缩包中进行安装三种方式。

- 引用ohpm仓中的HAR，首先需要设置三方HAR的仓库信息，DevEco Studio默认仓库地址为OpenHarmony三方库中心仓，如果您想设置自定义仓库，请在DevEco Studio的**Terminal**窗口执行如下命令进行设置（执行命令前，请确保已[将ohpm配置到环境变量中](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-environment-config#zh-cn_topic_0000001056725590_li1012418311835)，第一次配置环境变量后，需重启DevEco Studio）：
    
    1. ohpm config set registry your_registry1,your_registry2
    
    说明：ohpm支持多个仓库地址，采用英文逗号分隔。
    
    支持通过如下方式配置三方包依赖信息：
    
    - 方式一：在菜单栏点击**Tools >** **OHPM Index**，进入DevEco Studio内置的OpenHarmony开源中心仓，选择需要的三方包，详情请参考[使用OpenHarmony开源中心仓管理三方包](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-har-import#section1579838153916)。
        
        说明
        
        方式一仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。
        
    - 方式二：在**Terminal**窗口中，切换到需要引入三方包的模块，如entry模块，执行如下命令安装三方包，DevEco Studio会自动在该模块的oh-package.json5中自动添加三方包依赖。
        
        1. cd path/to/your/project/entry
        2. ohpm install @ohos/lottie
        
    - 方式三：在需要引入三方包的模块的oh-package.json5中设置三方包依赖，配置示例如下：
        
        1. "dependencies": {
        2.   "@ohos/lottie": "^2.0.0"
        3. }
        
        依赖设置完成后，需要执行**ohpm install**命令安装依赖包，依赖包会安装到该模块的oh_modules目录下。
        
        4. ohpm install
        
    
- 引用本地模块源码（该本地模块必须与宿主模块归属于同一个工程），如entry模块需要依赖foo模块的源码，有如下两种方式：
    - 方式一：在**Terminal**窗口中，切换到需要引入本地模块源码的模块，即entry模块下，执行如下命令进行安装，并会在该模块下的oh-package.json5中自动添加依赖。
        
        1. cd path/to/your/project/entry
        2. ohpm install path/to/foo
        
    - 方式二：在需要引入本地模块源码的模块的oh-package.json5中设置源码依赖项，即entry模块的oh-package.json5中，添加如下配置：
        
        1. "dependencies": {
        2.   "foo": "file:path/to/foo"  // 此处也可以是以当前oh-package.json5所在目录为起点的相对路径
        3. }
        
        依赖设置完成后，需要执行**ohpm install**命令安装依赖包，模块foo的源码会安装在entry模块的oh_modules目录下。
        
        4. ohpm install
        

- 引用本地HAR/HSP包，有如下两种方式：
    - 方式一：在**Terminal**窗口中，切换到需要引入本地HAR/HSP包的模块，如entry模块，执行如下命令进行安装，并会在oh-package.json5中自动添加依赖。以HAR/HSP包在工程根目录下为例，配置示例如下（实际配置时请以HAR/HSP包实际目录为准）：
        - 引用HAR：
            
            1. cd path/to/your/project/entry
            2. ohpm install path/to/package.har
            
        - 引用HSP（*.tgz包通过HSP模块在release模式下[编译](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hsp#section67683213597)生成）：
            
            1. cd path/to/your/project/entry
            2. ohpm install path/to/package.tgz
            
    - 方式二：在需要引入三方包的模块的oh-package.json5中设置本地HAR/HSP包。以HAR/HSP包在工程根目录下为例，配置示例如下（实际配置时请以HAR/HSP包实际目录为准）：
        
        - 引用HAR：
            
            1. "dependencies": {
            2.   "package": "file:path/to/package.har" // 此处也可以是以当前oh-package.json5所在目录为起点的相对路径。 
            3. }                                       
            
            说明
            
            代码片段中package.har为三方包文件名；"package"为引用该三方包所使用的依赖名称，建议与三方包包名，即三方包的oh-package.json5文件中的name字段保持一致。
            
        
        - 引用HSP：
            
            1. "dependencies": {
            2.   "package": "file:path/to/package.tgz" // 此处也可以是以当前oh-package.json5所在目录为起点的相对路径
            3. }
            
        
        依赖设置完成后，需要执行**ohpm install**命令安装依赖包，依赖包会安装在该模块的oh_modules目录下。
        
        1. ohpm install
        

另外，在安装或卸载共享包时，可在模块或工程的oh-package.json5文件中增加钩子设置，以管理install、uninstall命令的生命周期，配置示例如下：

1.  "hooks": {
2.     "preInstall": "echo 00 preInstall", // install命令执行之前
3.     "postInstall": "echo 00 postInstall", // install命令执行之后
4.     "preUninstall": "echo 00 preUninstall", // uninstall命令执行之前
5.     "postUninstall": "echo 00 postUninstall"  // uninstall命令执行之后
6.   }

说明

- 目前只支持执行当前模块或工程的oh-package.json5文件中hooks，不支持执行依赖中hooks。
- 在引用共享包时，请注意当前只支持在模块和工程下的oh-package.json5文件中声明dependencies依赖，才会被当做依赖使用，并在编译构建过程中进行相应的处理。

## 使用OpenHarmony开源中心仓管理三方包

说明

该功能仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。

从DevEco Studio 6.0.0 Beta5版本开始，新增OHPM Index入口，提供OHPM开源中心仓的高效筛选和管理能力，提升开发者选型开发效率，消减因软件信息不对称导致的选型使用风险，快速选择与定位所需的开源三方库。

1. 在菜单栏点击**Tools >** **OHPM Index**，进入OpenHarmony开源中心仓。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.96158870428592002736788671940440:50001231000000:2800:F00B2EC96B194DA04179EDE0ED83B6A743D4E9470F31447E19BCB054A605164A.png)
    
2. 在左侧搜索框可查询三方包名称，或点击目录树，根据分类查看不同分类下推荐的依赖包信息。选定所需要安装的三方包，点击右上角蓝色按钮**Install**进行安装。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.00264262641773983074414697268819:50001231000000:2800:66717839EA42F894029B4F5B54D2094C7D75B0A957300123BC0E7D44B311B5B6.png)
    
3. 安装过程中，如出现下方弹窗，点击**Add**按钮，将OpenHarmony中心仓地址添加到.ohpmrc文件中。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.00750492006311236153150700743102:50001231000000:2800:EFBBBAD07303D5AD3A05D1D6D001BC5655AE54CA1C312DA156E26E1E20445319.png)
    
4. 三方包安装完成后，在工程级oh-package.json5文件中可以看到已安装的三方包名称及版本信息，oh_modules中将同时添加该三方包。
5. 点击页面左上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.18995227090500129426534846495101:50001231000000:2800:E4A02DB855B5AC0AD9A2C726956B2F1CF5D00BBEEC83E904C7612E5267411E0D.png)图标，展示当前已安装的三方包信息。若当前三方包非最新版本，可以点击右上角**Update**按钮，更新至最新版本；点击**Delete**按钮，可以删除当前已安装的三方包。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.01244474986786530676248197887189:50001231000000:2800:8F88149E7CFD999C63FA8B99484013ED53296E1C0D8DD112DBEBD3C61D948488.png)
    
6. 若对于已使用的三方包依赖存在推荐的同类三方包，可点击编辑界面中黄色灯泡图标，在弹框中选择**Replace selected with recommended library**，将当前依赖替换为推荐的三方包依赖；或选择**Replace all with recommended libraries**，一键替换当前文件中所有同类推荐三方包。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.70550109990468813309011030061990:50001231000000:2800:7C791A4A71AD9B1D805D86D96CEACE9007C8229BDA3B9F3F425BF4E4D0B2CB7D.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-har-publish "发布共享包")
# 概述

更新时间: 2025-12-16 15:57

ohpm-repo是一个搭建轻量级的ohpm私仓服务的工具。它与ohpm包管理器兼容，并按需缓存所有依赖项，加速私有网络中的安装。

## 私有性

所发的三方库都是私有的，只能根据配置进行访问。

## 缓存

ohpm-repo根据需要缓存所有依赖项，加快私有网络的安装速度。

## 部署

ohpm-repo支持单点部署和多实例部署。

说明

- 单点部署：ohpm-repo仅部署在一台机器上使用。
- 多实例部署：ohpm-repo会部署到多台机器中，具有相同的配置内容，并且共享数据存储空间。
- 单点部署的数据如果需要迁移至多实例部署，请参考[数据迁移指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-data-migration)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo "ohpm-repo私仓搭建工具")
# 快速开始

更新时间: 2025-12-16 15:57

说明

ohpm-repo私仓不允许在Linux或macOS系统中使用root用户启动，请使用普通用户安装运行。

## 如何安装

### ohpm-repo

1. ohpm-repo依赖于Node运行，支持Node.js18.x及以上版本，请提前安装Nodejs，并完成环境变量的配置。Node.js安装请参考[Node.js官方网站](https://nodejs.org/download/release/latest/)。
    
2. 下载ohpm-repo私仓工具包。请在[下载中心](https://developer.huawei.com/consumer/cn/download/ohpm-repo)获取最新的ohpm-repo，并根据下载中心页面**工具完整性**指导进行完整性校验。
    
3. 解压ohpm-repo私仓工具包。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.26953948755514565847554434430571:50001231000000:2800:397F3C62BC6D38C7DCE6E6C08564715A98345AF1C629D13E9C39949F9FCFC696.png)
    
4. 请将ohpm-repo工具包解压目录中bin目录的路径配置到[系统环境变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-faq#section24117279211)path中，执行如下查询命令:
    
    1. ohpm-repo -v
    
    终端输出版本号（如：2.0.0），则表示安装包解压无问题。如有报错，请参考[常见问题FAQ](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-faq)解决。
    
    注意
    
    针对Linux和Mac系统，建议使用bash或zsh作为命令行界面。如果使用其他类型shell，写入ohpm-repo部署根目录[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_deploy_root)的环境变量时，默认写入.bashrc文件中。
    
5. 在启动ohpm-repo前，需要先按照如下方式完成配置修改：进入ohpm-repo解压目录的conf目录内，打开config.yaml[配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration)。
    
    说明
    
    **ohpm-repo成功启动后修改配置文件方法**：
    
    - 首次启动ohpm-repo时执行**install**命令已指定配置文件：找到指定的配置文件进行文件内容修改，然后重新执行install指定修改后的配置文件，再执行start启动ohpm-repo。
    - 首次启动ohpm-repo时执行**install**命令未指定配置文件：默认使用ohpm-repo压缩包解压路径下conf目录中的配置文件，修改该文件内容，然后重新执行install和start操作。
    
6. 检查[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)配置，默认配置为localhost:8088，表示仅支持监听本机地址；如果希望其他机器通过ip/域名访问，则建议修改listen配置为ohpm-repo部署机器的ip：
    
    1. listen: <部署ohpm-repo机器的ip>:8088
    
7. 检查[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_deploy_root)配置：如果不配置，会存储在默认地址中。该路径不允许配置为ohpm-repo解压根目录。
8. 检查[db](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_db)和[store](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)配置，db是元数据存储的配置项，store是文件存储的配置项。db支持fileDB本地存储和mysql数据库存储，store支持file storage本地存储，sftp storage存储和custom storage自定义插件存储。db和store不能随意搭配，需要符合表1的匹配规范。配置文件默认db使用fileDB本地存储，store使用file storage本地存储。
    
    **表1** db配置项与store配置项的搭配选择
    |db：元数据存储|与db所适配的store类型|
    |:--|:--|
    |fileDB|file storage|
    |mysql|file storage，sftp storage， custom storage|
    
9. 检查是否配置了[store.config.server](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)，用于指定ohpm-repo仓库内容的下载地址、不配置取默认值，详情见：[server: 仓库内容的下载地址](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_li922300957171146)。如果[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host为0.0.0.0，且本机存在多个网络接口，那么该值必须配置，建议手动修改host为本机指定的ip/域名，例如listen为0.0.0.0:8088，故server需配置为http://<指定部署机器的ip/域名>:8088。
    
    说明
    
    - 如果为ohpm-repo服务配置了反向代理服务器，则该地址需要填写为反向代理服务器的地址。
    - 如果ohpm-repo以多实例方式启动，必须配置反向代理服务器，多个实例之间需要统一的下载地址。
    - config.yaml中各项配置的详细描述请见：[配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration)。
    
10. 进入ohpm-repo工具包解压目录中的bin目录下，执行安装命令:
    
    1. ohpm-repo install
    
    结果实例：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.09761820138153434835407729510598:50001231000000:2800:75B03BBD6D59C450EAB2052042A47077E8D7C72A06CAFC037D20D46FA3E23FC7.png "点击放大")
    
11. 安装成功后，**必须**根据给出的提示信息刷新部署目录的环境变量，针对Windows系统和Linux/Mac系统，有不同处理方式：
    
    - Windows系统：关闭当前窗口，重新开启一个窗口。
    - Linux/Mac系统：在命令行中执行刷新命令：当shell为bash时执行_source ~/.bashrc_或者. _~/.bashrc_；当shell为zsh时执行_source ~/.zshrc_或者. _~/.zshrc_。
    

## 如何启动

ohpm-repo安装成功后，进入ohpm-repo工具包解压目录下的bin目录下，执行如下命令，启动ohpm-repo：

1. ohpm-repo start

启动成功，将会出现以下日志信息：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155728.23256220499120318108885047551030:50001231000000:2800:A56E5370C658F380F27C47495D1E448B62FE2196E3FECACB6ADF751FBD55E912.png "点击放大")

说明

ohpm-repo首次启动时，默认创建一个管理员账号，账号名称：_**admin**_，密码：_**12345Qq!**_。该账号在首次登录时，需要修改其密码，请修改密码后，重新登录该账号。

## 从ohpm-repo获取三方库

可以为所有项目配置该私有仓，例如执行以下命令：

1. ohpm config set registry <配置的ohpm-repo私仓服务地址>/repos/ohpm
2. ohpm install

或者在命令行中配置参数--registry使用，例如以下命令：

1. ohpm install @ohos/lottie --registry <配置的ohpm-repo私仓服务地址>/repos/ohpm

说明

<配置的ohpm-repo私仓服务地址>：配置文件中[store.config.server](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)的地址信息，例如：_[store.config.server](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store):为http://127.0.0.1:8088_，故registry为：_http://127.0.0.1:8088/repos/ohpm。_如果[store.config.server](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)没有配置，取默认值。

## 将三方库发布到ohpm-repo

三方库包含静态共享包HAR包和动态共享包HSP包，可以通过ohpm命令行工具和使用Web页面两种方式发布。

说明

从ohpm命令行工具1.3.0版本和ohpm-repo私仓1.1.0版本开始，支持动态共享包HSP包以.tgz文件形式发布到ohpm-repo，之前版本仅支持发布以.har文件形式的静态共享包。

### 使用命令行工具发布

1. 利用工具ssh-keygen生成公、私钥，可执行以下命令：
    
    1. ssh-keygen -m PEM -t RSA -b 4096 -f <your_key_path>
    
    说明
    
    - <your_key_path>：配置公钥和私钥的名称和存放路径，仅包含名称时，以当前命令行工作路径为存储目录。
    - OHPM包管理器只支持加密密钥认证，请在生成公私钥时输入密码。
    
    示例：
    
    1. ssh-keygen -m PEM -t RSA -b 4096 -f D:\path\my_key_path
    
    说明
    
    公钥和私钥存储在D盘的path目录下，公钥和私钥名称分别为my_key_path.pub和my_key_path。
    

2. 登录ohpm-repo私仓管理地址，单击主页右上角的个人中心 > 认证管理，新增公钥，将公钥文件（<your_key_path>.pub）的内容粘贴到公钥输入框中。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155729.86139986513094915514745675469529:50001231000000:2800:4E60B8574B776151C02F433BA95A4AAB663EF2435CDE539262847BD8EBF02AB5.png "点击放大")
    

3. 打开命令行工具，执行如下命令设置私钥路径。
    
    1. ohpm config set key_path <your_key_path>
    

4. 登录ohpm-repo私仓管理地址，单击主页右上角的个人中心，复制发布码。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155729.04770257570213834202218770973228:50001231000000:2800:63F82E297B5FE13E85810D2C1B63398CC917CE8621EF1B719A3C19DAD7AB997D.png "点击放大")
    

5. 将发布码配置到.ohpmrc文件中，可执行如下命令：
    
    1. ohpm config set publish_id <your_publish_id>
    

6. 三方库包含静态共享包HAR包和动态共享包HSP包，发布方式存在不同。
    
    - 静态共享包HAR包
        
        执行 ''ohpm publish <HAR包路径>'' 命令发布HAR包，<HAR包路径> 指向的文件后缀需为.har文件的具体路径。例如执行以下命令：
        
        1. ohpm config set publish_registry <ohpm-repo私仓管理地址>/repos/ohpm
        2. ohpm publish demo.har
        
        或在命令行中配置参数--publish_registry使用，例如以下命令：
        
        1. ohpm publish demo.har --publish_registry <ohpm-repo私仓管理地址>/repos/ohpm
        
    
    - 动态共享包HSP包
        
        动态共享包HSP包不能直接发布在ohpm-repo内，需要先转化为.tgz包，转换方法见：[编译HSP模块](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hsp#section67683213597)。TGZ包的发布流程同HAR一致。
        
        执行 ''ohpm publish <TGZ包路径>'' 命令发布TGZ包，< TGZ 包路径> 指向的文件后缀需为.tgz文件的具体路径。例如执行以下命令：
        
        1. ohpm config set publish_registry <ohpm-repo私仓管理地址>/repos/ohpm
        2. ohpm publish demo.tgz
        
        或在命令行中配置参数--publish_registry使用，例如以下命令：
        
        1. ohpm publish demo.tgz --publish_registry <ohpm-repo私仓管理地址>/repos/ohpm
        
    
    说明
    
    - 开发HAR包和HSP包，HSP生成.tgz包和.tgz格式共享包转换为.har格式等更详细内容请参考：[开发及引用共享包](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-creating-har-api9)。
    - 发布时ohpm-repo私仓管理地址填写规则如下：
        - listen的host不为0.0.0.0时， 管理地址使用[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的完整格式，例如：当listen：localhost:8088，此处ohpm-repo私仓管理地址应填写：http://localhost:8088。
        - listen的host为0.0.0.0时，host需更改为ohpm-repo私仓部署机器的ip/域名，例如：当listen：0.0.0.0:8088，此处ohpm-repo私仓管理地址应填写：http://<ohpm-repo私仓部署机器的ip/域名>:8088。
    

### 使用Web页面发布

在Web页面用管理员账号登录ohpm-repo私仓管理地址，在个人中心 > 仓库管理中，点击管理三方包 > 上传三方包，包的后缀名必须为.har或者.tgz。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155729.70907301552523824327609617495094:50001231000000:2800:81E8BDFDC22A9A67CA215F760752EB759CA2481D4F324136F96CB11E4B4C3C46.png "点击放大")

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155729.99059356379224716837500933380524:50001231000000:2800:39606E0F346DBED7585EA95458438D7580C764D6F1FF778BC0D7033F13276DBA.png "点击放大")

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-overview "概述")
# 配置文件

更新时间: 2025-12-16 15:57

config.yaml是ohpm-repo的重要文件，可以在其中修改默认参数配置，启动插件和扩展功能。ohpm-repo私仓解压目录中的conf目录下带有一个默认配置文件config.yaml，ohpm-repo执行install命令时默认读取该文件。

说明

**ohpm-repo成功启动后修改配置文件方法**：

- 首次启动ohpm-repo时执行**install**命令时已指定配置文件：找到指定的配置文件进行文件内容修改，然后重新执行install指定修改后的配置文件，再执行start启动ohpm-repo。
- 首次启动ohpm-repo时执行**install**命令未指定配置文件：默认使用ohpm-repo压缩包解压路径下conf目录中的配置文件，修改该文件内容，然后重新执行install和start操作。

## 默认配置

1. ##### server configuration section #####
2. listen: localhost:8088        # 建议修改为具体的ip/域名
3. # listen:
4. # - localhost:8088            # 监听本机环回地址
5. # - http://localhost:8088     # 监听本机环回地址
6. # - 0.0.0.0:8088              # 监听本机所有地址 (INADDR_ANY)
7. # 协议可配置 http 或者 https，默认为 http
8. # port: 1-65535(Windows系统)/ 1024-65535(Linux或Mac系统）

9. # 可选 (listen 为 https 协议时必须配置)
10. https_key: ''                 # https 服务使用的 key 的路径  (不配置默认为'')
11. https_cert: ''                # https 服务使用的 crt 的路径  (不配置默认为'')

12. ##### server deploy root section #####
13. deploy_root: ''                # 安装根目录，只支持绝对路径，且目录必须存在

14. ##### server numeric limit section #####
15. max_package_size: 500          # 上传包大小限制，单位是MB (0, 500]，不配置或配置为0默认为 500
16. max_extract_size: 800          # 压缩包解压后大小限制，单位是MB ，不配置或配置为0默认为 800
17. max_extract_file_num: 30000    # 压缩包解压后文件个数限制，不配置或配置为0默认为30000个
18. user_rate_limit: 100           # 用户访问频率控制，单位是次/小时 (0, 10000]，不配置或配置为0默认为 100
19. fetch_timeout: 60              # 请求/响应的超时时间，单位是秒 (0, 3600]，不配置或配置为0默认为 60
20. keep_alive_timeout: 60         # TCP 保持连接的超时时间，单位是秒 (0, 3600]，不配置或配置为0默认为 60
21. api_timeout: 60                # api超时时间，单位是秒(0, 3600]，不配置或配置为0默认为 60
22. upload_api_timeout: 300        # 上传三方包api超时时间，单位是秒(0, 3600]，不配置或配置为0默认为 300
23. upload_lock_hour: 24           # 下架某一三方包所有版本后，限时禁止同名三方包上传，单位是小时 (0, 168]，不配置或配置为0默认为 24
24. upload_max_times: 100          # 单用户24小时内上传次数限制 (0, 100000]，不配置或配置为0默认为 100
25. operation_log_retention: 100   # 数据库中操作日志保留时间，单位是天，不配置或配置为0默认为 100

26. ##### metadata storage section #####
27. ## 数据存储类型 filedb 和 mysql 二选一，不可都配置
28. db:                         # 必须用 yaml 数组形式写法
29.   type: filedb
30.   config:                   # 如果想修改存储路径且保留旧的数据，则需要把旧路径下的数据文件迁移至新路径
31.     path: ./db              # 本地数据存储路径，不配置默认为<deploy_root>/db;

32. #db:                        # 必须用yaml数组形式写法
33. #  type: mysql
34. #  config:
35. #    host: "localhost"      # 数据库主机地址
36. #    port: 3306             # 数据库端口 (0,65535]
37. #    username: tctAdmin         # 数据库的用户名
38. #    password: "password"   # 数据库的用户密码（请配置明文, 最终在部署目录中会转换为密文）
39. #    database: "repo"       # 数据库名

40. ##### storage section #####
41. ## 文件存储类型fs,sftp 和 custom 三选一，不可多选。

42. store:                               # 必须用 yaml 数组形式写法
43.   type: fs
44.   config:                            # 上传资源后如若要修改存储路径，则需要把旧路径下的数据迁移至新路径中
45.     path: ./storage                  # 已上架三方库存储路径，不配置默认为 <deploy_root>/storage;
46.     #server: http://localhost:8088   # 仓库下载链接地址，不配置取默认值

47. # 文件存储类型为 sftp 时，最多配置三个 sftp
48. #store:                               # 必须用 yaml 数组形式写法
49. #  type: sftp                         # 当且仅当 db 的类型为 mysql 时，store 的类型才能为 sftp
50. #  config:
51. #    location:
52. #      -
53. #        name: test_one_sftp          # 主机名字不能与其他sftp配置重复
54. #        host: "localhost"            # 主机地址
55. #        port: 22                     # 主机端口 (0,65535]
56. #        read_username: "read"        # 主机有读权限的用户名字
57. #        read_password: "password"    # 主机有读权限的用户密码（请配置明文, 最终在部署目录中会转换为密文）
58. #        write_username: "write"      # 主机有写权限的用户名字
59. #        write_password: "password"   # 主机有写权限的用户密码（请配置明文, 最终在部署目录中会转换为密文）
60. #        path: /source22              # 相对 sftp 根目录的文件路径，仅限/开头，且路径文件夹必须存在
61. #      -
62. #        name: test_two_sftp
63. #        host: "localhost"
64. #        port: 24
65. #        read_username: "read"
66. #        read_password: "password"
67. #        write_username: "write"
68. #        write_password: "password"
69. #        path: /source24
70. #    #server: http://localhost:8088   # 仓库下载链接地址，不配置取默认值

71. #store:
72. #  type: custom                                            # custom是自定义存储插件类型，自定义存储插件开发流程见[指导文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-storageplugin)
73. #  config:
74. #    export_name: CustomStorage                            # 插件export的类名
75. #    plugin_path: plugins/CustomStorage.js                 # 插件的绝对路径或者相对于ohpm-repo软件包的路径，建议将插件放在软件包的plugins目录下
76. #    custom_field: "test"                                  # 自定义字段，通过引入libs/common/getStorageConfigInfo.js的getStorageConfigInfo方法获取自定义字段的值
77. #    #server: http://localhost:8088                        # 仓库下载链接地址，不配置取默认值

78. ##### 是否使用反向代理 #####
79. # 可选项:true,false, 默认：false。如果使用反向代理，需要配置为true，客户端IP地址将从请求头中的x-forwarded-for字段获取
80. use_reverse_proxy: false

81. ##### uplink section #####
82. uplink_cache_path: ./uplink      # 缓存路径，不配置默认为 <deploy_root>/uplink
83. uplink_cache_time: 168           # 远程包 metadata 缓存时间，单位为小时，默认 168 小时，取值范围为 (0, 8760]

84. ##### log section #####
85. logs_path: ./logs                # 日志路径，不配置默认为 <deploy_root>/logs

86. ##### log level section #####
87. # 日志级别: 级别由低到高分别是 all、trace、debug、info、warn、error、fatal、mark、off
88. # run，operate 和 access 不配置或者配置错误，默认为 info
89. loglevel_run: info
90. loglevel_operate: info
91. loglevel_access: info

92. ##### auth plugin section #####
93. # 可选项，自定义认证插件配置
94. #auth_plugin:
95. #  name: CustomAuth              # 认证插件的名字
96. #  path: plugins/CustomAuth.js   # 插件的绝对路径或者相对于ohpm-repo软件包的路径，建议将插件放在软件包的plugins目录下

97. ##### fieldCheck plugin section #####
98. # 可选项，自定义元数据规则检验插件配置
99. #field_check_plugin:
100. #  config_file_path:  plugins/fieldCheckPlugin/CustomExtensionValidationConfig.json  # 字段校验配置文件的绝对路径或者相对于ohpm-repo软件包的路径，建议将文件放在软件包的plugins/fieldCheckPlugin目录下
101. #  check_func_dir: plugins/fieldCheckPlugin                                          # 字段校验函数文件所在目录的绝对路径或者相对于ohpm-repo软件包的路径，建议将目录设置为plugins/fieldCheckPlugin文件夹

102. ##### content check plugin #####
103. # 可选项，包内容规则检测插件配置
104. #content_check_plugin:
105.   # 该校验要求环境变量中有ark_disasm可执行文件、tar命令行工具
106.   # 检查范围：上架的字节码har、hsp
107. #  name: 'OHMUrlCheck'

108. ##### compatibleSdkVersion等兼容性字段检测日志等级 #####
109. # 可选值：close、info、warn、error，默认：warn
110. compability_log_level: warn

111. ##### 是否允许下架被其他组件依赖的包 #####
112. # 可选项:true,false, 默认：false
113. allow_remove_depended_packages: false

## 配置项说明

### listen

格式为三段式，即<proto>://<host>:<port>，其中<proto>可以不填，默认为http，如：

- 监听本机回环地址（默认）：
    
    1. listen: localhost:8088
    2. # 或 listen: http://localhost:8088
    
- 监听具体地址（建议）：
    
    1. listen: https://<ohpm-repo部署机器ip>:8088
    
- 监听所有地址（当选择监听所有地址时，配置项[store](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)中server值必须配置）：
    
    1. listen: 0.0.0.0:8088
    2. # 或 listen: http://0.0.0.0:8088
    

注意

listen值建议监听具体的地址。proto支持http和https协议，支持缺省，缺省时默认为http。为了确保ohpm-repo链接的安全，建议选择使用https协议，如果配置为https协议，则需要完善[https](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_https)相关配置。

### https

当配置[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)时选择使用https协议，则需要配置https_key和https_cert：

- https_key：ssl证书私钥文件。
- https_cert：ssl证书文件。

参考配置如下：

1. https_key: ./ssl/server.key
2. https_cert: ./ssl/server.crt

说明

生产环境必须使用受信任CA颁发的证书，避免因使用自签名证书导致浏览器安全警告。

### deploy_root

ohpm-repo的部署目录，存储运行时生成的文件数据。

- 如果<deploy_root>字段为空，则默认路径为：
    
    windows系统: ~/AppData/Roaming/Huawei/ohpm-repo
    
    其他操作系统：~/ohpm-repo
    
- 如果<deploy_root>字段不为空，则路径必须为**绝对路径**，且路径所指向文件夹**必须存在**。
    
- 该路径不允许配置为ohpm-repo安装包解压根目录。

参考配置如下：

1. deploy_root: ''

### server

服务相关配置，具体为：

- **max_package_size**: 上传包大小限制，单位为MB， 不配置或配置为0取默认值500MB，取值范围为 (0, 500] 。
- **max_extract_size**: 压缩包解压后大小限制，单位为MB，不配置或配置为0取默认值800MB。
- **max_extract_file_num**: 压缩包解压后文件个数限制，不配置或配置为0取默认值30000个。
- **user_rate_limit**: 用户访问频率控制，单位为次/秒，不配置或配置为0取默认值100 次/秒，取值范围为 (0, 10000]。
- **fetch_timeout**: 当使用[uplink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_uplink)时，请求uplink数据的请求/响应超时时间，单位为秒，不配置或配置为0取默认值60秒，取值范围为 (0, 3600]。
- **keep_alive_timeout**: TCP 保持连接的超时时间，单位为秒，不配置或配置为0取默认值60秒，取值范围为 (0, 3600]。
- **api_timeout**: 接口请求与响应超时时间，单位为秒，不配置或配置为0取默认值60秒，取值范围(0, 3600]。
- **upload_api_timeout**: 上传三方包接口请求与响应超时时间，单位为秒，不配置或配置为0取默认值300秒，取值范围(0, 3600]。
- **upload_lock_hour**: 下架某个三方包所有版本后，限时禁止同名三方包上传，单位为小时，不配置或配置为0取默认值24小时，取值范围为 (0, 168]。
- **upload_max_times**: 单用户24小时内上传次数限制，不配置或配置为0取默认值100次，取值范围为 (0, 100000]。
- **operation_log_retention**：数据库中操作日志保留时间，单位是天，不配置或配置为0取默认值100天。

参考配置如下：

1. max_package_size: 500
2. max_extract_size: 800
3. max_extract_file_num: 30000
4. user_rate_limit: 100
5. fetch_timeout: 60
6. keep_alive_timeout: 60
7. api_timeout: 60
8. upload_api_timeout: 300
9. upload_lock_hour: 24
10. upload_max_times: 100
11. operation_log_retention: 100   

注意

db是元数据存储的配置项，store是文件存储的配置项。db支持fileDB本地存储和mysql数据库存储；store支持file storage存储，sftp存储和custom storage 自定义插件存储。db和store不能随意搭配，需要符合表1的匹配规范：

**表1** db配置项与store配置项的搭配选择
|db：元数据存储|**与db所适配的store：三方包文件存储**|
|:--|:--|
|filedb|file storage|
|mysql(ohpm-repo 1.1.0开始支持）|file storage，sftp storage(ohpm-repo 1.1.0开始支持），custom storage(ohpm-repo 2.2.0开始支持）|

### db

ohpm-repo运行过程产生的用户信息，运行状态等元数据存储配置，支持本地磁盘存储filedb和mysql数据库存储。

**本地磁盘存储**

默认使用本地磁盘存储，配置如下：

- type: 存储插件名称，为filedb。
- config: 插件配置，具体为：
    - path: 数据库文件存储地址，默认值为./db，支持相对和绝对路径配置，当配置为相对路径时，则以[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_%E5%85%B3%E4%BA%8E-deploy_root)为根目录。

说明

如果想修改数据库文件存储路径同时保留旧的数据，则需要把旧路径下的数据文件迁移至新路径。

参考配置如下：

1. db:                
2.   type: filedb     
3.   config:
4.     path: ./db     

**Mysql存储**

- type: 插件名称，配置为mysql。
- config: 插件配置，具体为：
    - host: 数据库主机地址。
    - port: 数据库端口。
    - username: 数据库的用户名。
    - password: 数据库的用户密码（请配置明文, 最终在部署目录中会转换为密文）。
    - database: 数据库名。

参考配置如下：

1. db:                         
2.   type: mysql
3.   config:
4.     host: "localhost"
5.     port: 3306
6.     username: "tctAdmin"
7.     password: "password"
8.     database: "repo"

注意

为了避免潜在的安全风险，建议使用非最高权限的数据库账户进行连接。

### store

三方库及其元数据等资源文件存储配置，支持本地磁盘存储，sftp存储和自定义插件存储。

**本地磁盘存储**

默认使用本地磁盘存储文件，具体配置为：

- type: 插件名称，为fs。
- config: 插件配置，具体为：
    - path: 存储根目录路径，默认为./storage，支持相对和绝对路径配置，当配置为相对路径时，则以[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_%E5%85%B3%E4%BA%8E-deploy_root)为根目录。
    - server: 仓库内容的下载地址，当[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host为0.0.0.0且本机存在多个网络接口时，**必须配置**。
        - server的格式如下：<[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的proto>://<host>:<[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的port>；
        - 当配置项[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host不为0.0.0.0时，则server**默认**取listen的完整格式，例如listen为127.0.0.1:8088，故server默认值为http://127.0.0.1:8088；
        - 当配置项[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host为0.0.0.0时，如果本机仅存在一个网络接口，则server中的host默认为本机网络接口的ipv4地址；如果本机存在多个网络接口，则server中的host默认为本机获取到的第一个网络接口的ipv4地址，建议手动修改host为指定的本机ip/域名，例如listen为0.0.0.0:8088，故server需配置为http://<本机ip/域名>:8088；
        - 如果需要通过反向代理来访问ohpm-repo服务，则该字段须配置为反向代理服务器的域名地址，且需要配置[use_reverse_proxy](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#section1074004784011)值为true。

注意

上传资源后如若要修改存储路径，则需要把旧路径下的数据迁移至新路径中。

参考配置如下：

1. store:
2.   type: fs
3.   config:
4.     path: ./storage
5.     #server: http://localhost:8088

**sftp 存储**

支持使用sftp存储文件，仅当数据存储为mysql存储时才能使用sftp存储，具体配置为：

- type: 插件名称，其名称为sftp。
- config: 插件配置。
    - location: 支持配置最多3个sftp服务，必须用yaml的数组形式写法，详细配置如下；
        - name: sftp服务名，名字不能与其他sftp配置重复。
        - host: sftp服务主机地址。
        - port：sftp服务端口。
        - read_username：有读权限的用户名。
        - read_password：有读权限的用户密码（请配置明文, 最终在部署目录中会转换为密文)。
        - write_username：有写权限的用户名。
        - write_password：有写权限的用户密码（请配置明文, 最终在部署目录中会转换为密文)。
        - path：相对 sftp 根目录的文件路径，仅限/开头，且路径所指向的文件夹必须存在。
    - server: 仓库内容的下载地址，当[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host为0.0.0.0且本机存在多个网络接口时，**必须配置**。
        - server的格式如下：<[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的proto>://<host>:<[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的port>
        - 当配置项[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host不为0.0.0.0时，则server**默认**取listen的完整格式，例如listen为127.0.0.1:8088，故server默认值为 http://127.0.0.1:8088；
        - 当配置项[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host为0.0.0.0时，如果本机仅存在一个网络接口，则server中的host默认为本机网络接口的ipv4地址；如果本机存在多个网络接口，则server中的host默认为本机获取到的第一个网络接口的ipv4地址，建议手动修改host为指定的本机ip/域名，例如listen为0.0.0.0:8088，故server需配置为http://<本机ip/域名>:8088；
        - 如果需要通过反向代理来访问ohpm-repo服务，则该字段须配置为反向代理服务器的域名地址，且需要配置[use_reverse_proxy](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#section1074004784011)值为true。

参考配置如下：

1. store:                               
2.   type: sftp                         
3.   config:
4.     location:
5.       - 
6.         name: test_one_sftp          
7.         host: "localhost"           
8.         port: 22                     
9.         read_username: "read"   
10.         read_password: "password" 
11.         write_username: "write"   
12.         write_password: "password" 
13.         path: /source22
14.       -
15.         name: test_two_sftp
16.         host: "localhost"
17.         port: 24
18.         read_username: "read"
19.         read_password: "password"
20.         write_username: "write"
21.         write_password: "password"
22.         path: /source24
23.     #server: http://localhost:8088

**custom存储**

使用自定义插件存储，具体配置为：

- type: 插件名称，为custom。custom是自定义存储插件类型，自定义存储插件[开发流程见官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-storageplugin)。
- config: 插件配置，具体为：
    - export_name：待书写插件export的类名。
    - plugin_path：插件的绝对路径或者相对于ohpm-repo软件包的路径，建议将插件放在软件包的plugins目录下。
    - custom_field：自定义字段，通过引入ohpm-repo解压包中libs/common/getStorageConfigInfo.js的getStorageConfigInfo方法获取自定义字段的值。
    - server: 本地仓库下载地址：
        - 当配置项[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host不为0.0.0.0时，则**默认**取listen的完整格式，例如listen为127.0.0.1:8088，故server默认值为http://127.0.0.1:8088；
        - 如果配置项[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host为0.0.0.0，则server中的host默认为localhost，如http://localhost:8088。建议手动修改host为本机的ip/域名，例如listen为 0.0.0.0:8088，故server需配置为http://<本机ip/域名>:8088；
        - 如果需要通过反向代理来访问ohpm-repo服务，则该字段须配置为反向代理服务器的域名地址。多实例部署ohpm-repo时必须配置反向代理服务器，且需要配置[use_reverse_proxy](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#section1074004784011)值为true。

参考配置如下：

1. store:
2.   type: custom                                            
3.   config:
4.     export_name: "MyStorage"                              
5.     plugin_path: "plugins/storagePlugin/MyStorage.js"        
6.     custom_field: "test"                                  
7.     #server: http://localhost:8088

### use_reverse_proxy

- use_reverse_proxy: 是否使用反向代理选项。可选项：true/false， 默认：false。如果使用反向代理，必须配置为true，客户端IP地址将从请求头中的x-forwarded-for字段获取。

1. use_reverse_proxy: false

注意

当use_reverse_proxy配置为true时，必须在反向代理配置时刷新x-forwarded-for值（如果存在多级代理，只需要在最外层代理配置刷新），如果不刷新将存在x-forwarded-for数据被篡改风险，反向代理配置刷新x-forwarded-for命令如下：

1. proxy_set_header x-forwarded-for $remote_addr

### uplink

- uplink_cache_path：远程包缓存路径，默认路径为./uplink，支持相对和绝对路径配置，当配置为相对路径时，则以[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_%E5%85%B3%E4%BA%8E-deploy_root)为基准目录。
- uplink_cache_time：远程包metadata缓存时间，单位为小时，默认168小时，取值范围为(0, 8760]。

参考配置如下：

1. uplink_cache_path: ./uplink
2. uplink_cache_time: 168

### logs

- logs_path: 日志存储，默认路径为./logs，支持相对路径和绝对路径配置，当配置为相对路径时，以[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_%E5%85%B3%E4%BA%8E-deploy_root)为基准目录。

参考配置如下：

1. logs_path: ./logs 

### loglevel

loglevel自定义配置，具体配置为：

- loglevel_run：run日志文件的存储级别，默认级别为info，输出的日志信息级别高于设定的日志级别才会存储到run日志文件中。
- loglevel_operate：operate日志文件的存储级别，默认级别为info，输出的日志信息级别高于设定的日志级别才会存储到operate日志文件中。
- loglevel_access：access日志文件的存储级别，默认级别为info，输出的日志信息级别高于设定的日志级别才会存储到access日志文件中。

说明

- 日志级别由低到高分别是all、trace、debug、info、warn、error、fatal、mark 和 off。
- run、operate和access，日志级别不配置或者配置错误，默认为info。

参考配置如下：

1. loglevel_run: info
2. loglevel_operate: info
3. loglevel_access: info

### auth_plugin

ohpm-repo从2.3.0版本开始支持自定义认证插件（需配套使用1.8.0及以上版本ohpm命令行工具），允许您开发定制化的认证插件来对接您自己的用户信息系统。自定义认证插件开发流程见[认证插件说明文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-custom-auth-plugin)。

参数说明：

- name: 插件名称，自定义插件文件CustomAuth.js中定义的实现类名称，如果实现类为CustomAuth，故此处值为：CustomAuth 。
- path: 编译后插件文件CustomAuth.js的存储位置。支持绝对路径和相对路径，相对路径的基准为ohpm-repo解压根目录。

参考配置如下（默认不开启）：

1. #auth_plugin:
2. #  name: CustomAuth              
3. #  path: plugins/CustomAuth.js   

### field_check_plugin

ohpm-repo从5.1.3版本开始支持自定义元数据规则校验，可以对oh-package.json5中部分字段开发定制化的校验规则。自定义元数据规则校验插件开发流程见[自定义元数据规则校验插件说明文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-custom-metadata-rule-validation-config)。

参数说明：

- config_file_path：字段校验配置文件路径，支持绝对路径和相对路径，相对路径的基准为ohpm-repo解压根目录，建议将文件存放在软件包的plugins/fieldCheckPlugin目录下，默认值为plugins/fieldCheckPlugin/CustomExtensionValidationConfig.json。
- check_func_dir：字段校验函数文件所在目录路径，支持绝对路径和相对路径，相对路径的基准为ohpm-repo解压根目录，建议将目录设置为plugins/fieldCheckPlugin文件夹，默认值为plugins/fieldCheckPlugin。

参考配置如下（默认不开启）：

1. #field_check_plugin:
2. #  config_file_path:  plugins/fieldCheckPlugin/CustomExtensionValidationConfig.json   
3. #  check_func_dir: plugins/fieldCheckPlugin                                           

### content_check_plugin

ohpm-repo从5.2.0版本开始支持三方库字节码文件的OHMUrl版本一致性校验，可以对字节码har文件中module.abc文件中的OHMUrl的版本号与har文件中实际的版本号进行一致性校验，阻止不一致包的上传，以防止运行时崩溃。

注意

一致性检查将用到ark_disasm工具及系统自带的tar解压工具。ark_disasm工具位于命令行工具中，用于反编译module.abc文件，请先下载[命令行工具](https://developer.huawei.com/consumer/cn/download/command-line-tools-for-hmos)，并将ark_disasm工具所在路径（默认路径为command-line-tools/sdk/default/openharmony/toolchains）及tar解压工具的所在路径添加到系统环境变量中（对于Linux/macOS系统，请将bsdtar解压工具所在路径添加到系统环境变量中）。如在上传三方库过程中发现ark_disasm导致报错，请联系管理员，确保您使用的DevEco Studio与ark_disasm工具配套。

参数说明：

- name：固定为"OHMUrlCheck"

参考配置如下（默认不开启）：

1. #content_check_plugin:
2. #  name: 'OHMUrlCheck'     

### compability_log_level

- compability_log_level: compatibleSdkVersion等兼容性字段检测日志等级，可选值：close、info、warn、error，默认为warn，参考配置如下：

1. compability_log_level: warn

### allow_remove_depended_packages

- allow_remove_depended_packages: 是否允许下架被其他组件依赖的包，可选项：true，false，默认为false，参考配置如下：

1. allow_remove_depended_packages: false

## 关于 deploy_root

deploy_root为ohpm-repo的部署目录，通过配置文件中字段<[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_deploy_root)>可进行配置。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-quickstart "快速开始")
# 日志

更新时间: 2025-12-16 15:57

与任何web应用程序相同，ohpm-repo有一个内置的日志记录器，其定义了四种日志类型。

## 访问日志 - access.log

访问日志中主要包含操作时间、服务器ip、操作源、操作结果以及请求接口或者请求静态资源，其文件保存个数最多为180个。

## 操作日志 - operate.log

操作日志中主要包含操作时间、日志级别、操作人id(userId)、终端 ip(ip)、操作资源（resource）、操作方法名（event）以及操作结果（result），其文件保存个数最多为180个。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155730.30170832545881200844300880730911:50001231000000:2800:F24083DE962E220B06BC79612A3601F061DCCC148570DD048939F230A0631BD0.png "点击放大")

说明

**操作方法名(event)**： 当在ohpm-repo管理界面执行一系列操作时，会在operate.log文件生成一条条操作数据，操作方法名即表示当前操作涉及到的方法名字，例如login即表示登录操作，analyzePackage即表示上传包时对包的解析操作。

**表1** 常用操作方法说明
|序号|Event描述|说明|
|:--|:--|:--|
|1|generateAccessToken / deleteAccessToken|生成 / 删除AccessToken|
|2|login / logout|登入 / 登出|
|3|publish / unPublish/batchUnPublish|上架资源包/ 下架资源包/批量下架资源包|
|4|addGroup / deleteGroup|添加/删除组织|
|5|updateGroup|更新组织|
|6|addMember/deleteMember|添加 / 删除组织成员|
|7|addAdminMember/deleteAdminMember|添加/删除组织管理员|
|8|addPublicKey / delPublicKeyById|添加 / 删除发布公钥|
|9|addRepo/updateRepo/deleteRepo|新增仓库/更新仓库/删除仓库|
|10|analyzePackage|解析上传的包文件|
|11|uploadPackage|上传包文件|
|12|getPackageSizeLimit|获取包的大小限制|
|13|addUplink / deleteUplink|添加 / 删除uplink|
|14|updateUplink|更新uplink|
|15|updateUplinkProxy|更新Uplink代理|
|16|addUser / delUserByUserId|添加/删除用户|
|17|changePassWord|改变用户账户密码|
|18|resetPassWord|重置用户账户密码|
|19|changeRole|修改用户角色(管理员和非管理员)|
|20|register|注册账户|
|21|resetKey|重置系统密钥|
|22|addPackagePermissionOwner/deletePackagePermissionOwner/transferPackagePermissionOwner|新增/删除/转移包所有者|
|23|addPackagePermissionMaintainer/deletePackagePermissionMaintainer|新增/删除包维护者|
|24|addPackagePermissionVisitor/deletePackagePermissionVisitor|新增/删除包白名单用户|
|25|editPackageReadPolicy|编辑包可见性|

## 运行日志 - run.log

运行日志中主要包含操作时间、日志级别以及日志信息，其文件保存个数最多为30个。运行日志定义了日志级别：all，trace，debug，info，warn，error，fatal，mark和off。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155730.94829438043169180468312748481339:50001231000000:2800:FBD594AB2E8E32A5542F89B17ED6350FF525906696F4656695A47E57FC58D0A9.png "点击放大")

## 运行错误日志 - repoError.log

当ohpm-repo在运行过程中，所有run.log中生成的error日志都会打印到repoError.log中，是error日志的集合，日志打印级别与run.log日志保持一致。

## 下载错误日志

当从仓库中下载某个包失败时，仓库会生成一条错误日志记录在数据库中的downloadfailure 表中，当为ohpm-repo配置了sftp存储服务时，从任意一个sftp服务中下载失败时，都会生成一条错误日志并保存。每条日志都有handled标识，handled为0时表示已处理，handled为1时表示未处理。

## 日志存储路径

日志存储的默认路径为./logs，相对路径基准为ohpm-repo部署根目录[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_%E5%85%B3%E4%BA%8E-deploy_root)。

## 日志打印级别

在配置文件中可以设置访问、操作、运行日志的打印级别，日志将会只打印不低于设置级别的日志，日志级别由低到高为：all，trace，debug，info，warn，error，fatal，mark和off。

1. loglevel_run: info
2. loglevel_operate: info
3. loglevel_access: info

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration "配置文件")
# 单点部署

更新时间: 2025-12-16 15:57

说明

ohpm-repo私仓不允许在Linux或macOS系统中使用root用户启动，请使用普通用户安装运行。

## 安装ohpm-repo工具

1. ohpm-repo依赖于Node运行，支持Node.js 18.x及以上版本，请提前安装Nodejs，并完成环境变量的配置。Node.js安装请参考[Node.js官方网站](https://nodejs.org/download/release/latest/)。
    
2. 下载ohpm-repo工具包，[点击链接获取](https://developer.huawei.com/consumer/cn/download/ohpm-repo)**。**
    
3. 解压ohpm-repo私仓工具包。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155733.54164763087581820782279345443324:50001231000000:2800:7B50FA61311BAA26CAFA40FEB5B26C30549090E688DB68659B8D61CAC21D75D9.png)
    

4. 请将ohpm-repo工具包解压目录中bin目录的路径配置到[系统环境变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-faq#section24117279211)path中，执行如下查询命令:
    
    1. ohpm-repo -v
    
    终端输出版本号（如：2.0.0），则表示安装包解压无问题。如有报错，请参考[FAQ](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-faq#section82-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4-ohpm-repo-command%E6%8A%A5%E9%94%99-ohpm-repo-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%88%96%E8%80%85-command-%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%AD%98%E5%9C%A8)解决。
    
    注意
    
    针对Linux和Mac系统，建议使用bash作为命令行界面。
    
5. 进入ohpm-repo解压目录的conf目录中，修改配置文件config.yaml：
    - 检查[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)配置，默认配置为localhost:8088 ，表示仅支持监听本机地址；如果希望其他机器通过ip/域名访问，则建议修改listen配置为ohpm-repo部署机器的ip：
        
        1. listen: <部署ohpm-repo机器的ip>:8088
        
    - 检查[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_deploy_root)配置：如果选择不配置，会存储在默认地址中。禁止该路径配置为ohpm-repo解压根目录。
    - 数据存储db模块使用filedb：
        
        1. db:
        2.   type: filedb
        3.   config:
        4.     path: ./db
        
    - 文件存储store模块使用fs：
        
        1. store:
        2.   type: fs
        3.   config:
        4.     path: ./storage
        5.     #server: http://localhost:8088
        
    - 检查是否配置了[store.config.server](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)，用于指定ohpm-repo仓库内容的下载地址，不配置取默认值，具体请参考[server: 仓库内容的下载地址](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_li922300957171146)。如果[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)的host为0.0.0.0，且本机存在多个网络接口，那么该值必须配置，建议手动修改server的host为本机指定的ip/域名，例如listen为0.0.0.0:8088，故server需配置为http://<指定部署机器的ip/域名>:8088。
        
        说明
        
        - 如果为ohpm-repo服务配置了反向代理服务器，则[store.config.server](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)必须填写为反向代理服务器的ip/域名地址，且需要配置[use_reverse_proxy](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#section1074004784011)值为true。
        - config.yaml中各项配置的详细描述请见：[配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration)。
        
6. 进入ohpm-repo解压目录的bin目录下，执行安装命令:
    
    1. ohpm-repo install 
    
    说明
    
    不配置参数--config，默认使用ohpm-repo根目录中conf目录内自带的配置文件config.yaml。
    
    启动成功日志信息如下：
    
    2. PS D:\> ohpm-repo install
    3. [2025-08-26T14:29:15.153] [WARN] default - "listen" protocol is set to 'http' in "config.yaml" file, which is insecure, advise to use the more secure 'https' protocol instead.
    4. [2025-08-26T14:29:15.178] [INFO] default - initialize encryption component successfully.
    5. [2025-08-26T14:29:15.179] [INFO] default - initialize "file database" successfully.
    6. [2025-08-26T14:29:15.184] [INFO] default - initialize "file storage" successfully.
    7. 。。。
    8. [2025-08-26T14:29:15.194] [INFO] console - install successfully.
    9. [2025-08-26T14:29:15.195] [INFO] default - "deploy_root" environment variables: "OHPM_REPO_DEPLOY_ROOT = C:\Users\xxx\AppData\Roaming\Huawei\ohpm-repo".
    
7. 安装成功后，必须根据给出的提示信息及时刷新环境变量，针对Windows系统和Linux/Mac系统，有不同处理方式：
    
    说明
    
    - Windows系统： 关闭当前窗口，重新开启一个窗口。
    - Linux系统或Mac系统： 在命令行中执行刷新命令：当shell为bash时执行_**source ~/.bashrc**_ 或者 . **_~/.bashrc_** ；当shell为zsh时，执行_source ~/.zshrc_ 或者 . _~/.zshrc_ 。
    

## 启动ohpm-repo

执行start命令启动ohpm-repo。

1. ohpm-repo start 

启动成功日志信息如下：

1. PS D:\> ohpm-repo start
2. [2025-08-26T14:31:22.209] [WARN] default - "listen" protocol is set to 'http' in "config.yaml" file, which is insecure, advise to use the more secure 'https' protocol instead.
3. [2025-08-26T14:31:22.211] [INFO] default - config file path: "C:\Users\xxx\AppData\Roaming\Huawei\ohpm-repo\conf\config.yaml".
4. [2025-08-26T14:31:22.216] [INFO] default - initialize "file database" successfully.
5. [2025-08-26T14:31:22.217] [INFO] default - initialize "file storage" successfully.
6. [2025-08-26T14:31:22.237] [INFO] console - http address - localhost:8088 - ohpm-repo/5.1.5.

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-deploy-guide "部署指导")
# 多实例部署

更新时间: 2025-12-16 15:57

说明

- ohpm-repo私仓不允许在Linux或macOS系统中使用root用户启动，请使用普通用户安装运行。
- 只有db存储为mysql且store存储为sftp或者custom时，才支持多实例方式部署。本章节多实例部署以db存储为mysql，store存储为sftp为例。

## 环境准备

1. 准备mysql数据库服务；
2. 准备至少一个sftp存储服务，ohpm-repo最大支持连接3个sftp服务；
3. 安装Node.js18.x及以上版本。

说明

- 确保sftp服务端口能够被外部机器访问。
- sftp服务的读写用户应该指定相同的存储根目录。

## 安装ohpm-repo工具

1. 解压ohpm-repo工具包
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155735.54463571741923025075604999129090:50001231000000:2800:2EA6DD10EC0831DB580711BCD852879A41B7F5AB772702DD21B0F0D2CF9D0B44.png)
    
2. 请将ohpm-repo工具包解压目录中bin目录的路径配置到[系统环境变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-faq#section24117279211)path中，执行如下查询命令:
    
    1. ohpm-repo -v
    
    终端输出版本号（如：2.0.0），则表示安装包解压无问题。如有报错，请参考[FAQ](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-faq#section82-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4-ohpm-repo-command%E6%8A%A5%E9%94%99-ohpm-repo-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%88%96%E8%80%85-command-%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%AD%98%E5%9C%A8)解决。
    
    注意
    
    针对Linux和Mac系统，建议使用bash作为命令行界面。
    
3. 进入ohpm-repo解压目录的conf目录中，修改配置文件config.yaml：
    - 检查[listen](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_listen)配置，默认配置为localhost:8088 ，表示仅支持监听本机地址；如果希望其他机器通过ip/域名访问，则建议修改listen配置为ohpm-repo部署机器的ip地址：
        
        1. listen: <部署ohpm-repo机器的ip>:8088
        
    - 检查[deploy_root](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_deploy_root)配置：如果选择不配置，会存储在默认地址中。禁止配置该路径配置为ohpm-repo解压根目录。
    - 数据存储db模块使用mysql：
        
        1. db:                         
        2.   type: mysql
        3.   config:
        4.     host: "localhost"
        5.     port: 3306
        6.     username: "tctAdmin"
        7.     password: "password"
        8.     database: "repo"
        
    - 文件存储store模块使用sftp，sftp配置最多只能设置3个：
        
        1. store:                               
        2.   type: sftp                         
        3.   config:
        4.     location:
        5.       -      
        6.         name: test_one_sftp          
        7.         host: "localhost"           
        8.         port: 22                     
        9.         read_username: "read"   
        10.         read_password: "password" 
        11.         write_username: "write"   
        12.         write_password: "password" 
        13.         path: /source22 
        14.       -  
        15.         name: test_two_sftp
        16.         host: "localhost"
        17.         port: 24
        18.         read_username: "read"
        19.         read_password: "password"
        20.         write_username: "write"
        21.         write_password: "password"
        22.         path: /source24
        23.     #server: http://localhost:8088
        
        注意
        
        1、ohpm-repo文件的存储路径为： <sftp服务器配置的存储根目录> +<store配置的[path](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_li1275312401171146)路径>，其中path只支持相对路径，必须以/开头。例如sftp服务器存储根目录为/user/sftp/data，store中[path](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_li1275312401171146)配置的路径为/source，故最终ohpm-repo文件存储路径为/user/sftp/data/source。
        
        2、多实例部署ohpm-repo时，必须配置反向代理服务器，转发客户端请求到部署的多个ohpm-repo实例服务器中，故[store.config.server](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#zh-cn_topic_0000001745376470_store)必须手动配置为反向代理服务器的域名/ip地址，且需要配置[use_reverse_proxy](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-configuration#section1074004784011)值为true。
        

4. 进入ohpm-repo解压目录的bin目录下，执行安装命令:
    
    1. ohpm-repo install 
    
    说明
    
    不配置参数--config，则默认使用ohpm-repo解压目录中conf目录内自带的配置文件config.yaml。
    
    安装成功日志信息如下：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155735.67449947767883164404962491991226:50001231000000:2800:735E9574828A02BC49FDF21EA6F276E00B5E988B0949A969FDF68872FD3DBDE1.png "点击放大")
    
5. 安装成功后，必须根据给出的提示信息刷新环境变量，针对Windows系统和Linux/Mac系统，有不同处理方式：
    
    说明
    
    - Windows系统： 关闭当前窗口，重新开启一个窗口。
    - Linux系统或Mac系统： 在命令行中执行刷新命令：当shell为bash时执行_source ~/.bashrc_ 或者 . _~/.bashrc_ ；当shell为zsh时，执行_source ~/.zshrc_ 或者 . _~/.zshrc_ 。
    

## 部署首个节点

进入ohpm-repo解压目录的bin目录中，命令行启动ohpm-repo。

1. ohpm-repo start 

启动成功日志信息如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155735.63186911601241611065768982095122:50001231000000:2800:575DF1CE831A2A7EDDE766519CCC43507676AE76B1892DCC06D92DA88BF5FC19.png "点击放大")

## 打包和部署

为帮助更方便地完成多实例部署，已提供打包和部署命令。

### 打包

在完成了多实例配置并首次启动过ohpm-repo服务实例的机器上，执行ohpm-repo pack <deploy_root>。

1. ohpm-repo pack D:\ohpm-repo

说明

该命令用来打包备份ohpm-repo的<deploy_root>/conf，<deploy_root>/meta目录，并在命令行工作目录下生成压缩包。

打包成功日志信息如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155735.92188108768855022625393754288554:50001231000000:2800:45E7E34DE1731F45553D1679FEECF8C89255B56635C98F75FAF27A60EF61239F.png "点击放大")

### 部署

将pack命令的产物拷贝到其他机器中。在解压ohpm-repo压缩包后，使用ohpm-repo deploy <file_path>命令部署新的实例。

1. ohpm-repo deploy D:\ohpm-repo\bin\pack_1695805599689.zip --deploy_root D:\new-ohpm-repo\ohpm-repo-deploy

说明

- <file_path>： 参数指定备份压缩包地址。
- --deploy_root： 指定部署根目录，用于存储ohpm-repo启动时生成的文件，默认使用 <现有用户home目录>/ohpm-repo。

部署成功日志信息如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155735.91767962816868892173601205338260:50001231000000:2800:835CD690D0174D80417B05B10833CC33C69826E239E083A190003C460FCE9689.png "点击放大")

部署成功后可执行ohpm-repo start启动ohpm-repo。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155735.58858309358905961247866221576817:50001231000000:2800:049301635BE6EDFF30CDAA14CCA33D8923EA13CA84FFF797D30E9E801DF8D79A.png "点击放大")

## 配置自动重启（可选）

为ohpm-repo实例配置系统重启时自动重启的功能。

说明

在进行该配置前需要将ohpm-repo工具bin目录配置到[系统环境变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-repo-faq#section24117279211)path中。

### Linux

1. 在ohpm-repo工具的bin目录下创建自动运行脚本run-repo.sh：
    
    1. touch run-repo.sh
    
2. 写入下面内容，保存并关闭文件：
    
    说明
    
    当mysql或sftp服务与ohpm-repo部署在同一服务器上时，请将mysql和sftp的启动命令放在ohpm-repo start命令之前。
    
    1. #!/bin/bash
    2. ohpm-repo start
    
3. 将该脚本设置为可执行文件：
    
    1. chmod +x run-repo.sh
    
4. 使用linux的定时任务工具crontab重启自动执行脚本。编辑当前用户的crontab配置：
    
    1. crontab -e
    
5. 当前用户的crontab配置写入下面内容，保存并关闭文件：
    
    1. @reboot /bin/sh run-repo.sh >/dev/null 2>&1
    

其中run-repo.sh表示要执行的脚本路径；>/dev/null 2>&1表示将输出重定向到空设备，即不输出任何信息。

现在，每次系统启动时，都会自动执行run-repo.sh脚本中的命令。

### Windows

1. 新建run-repo.bat文件，写入下面内容：
    
    说明
    
    当mysql或sftp服务与ohpm-repo部署在同一服务器上时，请将mysql和sftp的启动命令放在ohpm-repo start命令之前。
    
    1. @echo off
    2. call ohpm-repo start
    3. exit
    
2. 按下win+R，输入shell:startup，回车：弹出启动文件框；将run-repo.bat文件剪切到启动文件夹下即可。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155736.07487797604045365124258516091099:50001231000000:2800:3B10926558813F2911FD8E27384CDC608E96173DEF23901F940682344C5222B7.png "点击放大")
    

现在，每次系统启动时，都会自动执行run-repo.bat脚本中的命令。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ohpm-deploy-single-instance "单点部署")
# 在模块中添加Ability

更新时间: 2025-12-16 15:57

Ability是应用/元服务所具备的能力的抽象，应用的一个Module可以包含一个或多个Ability，元服务仅包含一个Ability。应用/元服务先后提供了两种应用模型：

- FA（Feature Ability）模型： API 7开始支持的模型，已经不再主推。
- Stage模型：HarmonyOS 3.1 Developer Preview版本开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Windows窗口的“舞台”，因此称这种应用模型为Stage模型。
    
    Stage模型包含两种Ability组件类型：
    
    - UIAbility组件：包含UI界面，提供展示UI的能力，主要用于和用户交互。详细介绍请参见[UIAbility组件概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-overview)。
    - ExtensionAbility组件：提供特定场景的扩展能力，满足更多的使用场景。详细介绍请参见[ExtensionAbility概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/extensionability-overview)。元服务暂不支持使用ExtensionAbility组件。

## Stage模型添加Ability

### 在模块中添加UIAbility

1. 选中对应的模块，单击鼠标右键，选择**New > Ability**。
2. 设置Ability名称，选择是否在设备主屏幕上显示该功能的启动图标，单击Finish完成Ability创建。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.93846847532218884989227254091387:50001231000000:2800:D2245EF416B2006B97055D3EAC95E9E2A6EB27D099D566BD1166968A62E0405C.png)
    

### 在模块中添加Extension Ability

1. 在工程中选中对应的模块，单击鼠标右键，选择**New > Extension Ability**，选择不同的场景类型 。当前仅Application工程支持创建Extension Ability。
    
    - 若创建的模块类型为entry或feature，支持创建以下五种Extension Ability：
        - **EmbeddedUIExtensionAbility**：用于提供[跨进程界面嵌入](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/embeddeduiextensionability)的能力。
        - **Backup****Ability**：用于提供[备份及恢复应用数据](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-file-backup-overview)的能力。
        - **WorkScheduler**：用于提供[延迟任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/work-scheduler)的相关能力。
        - **RemoteNotificationAbility**：用于提供获取场景化消息数据和生命周期销毁的回调的通知能力。
        - **Driver**：用于提供[驱动相关扩展框架](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/driverextensionability)。仅在当前工程的设备类型只含有2in1设备时，支持创建该类型。
    - 若创建的模块类型为HAR或HSP，支持创建以下两种Extension Ability：
        - **EmbeddedUIExtensionAbility**：用于提供[跨进程界面嵌入](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/embeddeduiextensionability)的能力。
        - **WorkScheduler**：用于提供[延迟任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/work-scheduler)的相关能力。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.49842738246989101511143584420369:50001231000000:2800:E614B56A7BD7B894330905903C851A073348200A48CB71E8D637CF1B5130AA79.png)
    
2. 设置Ability名称，单击Finish完成Extension Ability创建。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.41738365717439615718963176324754:50001231000000:2800:1235D21ACEF999157D9FD28C0776DE5060E529E94F70450E2094943C75CFA194.png)
    

## FA模型添加Ability

ArkTS工程与JS工程在FA模型中添加Ability的操作方式一致，本节内容以ArkTS工程为例介绍在模块中添加Ability。

### 创建Particle Ability

1. 选中对应的模块，单击鼠标右键，选择**New > Ability** ，然后选择对应的Data Ability/Service Ability模板。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.67620966478069682345558224380351:50001231000000:2800:F718783307507C6E23625E05FC25AE766A81ECF11E19BDF7C297F48F417BD98C.png)
    
2. 根据选择的Ability模板，设置Ability的基本信息。
    
    - **Ability name**：Ability类名称，由大小写字母、数字和下划线组成。
    - **Language**：该Ability使用的开发语言。
    
3. 单击**Finish**完成Ability的创建，可以在工程目录对应的模块中查看和编辑Ability。

### 创建Feature Ability

1. 选中对应的模块，单击鼠标右键，选择**New > Ability** ，然后选择对应的Page Ability模板。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155724.18840219801761584670492251659824:50001231000000:2800:03C321E2B4B38364B98F7E6DE71286744BD1BCBF155519507C3A2C2F1E540C2D.png)
    
2. 根据选择的Ability模板，设置Ability的基本信息。
    
    - **Ability name**：Ability类名称，由大小写字母、数字和下划线组成。
    - **Launcher ability**：表示该Ability在终端桌面上是否有启动图标，一个HAP可以有多个启动图标，来启动不同的FA。
    - **Language**：该Ability使用的开发语言。
    
3. 单击**Finish**完成Ability的创建，可以在工程目录对应的模块中查看和编辑Ability。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-rule-verification-template-file "模板文件")
# 创建服务卡片

更新时间: 2025-12-16 15:57

## 概述

[服务卡片（简称“卡片”）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/formkit-overview)可将元服务/应用的重要信息以卡片的形式展示在桌面，用户可通过快捷手势使用卡片，通过轻量交互行为实现服务直达、减少层级跳转的目的。

卡片类型分静态卡片和动态卡片两种。静态卡片内存占用较小，有助实现整机内存优化，可实现静态信息展示、刷新和点击跳转；动态卡片支持自定义交互、动效、滑动等功能，功能丰富但内存占用较大。

从编译产物角度，卡片包产物分为共包和独立包两种类型，详情请参考[创建ArkTS卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation)。

|创建方式|卡片类型|
|:--|:--|
|共包|静态卡片（Static Widget）|
|动态卡片（Dynamic Widget）|
|独立包|独立静态卡片（Static Widget(Standalone)）|
|独立动态卡片（Dynamic Widget(Standalone)）|

创建卡片后可选择不同卡片模板以满足业务需求，具体卡片模板和详细描述如下。

|模板名称|支持的设备|支持的开发语言|模板描述|
|:--|:--|:--|:--|
|Hello World|Phone、Tablet、2in1、Wearable、Car、TV|ArkTS、JS|HelloWorld卡片，用于高效直观地构建UI。当前Hello World卡片模板支持使用6*4尺寸。|
|Image With Information（图文卡片模板）|Phone、Tablet、2in1、Wearable、Car|ArkTS、JS|图文卡片模板主要在于展现图片和一定数量文本的搭配，在这种布局下，图片和文本属于同等重要的信息。在不同尺寸下，图片大小和文本数量会发生一定变化，用于凸显关键信息。|
|Immersive Information（沉浸图文卡片模板）|Phone、Tablet、2in1、Wearable、Car|ArkTS、JS|沉浸式卡片的装饰性较强，能够较好的提升卡片品质感并起到装饰桌面的作用，合理的去布局信息与背景图片之间的空间比例，可以提升用户的个性化使用体验。|
|List|Phone、Tablet、2in1、Car|ArkTS|提供基本的列表功能。当前仅动态卡片支持在API 11及以上工程创建List卡片模板。|
|Control Button|Phone、Tablet、2in1、Car|ArkTS|操控类型的卡片，展示文本信息与按钮操作，点击按钮响应事件。当前仅静态卡片支持API 11及以上工程创建Control Button卡片模板。|
|Control Search|Phone、Tablet、2in1、Car|ArkTS|操控类型的卡片，适用于搜索场景。当前仅静态卡片支持API 11及以上工程创建Control Search卡片模板。|

## 使用约束

- 卡片不支持调试。
- 仅应用的Hello World、Image With Information、Immersive Information的动态卡片和独立动态卡片支持JS语言，元服务不支持JS语言。
- 从DevEco Studio 5.0.4 Release开始，支持在API 16及以上工程创建Wearable设备可用的卡片。
- 从DevEco Studio 6.0.0 Beta3开始，支持在API 20及以上工程创建Car设备可用的卡片。
- 从DevEco Studio 6.0.0 Beta3开始，支持Phone设备创建独立静态/动态卡片。
- DevEco Studio 5.1.1 Release（Build Version:5.1.1.850）版本、DevEco Studio 6.0.0 Release（Build Version:6.0.0.868）及以上版本，支持工程创建TV设备可用的卡片。
- 一个工程模块内，仅支持创建共包类型卡片或独立包类型卡片。
- 每个模块最多可以配置16张卡片。

## 创建服务卡片

[创建一个工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-create-new-project)后，可以通过如下方法进行创建卡片。

1. 创建卡片包括如下两种方式：
    
    - 选择模块（如entry模块）下的任意文件，单击菜单栏**File > New > Service Widget**，[按需选择卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-service-widget#section6353219163116)。
    - 选择模块（如entry模块）下的任意文件，单击**右键 > New > Service Widget**，[按需选择卡片](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-service-widget#section6353219163116)。
    
    说明
    
    - API 11 Stage模型及以上，创建元服务工程或在元服务工程中创建模块时，不再默认创建卡片和EntryCard。
    
2. 在**Choose a Template for Your Service Widget**界面中，选择卡片模板，单击**Next**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.92724805757218177950828966990057:50001231000000:2800:6AF6F9353D526CF0C1DC4F3D8C63F69F8A90C5DC5F5770DDF6E5F1245BBC6A0F.png)
    
3. 在**Configure Your Service Widget**界面中，配置卡片的基本信息，包括：
    
    - **Service widget name**：卡片的名称，在同一个应用/元服务中，卡片名称不能重复，且只能包含大小写字母、数字和下划线。
    - **Display name**：卡片预览面板上显示的卡片名称。仅API 11 及以上Stage工程支持配置该字段。
    - **Description**：卡片的描述信息。
    - **Language：**界面开发语言，可选择创建ArkTS/JS卡片。
    - **Support dimension**：选择卡片的规格。部分卡片支持同时设置多种规格。首次创建卡片时，将默认生成一个EntryCard目录，用于存放卡片快照。
    - **Default dimension**：在下拉框中可选择默认的卡片。
    - **Ability name：**选择一个挂靠卡片的Form Ability，或者创建一个新的Form Ability。
    - **Module name：**卡片所属的模块。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.19184888172375033502626385276631:50001231000000:2800:9C3B749409F2590824F4A2BB42141C1383614B7FBF7B829E86E7CDD768B06FAC.png)
    
4. 单击**Finish**完成卡片的创建。创建完成后，工具会自动创建出卡片的布局文件，并在form_config.json文件中写入服务卡片的属性字段，关于各字段的说明请参考[配置文件说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-configuration)。
5. 卡片创建完成后，请根据开发指导，完成卡片的开发，详情请参考[服务卡片开发指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget)。

## 预览服务卡片

在开发卡片过程中，支持对卡片进行实时预览。卡片通过ArkTS文件进行布局设计，在开发过程中，可以对布局文件进行实时预览，只要在布局文件中保存了修改的源代码，在预览器中就可以实时查看布局效果。在Phone和Tablet卡片的预览效果中，每个尺寸的卡片提供3种场景的预览效果，分别为极窄（Minimum）、默认（Default）、极宽(Maximum)，开发者应确保三种尺寸的显示效果均正常，以便适应不同屏幕尺寸的设备。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.03196906111669397724568461998436:50001231000000:2800:CE944F0C380585DAC409BD2CF9880E2B5514CFF83CE8A045E38A79BD423E30B4.png)

关于预览器的使用详细说明请参考[界面预览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-01)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-add-new-ability "在模块中添加Ability")
# 添加Page

更新时间: 2025-12-16 15:57

在ArkTS语言的工程中，支持添加Page。Page是表示应用/元服务的一个页面。应用/元服务可以设计为多个功能页面，每个页面进行单独的文件管理，并通过路由API实现页面的调度管理，以实现应用内功能的解耦。ArkTS语言的工程添加Page后，会在pages文件夹下生成一个新的ets文件。

1. 在Stage工程中选中ets文件夹下的pages，单击鼠标右键，选择**New > Page**，当前提供如下Page类型：
    
    - Empty Page：创建一个普通页面，展示基础的Hello World功能；
    - Map Page：创建一个地图页面，展示地图视图功能，当前仅支持在Phone设备中使用；
    - Payment Page：创建一个支付页面，可以实现点击按钮调起支付弹窗，当前仅支持在Phone设备中使用；
    - Iap Page：IAP Kit场景化模板，支持快速创建应用内支付购买虚拟数字商品相关代码。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.49382668994428618117082322716229:50001231000000:2800:17E2AB53FD21E59611E17336F718B7874448FBD72054F514D0530FD0BA9ACEEB.png)
    
    说明
    
    API 10工程中仅支持创建Page，展示基础的Hello World功能；如需使用场景化Page模板，请将工程切换为API 11及以上后进行开发。
    
2. 输入Page name（由大小写字母、数字和下划线组成），单击**Finish**完成添加。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.46442292332562793895285737461490:50001231000000:2800:45DFEF277CB36FAFCD2D01DE2B8D49537C6C87134DED0326C68E9A020C03BC4E.png "点击放大")
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-service-widget "创建服务卡片")
# 业务介绍

更新时间: 2025-12-16 15:57

## 什么是端云一体化开发

为丰富HarmonyOS对云端开发的支持、实现端云联动，DevEco Studio以[Cloud Foundation Kit（云开发服务）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-introduction)为底座、在传统的“端开发”基础上新增“云开发”能力：开发者选择云开发工程模板，可创建一个同时包含端侧工程与云侧工程的端云一体化工程。之后，开发者在云侧工程对云函数或者云数据库等服务进行开发、调试和部署，而后在端侧工程通过Cloud Foundation Kit调用部署的云端服务。

DevEco Studio中提供的端云一体化开发体验，支持开发者基于统一的技术栈进行端、云代码协同开发，前端开发人员轻松转换为全栈工程师，极大提高了构建HarmonyOS应用和元服务的效率、降低开发成本。

## 什么是云开发工程模板

云开发工程模板是为端云一体化开发工程构建的场景化模板，提供了常见场景的代码实现。使用云开发工程模板，您可根据工程向导轻松创建端云一体化开发工程，工程将自动加载模板内预置的代码和资源文件。

DevEco Studio目前预置了通用云开发模板，该模板当前使用[Cloud Foundation Kit（云开发服务）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-introduction)搭建了基础的演示项目，不含业务属性。您可参考模板学习如何进行基础的端云工程开发，后续开发时可删除预置的页面代码。

[点击此处](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-emptyability)了解通用云开发模板的更多信息。

## 端云一体化开发特性

端云一体化开发特性主要包含了如下功能。

|主要功能|说明|
|:--|:--|
|端云一体化开发|您不仅可以在DevEco Studio中开发和调试应用端侧的业务代码，还可以开发和调试应用云侧的服务代码、并在开发完成后将云侧工程一键部署至AGC云端。|
|Cloud Foundation Kit|云侧工程接入Cloud Foundation Kit，按需为应用提供云函数、云数据库、云存储等云端服务，借助Cloud Foundation Kit开箱即用、一键部署、自动弹性伸缩、免运维等特点助力开发者降本增效。|

## 端云一体化开发的优势

相比于传统开发模式，端云一体化开发模式具备成本低、效率高、门槛低等优势，具体区别见下表。

|区别点|传统开发模式|端云一体化开发模式|
|:--|:--|:--|
|开发工具|端侧与云侧各需一套开发工具，云侧需自建服务器，工具成本高。|DevEco Studio一套开发工具即可支撑端侧与云侧同时开发，无需搭建服务器，工具成本低。|
|开发人员|- 端侧与云侧要求不同的开发语言，技能要求高。<br>- 需多人投入，且开发人员之间需持续、准确沟通，人力与沟通成本高、效率低。|- 依托Cloud Foundation Kit开放的接口，端侧开发人员也能轻松开发云侧代码，大大降低开发门槛。<br>- 开发人员数量少，降低人力成本，提高沟通效率。|
|运维|需自行构建运营与运维能力，成本高、负担重。|直接接入Cloud Foundation Kit，具有开箱即用、一键部署、自动弹性伸缩、免运维等特点，开发者可聚焦业务逻辑本身，实现降本增效。|

## 工作原理

DevEco Studio支持开发者在本地完成云侧服务资源的开发与部署，并可在端侧工程中调用您开发的云侧代码，真正实现端云一体化开发。

1. 选择云开发工程模板，根据工程向导[创建端云一体化开发工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-devproject)。
2. 分别为Cloud Foundation Kit提供的各个服务完成端云代码的开发、调试和部署。
    
    说明
    
    云侧与端侧工程的代码可并行开发，一般无先后顺序。但若需在端侧代码中调用云侧代码，云侧代码必须先部署到AGC云端，因此建议您先完成云侧代码的开发、调试与部署，再进行端侧代码开发与调试。
    
    1. 开发云侧工程：在云侧工程开发Cloud Foundation Kit提供的服务，目前包括云函数、云对象和云数据库。
        - [开发云函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudfunctions)：在云侧工程下创建并配置函数、开发函数代码、调试函数、部署函数到AGC云端。
        - [开发云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudobj)：在云侧工程下创建云对象、开发云对象代码、调试云对象、部署云对象到AGC云端。
        - [开发云数据库](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-clouddb)：在云侧工程下中创建对象类型、在对象类型中添加数据条目、部署云数据库到AGC云端。
    2. [部署云侧工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploy)：云侧工程代码开发调试完毕后，一键部署云侧工程到AGC云端。
    3. [开发端侧工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-appdevelop)：在端侧工程下通过Cloud Foundation Kit调用部署的云侧代码，包括调用云函数、调用云对象、访问云数据库、调用云存储。
    
3. 端云两侧工程代码全部开发完成后，将端云一体化工程打包成APP，提交至AGC申请上架。

## 约束与限制

### 支持的设备

仅支持手机。

### 支持的国家/地区

当前仅在中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）提供服务。

### 支持的签名方式

当前自动签名仅支持“[关联注册应用进行签名](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-signing#section20943184413328)”方式。

### 模拟器支持情况

从6.0.0(20) Beta5版本开始支持模拟器开发，但与真机存在部分能力差异，详情请参见“[模拟器与真机的差异](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-specification#section38231424133213)”。

关于如何使用模拟器调试，请参见[使用模拟器调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-emulator)。

## 计费说明

使用端云一体化开发服务时，会开通并使用云函数、云数据库、云存储服务。华为为每个服务都提供了免费额度以供试用，具体的配额明细可以参考各服务的配额说明：

- [云函数](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-cloud-function-price-0000001211271102)
- [云数据库](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-clouddb-price-0000001256815629)
- [云存储](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-cloudstorage-price-0000001253665999)

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddevguide "端云一体化开发")

# # 实践说明

更新时间: 2025-12-16 15:59

某对外发布应用共有两个版本：

1. Community社区版本，免费，向个人开发者用户提供该应用绝大部分基础功能，但是不提供部分定制化限定功能及技术支持。

2. Ultimate终极版本，收费，向个人、政企等开发者用户提供该应用全部基础功能，同时提供定制化限定功能及技术支持。

可以看出在Community版本与Ultimate版本之间，部分功能存在重合，同时也存在某些特定功能，所以期望通过一次开发以实现差异化，根据不同配置完成多种特定运行环境的开发、预览、打包、调试等功能。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155927.03153565758301484936462732542955:50001231000000:2800:F06E637921572ED77D30AB03AA90A09845AAD27236A5E18C5DDE49BE87D7BA6F.png)

1. 两个不同版本的软件，可能存在差异：如不同的应用标题、应用图标、版本声明。我们可以在工程级build-profile.json5->app{}->products[]中，可以对两种不同的外发版本进行差异化定制，新增两个product：Community和Ultimate。根据已支持的字段进行定制修改。

2. {
3.   "name": "Ultimate",
4.   // ultimate版本签名
5.   "signingConfig": "Ultimate",
6.   // ultimate版本包名
7.   "bundleName": "com.example.ultimate.app",
8.   // ultimate版本应用图标
9.   "icon": "$media:app_icon",
10.   // ultimate版本应用标签
11.   "label": "$string:app_name",
12.   "versionCode": 10000,
13.   "versionName": "1.0.0",
14.   // ultimate版本指定资源目录
15.   "resource": {
16.     "directories": [
17.       "./AppScope/ultimateRes"
18.     ]
19.   },
20.   // ultimate版本指定输出产物名
21.   "output": {
22.     "artifactName": "ultimate_version"
23.   },
24.   "bundleType": "app",
25.   "compatibleSdkVersion": "6.0.1(21)",
26.   "runtimeOS": "HarmonyOS"
27. },
28. {
29.   "name": "Community",
30.   "signingConfig": "Community",
31.   // community版本签名
32.   "bundleName": "com.example.community.app",
33.   // community版本包名
34.   "icon": "$media:app_icon",
35.   // community版本应用图标
36.   "label": "$string:app_name",
37.   // community版本应用标签
38.   "versionCode": 10000,
39.   "versionName": "1.0.0",
40.   // community版本指定资源目录
41.   "resource": {
42.     "directories": [
43.       "./AppScope/communityRes"
44.     ]
45.   },
46.   // community版本指定输出产物名
47.   "output": {
48.     "artifactName": "community_version"
49.   },
50.   "bundleType": "app",
51.   "compatibleSdkVersion": "6.0.1(21)",
52.   "runtimeOS": "HarmonyOS",
53. }

54. 应用软件部分功能可能针对特定场景存在定制场景：如ultimate版本的功能A在phone设备类型上免费，在TV设备类型上需要收费；再如community版本的功能B在2in1设备类型上的启动页与在wearable设备类型上呈现效果存在差异。在模块级build-profile.json5->targets[]中新增2个 target：vip和free。

55. {
56.   "name": "vip",
57.   // 定制vip包输出产物名
58.   "output": {
59.     "artifactName": "vipVersion"
60.   },
61.   // 定制vip包源码指定页面
62.   "source": {
63.     "pages": [
64.       "pages/vipIndex"
65.     ]
66.   },
67.   // 指定vip包资源目录
68.   "resource": {
69.     "directories": [
70.       "./src/main/ultimateRes"
71.     ]
72.   },
73.   "config": {
74.     // 指定vip包适用设备类型
75.     "deviceType": [
76.       "phone",
77.       "tablet",
78.       "2in1"
79.     ]
80.   }
81. },
82. {
83.   "name": "free",
84.   // 定制free包输出产物名
85.   "output": {
86.     "artifactName": "freeVersion"
87.   },
88.   // 定制free包源码指定页面
89.   "source": {
90.     "pages": [
91.       "pages/freeIndex"
92.     ]
93.   },
94.   // 指定free包资源目录
95.   "resource": {
96.     "directories": [
97.       "./src/main/communityRes"
98.     ]
99.   },
100.   "config": {
101.     // 指定free包适用设备类型
102.     "deviceType": [
103.       "phone",
104.       "tablet"
105.     ]
106.   }
107. }

108. 新增product、target后，需要在工程级build-profile.json5->modules[]->targets[]->applyToProducts中，指定关联关系。此处表示当前模块的target具体应用到工程product的配置。

109. "targets": [
110.   {
111.     "name": "default",
112.     "applyToProducts": [
113.       "default",
114.       "Community",
115.       "Ultimate"
116.     ]
117.   },
118.   {
119.     "name": "free",
120.     "applyToProducts": [
121.       "default",
122.       "Community"
123.     ]
124.   },
125.   {
126.     "name": "vip",
127.     "applyToProducts": [
128.       "default",
129.       "Ultimate"
130.     ]
131.   }
132. ]

由上配置：

- target：default被应用至product：default、Ultimate、Community中；
- target：vip被应用至product：default、Ultimate中；
- target：free被应用至product：default、Community中。

4. 在实际构建中，可通过可视化窗口灵活选择product-target的关联关系以构建出需要的APP/HAP包。

例：用户需要构建Ultimate版本的且具有vip特性的应用，可以选择product：Ultimate，target：vip，apply之后执行构建。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155927.41502832397563865442071473231876:50001231000000:2800:4F6B44004C603BE8D046F8FBE4C59291757092A93D7E109B562744ECEA1ED655.png)

查看构建产物

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155927.94145353286063048080169494513659:50001231000000:2800:EA685A1AA2BEAA061360B958F909359A016F53309C5C167A8D03155947F3688B.png)

[能力说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides "能力说明")


更新时间: 2025-12-16 15:59

通常情况下，应用厂商会根据不同的部署环境，不同的目标人群，不同的运行环境等，将同一个应用定制为不同的版本，如国内版、国际版、普通版、VIP版、免费版、付费版等。针对以上场景，DevEco Studio支持通过少量的代码配置以实例化不同的差异版本，在编译构建过程中实现一个应用构建出不同的目标产物版本，从而实现源代码、资源文件等的高效复用。

在了解HarmonyOS应用的多目标构建产物如何定制前，先了解target和product的概念：

- 工程内的每一个Entry/Feature模块，对应的构建产物为HAP，HAP是应用/元服务可以独立运行在设备中的形态。由于在不同的业务场景中，同一个模块可能需要定制不同的功能或资源，因此引入target的概念。一个模块可以定义多个target，每个target对应一个定制的HAP，通过配置可以实现一个模块构建出不同的HAP。
- 一个HarmonyOS工程的构建产物为APP包，APP包用于应用/元服务发布上架应用市场。由于不同的业务场景，需要定制不同的应用包，因此引入product概念。一个工程可以定义多个product，每个product对应一个定制化应用包，通过配置可以实现一个工程构建出多个不同的应用包。

更多关于多目标产物的实践请参考[多目标产物构建开发实践](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-target)。

## 定制HAP多目标构建产物

每一个Entry/Feature模块均支持定制不同的target，通过在模块中的build-profile.json5文件中实现差异化定制，当前支持HAP包名、设备类型（deviceType）、源码集（source）、资源（resource）、buildOption配置项（如C++依赖的.so、混淆配置、abi类型、cppFlags等）、分发规则（distributionFilter）的定制。

**定义目标产物target**

每一个target对应一个定制的HAP，因此，在定制HAP多目标构建产物前，应提前规划好需要定制的target名称。例如，以ArkTS Stage模型为例，定义一个免费版和付费版，模块级build-profile.json5文件示例如下：

1. { 
2.   "apiType": 'stageMode', 
3.   "buildOption": {   
4.   }, 
5.   "targets": [  //定义不同的target 
6.     { 
7.       "name": "default",  //默认target名称default 
8.     }, 
9.     { 
10.       "name": "free",  //免费版target名称 
11.     }, 
12.     { 
13.       "name": "pay",  //付费版target名称 
14.     } 
15.   ] 
16. }

按照上述target的定义，在编译构建时，会同时打包生成default、free和pay三个不同的HAP。

### 定义产物的HAP包名

每一个target均可以指定产物命名。

1. { 
2.   "apiType": "stageMode", 
3.   "buildOption": { 
4.   }, 
5.   "targets": [ 
6.     { 
7.       "name": "default", 
8.       "output": { 
9.         "artifactName": "customizedTargetOutputName-1.0.0"  //产物名称为customizedTargetOutputName-1.0.0
10.       } 
11.     }, 
12.     { 
13.       "name": "free", 
14.       "output": { 
15.         "artifactName": "customizedTargetOutputName1-1.0.0"  //产物名称为customizedTargetOutputName1-1.0.0
16.       } 
17.     }, 
18.     { 
19.       "name": "pay", 
20.       "output": { 
21.         "artifactName": "customizedTargetOutputName2-1.0.0"  //产物名称为customizedTargetOutputName2-1.0.0
22.       } 
23.     } 
24.   ] 
25. }

如果已配置签名，target产物对应的HAP包名为开发者定制的名称；如果未配置签名，target产物对应的HAP包名为开发者定制的名称+unsigned。

### 定义产物的deviceType

每一个target均可以指定支持的设备类型deviceType，也可以不定义。如果不定义，则该target默认支持module.json5/[config.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-configuration-file-overview-fa)中定义的设备类型。

同时，在定义每个target的deviceType时，支持的设备类型必须在module.json5或config.json中已经定义。例如，在上述定义的3个target中，分别定义default默认支持所有设备类型，free和pay版本只支持phone设备。

1. { 
2.   "apiType": 'stageMode', 
3.   "buildOption": { 
4.   }, 
5.   "targets": [ 
6.     { 
7.       "name": "default",  //未定义deviceType，默认支持config.json或module.json5中定义的设备类型 

8.     }, 
9.     { 
10.       "name": "free", 
11.       "config": { 
12.         "deviceType": [  //定义free支持的设备类型为phone 
13.           "phone" 
14.         ] 
15.       } 
16.     }, 
17.     { 
18.       "name": "pay", 
19.       "config": { 
20.         "deviceType": [  //定义pay支持的设备类型为phone 
21.           "phone" 
22.         ] 
23.       } 
24.     } 
25.   ] 
26. }

### 定义产物的distributionFilter

在未定义target的分发规则distributionFilter时，以module配置[distributionFilter](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#distributionfilter%E6%A0%87%E7%AD%BE)/[distroFilter](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-structure#distrofilter%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84)分发规则为准。

针对多target存在相同设备类型deviceType的场景，相同设备类型的target需要指定分发规则distributionFilter。

如果是FA工程，请将distributionFilter字段替换为distroFilter。

1. { 
2.   "apiType": "stageMode", 
3.   "buildOption": { 
4.   }, 
5.   "targets": [ 
6.     { 
7.       "name": "default", 

8.     }, 
9.     { 
10.       "name": "free", 
11.       "config": { 
12.         "distributionFilter": {  // 具体请参考distributionFilter标签
13.           "screenShape": { // 屏幕形状枚举 
14.             "policy": "include", 
15.             "value": ["circle"] 
16.           } 
17.         } 
18.       } 
19.     }, 
20.     { 
21.       "name": "pay", 
22.       "config": { 
23.         "distributionFilter": { 
24.           "screenShape": { 
25.             "policy": "include", 
26.             "value": ["rect"] 
27.           } 
28.         } 
29.       } 
30.     } 
31.   ] 
32. }

### 定义产物preloads的分包

对于元服务，每一个target均可以指定preloads的分包，也可以不定义。如果不定义，则以module.json5中的配置为准。

1. { 
2.   "apiType": 'stageMode', 
3.   "showInServiceCenter": true, 
4.   "buildOption": { 
5.   }, 
6.   "targets": [   
7.     { 
8.       "name": "default",   
9.     },
10.     { 
11.       "name": "free",   
12.     },
13.     { 
14.       "name": "pay",   
15.       "config": { 
16.         "atomicService": { 
17.           "preloads": [  //指定preloads的分包 
18.             { 
19.               "moduleName": "preloadSharedLibrary"
20.             } 
21.           ] 
22.         } 
23.       } 
24.     } 
25.   ] 
26. }

### 定义产物的source源码集-pages

对于source源码集的定制，由于Stage模型和FA模型的差异，Stage模型支持对pages源码目录的page页面进行定制，FA模型则支持对Ability源码目录下的page页面进行定制。

- 例如，Stage模型中的工程，在模块的pages目录下分别定义了Index.ets、Page1.ets和Page2.ets三个页面。其中default使用了Index.ets页面；free使用了Index.ets和Page1.ets页面；pay使用了Index.ets和Page2.ets页面，则示例代码如下所示：
    
    1. { 
    2.    "apiType": 'stageMode', 
    3.    "buildOption": { 
    4.    }, 
    5.    "targets": [ 
    6.      { 
    7.        "name": "default", 
    8.        "source": {  //定义Stage模型中默认版target的pages源码文件
    9.          "pages": [ 
    10.            "pages/Index" 
    11.          ] 
    12.        } 
    13.      }, 
    14.      { 
    15.        "name": "free", 
    16.        "config": { 
    17.          "deviceType": [ 
    18.            "phone" 
    19.          ] 
    20.        }, 
    21.        "source": {  //定义Stage模型中免费版target的pages源码文件
    22.          "pages": [ 
    23.            "pages/Index", 
    24.            "pages/Page1" 
    25.          ] 
    26.        } 
    27.      }, 
    28.      { 
    29.        "name": "pay", 
    30.        "config": { 
    31.          "deviceType": [ 
    32.            "phone" 
    33.          ] 
    34.        }, 
    35.        "source": {  //定义Stage模型中付费版target的pages源码文件
    36.          "pages": [ 
    37.            "pages/Index", 
    38.            "pages/Page2" 
    39.          ] 
    40.        } 
    41.      } 
    42.    ] 
    43.  }
    

- 例如，FA模型中的工程，在模块的MainAbility中定义了index.ets、page1.ets和page2.ets，其中：default使用了index.ets 页面；free使用了index.ets和page1.ets页面；pay使用了index.ets和page2.ets页面。
    
    1. { 
    2.    "apiType": 'faMode', 
    3.    "buildOption": { 
    4.    }, 
    5.    "targets": [ 
    6.      { 
    7.        "name": "default", 
    8.        "source": {  //定义FA模型中默认版target的pages源码文件
    9.          "abilities": [ 
    10.            { 
    11.              "name": ".MainAbility", 
    12.              "pages": [ 
    13.                "pages/index" 
    14.              ] 
    15.            } 
    16.          ], 
    17.        } 
    18.      }, 
    19.      { 
    20.        "name": "free", 
    21.        "config": { 
    22.          "deviceType": [ 
    23.            "phone" 
    24.          ] 
    25.        }, 
    26.        "source": {  //定义FA模型中免费版target的pages源码文件
    27.          "abilities": [ 
    28.            { 
    29.              "name": ".MainAbility", 
    30.              "pages": [ 
    31.                "pages/index", 
    32.                "pages/page1" 
    33.              ] 
    34.            } 
    35.          ], 
    36.        } 
    37.      }, 
    38.      { 
    39.        "name": "pay", 
    40.        "config": { 
    41.          "deviceType": [ 
    42.            "phone" 
    43.          ] 
    44.        }, 
    45.        "source": {  //定义FA模型中付费版target的pages源码文件
    46.          "abilities": [ 
    47.            { 
    48.              "name": ".MainAbility", 
    49.              "pages": [ 
    50.                "pages/index", 
    51.                "pages/page2" 
    52.              ] 
    53.            } 
    54.          ], 
    55.        } 
    56.      } 
    57.    ] 
    58.  }
    

### 定义产物的source源码集-sourceRoots

在模块的主代码空间（src/main）下，承载着开发者编写的公共代码。如果开发者需要实现不同target之间的差异化逻辑，可以使用差异化代码空间（sourceRoots）。配合差异化代码空间的能力，可以在主代码空间中代码不变的情况下，针对不同的target，编译对应的代码到最终产物中。

**概念说明**

- packageName：当前模块的oh-package.json5中的name字段对应的值。
- sourceRoot：<defaultSourceRoot> | <targetSourceRoot> ，其中<defaultSourceRoot>是 src/main，<targetSourceRoot>可自定义，寻址优先级为 <targetSourceRoot> > <defaultSourceRoot>。
- sourcePath：在sourceRoot中的代码结构目录。
- sourceFileName：代码目录下的ets文件名。

例如以下工程目录：

1. entry
2. |--src
3. |----main
4. |------ets
5. |--------code
6. |----------test.ets
7. |----target
8. |------util
9. |--------util.ets

- packageName为entry。
- sourceRoot为src/main、src/target。
- sourcePath为ets/code、util。
- sourceFileName为test.ets、util.ets。

**规格限制**

1. import xxx from '<packageName>/sourcePath/sourceFileName' ：通过packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建。

2. 支持hap、hsp、har（请注意：开启[文件/文件夹名称混淆](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/source-obfuscation#section-enable-filename-obfuscation)的har模块需要使用-keep-file-name指定sourceRoot，sourcePath，sourceFileName对应的文件/文件夹名称不被混淆）。

3. 不支持跨模块引用。

4. 不支持动态import。

**编译时模块target的选择优先级说明**

在模块编译的过程中，该模块使用的sourceRoots由当前模块编译时的target来决定。当前模块编译时选择target的优先级则为：命令行显式指定 > 直接引用方target > default。

如以下示例：

hap -> hsp -> har（->表示依赖）

其中hap和hsp存在三个target：default、custom、static，而har存在两个target：default、static。

- 执行编译命令：hvigorw -p module=hap@custom assembleHap，hap指定target为custom进行编译，那么三个模块编译时的target分别为：
    
    hap: custom，命令行显式指定；
    
    hsp: custom，命令行没有显式指定，则基于直接引用方查找，hsp的直接引用方为hap，hap的target为custom，hsp存在该target，则hsp的target为custom；
    
    har: default，命令行没有显式指定，则基于直接引用方查找，har的直接引用方为hsp，hsp的target为custom，har不存在该target，则har的target为default；
    

- 执行编译命令：hvigorw -p module=hap@custom,hsp@static assembleHap assembleHsp，hap指定target为custom，hsp则指定target为static进行编译，那么三个模块编译时的target分别为：
    
    hap: custom，命令行显式指定；
    
    hsp: static，命令行显式指定；
    
    har: static，命令行没有显式指定，则基于直接引用方查找，har的直接引用方为hsp，hsp的target为static，har存在该target，则har的target为static。
    
- 在当前依赖关系的基础上，添加依赖：hap -> har。执行编译命令：hvigorw -p module=hap@custom,hsp@static assembleHap assembleHsp。由于har没有显式指定target，且存在两个target不同的直接引用方（hap和hsp，对应的target分别为custom和static），所以编译过程中har的target只能二选一。基于这种场景，建议开发者显式指定模块的target进行编译：hvigorw -p module=hap@custom,hsp@static,har@static assembleHap assembleHsp assembleHar。

**示例**

1. 在entry模块的build-profile.json5中添加sourceRoots：

2. {
3.   "apiType": "stageMode",
4.   "buildOption": {},
5.   "targets": [ 
6.     { 
7.       "name": "default", 
8.       "source": { 
9.         "sourceRoots": ["./src/default"] // 配置target为default的差异化代码空间
10.       } 
11.     }, 
12.     { 
13.       "name": "custom", 
14.       "source": { 
15.         "sourceRoots": ["./src/custom"] // 配置target为custom的差异化代码空间
16.       } 
17.     } 
18.   ]
19. }

20. 在src目录下新增default/Test.ets和custom/Test.ets，新增后的模块目录结构：

21. entry
22.   |--src
23.     |--main
24.       |--ets
25.         |--pages
26.           |--Index.ets
27.     |--default
28.       |--Test.ets  // 新增
29.     |--custom
30.       |--Test.ets  // 新增  

31. 在default/Test.ets中写入代码：

32. export const getName = () => "default"

33. 在custom/Test.ets中写入代码：

34. export const getName = () => "custom"

35. 修改src/main/ets/pages/Index.ets的代码：

36. import { getName } from 'entry/Test'; // 其中entry为模块级的oh-package.json5中的name字段的值
37. @Entry
38. @Component
39. struct Index { 
40.   @State message: string = getName(); 
41.   build() { 
42.     RelativeContainer() { 
43.       Text(this.message) 
44.     } 
45.     .height('100%') 
46.     .width('100%') 
47.   }
48. }

49. 在工程级的build-profile.json5中配置targets：

50. {
51.   "app": {
52.     "signingConfigs": [],
53.     "products": [
54.       {
55.         "name": "default",
56.         "signingConfig": "default",
57.         "compatibleSdkVersion": "6.0.1(21)",
58.         "runtimeOS": "HarmonyOS",
59.       }
60.     ],
61.     "buildModeSet": [
62.       {
63.         "name": "debug",
64.       },
65.       {
66.         "name": "release"
67.       }
68.     ]
69.   },
70.   "modules": [
71.     {
72.       "name": "entry",
73.       "srcPath": "./entry",
74.       "targets": [
75.         {
76.           "name": "default",
77.           "applyToProducts": [
78.             "default"
79.           ]
80.         },
81.         {
82.           "name": "custom",
83.           "applyToProducts": [
84.             "default"
85.           ]
86.         }
87.       ]
88.     }
89.   ]
90. }

91. Sync完成后，选择entry的target为default，点击Run，界面展示default；选择entry的target为custom，点击Run，则界面展示custom。

### 定义产物的资源

每个target使用的资源文件可能存在差异，在开发过程中，开发者可以将每个target所使用的资源存放在不同的资源目录下。其中，ArkTS工程支持对main目录下的资源文件目录（resource）进行定制；JS工程支持对main目录下的资源文件目录（resource）及 Ability下的资源文件目录（res）进行定制。如下为ArkTS工程的资源文件目录定制示例：

1. { 
2.   "apiType": 'stageMode', 
3.   "buildOption": { 
4.   }, 
5.   "targets": [ 
6.     { 
7.       "name": "default", 
8.       "source": { 
9.         "pages": [ 
10.           "pages/Index" 
11.         ] 
12.       }, 
13.       "resource": {  // 定义默认版target使用的资源文件目录 
14.         "directories": [ 
15.           "./src/main/resources_default" 
16.         ] 
17.       } 
18.     }, 
19.     { 
20.       "name": "free", 
21.       "config": { 
22.         "deviceType": [ 
23.           "phone" 
24.         ] 
25.       }, 
26.       "source": {   
27.         "pages": [ 
28.           "pages/Index", 
29.           "pages/Page1" 
30.         ] 
31.       }, 
32.       "resource": {  // 定义免费版target使用的资源文件目录 
33.         "directories": [ 
34.           "./src/main/resources_free",
35.           "./src/main/resources_default"
36.         ] 
37.       } 
38.     }, 
39.     { 
40.       "name": "pay", 
41.       "config": { 
42.         "deviceType": [ 
43.           "phone" 
44.         ] 
45.       }, 
46.       "source": {   
47.         "pages": [ 
48.           "pages/Index", 
49.           "pages/Page2" 
50.         ] 
51.       }, 
52.       "resource": {  // 定义付费版target使用的资源文件目录
53.         "directories": [ 
54.           "./src/main/resources_pay",
55.           "./src/main/resources_default"
56.         ] 
57.       } 
58.     } 
59.   ] 
60. }

编译构建时，资源文件存在以下优先级顺序：

- AppScope目录下的资源文件会合入到模块下相同路径的资源目录中。如果两个目录下存在重名文件，编译打包后AppScope目录下的资源文件会覆盖模块下的资源。
- 如果target引用的多个资源文件目录下，存在重名文件，则在构建打包过程中，将按照配置的资源文件目录顺序进行选择。例如，上述付费版target引用的资源中，resources_pay和resources_default中存在重名文件，则resources_pay中的资源会被打包到HAP中。

### 定义产物的icon、label、launchType

针对每一个的target的ability，均可以定制不同的icon、label和launchType。如果不定义，则该target采用module.json5中module.abilities配置的icon、label，launchType默认为"singleton"。示例如下所示：

1. { 
2.    "apiType": 'stageMode', 
3.    "buildOption": { 
4.    }, 
5.    "targets": [ 
6.      { 
7.        "name": "default", 
8.        "source": {
9.         "abilities": [
10.           {
11.             "name": "EntryAbility",
12.             "icon":"$media:layered_image",
13.             "label":"$string:EntryAbility_label",
14.             "launchType": "singleton"
15.           }
16.         ]
17.       }
18.      }, 
19.      { 
20.        "name": "free", 
21.        "source": {
22.         "abilities": [
23.           {
24.             "name": "EntryAbility",
25.             "icon":"$media:layered_image",
26.             "label":"$string:EntryAbility_label",
27.             "launchType": "multiton"
28.           }
29.         ]
30.       }
31.      }
32.    ] 
33.  }

### 定义C++工程依赖的.so文件

在 C++ 工程中，可以对每个target依赖的.so文件进行定制。例如某模块依赖了function1.so、function2.so和function3.so三个文件，其中target为default的产物依赖了function1.so和function2.so；其中target为vip的产物依赖了function1.so和 function3.so，则示例代码如下所示：

1. {
2.   "apiType": 'stageMode',
3.   "buildOption": {
4.     "externalNativeOptions": {
5.       "path": "./src/main/cpp/CMakeLists.txt",
6.       "arguments": [],
7.       "abiFilters": [
8.         "arm64-v8a",
9.         "x86_64"
10.       ],
11.       "cppFlags": "",
12.     }
13.   },
14.   "targets": [  //定义不同的target 
15.     {
16.       "name": "default",
17.       "config": {
18.         "buildOption": {
19.           "nativeLib": {
20.             "filter": {
21.               //按照.so文件的优先级顺序，打包最高优先级的function1.so文件 
22.               "pickFirsts": [
23.                 "**/function1.so"
24.               ],
25.               //排除不打包的function3.so文件 
26.               "excludes": [
27.                 "**/function3.so"
28.               ],
29.               //允许当.so中资源重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件 
30.               "enableOverride": true
31.             }
32.           }
33.         }
34.       }
35.     },
36.     {
37.       "name": "vip",
38.       "config": {
39.         "buildOption": {
40.           "nativeLib": {
41.             "filter": {
42.               //按照.so文件的优先级顺序，打包最高优先级的function1.so文件 
43.               "pickFirsts": [
44.                 "**/function1.so"
45.               ],
46.               //排除不打包的function2.so文件 
47.               "excludes": [
48.                 "**/function2.so"
49.               ],
50.               //允许当.so中资源重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件 
51.               "enableOverride": true
52.             }
53.           }
54.         }
55.       }
56.     }
57.   ]
58. }

## 定制HAR多目标构建产物

每一个HAR模块均支持定制不同的target，通过在模块中的build-profile.json5文件中实现差异化定制，当前支持设备类型（deviceType）、资源（resource）、buildOption配置项（如C++依赖的.so、混淆配置、abi类型、cppFlags等）、源码集（source）的定制。

说明

在DevEco Studio中编译HAR模块时，仅支持default target，若需指定其他target，需通过命令行来指定，并通过命令行来编译。

例如构建指定的自定义target:free的har，可参考执行以下命令：

1. hvigorw --mode module -p product=default -p module=library@free -p buildMode=debug assembleHar

### 定义产物的deviceType

每一个target均可以指定支持的设备类型deviceType，也可以不定义。如果不定义，则该target默认支持module.json5/[config.json](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-configuration-file-overview-fa)中定义的设备类型。

同时，在定义每个target的deviceType时，支持的设备类型必须在module.json5或config.json中已经定义。例如，在上述定义的2个target中，分别定义default默认支持所有设备类型，free版本只支持2in1设备。

1. { 
2.   "apiType": 'stageMode', 
3.   "buildOption": { 
4.   }, 
5.   "targets": [ 
6.     { 
7.       "name": "default"  //未定义deviceType，默认支持config.json或module.json5中定义的设备类型 
8.     }, 
9.     { 
10.       "name": "free",
11.       "config": { 
12.         "deviceType": [  //定义free支持的设备类型为2in1
13.           "2in1" 
14.         ] 
15.       } 
16.     }
17.   ] 
18. }

### 定义C++工程依赖的.so文件

在 C++ 工程中，可以对每个target依赖的.so文件进行定制。例如某模块依赖了function1.so、function2.so和function3.so三个文件，其中target为default的产物依赖了function1.so和function2.so；其中target为vip的产物依赖了function1.so和 function3.so，则示例代码如下所示：

1. {
2.   "apiType": 'stageMode',
3.   "buildOption": {
4.     "externalNativeOptions": {
5.       "path": "./src/main/cpp/CMakeLists.txt",
6.       "arguments": [],
7.       "abiFilters": [
8.         "arm64-v8a",
9.         "x86_64"
10.       ],
11.       "cppFlags": "",
12.     }
13.   },
14.   "targets": [  //定义不同的target 
15.     {
16.       "name": "default",
17.       "config": {
18.         "buildOption": {
19.           "nativeLib": {
20.             "filter": {
21.               //按照.so文件的优先级顺序，打包最高优先级的function1.so文件 
22.               "pickFirsts": [
23.                 "**/function1.so"
24.               ],
25.               //排除不打包的function3.so文件 
26.               "excludes": [
27.                 "**/function3.so"
28.               ],
29.               //允许当.so中资源重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件 
30.               "enableOverride": true
31.             }
32.           }
33.         }
34.       }
35.     },
36.     {
37.       "name": "vip",
38.       "config": {
39.         "buildOption": {
40.           "nativeLib": {
41.             "filter": {
42.               //按照.so文件的优先级顺序，打包最高优先级的function1.so文件 
43.               "pickFirsts": [
44.                 "**/function1.so"
45.               ],
46.               //排除不打包的function2.so文件 
47.               "excludes": [
48.                 "**/function2.so"
49.               ],
50.               //允许当.so中资源重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件 
51.               "enableOverride": true
52.             }
53.           }
54.         }
55.       }
56.     }
57.   ]
58. }

### 定义产物的资源

每个target使用的资源文件可能存在差异，在开发过程中，开发者可以将每个target所使用的资源存放在不同的资源目录下。其中，ArkTS工程支持对main目录下的资源文件目录（resource）进行定制；JS工程支持对main目录下的资源文件目录（resource）及 Ability下的资源文件目录（res）进行定制。如下为ArkTS工程的资源文件目录定制示例：

1. { 
2.   "apiType": 'stageMode', 
3.   "buildOption": { 
4.   }, 
5.   "targets": [ 
6.     { 
7.       "name": "default",
8.       "resource": {  //定义默认版target使用的资源文件目录 
9.         "directories": [ 
10.           "./src/main/resources_default" 
11.         ] 
12.       } 
13.     }, 
14.     { 
15.       "name": "free", 
16.       "config": { 
17.         "deviceType": [ 
18.           "2in1" 
19.         ] 
20.       }, 
21.       "resource": {  //定义免费版target使用的资源文件目录 
22.         "directories": [ 
23.           "./src/main/resources_free",
24.           "./src/main/resources_default"
25.         ] 
26.       } 
27.     },
28.   ] 
29. }

### 定义产物的source源码集-sourceRoots

请参考[定义产物的source源码集-sourceRoots](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides#section18668905913)。

## 配置APP多目标构建产物

APP用于应用/元服务上架发布，针对不同的应用场景，可以定制不同的product，每个product中支持对bundleName、bundleType、签名信息、icon和label以及包含的target进行定制。

**定义目标产物product**

每一个product对应一个定制的APP包，因此，在定制APP多目标构建产物前，应提前规划好需要定制的product名称。例如，定义productA和productB。工程级build-profile.json5文件示例如下：

在定制product时，必须存在"default"的product，否则编译时会出现错误。

说明

在编译构建流程中，default product或者default target都承载着兜底机制，其中，default target可以缺省。当某个模块的default target缺省时，Hvigor会默认加上default target并挂载到default product中，因此，构建default product时，默认会构建出default target。如果不想构建出default target，建议参考[定义product中包含的target](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides#section7613106105114)，自定义product以及包含的target。

1. "app": { 
2.   "signingConfigs": [], 
3.   "products": [ 
4.     { 
5.       "name": "default", 
6.       "signingConfig": "default", 
7.       "compatibleSdkVersion": "6.0.1(21)", 
8.       "runtimeOS": "HarmonyOS", 
9.     }, 
10.     { 
11.       "name": "productA", 
12.       "compatibleSdkVersion": "6.0.1(21)", 
13.       "runtimeOS": "HarmonyOS", 
14.     }, 
15.     { 
16.       "name": "productB", 
17.       "compatibleSdkVersion": "6.0.1(21)", 
18.       "runtimeOS": "HarmonyOS", 
19.     } 
20.   ], 
21.   "buildModeSet": [ 
22.     { 
23.       "name": "debug", 
24.     }, 
25.     { 
26.       "name": "release" 
27.     } 
28.   ] 
29. }

### 定义产物的APP包名和供应商名称

每一个product均可以指定产物命名和供应商名称。

1. { 
2.   "app": { 
3.     "signingConfigs": [], 
4.     "products": [ 
5.       { 
6.         "name": "default", 
7.         "signingConfig": "default", 
8.         "compatibleSdkVersion": "6.0.1(21)", 
9.         "runtimeOS": "HarmonyOS", 
10.         "output": { 
11.           "artifactName": "customizedProductOutputName-1.0.0"  //产物名称为customizedProductOutputName-1.0.0
12.         }, 
13.         "vendor": "customizedProductVendorName"   //供应商名称为customizedProductVendorName
14.       }, 
15.       { 
16.         "name": "productA", 
17.         "compatibleSdkVersion": "6.0.1(21)", 
18.         "runtimeOS": "HarmonyOS", 
19.         "output": { 
20.           "artifactName": "customizedProductOutputNameA-1.0.0"  //产物名称为customizedProductOutputNameA-1.0.0
21.         }, 
22.         "vendor": "customizedProductVendorNameA"   //供应商名称为customizedProductVendorNameA
23.       }, 
24.       { 
25.         "name": "productB", 
26.         "compatibleSdkVersion": "6.0.1(21)", 
27.         "runtimeOS": "HarmonyOS", 
28.         "output": { 
29.           "artifactName": "customizedProductOutputNameB-1.0.0" //产物名称为customizedProductOutputNameB-1.0.0
30.         }, 
31.         "vendor": "customizedProductVendorNameB"   //供应商名称为customizedProductVendorNameB
32.       } 
33.     ], 
34.     "buildModeSet": [ 
35.       { 
36.         "name": "debug", 
37.       }, 
38.       { 
39.         "name": "release" 
40.       } 
41.     ] 
42.   }, 
43. }

如果已配置签名，product产物对应的APP包名为开发者定制的名称；如果未配置签名，product产物对应的APP包名为开发者定制的名称+unsigned。

### 定义product的bundleName

针对每个定义的product，均可以定制不同的bundleName，如果product未定义bundleName，则采用工程默认的bundleName。示例如下所示：

1. "app": { 
2.   "signingConfigs": [], 
3.   "products": [ 
4.     { 
5.       "name": "default", 
6.       "signingConfig": "default",
7.       "compatibleSdkVersion": "6.0.1(21)", 
8.       "runtimeOS": "HarmonyOS", 
9.       "bundleName": "com.example00.com"  //定义default的bundleName信息 
10.     }, 
11.     { 
12.       "name": "productA", 
13.       "signingConfig": "default",

14.       "compatibleSdkVersion": "6.0.1(21)", 
15.       "runtimeOS": "HarmonyOS", 
16.       "bundleName": "com.example01.com"  //定义productA的bundleName信息
17.     }, 
18.     { 
19.       "name": "productB", 
20.       "signingConfig": "default",
21.       "compatibleSdkVersion": "6.0.1(21)", 
22.       "runtimeOS": "HarmonyOS", 
23.       "bundleName": "com.example02.com"  //定义productB的bundleName信息 
24.     } 
25.   ], 
26.   "buildModeSet": [ 
27.     { 
28.       "name": "debug", 
29.     }, 
30.     { 
31.       "name": "release" 
32.     } 
33.   ] 
34. }

### 定义product的bundleType

针对每个定义的product，均可以定制不同的bundleType。开发者可以通过定义每个product的bundleType，分别定义产物类型：

- bundleType值为app，表示产物为应用；
- bundleType值为atomicService，表示产物为元服务。

如果product未定义bundleType，则采用工程的bundleType（即创建工程时选择的Application/Atomic Service）。示例如下所示：

1. "app": { 
2.   "signingConfigs": [], 
3.   "products": [ 
4.     { 
5.       "name": "default", 
6.       "signingConfig": "default",
7.       "compatibleSdkVersion": "6.0.1(21)", 
8.       "runtimeOS": "HarmonyOS", 
9.       "bundleName": "com.example00.com",   
10.       "bundleType": "app" //定义default的bundleType信息 
11.     },
12.     { 
13.       "name": "productA", 
14.       "signingConfig": "default",
15.       "compatibleSdkVersion": "6.0.1(21)", 
16.       "runtimeOS": "HarmonyOS", 
17.       "bundleName": "com.example01.com",    
18.       "bundleType": "atomicService"  //定义productA的bundleType信息 
19.     },
20.     { 
21.       "name": "productB", 
22.       "signingConfig": "default",
23.       "compatibleSdkVersion": "6.0.1(21)", 
24.       "runtimeOS": "HarmonyOS", 
25.       "bundleName": "com.example02.com",    
26.       "bundleType": "atomicService"  //定义productB的bundleType信息 
27.     } 
28.   ], 
29.   "buildModeSet": [ 
30.     { 
31.       "name": "debug", 
32.     },
33.     { 
34.       "name": "release"
35.     } 
36.   ] 
37. }

### 定义product的签名配置信息

针对每个定义的product，均可以定制不同的signingConfig签名文件，如果product未定义signingConfig，则构建生成未签名的APP包。

通常情况下，您首先需要在签名配置界面或工程的build-profile.json5文件中配置签名信息。例如在**File > Project Structure > Project > Signing Configs**界面，分别配置default、productA和productB的签名信息，如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155925.76859740333082173178241760995861:50001231000000:2800:4A3702A7B29B44525C493F03FAE55509528B34A9BD0021432613E1499B016C27.png)

签名信息配置完成后，再添加各个product对应的签名文件，示例如下所示：

您也可以提前在product中定义签名文件信息，然后在签名界面对每个product进行签名，确保配置的product签名文件与签名界面配置的签名文件保持一致即可。

1. "app": { 
2.   "signingConfigs": [], //此处通过界面配置签名后会自动生成相应的签名配置，本文略 
3.   "products": [ 
4.     { 
5.       "name": "default", 
6.       "signingConfig": "default", //定义default的签名文件信息
7.       "compatibleSdkVersion": "6.0.1(21)", 
8.       "runtimeOS": "HarmonyOS", 
9.       "bundleName": "com.example00.com"  
10.     }, 
11.     { 
12.       "name": "productA", 
13.       "signingConfig": "productA", //定义productA的签名文件信息
14.       "compatibleSdkVersion": "6.0.1(21)", 
15.       "runtimeOS": "HarmonyOS", 
16.       "bundleName": "com.example01.com"  
17.     }, 
18.     { 
19.       "name": "productB", 
20.       "signingConfig": "productB", //定义productB的签名文件信息
21.       "compatibleSdkVersion": "6.0.1(21)", 
22.       "runtimeOS": "HarmonyOS", 
23.       "bundleName": "com.example02.com" 
24.     } 
25.   ], 
26.   "buildModeSet": [ 
27.     { 
28.       "name": "debug", 
29.     }, 
30.     { 
31.       "name": "release" 
32.     } 
33.   ] 
34. }

### 定义product的icon和label

针对每个定义的product，均可以定制不同的icon和label，如果product未定义icon和label，则采用工程默认的icon和label。示例如下所示：

说明

products中的icon和label字段在编译时会替换[app.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-configuration-file)中对应的字段，app.json5和module.json5均可以配置这两个字段，如果都配置，优先级顺序请参考[配置优先级](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/layered-image#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5)。

1. {
2.   "app": {
3.     "signingConfigs": [],
4.     "products": [
5.       {
6.         "name": "default",
7.         "signingConfig": "default",
8.         "compatibleSdkVersion": "6.0.1(21)",
9.         "runtimeOS": "HarmonyOS",
10.         "icon":"$media:default_icon", //定义default的icon
11.         "label":"$string:default_name", //定义default的label
12.       },
13.       {
14.         "name": "productA",
15.         "signingConfig": "default",
16.         "compatibleSdkVersion": "6.0.1(21)",
17.         "icon":"$media:productA_icon", //定义productA的icon
18.         "label":"$string:productA_name", //定义productA的label
19.       },
20.       {
21.         "name": "productB",
22.         "signingConfig": "default",
23.         "compatibleSdkVersion": "6.0.1(21)",
24.         "runtimeOS": "HarmonyOS",
25.         "icon":"$media:productB_icon", //定义productB的icon
26.         "label":"$string:productB_name",  //定义productB的label
27.       }
28.     ],
29.     "buildModeSet": [
30.       {
31.         "name": "debug",
32.       },
33.       {
34.         "name": "release"
35.       }
36.     ]
37.   },
38.   ...
39. }

### 定义product中包含的target

开发者可以选择需要将定义的target分别打包到哪一个product中，每个product可以指定一个或多个target。

同时每个target也可以打包到不同的product中，但是同一个module的不同target不能打包到同一个product中（除非该module的不同target配置了不同的deviceType或distributionFilter/distroFilter）。

例如，前面定义了default、free和pay三个target，现需要将default target打包到default product中；将free target打包到productA中；将pay target打包到productB中，对应的示例代码如下所示：

1. { 
2.   "app": { 
3.     "signingConfigs": [], //此处通过界面配置签名后会自动生成相应的签名配置，本文略 
4.     "products": [ 
5.       { 
6.         "name": "default", 
7.         "signingConfig": "default",
8.         "compatibleSdkVersion": "6.0.1(21)", 
9.         "runtimeOS": "HarmonyOS", 
10.         "bundleName": "com.example00.com"  
11.       }, 
12.       { 
13.         "name": "productA", 
14.         "signingConfig": "productA",
15.         "compatibleSdkVersion": "6.0.1(21)", 
16.         "runtimeOS": "HarmonyOS", 
17.         "bundleName": "com.example01.com"  
18.       }, 
19.       { 
20.         "name": "productB", 
21.         "signingConfig": "productB",  
22.         "compatibleSdkVersion": "6.0.1(21)", 
23.         "runtimeOS": "HarmonyOS", 
24.         "bundleName": "com.example02.com" 
25.       } 
26.     ], 
27.   "modules": [ 
28.     { 
29.       "name": "entry", 
30.       "srcPath": "./entry", 
31.       "targets": [ 
32.         { 
33.           "name": "default",  //将default target打包到default APP中 
34.           "applyToProducts": [ 
35.             "default" 
36.           ] 
37.         }, 
38.         { 
39.           "name": "free",  //将free target打包到productA APP中 
40.           "applyToProducts": [ 
41.             "productA" 
42.           ] 
43.         }, 
44.         { 
45.           "name": "pay",  //将pay target打包到productB APP中 
46.           "applyToProducts": [ 
47.             "productB" 
48.           ] 
49.         } 
50.       ] 
51.     } 
52.   ] 
53. }

## 构建定义的目标产物

每个target对应一个HAP，每个product对应一个APP包，在编译构建时，如果存在多product或多target时，您可以指定编译具体的包。

单击右上角的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155925.33520190340992899505106998533655:50001231000000:2800:6665C2E87674036DB628802462B87D3826697F40955507536677169BAAF977A8.png)图标，指定需要打包的**Product**及**Target**，然后单击**Apply**保存。例如选择"ProductA"中，entry模块对应的"free" Target。

- **Product**：选择需要构建的APP包。
- **Build Mode**：选择[编译模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)。
- **Product Info**：该APP包的BundleName和SigningConfig信息。
- **Target Select**：选择各个模块的Target，该Target需要包含在定义的Product中才能选择，如果未包含则显示"No Target to apply"

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155925.07231273815904323073680600244676:50001231000000:2800:57AE7258A8AA556F56FAAC7311FC5B0BD065FF3440DEC36BC785B2BFA99464EF.png)

然后执行编译构建APP/HAP的任务：

- 单击菜单栏的**Build > Build Hap(s)/APP(s) > Build APP(s)** ，构建指定的Product对应的APP。例如，按照[上述配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides#section7613106105114)和上图中的配置，此时DevEco Studio将构建生成ProductA的APP包。default和ProductB的APP均不会生成。
- 单击菜单栏的**Build > Build Hap(s)/APP(s) > Build Hap(s)**，构建指定Product下的所有Target对应的HAP。

如果您想将某个模块下的指定target打包生成HAP，可以在工程目录中，单击模块名，然后再单击**Build > Make Module** **‘模块名** **’**，此时DevEco Studio将构建生成模块下指定target对应的包。例如，按照上述配置，此时DevEco Studio将构建生成entry模块下free的HAP。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155925.89968572620569037744078547423111:50001231000000:2800:5B6D40436413A91ADEF4877252D80CD900CF23FFFD6C5FCC890C20D65550C898.png)

## 调试和运行指定的Target

使用DevEco Studio调试或运行应用/元服务时，每个模块只能选择其中的一个target运行，可以通过单击右上角的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155925.43971437464333064536486430486909:50001231000000:2800:6E1617639F29F672CB44BC550564AA26E7D3E30C6AF4BD9C8EC7E2D797892F1B.png)图标，指定需要调试或运行的**Product**下对应的**Module Target**，然后单击**Apply**保存。

说明

在选择需要调试或运行的target时，需要注意选择该target所属的Product，否则将找不到可调试和运行的target。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155925.54479128479366383485868644744569:50001231000000:2800:E42063C3BC61DDBABB067B67A3659927846675F34535FCCCBE39AFD5CD4CEF05.png)

## 多产物构建target

- align target
    
    编译构建时，优先级最高的target。工程配置align target后，如果模块中存在align target，那么将自动选择align target进行构建。align target作用范围是整个工程，只能配置一个，支持命令行和配置文件两种方式。
    
    - 命令行方式示例如下：
        
        1. hvigorw -c properties.ohos.align.target=target1 assembleHap
        
    
    - 在hvigor-config.json5配置文件中添加ohos.align.target，示例如下：
        
        1. "properties": {
        2.   'ohos.align.target': 'target1'
        3. },
        

- fallback target
    
    当模块不存在指定的target时会选用default进行构建，但如果不想用default进行构建，那么可以配置fallback target，当找不到指定target时，如果模块中存在fallback target，则使用fallback target进行构建。fallback target作用范围是整个工程，可配置多个，配置多个时按数组顺序先命中的生效。
    
    - 命令行方式示例如下：
        
        1. hvigorw -c properties.ohos.fallback.target=target1,target2 assembleHap
        
    
    - 在hvigor-config.json5配置文件中添加ohos.fallback.target，示例如下：
        
        1. "properties": {
        2.   'ohos.fallback.target': ['target1', 'target2']
        3. }
        

说明

- align target和fallback target配置方式命令行优先级高于配置文件。

- 使用配置文件配置align target和fallback target，仅支持DevEco Studio界面**Build**菜单栏功能，不支持**Run**菜单栏功能，可通过[hdc命令行工具](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdc)进行推包运行、调试。

多个target的优先级顺序为：align target > 命令行指定模块target > 父级模块target > fallback target > default。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155926.74828193592432883506978091717509:50001231000000:2800:11D628602CD9A452E8D3A8AAF14061CCC592B805339F17D011600001797F845A.png)

举例说明：

工程依赖entry->lib1->lib2，需要构建多个产品A、B、C，工程中target配置如下：

entry: A、B、default

lib1: B、C、default

lib2: A、C、default

指定align target为A，fallback target为C。那么构建hap时的编译命令为：

1. hvigorw --mode module -p module=entry -c properties.ohos.align.target=A -c properties.ohos.fallback.target=C assembleHap

编译的target选择就是：entry@A, lib1@C, lib2@A。

说明

以上所有说明仅针对非ohosTest模式。在ohosTest模式下，依赖的target固定为default，其他target均不生效。
### 基本概念

- target：对应HAR、HSP、HAP的多目标产物。工程内的每一个模块可以定义多个target，每个Target对应一个定制的HAP、HAR包，通过配置可以实现一个模块构建出不同的HAP、HAR包。
- product：对应App的多目标产物。一个HarmonyOS工程的构建产物为App包，一个工程可以定义多个product，每个product对应一个定制化应用包，通过配置可以实现一个工程构建出多个不同的应用包。

在构建过程中，鸿蒙构建系统会根据配置文件中定义的product和target信息，生成相应的构建产物。对于每个target，构建系统会生成一个对应的HAP/HSP/HAR。这个HAP/HSP/HAR包含了该target所需的所有代码和资源。对于每个product，构建系统会生成一个包含了其所有依赖的target的App包。这个App包可以用于发布和上架到应用市场。

### 应用场景

主要应用场景:

- 不同用户群体：针对不同的用户群体（如国内用户与国际用户等），系统支持构建不同的应用版本。这些版本在功能、界面、语言等方面可能有所不同，以满足不同用户群体的需求。
- 不同业务场景：在不同的业务场景中，同一个应用可能需要提供不同的功能或资源。例如，一个在线教育应用可能需要为学生提供学习资料，而为教师提供教学资料。HarmonyOS系统支持通过配置不同的Target来实现这种差异化定制。

针对以上场景，开发者需要通过修改build-profile.json5、module.json5等配置文件，定义出不同的product和target。在这些配置文件中，开发者不仅可以为每个target指定不同的设备类型、源码集、资源等，并且还可以根据业务需要为不同的product分配不同的target。然后在构建过程中，构建工具会根据这些配置生成不同的target，然后通过不同的target搭配构建出不同的product产物。

本文将通过一个具体的案例来介绍如何配置不同资源以及如何构建出多目标产物。

## 实现原理

HarmonyOS多目标产物支持[HAP](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hap-package)（应用安装的基本单位，每个HAP都对应一个应用模块）、[HAR](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package)（静态共享包）、[HSP](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp)（动态共享包）以及App（由多个HAP打包一起上架的完整应用程序）包多种类型的包，以满足不同业务场景下的应用开发和定制需求。

### 多目标产物定制项

目前多目标产物支持的定制项信息如下表所示，表中已给出每一项的作用。详细的每一个定制项的配置方法可以参考：[配置多目标产物](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products)。

**表1** 产物定制项
|多目标模块|定制项|作用|
|:--|:--|:--|
|HAP|HAP包名（artifactName）|产品生成的应用包名称，可由数字、英文字母、中划线、下划线和英文句号（.）组成，支持输入版本号。|
|设备类型（deviceType）|用于配置支持的设备类型，如Phone、Tablet等。|
|源码集（source）|target的源码范围：<br><br>- pages：定制pages源码目录的page页面，数组长度至少为1。<br>- sourceRoots：定制差异化代码空间，数组长度至少为1。|
|资源（resource）|配置需要的资源文件路径，支持配置多个资源文件路径。|
|分发规则（distributionFilter）|针对多target存在相同设备类型deviceType的场景，相同设备类型的target需要指定分发规则distributionFilter。|
|产物分包（preloads）|对于元服务，每一个target均可以指定preloads的分包。|
|abilities能力项（icon、label和launchType）|定制产物图标、名称、启动模式。|
|so库依赖（nativeLib-filter）|定制打包so库的过滤规则。|
|HAR/HSP|设备类型（deviceType）|用于配置支持的设备类型，如Phone、Tablet等。|
|so库依赖（nativeLib-filter）|定制打包so库的过滤规则。|
|源码集（source）|target的源码范围：<br><br>- pages：定制pages源码目录的page页面，数组长度至少为1。<br>- sourceRoots：定制差异化代码空间，数组长度至少为1。|
|资源（resource）|配置需要的资源文件路径，支持配置多个资源文件路径。|
|App|App包名和供应商名称(artifactName、vendor)|指定产物命名和供应商名称。|
|bundleName|定义工程的bundleName信息，在签名的时候可以选择对应的bundleName进行签名。如果product未定义bundleName，则采用工程默认的bundleName。|
|bundleType|定义产物类型：<br><br>- bundleType值为app，表示产物为应用；<br>- bundleType值为atomicService，表示产物为元服务。|
|签名配置信息(signingConfig)|为不同产物定制不同的签名文件。|
|应用图标、名称（icon、label）|为不同产物定制不同的图标和名称。|
|依赖的模块（modules）|定义product中包含的target，每个product可以指定一个或多个target。|

综上所述，App、HAP、HAR、HSP包目前并不支持配置所有配置项的差异化定制，开发者在开发过程中需要根据已支持的配置项合理的进行多目标定制。

### 构建原理图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.24482997784580331477105756086491:50001231000000:2800:1631421593367B48AC9A64B339291F0FE7789B0E9937BFA4C7FE35ABEBDC9B72.png "点击放大")

如图所示，在HarmonyOS应用开发过程中，一个应用通常包含多个HAR/HAP/HSP模块。每个HAR/HAP/HSP模块可以通过配置模块级的build-profile.json文件定义多个target，每个target可以定制不同的资源（具体可参考上文定制项介绍）。因此形成了具有差异性的target，如：Module A通过定制生成了TargetA-1、TargetA-2；Module B通过定制生成了TargetB-1、TargetB-2、TargetB-3；Module C通过定制生成了TargetC-1、TargetC-2。然后通过配置工程级的build-profile.json定义多个product，每个product可以依赖不同的Target并且配置不同的App产物定制项。因此形成了具有差异的product，如：依赖TargetA-1、TargetB-1、TargetC-1构建出App-product1；依赖TargetB-3、TargetC-2构建出App-product2。最终在构建工程时选择相应的product就可以显示出对应的定制效果。

### 开发流程

1. 首先需要拆解需求，根据具体的业务场景判断出product、target信息。即确认我们要构建哪些product，每个product依赖哪些target以及每个target的定制项有哪些。
2. 分别定制每个target定制项的内容。
3. 分别定制product定制项并为其依赖需要的target。
4. 实现不同目标产物需要定制的业务逻辑。
5. 选择不同的product构建出不同目标产物。

## 场景案例

本节主要根据一个案例介绍构建多目标产物的流程和方法，该案例可以由同一套源代码构建出Official版本（官方版）和Test版本（测试版）两个product工程。两个工程的实现效果如下：

Official版本：工程会在首页中显示Official版的资源以及一个页面跳转按钮，该页面是一个HAP模块页面。通过点击按钮可以跳转到Official版定制页面，该页面是一个HAR模块页面，其中包含了一个运算器。该运算器支持加法和减法。

Test版本：工程会在首页中显示Test版的资源以及一个页面跳转按钮，该页面是一个HAP模块页面。通过点击按钮可以跳转到Test版定制页面，该页面是一个HAR模块页面，其中包含了一个普通版的运算器。该运算器仅支持减法。

该案例包含了HAP、HAR、APP相关定制项，具体差异项信息如下：

**表2** 定制项信息
|定制模块|Official版本定制项|Test版本定制项|
|:--|:--|:--|
|HAP模块(target)|1. target名称official<br>2. source源码集-pages<br>3. 资源文件目录<br>4. source源码集-sourceRoots|1. target名称test<br>2. source源码集-pages<br>3. 资源文件目录<br>4. source源码集-sourceRoots|
|HAR模块(target)|1. target名称official<br>2. buildProfileFields自定义参数<br>3. 产物名称<br>4. source源码集-sourceRoots<br>5. 资源文件目录<br>6. 剔除的.so文件|1. target名称test<br>2. buildProfileFields自定义参数<br>3. 产物名称<br>4. source源码集-sourceRoots<br>5. 资源文件目录|
|App工程（product）|1. product名称official<br>2. 产物bundleName<br>3. 签名配置信息<br>4. 应用图标<br>5. 依赖的target|1. product名称test<br>2. 产物bundleName<br>3. 签名配置信息<br>4. 应用图标<br>5. 依赖的target|

1. 拆解需求，根据具体的业务场景判断出product、target信息。
    
    首先，根据上面案例设计和定制项表格可以确认我们需要定制两个product版本，即Official版本和Test版本。每个product需要依赖两个模块，即一个HAP模块和一个HAR模块。
    
2. 定制target内容。
    
    HAP模块：在模块级build-profile.json5文件中配置。
    
    1. "targets": [
    2.   {
    3.     "name": "official",
    4.     "config": {
    5.       "buildOption": {
    6.         "arkOptions": {
    7.           "buildProfileFields": {
    8.             "productName": "official"
    9.           }
    10.         },
    11.         "nativeLib": {
    12.           "filter": {
    13.             "excludes": [
    14.               "../libs/arm64-v8a/libentry.so"
    15.             ]
    16.           }
    17.         }
    18.       }
    19.     },
    20.     "runtimeOS": "HarmonyOS",
    21.     "output": {
    22.       "artifactName": "official"
    23.     },
    24.     "source": {
    25.       "sourceRoots": [
    26.         "./src/official_pages"
    27.       ]
    28.     },
    29.     "resource": {
    30.       "directories": [
    31.         "./src/main/official/resources",
    32.         "./src/main/resources"
    33.       ]
    34.     }
    35.   },
    36.   {
    37.     "name": "test",
    38.     "config": {
    39.       "buildOption": {
    40.         "arkOptions": {
    41.           "buildProfileFields": {
    42.             "productName": "test"
    43.           }
    44.         }
    45.       }
    46.     },
    47.     "runtimeOS": "HarmonyOS",
    48.     "output": {
    49.       "artifactName": "test"
    50.     },
    51.     "source": {
    52.       "sourceRoots": [
    53.         "./src/test_pages"
    54.       ]
    55.     },
    56.     "resource": {
    57.       "directories": [
    58.         "./src/main/test/resources",
    59.         "./src/main/resources"
    60.       ]
    61.     }
    62.   }
    63. ],
    
    [build-profile.json5](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/myhar/build-profile.json5#L22-L84)
    
    上述配置文件代码中，配置了official版本与test版本的target名称、source源码集-pages、source源码集-sourceRoots以及资源文件路径，因此我们需要在对应的目录结构下创建我们配置的文件以及目录。针对以上配置信息，我们需要创建pages目录下的Index.ets文件、src目录下的test_pages和official_pages目录以及src/main目录下的resource_test和resource_official目录。
    
    在配置不同target的资源文件目录时，可以配置多个资源文件目录，建议将共有的资源文件放置到默认的资源文件目录中，将有差异的资源部分放置到定制的资源文件目录中，然后在配置资源目录时将默认的资源目录和定制的资源目录都加上。例如：案例中即给不同版本配置了两个资源目录，一个用于存放共有资源，一个存放不同target的差异性资源。
    
    如果target引用的多个资源文件目录下，存在同名的资源，则在构建打包过程中，将按照配置的资源文件目录顺序进行选择。例如，上述official版target引用的资源中，resource_official和resource中存在同名的资源文件，则resource_official中的资源会被打包到HAP中。
    
    * 配置文件中，default为创建工程时默认生成的target，一般无需特殊处理。
    
    HAR模块：在模块级build-profile.json5文件中配置。
    
    1. {
    2.   "app": {
    3.     "signingConfigs": [],
    4.     "products": [
    5.       {
    6.         "name": "official",
    7.         "compatibleSdkVersion": "5.0.5(17)",
    8.         "targetSdkVersion": "5.0.5(17)",
    9.         "runtimeOS": "HarmonyOS",
    10.         "buildOption": {
    11.           "strictMode": {
    12.             "caseSensitiveCheck": true,
    13.             "useNormalizedOHMUrl": true
    14.           }
    15.         },
    16.         "bundleName": "com.official.com",
    17.         "bundleType": "app",
    18.         "icon": "$media:startIcon",
    19.         "label": "$string:official_app_name"
    20.       },
    21.       {
    22.         "name": "test",
    23.         "compatibleSdkVersion": "5.0.5(17)",
    24.         "targetSdkVersion": "5.0.5(17)",
    25.         "runtimeOS": "HarmonyOS",
    26.         "buildOption": {
    27.           "strictMode": {
    28.             "caseSensitiveCheck": true,
    29.             "useNormalizedOHMUrl": true
    30.           }
    31.         },
    32.         "bundleName": "com.test.com",
    33.         "bundleType": "app",
    34.         "icon": "$media:app_icon",
    35.         "label": "$string:test_app_name"
    36.       },
    37.       {
    38.         "name": "default",
    39.         "compatibleSdkVersion": "5.0.5(17)",
    40.         "targetSdkVersion": "5.0.5(17)",
    41.         "runtimeOS": "HarmonyOS",
    42.       }
    43.     ],
    44.     "buildModeSet": [
    45.       {
    46.         "name": "debug",
    47.       },
    48.       {
    49.         "name": "release"
    50.       }
    51.     ]
    52.   },
    53.   "modules": [
    54.     {
    55.       "name": "entry",
    56.       "srcPath": "./entry",
    57.       "targets": [
    58.         {
    59.           "name": "official",
    60.           "applyToProducts": [
    61.             "official"
    62.           ]
    63.         },
    64.         {
    65.           "name": "test",
    66.           "applyToProducts": [
    67.             "test"
    68.           ]
    69.         }
    70.       ]
    71.     },
    72.     {
    73.       "name": "myhar",
    74.       "srcPath": "./myhar"
    75.     }
    76.   ]
    77. }
    
    [build-profile.json5](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/build-profile.json5#L0-L77)
    
    上述配置文件代码中，配置了official版本与test版本的target名称、buildProFields自定义参数、产物名称、source源码集-sourceRoots以及资源文件目录，并且在official版本中剔除了无需打包的.so文件。同样的，我们也需要创建我们需要的文件目录，因此我们需要在该HAR模块的src/main/目录下创建resources_test和resources_official文件夹，在src/目录下创建official_pages和test_pages文件夹。
    
3. 定制product内容。
    
    App工程：在工程级build-profile.json5文件中配置。
    
    1. {
    2.   "app": {
    3.     "signingConfigs": [],
    4.     "products": [
    5.       {
    6.         "name": "official",
    7.         "compatibleSdkVersion": "5.0.0(12)",
    8.         "runtimeOS": "HarmonyOS",
    9.         "buildOption": {
    10.           "strictMode": {
    11.             "caseSensitiveCheck": true,
    12.             "useNormalizedOHMUrl": true
    13.           }
    14.         },
    15.         "bundleName": "com.official.com",
    16.         "bundleType": "app",
    17.         "icon": "$media:startIcon",
    18.         "label": "$string:official_app_name"
    19.       },
    20.       {
    21.         "name": "test",
    22.         "compatibleSdkVersion": "5.0.0(12)",
    23.         "runtimeOS": "HarmonyOS",
    24.         "buildOption": {
    25.           "strictMode": {
    26.             "caseSensitiveCheck": true,
    27.             "useNormalizedOHMUrl": true
    28.           }
    29.         },
    30.         "bundleName": "com.test.com",
    31.         "bundleType": "app",
    32.         "icon": "$media:app_icon",
    33.         "label": "$string:test_app_name"
    34.       },
    35.       {
    36.         "name": "default",
    37.         "compatibleSdkVersion": "5.0.0(12)",
    38.         "runtimeOS": "HarmonyOS",
    39.       }
    40.     ],
    41.     "buildModeSet": [
    42.       {
    43.         "name": "debug",
    44.       },
    45.       {
    46.         "name": "release"
    47.       }
    48.     ]
    49.   },
    50.   "modules": [
    51.     {
    52.       "name": "entry",
    53.       "srcPath": "./entry",
    54.       "targets": [
    55.         {
    56.           "name": "default",
    57.           "applyToProducts": [
    58.             "default"
    59.           ]
    60.         },
    61.         {
    62.           "name": "official",
    63.           "applyToProducts": [
    64.             "official"
    65.           ]
    66.         },
    67.         {
    68.           "name": "test",
    69.           "applyToProducts": [
    70.             "test"
    71.           ]
    72.         }
    73.       ]
    74.     },
    75.     {
    76.       "name": "myhar",
    77.       "srcPath": "./myhar",
    78.       "targets": [
    79.         {
    80.           "name": "official",
    81.           "applyToProducts": [
    82.             "official"
    83.           ]
    84.         },
    85.         {
    86.           "name": "test",
    87.           "applyToProducts": [
    88.             "test"
    89.           ]
    90.         }
    91.       ]
    92.     }
    93.   ]
    94. }
    
    [build-profile.json5](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/build-profile.json5#L2-L95)
    
    在该配置文件中，配置了product名称、产物bundleName、签名配置信息、应用图标、依赖的target信息。这里需要注意的是，依赖的HAR模块需要在引用他的模块内配置依赖关系。我们的案例是在entry模块里调用的HAR包，所以需要在其对应的oh-package.json5文件中配置dependencies依赖。
    
4. 实现不同目标产物需要定制的业务逻辑。
    - 通过[source源码集-sourceRoots配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides#section18668905913)的差异性代码空间，实现标题（代码文件）多目标效果。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.05260022138999146076644831594595:50001231000000:2800:1D795D35632356D6734F4F33D7C625D37372BB9FB9C46E02D477F671D396AA70.png) ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.34424892153621911643794851656599:50001231000000:2800:85B9AFC2AFA8B1689655CDE96FAB43A72E702E28105583AB37D28774DCEB76BA.png)
        
        在上述配置文件中，配置了HAP模块的source源码集-sourceRoots目录，official版本与test版本分别对应src/official_pages和src/test_pages。
        
        分别在对应的sourceRoots目录下创建同名ets文件并创建同名同类型的方法，例如：示例中创建的是VersionInfo.ets文件。添加如下代码：
        
        src/official_pages/VersionInfo.ets
        
        1. export const getName = () => "This is official version."
        2. export const getTitleName = () => $r('app.string.title')
        
        [VersionInfo.ets](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/entry/src/official_pages/VersionInfo.ets#L16-L17)
        
        src/test_pages/VersionInfo.ets
        
        1. export const getName = () => "This is test version."
        2. export const getTitleName = () => $r('app.string.title')
        
        [VersionInfo.ets](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/entry/src/test_pages/VersionInfo.ets#L16-L17)
        
        在Index.ets文件中，通过import packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建（ import xxx from '<packageName>/sourceFileName'）。该能力具体可参考：[source源码集-sourceRoots配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides#section18668905913)。
        
        1. import { getName, getTitleName } from '../../../test_pages/VersionInfo'
        
        2. @Entry
        3. @Component
        4. struct Index {
        5.   @State message: string = getName();
        6.   @State titleMessage: Resource = getTitleName();
        
        7.   build() {
        8.     Column() {
        9.       Column() {
        10.         Text(this.titleMessage)
        11.           .height(40)
        12.           .fontSize(30)
        13.           .fontWeight(FontWeight.Medium)
        14.         Text(this.message)
        15.           .fontSize(14)
        16.           .fontWeight(FontWeight.Normal)
        17.           .fontColor(Color.Black)
        18.           .opacity(0.6)
        19.           .height(19)
        20.           .margin({ top: 2 })
        21.       }
        22.       // ...
        23.     }
        24.     // ...
        25.   }
        26. }
        
        [Index.ets](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/entry/src/main/ets/pages/Index.ets#L17-L65)
        
    - 在HAR模块引用差异性资源，实现页面中资源多目标效果。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.77562873197520478719083339604162:50001231000000:2800:CA79CF023C2AD62AC58D247E6DBBCA473F2B14B64F5CDFF9B34173C861AB02D3.png) ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.71149392624958117366220101621863:50001231000000:2800:757DE1256131C5E34355DF2332639CF278518200E1B1A3D755BF20CD27B7EF21.png)
        
        在上述配置文件中，我们配置了HAR模块的资源文件路径，official版本和test版本分别对应src/main/resources_official和src/main/resources_test文件。
        
        分别在对应的资源文件目录下添加同名图片资源和json字符串。例如：示例中分别在资源文件目录下的media文件中放入同名的HarImage.jpg图片（图片内容不同），并在element文件下的string.json中添加同名参数"title_description"（其对应的"value"值不相同）。
        
        在页面中直接引用对应同名资源即可，代码如下：
        
        1. TextArea({ text: 'This is the first page of the beta version of the HAR module. Click the button below to jump to the second page of the beta version of the HAR module - the calculator page.' })
        2.   .fontSize(16)
        3.   .width('100%')
        4.   .fontColor('#e6000000')
        5.   .fontWeight(FontWeight.Normal)
        6.   .borderRadius(16)
        7.   .focusable(false)
        8. Image($r('app.media.HarImage'))
        9.   .width('100%')
        10.   .borderRadius(12)
        11.   .padding({ top: 16 })
        
        [MainPage.ets](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/myhar/src/main/ets/components/MainPage.ets#L42-L52)
        
    - 在HAR模块中通过不同自定义参数信息跳转到不同页面，实现路由跳转多目标效果。
        
        效果对比如下：
        
        **图1** official版本  
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.73365647416845698743480051866265:50001231000000:2800:AEF37D7E652843AFB0A0922B1269A5976D93A20B5B018BD1942DBB0207E95E7F.gif)
        
        **图2** test版本  
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.31618739949542067673026564324458:50001231000000:2800:586072D80C9C7C1155C37F4A040FF7BAE3DBE9A464288868691B3CCFDEC61E1C.gif)
        
        在先前的案例中，已经介绍了如何在sourceRoot目录配置的差异性代码空间中实现对同名文件中的同名方法的调用。这里主要介绍在不同的target中如何调用不同名的文件中的不同方法。
        
        首先，需要通过配置文件中配置的自定义参数[生成相应的BuildProfile.ets文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-get-build-profile-para-guide#section8279154125918)。上述HAR模块的配置文件中，我们配置了buildProfileFields自定义参数"productName",在official和test版本中分别配置了不同的值"official"和"test"。这样我们构建不同的产物版本就会生成不同的"productName"值，用于在代码工程中区分不同的产物版本。
        
        然后，分别在official和test的对应的sourceRoots目录下创建不同的ets文件，并导出相应的组件。如示例中在HAR模块的src/official_pages目录下创建了OfficialSecondPages.ets并export了一个OfficialSecond组件，然后在src/test_pages目录下创建了TestSecondPages.ets并export了一个TestSecond组件。这两个组件中分别包含了不同的页面信息。
        
        最后在首页中import相应的方法实现跳转逻辑。具体代码如下：
        
        导入方法及组件：
        
        1. import BuildProfile from '../../../../BuildProfile';
        2. import { OfficialSecond } from '../../../official_pages/OfficialSecondPage';
        3. import { TestSecond } from '../../../test_pages/TestSecondPage';
        
        [MainPage.ets](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/myhar/src/main/ets/components/MainPage.ets#L16-L18)
        
        定义页面跳转逻辑：接收到不同的参数值跳转不同页面。
        
        4. @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack();
        
        5. @Builder
        6. PagesMap(name: string) {
        7.   if (name == 'official') {
        8.     // According to the user-defined parameter value, if the value is Official, the
        9.     // second page of official will jump correspondingly.
        10.     OfficialSecond();
        11.   } else {
        12.     TestSecond();
        13.   }
        14. }
        
        [MainPage.ets](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/myhar/src/main/ets/components/MainPage.ets#L23-L34)
        
        为按钮添加点击属性，并传递自定义参数，用于实现Navigation路由跳转：
        
        15. Button($r('app.string.button_describe'))
        16.   .fontSize(16)
        17.   .height(40)
        18.   .width('100%')
        19.   .onClick(() => {
        20.     this.pageInfos.pushPath({ name: 'official' });
        21.   })
        
        [MainPage.ets](https://gitee.com/harmonyos_samples/MultiTarget/blob/master/myhar/src/main/ets/components/MainPage.ets#L56-L62)
        
5. 选择不同的product构建出不同的目标产物。
    
    **图3** 构建图示  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193142.65641268482498624617481720027151:50001231000000:2800:A1ECDE68EBFF51798D3D7B3AC032F314C0B990D8CE786DF4C4A285A39E9B81CD.png)
    
    首先点击DevEco Studio工具右上角的Product按钮，即图中的1号标识处，然后在2号标识处选择对应的product工程，选择完工程之后会自动映射出我们文件中已经依赖的target，最后点击Apply应用。上述操作完成之后就可以点击运行按钮查看多目标产物效果了。本案例运行效果图如下：
    
    **图4** Official版本
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193143.78322359308695005543034684269330:50001231000000:2800:C925783D4935BDB30DAA9A3404C8E1F1184912FDCFEF259DED4C515B41D1EC5C.gif)
    
    **图5** Test版本  
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193143.32060157002366306283670191125746:50001231000000:2800:ED69ED9C5D706A095B42F34473CABE898035833DEFC5BD93FF2D8D6CACE52B02.gif)
    

## 常见问题

### 如何为不同的product产物配置签名信息？

配置工程级的build-profile.json5文件.

首先需要在每个product下添加配置项"signingConfig"。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193143.93013629295686079928253244687536:50001231000000:2800:238059E4AE050701FB745888B496145A88C9DCC6A6BBEAE8D2DF5A3D4D64092A.png "点击放大")

然后进入到签名配置页面，点击加号，添加签名信息：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193143.21073196296408847812557469124314:50001231000000:2800:FCB8661C177AC6EFA6D00C57EE9C75059322A8CF8F8EAB3490FE44082EFF06A7.png "点击放大")

然后选择对应的bundle name，并填写上面配置的"signingConfig"信息（每个product产物都需要配置）：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193143.36697489391407090577211001761816:50001231000000:2800:03A4D833F16D6628306E843561D5667B230A0F8F52B8A80C2C7FC29CFA8BD953.png "点击放大")

点击ok之后，进行签名即可。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251212193143.77170128502284522960984638953880:50001231000000:2800:FF7D1A34D98E9CF726941A7BD66E9E289BB6CD3BE8363730370208D7AD642250.png "点击放大")

## 示例代码

- [构建多目标产物工程](https://gitee.com/harmonyos_samples/MultiTarget)
# 在AGC创建项目和HarmonyOS应用/元服务

更新时间: 2025-12-16 15:57

## 创建项目

项目是您在AppGallery Connect（以下简称AGC）资源的组织实体，您可以将一个应用的不同平台版本添加到同一个项目中。当您的应用需要使用华为服务时，您需要在AGC中[创建您的项目](https://developer.huawei.com/consumer/cn/doc/app/agc-help-create-project-0000002242804048)。

## 创建HarmonyOS应用/元服务

如果您需要在华为应用市场发布您的HarmonyOS应用/元服务，或者使用AGC提供的各类服务，您需要先在AGC中[创建HarmonyOS应用/元服务](https://developer.huawei.com/consumer/cn/doc/app/agc-help-app-0000002235710234)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-setup "搭建开发环境")
开发鸿蒙应用调用高德地图HarmonyOS版本SDK不需要通过MCP（Module Control Protocol）。以下是完整的开发步骤示例：

1.搭建开发环境

· 安装DevEco Studio，配置HarmonyOS开发环境，创建新的HarmonyOS项目。

2.获取应用的AppID

· 在应用工程中，通过代码获取应用的AppID：

let flag = bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_SIGNATURE_INFO;

let bundleInfo = bundleManager.getBundleInfoForSelfSync(flag);

let appId = bundleInfo.signatureInfo.appId;

· 注意：云真机调试时获取的AppID格式可能不完整，需确保使用正确的AppID格式（包含签名信息）。

3.申请高德API Key

· 访问高德开放平台官网（ [https://lbs.amap.com/），登录后进入控制台。](https://lbs.amap.com/%EF%BC%89%EF%BC%8C%E7%99%BB%E5%BD%95%E5%90%8E%E8%BF%9B%E5%85%A5%E6%8E%A7%E5%88%B6%E5%8F%B0%E3%80%82) · 创建新应用，选择“HarmonyOS平台”，输入获取到的AppID，申请API Key。

4.配置项目依赖

· 在项目模块的

build.gradle文件中，添加高德地图SDK依赖：

dependencies {

implementation filetree(dir: 'libs', include: ['*.har'])

}

· 将高德地图SDK的

.har文件放入项目

libs目录。

5.配置权限

· 在

config.json文件中声明网络权限：

"reqPermissions": [

{

"name": "ohos.permission.internet",

"reason": "地图需要网络连接"

}

]

6.初始化地图

· 在应用的入口文件（如

main.ets或

entry.ets）中，设置API Key并初始化地图：

import { mapsInitializer } from '@amap/amap_lbs_common';

// 设置API Key

mapsInitializer.setApiKey('您的API Key');

// 在页面中创建地图组件

@Entry

@Component

struct MapPage {

build() {

Column() {

MapView()

.width('100%')

.height('100%')

}

}

}

7.使用地图功能

· 在页面逻辑中获取地图对象，进行地图操作：

import { mapViewManager, amap } from '@amap/amap_lbs_map3d';

@Entry

@Component

struct MapPage {

private map: amap;

```
build() {    Column() {        MapView()            .width('100%')            .height('100%')            .onInit((mapView) => {                mapView.onCreate();                mapView.getMapAsync((amap) => {                    this.map = amap;                    // 设置地图中心点和缩放级别                    this.map.moveCamera(CameraUpdateFactory.newCameraPosition(                        new CameraPosition.Builder()                            .target(new LatLng(39.90923, 116.397428)) // 北京天安门坐标                            .zoom(12)                            .build()                    ));                });            })    }}
```

Plain Text

}

以上步骤涵盖了从环境搭建、权限配置到地图功能调用的完整流程。实际开发中，可根据需求进一步扩展地图功能，如添加标记点、路径规划、定位等。 根据您提供的文档内容，我将为您提供一份从零开始创建HarmonyOS项目的详细图文版本指南。
# 显示地图最后更新时间: 2025年12月10日

使用地图SDK之前，需要在 config.json 文件中进行相关权限设置，确保地图功能可以正常使用。

## 第一步，配置module.json5

#### 首先，声明权限

```
...
"requestPermissions": [
  {
    "name": 'ohos.permission.INTERNET',
  }
]
...
```

Json

## 第二步，在工程的oh-package.json5文件中添加依赖

#### 从ohpm仓库获取高德地图包

```
"dependencies": {
    "@amap/amap_lbs_common": ">=1.2.3",
    "@amap/amap_lbs_map3d": ">=2.2.7",
    "@amap/amap_lbs_search": ">=1.0.2",
}
```

Json

## 第三步，初始化地图容器

1

#### 从高德地图包中导入所需模块

```
import { AMap, MapsInitializer, MapView, MapViewComponent, MapViewManager } from '@amap/amap_lbs_map3d';
```

2

#### 设置Key

[获取Key](https://lbs.amap.com/api/harmonyosnext-map3d-sdk/guide/get-key)

```
MapsInitializer.setApiKey("您的key");
```

3

#### 获取MapView

```
MapViewManager.getInstance().registerMapViewCreatedCallback((mapview?: MapView, mapViewName?: string) => {
  if (!mapview) {
    return;
  }
  let mapView = mapview;
  ...
})
```

4

#### 初始化地图并获取AMap对象

```
mapView.onCreate();
mapView.getMapAsync((map) => {
let aMap: AMap = map;
// aMap.setTrafficEnabled(true) //打开交通路况图层
// TODO
})
```

5

#### 地图组件配置

```
MapViewComponent()
.width('100%')
.height('100%')
```

![](https://a.amap.com/lbs/static/img/doc/doc_1712732554708_a2031.png)

至此就可以看到地图展示，并且拿到了AMap对象后，就可以往地图上添加点线面等覆盖物

6

#### 完整代码示例

```
import { AMap, MapsInitializer, MapView, MapViewComponent, MapViewManager, } from '@amap/amap_lbs_map3d';

MapsInitializer.setApiKey("您的key");
MapViewManager.getInstance().registerMapViewCreatedCallback((mapview?: MapView, mapViewName?: string) => {
  if (!mapview) {
    return;
  }
  let mapView = mapview;
  mapView.onCreate();
  mapView.getMapAsync((map) => {
    let aMap: AMap = map;
  })
})

@Entry
@Component
struct Index {
  build() {
    Row() {
      MapViewComponent()
        .width('100%')
        .height('100%')
    }
  }
}
```

# 切换地图图层最后更新时间: 2025年11月17日

在使用地图图层前，请务必确保您已按照 [显示地图](https://lbs.amap.com/api/harmonyosnext-map3d-sdk/guide/create-map/show-map) 完成了所有必要的配置步骤。HarmonyOS 地图 SDK 提供了几种预置的地图图层，包括普通地图、卫星地图、夜景地图、导航地图、公交地图、导航夜景地图。

AMap 类提供图层类型常量，详细如下：

注意：路况图层是通过开关控制，不通过常量控制。

|   |   |
|---|---|
|类型|说明|
|MAP_TYPE_NORMAL：1|普通地图模式（默认模式）|
|MAP_TYPE_SATELLITE：2|卫星图模式|
|MAP_TYPE_NIGHT：3|夜景图模式|
|MAP_TYPE_NAVI：4|导航模式|
|MAP_TYPE_BUS: 5|公交模式|
|MAP_TYPE_NAVI_NIGHT: 6|导航夜间模式|

下文就卫星模式地图、夜景模式地图、导航模式地图为例做简单介绍。

## 卫星地图

在初始化地图时，除了可用选择默认的标准地图，还可以设置地图类型为「卫星图」，代码如下：

```
mapView.getMapAsync((map) => {
  map.setMapType(MapType.MAP_TYPE_SATELLITE)  //设置地图类型为卫星图
  let aMap: AMap = map;
})
```

提示：需要引入地图枚举类型

```
import {MapType} from '@amap/amap_lbs_map3d';
```

显示效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1763086826373_1c0b8.jpeg)

## 夜景地图

设置地图类型为「夜景图」，代码如下：

```
mapView.getMapAsync((map) => {
  map.setMapType(MapType.MAP_TYPE_NIGHT)  //设置地图类型为夜景图
  let aMap: AMap = map;
})
```

显示效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1763086850510_d9d85.jpeg)

## 导航模式地图

设置地图类型为「导航图」，代码如下：

```
mapView.getMapAsync((map) => {
  map.setMapType(MapType.MAP_TYPE_NAVI)  //设置地图类型为导航图
  let aMap: AMap = map;
})
```

显示效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1763086875883_57355.jpeg)
# 显示定位蓝点最后更新时间: 2025年11月04日

定位蓝点指的是进入地图后显示当前位置点的功能。

## 实现定位蓝点

1

#### 准备地图

显示地图详细讲解，前往 [显示地图](https://lbs.amap.com/api/harmonyosnext-map3d-sdk/guide/create-map/show-map) 文档。

```
let aMap: AMap = map;
aMap?.moveCamera(CameraUpdateFactory.newLatLngZoom(new LatLng(40.024279, 116.434153), 13)); //设置地图中心点以及缩放级别
```

2

#### 设置定位图层样式

```
let locationStyle: MyLocationStyle = new MyLocationStyle(); //定位样式构造函数

//设置我的位置展示模式
locationStyle.myLocationType(MyLocationStyle.LOCATION_TYPE_FOLLOW); //定位、且将视角移动到地图中心点，定位点跟随设备移动

aMap?.setMyLocationStyle(locationStyle); //设置定位图层的样式
```

3

#### 设置定位源

```
//定义了一个定位源，为地图提供定位数据
let locationSource: LocationSource = {
  activate(listener: OnLocationChangedListener): void {
    let location: geoLocationManager.Location = {
      accuracy: 1000,
      altitude: 0,
      direction: 0,
      //116.438055,40.025108
      latitude: 40.025108,
      longitude: 116.438055,
      speed: 0,
      timeSinceBoot: 123587419434256,
      timeStamp: 0,
      altitudeAccuracy: 0,
      speedAccuracy: 0,
      directionAccuracy: 0,
      uncertaintyOfTimeSinceBoot: 0,
      sourceType: 1
    }
    try {
      listener.onLocationChanged(location);
    } catch (e) {
      console.info((e as BusinessError).message);
    }
  },
  deactivate() {
  }
};

aMap?.setLocationSource(locationSource); //设置定位源
```

4

#### 打开定位图层

```
aMap?.setMyLocationEnabled(true); //打开定位图层
```
# 显示室内地图最后更新时间: 2025年12月10日

开启室内地图后，如果可见区域内包含室内地图覆盖区域（如：西单大悦城等知名商场），且缩放达到一定级别，便可直接在地图上看到精细室内地图效果。

缩放级别放大到一定级别时，地图上可以显示室内地图。

缩放级别继续放大时，不仅可以看到室内地图效果，还允许操作切换楼层，显示精细化室内地图。

左上角为楼层切换组件

如下图示：

![](https://a.amap.com/lbs/static/img/doc/doc_1765347727047_076c2.png)

可以通过以下接口控制是否显示室内地图：

```
/**
 * 设置是否显示室内地图，默认不显示。<br>
 * <p>
 * 注：如果打开了室内地图，会显示3D建筑物，即如果之前有设置不显示3D建筑物，3D建筑物也会被显示出来。
 *
 * @param enabled true：显示室内地图；false：不显示；
 */
public showIndoorMap(enabled: boolean): void {
    this.mapDelegate.setIndoorEnabled(enabled);
}
```

可以通过以下接口控制切换显示室内地图的某一层：

```
/**
 * 室内地图楼层控制接口，通过此接口可以控制某个室内地图显示的楼层。
 *
 * @param indoorBuildingInfo indoorBuildingInfo 对象，它定义了室内地图属性,详情{@link IndoorBuildingInfo}。
 */
public setIndoorBuildingInfo(indoorBuildingInfo: IndoorBuildingInfo): void {
    this.mapDelegate.setIndoorBuildingInfo(indoorBuildingInfo);
}
```

可以通过以下接口设置室内地图楼层状态监听(demo中实现楼层切换的关键)

```
/**
 * 设置室内地图状态监听接口
 *
 * @param listener 室内地图状态监听接口。
 * @since V2.2.4
 */
public setIndoorFloorSwitchAdapter(listener: IndoorFloorSwitchAdapter): void {
    try {
        this.mapDelegate.setIndoorFloorSwitchAdapter(listener);
    } catch (e) {
        LogUtil.e(Constants.MODULE_TAG, "AMap", e);
    }
}
```

调用上述室内地图的接口实现的demo(部分)

```
# 设置状态变量实现楼层切换组件与室内地图楼层之间的实时同步
 @State floorSwitch: IndoorFloorSwitchAdapter = new IndoorFloorSwitchAdapter();

# 楼层切换组件变化后的回调
  OnPicker(valueName: string): void {
    let indoorBuildingInfo: IndoorBuildingInfo = this.floorSwitch.mIndoorBuildingInfo;
    let offset: number = indoorBuildingInfo.floor_names.findIndex((value: string) => value === valueName);
    if (offset >= indoorBuildingInfo.floor_names.length || offset < 0) {
      return
    }
    let index = indoorBuildingInfo.floor_indexs[offset];
    this.floorSwitch.offset = offset;
    indoorBuildingInfo.activeFloorIndex = index;
    indoorBuildingInfo.activeFloorName = valueName;
    this.mAMap?.setIndoorBuildingInfo(indoorBuildingInfo);
  }

# 设置楼层切换组件
TextPicker({range: this.floorSwitch?.mIndoorBuildingInfo.floor_names, selected: this.floorSwitch?.offset})
  .position({left:0, top: 0})
  .visibility(this.floorSwitch.visible)
  .onScrollStop((value: string | string[], index: number | number[]) => {
    this.OnPicker(value as tring);
  })
  .opacity(1)
```
# 显示3D地形图最后更新时间: 2025年12月10日

地形图是在3D地图的基础上，融入地形高程，使3D地图能够显示地形的高低起伏，显示山脉的形状以及走向等。

可以通过以下接口控制是否显示3D地形图：

```
/**
 * 设置是否打开地形图, 默认为关闭
 * 打开地形图之后，底图会变成3D模式，添加的点线面等覆盖物也会自动带有高程
 * <p>
 * 注意：需要在MapView创建之前调用
 *
 * @param isTerrainEnable true为打开，默认false
 * @since 2.2.4
 */
public static setTerrainEnable(isTerrainEnable: boolean)
```

效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1765347794339_0d50f.png)

注意：地形图的渲染和普通3D地形图使用的引擎不同不能够同时显示。
# 自定义地图最后更新时间: 2025年09月15日

## 简介

自 Harmony 3D 地图 SDK v2.2.2 起，高德地图支持使用可视化自定义地图模版改变底图颜色和样式，实现可视化的编辑和控制显示地图元素。

## 创建样式文件

### 创建地图样式

高德地图开放平台的开发者在取得开发者账号后，可以进入[开发者控制台](https://lbs.amap.com/dev/key)，在[地图自定义平台](https://lbs.amap.com/dev/mapstyle/index)选择“创建地图样式”，可以选择一个模板进行创建。

![](https://a.amap.com/lbs/static/img/doc/doc_1757930035503_4a47a.png)

#### 编辑地图样式 

在创建的页面的左侧列表选择任一要素编辑样式属性；也可以单击地图，在弹出的列表中选择要素进行编辑。

![](https://a.amap.com/lbs/static/img/doc/doc_1757930043484_fb5c8.png)

#### 发布地图样式并下载 

编辑完成后点击右上角“保存”->“发布”，发布完成后，选择“使用方法”，然后选择“android”平台，点击“下载离线文件”。

![](https://a.amap.com/lbs/static/img/doc/doc_1757930050494_10fb1.png)

![](https://a.amap.com/lbs/static/img/doc/doc_1757930056708_09dd8.png)

## 设定样式文件

注意：自地图SDK v2.2.2 起，自定义地图使用方法进行了较大更新，具体请参见以下具体文档说明。

### 一、设定离线样式文件

1、在官网控制台-我的地图样式中选择与当前使用的地图SDK版本号所对应的版本进行样式文件下载：(注意：harmony 也是使用Android 离线地图样式，版本号选择最新版本)

![](https://a.amap.com/lbs/static/img/doc/doc_1757930065470_8266e.png)

2.下载得到的Zip文件，内部目录结构如下，每个文件都会对应 CustomMapStyleOptions 中一个接口：

|   |   |   |
|---|---|---|
|文件名称|文件内容说明|对应接口|
|style_extra.data|扩展内容，如网格背景色等|CustomMapStyleOptions.setStyleExtraData/setStyleExtraPath|
|style.data|具体样式配置|CustomMapStyleOptions.setStyleData/setStyleDataPath|
|textures.zip|纹理图片(zip文件)|CustomMapStyleOptions.setStyleTextureData/setStyleTexturePath|

注意：可将配置好的样式文件放入任意路径，比如“/mnt/sdcard/amap”

```
//该方法在AMap类中提供
this.aMap?.setCustomMapStyle(new CustomMapStyleOptions()
    .setEnable(true)
    .setStyleDataPath("file://docs/storage/Users/currentUser/style.data")
    .setStyleExtraPath("file://docs/storage/Users/currentUser/style_extra.data")
    .setStyleTexturePath("file://docs/storage/Users/currentUser/textures.zip")
)
```

注意：纹理功能需要[开通相关权限](https://lbs.amap.com/home/package?active=mapstyle)才可使用。

#### 二、设定在线样式文件（需要[开通权限](https://lbs.amap.com/home/package?active=mapstyle)）

1、如果觉得下载样式文件过程比较繁琐，也可以使用在线的方式调用：在自定义平台发布新样式后获得样式ID，并通过SDK的 setCustomMapStyleID 设置使用。如果需要变动样式，只需要在发布之后重新加载一次地图即可看到效果；

2、如果同时设置了在线样式和离线样式，会优先进行在线拉取，如果拉取失败了会再次读取离线样式；

3、示例代码：

```
//该方法在AMap类中提供
  this.aMap.setCustomMapStyle(
    new CustomMapStyleOptions()
    .setEnable(true)
    .setStyleId("您的styleid")//官网控制台-自定义样式 获取
    );
```

注意：纹理暂不支持在线拉取,如果调用了styleid也需要将纹理通过setStyleTexturePath设置了才会生效。
# 显示英文地图最后更新时间: 2025年11月17日

设置地图为英文地图

```
/**
 * 设置地图底图语言，目前支持中文底图和英文底图
 *
 * @param language 中文"zh_cn", 英文"en"
 * @since 2.2.4
 */
public static setMapLanguage(language: string)
```

效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1763087490591_b8fad.png)
# 使用离线地图最后更新时间: 2025年11月17日

## 离线地图与基本地图联动

高德3D 地图 SDK支持离线地图功能。（2D 地图 SDK 不支持离线地图功能）

离线地图可满足在无网络环境下查看地图信息的需求，在设备本地有离线地图数据的情况下，SDK 会优先加载离线地图。

## 离线地图UI组件（推荐）

自3D地图SDK V2.2.5起，新增离线地图UI组件，组件涵盖城市下载、暂停、更新、删除以及关键字城市查询等功能，是高德地图客户端离线地图功能的一个子集，UI交互风格上靠拢高德地图app，也考虑到与开发者应用UI的融合问题，尽可能的保持了简约极致。以下方法实现一键完成离线地图开发。

#### 增加权限

```
"requestPermissions": [
  {
    "name": 'ohos.permission.INTERNET',
  },
  {
    "name": 'ohos.permission.GET_NETWORK_INFO'
  }
]
```

#### 导入OfflineMapPage

离线地图使用的是OfflineMapPage组件，本组件在SDK内部实现，仅需要在当前Page中import { OfflineMapPage } from "@amap/amap_lbs_map3d" 即可使用OfflineMapPage组件。

#### 使用离线地图组件

```
import { OfflineMapPage } from "@amap/amap_lbs_map3d"

@Entry
@Component
export struct MapOfflineMapController {
  build() {
      OfflineMapPage()
  }
}
```

#### UI示意

![](https://a.amap.com/lbs/static/img/doc/doc_1763364960039_036ce.png)

## 自定义离线地图UI

#### 开始下载

可以根据城市编码和城市名称两种方式下载当前城市的离线地图。示例代码如下：

```
//构造OfflineMapManager对象 
this.amapManager = new OfflineMapManager(this.context, this)
//按照citycode下载
this.amapManager?.downloadByCityCode(citycode:string)；
//按照cityname下载
this.amapManager?.downloadByCityName(cityname:string)；
```

#### 暂停下载

通过代码暂停地图的下载:

示例代码如下：

```
this.amapManager?.pause();
```

#### 停止下载

停止所有当前正在执行的下载，包括下载队列中等待的部分。

示例代码如下：

```
this.amapManager.stop();
```

#### 更改离线地图存储目录

离线地图默认会下载到手机存储卡的“amap”目录下，也可以自定义路径：

通过 MapInitializer.sdcardDir 设置路径时，需要在 AMap 对象初始化之前进行，否则操作会无效。

```
// 设置应用单独的地图存储目录
MapsInitializer.sdcardDir = "自定义的目录";
```

#### 获取离线地图列表

其属性参数见下表：

|   |   |
|---|---|
|名称|说明|
|获取城市列表|OfflineMapManager.getOfflineMapCityList()|
|获取省列表|OfflineMapManager.getOfflineMapProvinceList()|
|获取已下载城市列表|OfflineMapManager.getDownloadOfflineMapCityList()|
|获取正在或等待下载城市列表|OfflineMapManager.getDownloadingCityList()|

## 检查更新

通过如下代码检查离线地图数据是否存在更新，检查更新操作会同时将本地离线地图配置文件更新成最新的，App 用户可依据最新的配置文件下载新版离线地图数据。

示例代码如下：

```
//通过updateOfflineCityByName方法判断离线地图数据是否存在更新
this.amapManager?.updateOfflineCityByName(city);
```

## 删除离线地图

执行 remove 操作时，需要等待 OfflineLoadedListener 回调之后才可以，否则（即使OfflineMapDownloadListener回调成功）操作将会无效。 

示例代码如下：

```
//删除某一城市的离线地图包
this.amapManager?.remove(city);
```

## 📋 **从零开始创建HarmonyOS项目（ArkTS）**

### **第一步：准备工作**

1. **注册华为开发者账号**并完成**实名认证**（注册地需为中国境内）

2. **安装DevEco Studio**（建议最新版本）

3. **确保账号无欠款**（否则云开发服务可能开通失败）

### **第二步：创建新工程**

#### **1. 打开工程创建向导**

- **方式一**：首次打开DevEco Studio，在欢迎页点击 **Create Project**

- **方式二**：已打开工程时，菜单栏选择 **File > New > Create Project**

创建工程入口

#### **2. 选择工程模板**

在 **Choose Your Ability Template** 界面：

- **Application**：普通应用开发

- **Atomic Service**：元服务开发（API 11及以上支持）

**推荐选择**： Application  →  Empty Ability （基础模板）

选择模板

#### **3. 配置工程信息**

进入 **Configure Your Project** 界面，填写以下关键信息：

|配置项|说明|填写示例/选择建议|
|---|---|---|
|**Project name**|工程名称|MyApplication （字母、数字、下划线）|
|**Bundle name**|包名（唯一标识）|com.example.myapplication （必须与AGC创建的应用包名一致）|
|**Save location**|保存路径|不含中文字符的路径|
|**Compatible SDK**|兼容的最低API版本|**关键选择**：根据需求选择（如 5.1.1(19) ）|
|**Module name**|模块名称|entry （默认）|
|**Device type**|支持的设备类型|**关键选择**：勾选目标设备|

**设备类型说明**：

- ✅ **Phone**：手机（最常用）

- ✅ **Tablet**：平板

- ✅ **2in1**：PC/二合一设备（支持多窗口）

- ✅ **Car**：车机

- ✅ **Wearable**：智能手表

- ✅ **TV**：智慧屏

- ✅ **Default**：默认设备（可编译但不上架）

配置工程

**重要提示**：

- **Bundle name**必须与在AGC（AppGallery Connect）创建的应用包名完全一致

- **Compatible SDK**选择后，应用将无法安装在低于此版本的设备上

- 如需**云开发**，必须选择 5.0.0(12) 或以上版本

#### **4. 特殊模板说明**

- **Native C++**：如需C++开发，选择此模板

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/3eedde57c6cc4e57aea3224bc9dbf8fe?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765677827%3B1765706627&q-key-time=1765677827%3B1765706627&q-header-list=&q-url-param-list=&q-signature=51201a8023d1dc0571b92a2692894bf081cb0c26)

- **[CloudDev]Empty Ability**：端云一体化开发模板

- **元服务工程**：Bundle name自动生成为 com.atomicservice.[appid] 格式

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/4b1bd4b240a74baead397b90b93c4f6a?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765677827%3B1765706627&q-key-time=1765677827%3B1765706627&q-header-list=&q-url-param-list=&q-signature=33be5d166a054fed53defa4330655e1e6f0068ef)

### **第三步：工程创建完成**

点击 **Finish**，DevEco Studio自动生成代码和资源文件。

### **第四步：工程结构解析**

创建完成后，工程目录结构如下：

```
MyApplication/├── .hvigor/                    # 构建配置目录├── .idea/                      # IDE配置目录├── AppScope/                   # 应用全局配置│   └── app.json5              # 应用全局配置文件├── entry/                      # 主模块（HAP包）│   ├── src/│   │   ├── main/│   │   │   ├── ets/           # ArkTS源代码│   │   │   │   ├── entryability/  # 应用入口Ability│   │   │   │   └── pages/     # 页面文件│   │   │   ├── resources/     # 资源文件（图片、字符串等）│   │   │   └── module.json5   # 模块配置文件│   │   └── ohosTest/          # 测试代码│   ├── build-profile.json5    # 模块构建配置│   └── oh-package.json5       # 依赖管理文件└── build-profile.json5        # 工程级构建配置
```

Plain Text

### **第五步：关键配置文件详解**

#### **1. app.json5（应用全局配置）**

```
{  "app": {    "bundleName": "com.example.myapplication",  // 必须与AGC包名一致    "vendor": "example",    "versionCode": 1000000,    "versionName": "1.0.0",    "icon": "$media:app_icon",    "label": "$string:app_name"  }}
```

JSON

#### **2. module.json5（模块配置）**

```
{  "module": {    "name": "entry",    "type": "entry",    "description": "$string:module_desc",    "mainElement": "EntryAbility",    "deviceTypes": ["phone", "tablet"],  // 支持的设备类型    "pages": "$profile:main_pages",    "abilities": [...],    "requestPermissions": [...]  // 权限声明  }}
```

JSON

#### **3. build-profile.json5（构建配置）**

```
{  "app": {    "signingConfigs": [],    "products": [      {        "name": "default",        "signingConfig": "default",        "compileSdkVersion": "5.1.1(19)",      // 编译SDK版本        "compatibleSdkVersion": "5.1.1(19)",   // 兼容的最低版本        "targetSdkVersion": "5.1.1(19)",       // 目标版本（可选）        "runtimeOS": "HarmonyOS",              // 运行环境        "buildOption": {          "externalNativeOptions": {            "abiFilters": ["armeabi-v7a"]      // Native C++需要（如RK开发板）          }        }      }    ]  }}
```

JSON

### **第六步：特殊场景配置**

#### **1. 创建OpenHarmony工程**

如需开发OpenHarmony应用，创建HarmonyOS工程后，修改 build-profile.json5 ：

```
{  "products": [    {      "name": "default",      "signingConfig": "default",      "compileSdkVersion": "20",        // 改为字符串      "compatibleSdkVersion": "20",    // 改为字符串      "runtimeOS": "OpenHarmony"        // 关键修改    }  ]}
```

JSON

#### **2. 配置AGC云开发**

如需使用云开发功能：

1. 创建工程时选择 **[CloudDev]Empty Ability** 模板

2. 确保 **Enable CloudDev** 已勾选

3. 工程创建后自动关联AGC项目

4. 在 module.json5 中添加AGC配置：

```
"metadata": [  {    "name": "client_id",    "value": "从AGC获取的Client ID"  }]
```

JSON

#### **3. 元服务工程特殊要求**

- Bundle name格式： com.atomicservice.[appid] 

- Compatible SDK必须≥ 5.0.0(12) 

- 自动生成包名，不可手动修改

### **第七步：同步与运行**

1. 配置完成后点击 **Sync Now** 同步工程

2. 如提示设备类型变更，点击 **Yes** 确认

3. 连接真机或启动模拟器

4. 点击 **Run** 运行应用

### **第八步：常见问题解决**

#### **问题1：工程检查报错**

```
Incorrect settings found in the build-profile.json5 file
```

Plain Text

**解决方案**：

- 检查 compileSdkVersion 、 compatibleSdkVersion 格式是否为字符串（如 "5.1.1(19)" ）

- 确认 runtimeOS 位置正确（在products数组内）

- 删除模块级 build-profile.json5 中的 runtimeOS 字段

#### **问题2：设备类型不匹配**

```
The type of target device does not match the device type configured by module
```

Plain Text

**解决方案**：

1. 检查 module.json5 中 deviceTypes 是否包含目标设备

2. 检查 build-profile.json5 中 targets 配置

3. 检查 hvigorfile.ts 是否修改了设备类型设置

#### **问题3：SDK版本兼容性**

- 确保真机/模拟器系统版本≥ compatibleSdkVersion 

- 如需使用新API， compileSdkVersion 需≥API版本

### **第九步：后续开发建议**

1. **添加新Module**：

- 菜单栏选择 **File > New > Module**

- 选择Module类型： Entry 、 Feature 、 Library 

2. **配置签名**：

- 调试阶段：使用自动签名

- 发布前：申请发布证书和Profile文件

3. **多设备适配**：

- 使用响应式布局

- 针对不同设备类型提供差异化资源

4. **版本管理**：

- 定期更新SDK版本

- 关注API变更和废弃通知

### **总结**

创建HarmonyOS项目的关键步骤：

1. **选择正确模板**（Application/Atomic Service）

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/a2ec83c6db984d2d8a8374b84b9ec05b?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765677827%3B1765706627&q-key-time=1765677827%3B1765706627&q-header-list=&q-url-param-list=&q-signature=60d9c6c093300fcbcadc3fcbf9f6b06a6ab2240c)

2. **配置唯一Bundle name**（与AGC一致）

3. **选择合适的SDK版本**（考虑兼容性和功能需求）

4. **勾选目标设备类型**（Phone、Tablet等）

5. **完成AGC关联**（如需云开发）

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/e294d4efed1f4b5b90568fbb9f36771e?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765677827%3B1765706627&q-key-time=1765677827%3B1765706627&q-header-list=&q-url-param-list=&q-signature=09927efec4915f8062de7146f480a5b6873a621c)

通过以上步骤，您就可以成功创建并配置一个HarmonyOS应用工程，开始您的应用开发之旅。 根据文档内容，我将为您详细解答如何从零开始创建一个HarmonyOS项目，包括SDK、Module Name、Device Type等关键配置的选择。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/98b79b6fda734971a67dccee3eb4779f?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765677843%3B1765706643&q-key-time=1765677843%3B1765706643&q-header-list=&q-url-param-list=&q-signature=6022aa9684e628e2d0679ae6c5ee1b33ad22b4fa)

## 📋 从零开始创建HarmonyOS项目的完整指南

### 1. **创建新工程的基本流程**

#### **第一步：打开工程创建向导**

- **方式一**：如果当前未打开任何工程，在DevEco Studio欢迎页选择 **Create Project**

- **方式二**：如果已打开工程，在菜单栏选择 **File > New > Create Project**

#### **第二步：选择工程类型**

```
Choose Your Ability Template├── Application（应用开发）│   ├── Empty Ability（空模板）│   ├── Native C++（C++开发）│   └── [CloudDev]Empty Ability（云开发模板）└── Atomic Service（元服务开发）    └── Empty Ability（空模板）
```

Plain Text

**选择建议**：

- **普通应用**：选择 **Application > Empty Ability**

- **需要云开发功能**：选择 **Application > [CloudDev]Empty Ability**

- **元服务**：选择 **Atomic Service > Empty Ability**

- **C++开发**：选择 **Native C++**

### 2. **配置工程基本信息**

#### **关键配置参数详解**

|参数|说明|选择建议|
|---|---|---|
|**Project name**|工程名称|由大小写字母、数字和下划线组成|
|**Bundle name**|包名|需保证唯一，需与AGC创建的HarmonyOS应用“应用包名”一致|
|**Save location**|保存路径|不能包含中文字符|
|**Compatible SDK**|兼容的最低API Version|**关键选择**：根据目标设备选择|
|**Module name**|模块名称|默认entry，可自定义|
|**Device type**|支持的设备类型|**关键选择**：根据应用目标设备选择|

#### **SDK版本选择（Compatible SDK）**

文档中提到的SDK版本示例：

-  5.0.0(12)  - 支持云开发的最低版本

-  5.0.4(16)  - Native版本示例

-  5.1.0(18)  - 常规开发版本

-  6.0.0(20)  - 较新版本

**选择原则**：

1. **功能需求**：如果需要云开发，选择 5.0.0(12) 或以上

2. **设备兼容**：考虑要支持的最低系统版本

3. **API特性**：新版SDK提供更多API能力

#### **设备类型选择（Device type）**

文档中列出的设备类型及枚举值：

|设备类型|枚举值|说明|
|---|---|---|
|手机|phone|最常用设备类型|
|平板|tablet|平板设备|
|PC/2in1|2in1|PC设备，支持多窗口、键盘鼠标操作|
|智慧屏|tv|电视设备|
|智能手表|wearable|系统能力较丰富的手表|
|车机|car|车载设备|
|默认设备|default|可编译但不支持上架，建议用phone替代|

**选择建议**：

- **单设备应用**：只选择目标设备类型

- **多设备应用**：勾选所有支持的设备类型

- **PC端适配**：必须包含 2in1 才能在PC上全屏展示

### 3. **Module Name配置**

#### **Module命名规则**

- Module name不可与工程名称相同

- 由字母、数字和下划线组成，且必须以字母开头

- 最大长度31字节

#### **Module类型选择**

在**添加Module**时需选择Module type：

- **Entry**：应用的主模块，一个工程只能有一个Entry模块

- **Feature**：动态特性模块

- **Library**：共享包模块（HAR/HSP）

### 4. **工程结构说明**

创建完成后生成的典型工程结构：

```
MyApplication/├── .hvigor/           # 构建配置├── .idea/             # IDE配置├── AppScope/          # 全局配置│   └── app.json5      # 应用全局配置├── entry/             # 主模块（默认Module name）│   ├── src/│   │   ├── main/│   │   │   ├── ets/           # ArkTS源码│   │   │   │   ├── entryability/  # 应用入口│   │   │   │   └── pages/      # 页面文件│   │   │   ├── resources/      # 资源文件│   │   │   └── module.json5    # 模块配置文件│   │   └── ohosTest/          # 测试代码│   ├── build-profile.json5    # 模块构建配置│   └── oh-package.json5       # 依赖管理└── build-profile.json5        # 工程级构建配置
```

Plain Text

### 5. **重要配置文件说明**

#### **module.json5 - 模块配置**

```
{  "module": {    "name": "entry",                    // Module名称    "type": "entry",                    // 模块类型：entry/feature/har/shared    "description": "$string:module_desc",    "mainElement": "EntryAbility",      // 主Ability    "deviceTypes": ["phone", "tablet"], // 支持的设备类型    "deliveryWithInstall": true,    "installationFree": false,    "pages": "$profile:main_pages",    "abilities": [...],    "metadata": [      {        "name": "client_id",           // AGC Client ID配置        "value": "***"      }    ]  }}
```

JSON

#### **app.json5 - 应用全局配置**

```
{  "app": {    "bundleName": "com.example.myapplication",  // 必须与AGC包名一致    "vendor": "example",    "versionCode": 1000000,    "versionName": "1.0.0",    "icon": "$media:app_icon",    "label": "$string:app_name"  }}
```

JSON

### 6. **特殊场景配置**

#### **创建OpenHarmony工程**

如需创建OpenHarmony工程，需修改 build-profile.json5 ：

```
{  "app": {    "products": [{      "name": "default",      "signingConfig": "default",      "compileSdkVersion": "20",        // 改为字符串类型      "compatibleSdkVersion": "20",     // 改为字符串类型      "runtimeOS": "OpenHarmony"        // 关键修改    }]  }}
```

JSON

#### **Native C++工程特殊配置**

如果选择Native C++模板且需要在RK开发板上运行：

```
{  "buildOption": {    "externalNativeOptions": {      "abiFilters": ["armeabi-v7a"]    // RK板需要    }  }}
```

JSON

#### **元服务工程特殊要求**

- Bundle name采用固定格式： com.atomicservice.[appid] 

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/6cb688a941564fce8a77c7955d456c93?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765677843%3B1765706643&q-key-time=1765677843%3B1765706643&q-header-list=&q-url-param-list=&q-signature=123faa43127e4d2da0d83100a5dd156ebb726b88)

- 自动生成，开发者无法手动修改

- Compatible SDK必须选择 5.0.0(12) 或以上版本

### 7. **常见问题与解决方案**

#### **编译报错：设备类型不匹配**

```
错误：The type of target device does not match the device type configured by module: xxx
```

Plain Text

**解决措施**：

1. 确保 module.json5 中 deviceTypes 包含所需设备类型

2. 确保 build-profile.json5 中 targets 下指定的设备类型包含所需类型

3. 检查 hvigorfile.ts 或 hvigorconfig.ts 是否修改了设备类型设置

#### **配置AGC身份信息**

在 module.json5 中添加：

```
"metadata": [  {    "name": "client_id",    "value": "从AGC获取的Client ID"  }]
```

JSON

### 8. **最佳实践建议**

1. **SDK版本选择**：

- 新项目建议选择较新版本（如 6.0.0(20) ）

- 考虑目标用户设备系统版本

- 如需云开发，必须≥ 5.0.0(12) 

2. **设备类型选择**：

- 初始开发可只选 phone 

- 如需多端适配，逐步添加 tablet 、 2in1 等

- PC端适配必须包含 2in1 

3. **Module规划**：

- 简单应用：一个Entry模块即可

- 复杂应用：Entry + 多个Feature模块

- 代码复用：创建Library模块（HAR/HSP）

4. **工程同步**：

- 配置修改后点击 **Sync Now**

- 如提示设备类型变更，点击 **Yes** 确认

通过以上步骤，您可以顺利完成HarmonyOS项目的创建和基础配置。根据您的具体应用场景选择合适的SDK版本和设备类型，是项目成功的关键第一步。

# 创建模拟器

更新时间: 2025-12-12 10:48

## 操作步骤

1. 点击菜单栏的**Tools > Device Manager**，点击右下角的**Edit**设置模拟器实例的存储路径**Local Emulator Location**，Mac默认存储在~/.Huawei/Emulator/deployed下，Windows默认存储在C:\Users\xxx\AppData\Local\Huawei\Emulator\deployed下。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/35ee78dc177d4b7996514109f99bac24?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=cc360ee6f6effef855400288825df9735d01eaa4)

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/8fc1f144c95d4c9981a8a02936b572af?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=de67e15fd1bc36678a28cb2dd819facfd2ef06fd)

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/28f31f77e64c40bca7c87f446dd59344?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=c4ba08bd2091b641dc922e61e7d39fdc16fe139d)

2. 在**Local Emulator**页签中，单击右下角的**New Emulator**按钮，创建一个模拟器。在模拟器配置界面，可以选择一个默认的设备模板，首次使用时请点击设备右侧的下载模拟器镜像，您也可以在该界面更新或删除不同设备的模拟器镜像。单击**Edit**可以设置镜像文件的存储路径。macOS默认存储在~/Library/Huawei/Sdk下，Windows默认存储在C:\Users\xxx\AppData\Local\Huawei\Sdk下。**说明**如果配置界面显示异常，例如设备列表为空等，可先关闭DevEco Studio，并清理~/Library/Huawei（Windows路径为C:\Users\xxx\AppData\Local\Huawei）路径下对应DevEco Studio版本的缓存。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/544ef58256714a93a3f32b36ba37aba5?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=99b9f1ad9864fff54b91b999a221bad19f2a477b)

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/be5dbf8287a34c4ba6aa9aa5055b7a88?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=be4bb8efe14b8f1ae147ed896cee3c335c8e338b)

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/f8b96c65f72a4b51b6c142e7f39ea46f?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=ec4fbb9f458c3c70f1be6b5cbed98be0e1a96e14)

3. 单击**Next**，设置设备相关的参数。该功能从DevEco Studio 6.0.0 Beta1版本开始支持。

- **Name**：设置模拟器的名称。

- **Screen Profile**：模拟器屏幕配置参数，可点击下拉框选择预置的机型配置，也可点击**Customize**自定义配置，在自定义配置的情况下可以对屏幕尺寸、分辨率和DPI进行修改，取值范围参考界面提示。

- **Screen size：**屏幕的对角线长度，单位为英寸。

- **Resolution**：分辨率，包括横向像素数量和纵向像素数量。

- **DPI**：像素密度，DPI 越高，UI组件占用的像素点越多，从而提供更精细的显示效果。

- **Memory**：设置模拟器的内存。

- **Storage**：设置模拟器的存储空间。

确认所有参数后，点击**Finish**创建模拟器。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/8a2115e6a0df41fead60b35fdb84db55?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=a9c46c05e8af5f30e5976dadc43ca183fbb4a4bb)

1. 在设备管理器页面，单击

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/66ecd72645af4f54980dad68ae819784?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=2f6e81fbab1ba095b85981abfaa00db6e2426006)

启动模拟器。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/35e8f081f423483b8a794076ca71c74e?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=cf147d77bcf84c2b5552582103c5c0784144095e)

2. 单击DevEco Studio的**Run > Run'模块名称'**或

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/5d190f8190e14afa95adc1e52f2fb631?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=a1f447d357303da294631977a8355d807497b745)

。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/d16c0c773df146ab8eae21160dd84b14?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=e3bc55c72fd2dda8af71d7afa6292b31b0da4595)

3. DevEco Studio会启动应用/元服务的编译构建与推包，完成后应用/元服务即可运行在模拟器上。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/c372ebf6130d469b94bf0121a0799a4a?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765678094%3B1765706894&q-key-time=1765678094%3B1765706894&q-header-list=&q-url-param-list=&q-signature=5df423ef20541b98288acc5f716077645bbe3739)

 [**管理模拟器**](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-management)  好的，根据您提供的文档内容，我将为您详细解释端云一体化开发工程与传统工程的不同之处，并提供一份详细的图文版开发过程指南。

# 📦 端云一体化开发工程详解与图文开发指南

## 一、 端云一体化开发工程与传统工程的核心区别

端云一体化开发工程是DevEco Studio中一种**集成云端服务**的特殊工程类型，它与传统的纯端侧HarmonyOS应用工程有本质区别。

|对比维度|**传统HarmonyOS应用工程**|**端云一体化开发工程**|
|---|---|---|
|**工程结构**|仅包含端侧工程 ( Application )。|包含**端侧工程 (** **Application** **)** 和**云侧工程 (** **CloudProgram** **)** 两个并列目录。|
|**开发工具**|仅需DevEco Studio进行端侧开发。|**一套DevEco Studio** 即可完成**端侧和云侧**的协同开发、调试与部署。|
|**技术栈与技能**|端侧开发人员需掌握ArkTS/ArkUI等端侧技术。|端侧开发人员依托**Cloud Foundation Kit**，使用**统一的ArkTS技术栈**即可开发云函数、云对象等云侧服务，降低了全栈开发门槛。|
|**服务器与运维**|需要开发者自行搭建、配置和维护后端服务器、数据库等基础设施。|**无需管理服务器**。云侧服务（云函数、云数据库、云存储）由华为AGC平台提供，具备**开箱即用、一键部署、自动弹性伸缩、免运维**的特点。|
|**开发流程**|端侧与云侧分离开发，沟通成本高，部署流程复杂。|**端云协同开发**：在DevEco Studio内即可完成云侧代码开发、调试，并**一键部署至AGC云端**，端侧代码可直接调用。|
|**工程模板**|选择  Empty Ability  等标准模板。|选择带有  [CloudDev]  前缀的模板，如  [CloudDev]Empty Ability 。|
|**签名方式**|支持自动签名和手动签名。|**当前仅支持手动签名**。|
|**运行调试**|支持模拟器和真机。|**仅支持真机**，不支持模拟器运行调试。|
|**服务地域**|无限制。|当前云服务**仅在中国境内**（不含港澳台）提供。|

**总结**：端云一体化开发工程的最大不同在于**将云服务的开发、部署和调用深度集成到了DevEco Studio IDE和开发流程中**，实现了前端开发者向全栈开发者的平滑过渡，极大提升了开发效率并降低了运维成本。

---

## 二、 端云一体化开发详细图文过程

以下流程基于文档《文档导览.pdf》、《创建HarmonyOS应用工程_acfec549.pdf》等综合整理。

### **第一阶段：准备阶段**

#### **步骤1：注册与认证**

1. 注册**华为开发者账号**。

2. 完成**实名认证**（企业或个人）。

3. 确保账号**无欠费**，否则可能影响云服务开通。

#### **步骤2：搭建开发环境**

1. **安装DevEco Studio**：必须使用 **NEXT Developer Beta1 或更高版本**。

2. **配置网络**：如果网络需要代理才能访问外网，请提前在DevEco Studio中**配置NPM代理**，否则工程初始化时下载依赖会失败。

### **第二阶段：创建端云一体化工程**

#### **步骤1：启动工程创建向导**

- **首次打开**：在欢迎页点击  **Create Project** 。

- **已有工程**：菜单栏选择  **File > New > Create Project** 。

创建工程入口

#### **步骤2：选择云开发模板**

在  Choose Your Ability Template  界面：

1. 选择  Application （应用）或  Atomic Service （元服务）。

2. 在模板列表中，**必须选择带有**  **[CloudDev]**  **标识的模板**，例如  [CloudDev]Empty Ability 。

> **说明**： [CloudDev]Empty Ability  是通用云开发模板，预置了云函数、云数据库、云存储的演示代码。

选择云开发模板

#### **步骤3：配置工程信息**

在  Configure Your Project  界面，填写关键信息：

|配置项|说明与要求|
|---|---|
|**Project name**|工程名称，字母、数字、下划线组成。|
|**Bundle name**|**应用包名，必须与在AGC（AppGallery Connect）创建的应用包名完全一致**。|
|**Save location**|工程保存路径，**不能包含中文字符**。|
|**Compatible SDK**|**必须选择 5.0.0(12) 或更高版本**，否则无法使用端云一体化功能。|
|**Module name**|模块名，默认  entry 。|
|**Device type**|目前**仅支持手机 (Phone)**。|
|**Enable CloudDev**|**必须勾选**（云开发模板默认已勾选且不可更改）。|

配置工程信息

#### **步骤4：关联云开发资源**

点击  Next  后，进入  Associate Your CloudDev Resources  界面。

1. 选择您的华为开发者账号和团队。

2. 选择或创建AGC项目。

3. **仔细阅读并勾选同意相关服务协议**（只有账号持有者或法务角色有权限签署）。

4. 点击  Finish 。

关联云资源

#### **步骤5：工程初始化**

1. DevEco Studio会自动执行工程同步。

2. **端侧工程**会自动执行  ohpm install  下载ArkTS依赖。

3. **云侧工程**会自动执行  npm install  下载Node.js依赖。

> **注意**：如果云侧  npm install  失败，请检查网络或NPM代理配置。

4. DevEco Studio会**自动为您在AGC关联的项目中开通云函数、云数据库、云存储服务**。开通状态可在  Notifications  窗口查看。

> **注意**：如果云存储服务开通失败，可能是账户欠费，需在AGC控制台手动开通。

### **第三阶段：工程结构与开发**

#### **工程目录结构**

创建完成后，工程包含两个核心部分：

```
MyCloudApp/                      # 工程根目录├── Application/                 # 【端侧工程】开发HarmonyOS应用/元服务界面和业务逻辑│   ├── entry/                   # 主模块│   │   └── src/main/ets/│   │       ├── pages/           # 页面文件，模板预置了云函数、数据库、存储的示例页面│   │       └── entryability/    # 应用入口│   └── cloud_objects/          # （可选）存放从云对象生成的端侧调用接口类└── CloudProgram/                # 【云侧工程】开发云端服务    ├── cloudfunctions/          # 云函数和云对象目录    │   └── id-generator/        # 示例云函数/对象    └── clouddb/                 # 云数据库目录        ├── objecttype/          # 对象类型定义        └── dataentry/           # 数据条目
```

Plain Text

#### **步骤6：开发云侧工程**

云侧工程支持开发三种核心服务：

1. **开发云函数/云对象**

- 在  CloudProgram/cloudfunctions/  下创建新的云函数或云对象。

- 编写业务逻辑代码（使用JavaScript/TypeScript）。

- 在DevEco Studio内进行**本地调试**。

- **部署到AGC**：右击云函数/对象，选择  Deploy 。

2. **开发云数据库**

- 在  CloudProgram/clouddb/objecttype/  下定义对象类型（数据表结构）。

- 在  CloudProgram/clouddb/dataentry/  下添加示例数据。

- 将数据库结构**部署到AGC**。

> **最佳实践建议**：虽然端云代码可并行开发，但若端侧需要调用云侧代码，**建议先完成云侧代码的开发、调试与部署**，再开发端侧。

#### **步骤7：开发端侧工程**

端侧工程在  Application  目录下开发，主要工作是调用已部署的云服务。

1. **调用云函数**：

```
import { cloudFunction } from '@kit.CloudFoundationKit';cloudFunction.call({ name: '你的云函数名' })  .then((res) => { /* 处理结果 */ })  .catch((err) => { /* 处理错误 */ });
```

TypeScript

2. **调用云对象**：

- 首先，在云侧工程右击云对象，选择  Generate Invoke Interface ，生成端侧调用接口类（位于  Application/cloud_objects/ ）。

- 在端侧代码中导入并调用该对象的方法。

3. **访问云数据库**：

- 首先，为云数据库对象类型**生成Client Model**（端侧数据模型）。

- 在端侧代码中引入Client Model，使用Cloud Foundation Kit API进行增删改查。

4. **调用云存储**：

- 初始化云存储实例。

- 使用  uploadFile ,  downloadFile  等接口进行文件操作。

通用模板 ( [CloudDev]Empty Ability ) 已在  entry/src/main/ets/pages/  下提供了上述四种调用的示例代码 ( CloudFunction.ets ,  CloudDb.ets ,  CloudStorage.ets )，可供参考。

#### **步骤8：配置云存储安全策略（重要！）**

由于模板初始化代码未配置AccessToken，**必须手动配置云存储安全策略为“始终可读写”**，否则文件上传会失败。

1. 登录 **AppGallery Connect**。

2. 进入您的项目，选择  **云开发(Serverless) > 云存储** 。

3. 进入  **安全**  页签。

4. 在“配置策略”中，将默认规则修改为：

```
allow read, write: if true;
```

Plain Text

5. 点击  **发布** 。

配置云存储策略

### **第四阶段：调试与发布**

#### **步骤9：本地调试**

1. 使用 **USB连接真机**（端云一体化开发不支持模拟器）。

2. 在DevEco Studio中点击运行按钮，将应用安装到手机。

3. 在手机上体验端云交互功能，查看运行效果和日志。

#### **步骤10：打包与发布**

1. 完成所有开发后，对工程进行**手动签名**（配置发布证书和Profile文件）。

2. 将签名的HAP/HAPP包**提交至AGC**，申请上架到华为应用市场。

---

## 三、 关键注意事项与常见问题

1. **设备与地域限制**：目前仅支持**手机设备**，且云服务仅在中国大陆可用。

2. **签名方式**：**仅支持手动签名**，不支持自动签名。

3. **目录结构**：工程根目录下**只能有**  **Application**  **和**  **CloudProgram**  **两个文件夹**，否则DevEco Studio可能无法识别为端云一体化工程。

4. **云数据库限制**：

- AGC云端**存储区(Zone)数量不得超过4个**。

- 已部署的数据库字段**不能修改**，如需修改需删除后重新创建。

![](https://ima-notebook-prod.image.myqcloud.com/2/bHkNGeYDapykL9V0ON6P2D/c4f55c59c9ca4104b6fc1322b3c56bf3?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1765679148%3B1765707948&q-key-time=1765679148%3B1765707948&q-header-list=&q-url-param-list=&q-signature=ab823b7a75a41d63099c2f2498e17586e5645852)

5. **历史工程转换**：可以将已有的非端云工程转换为端云一体化工程，方法是创建一个同Bundle name的端云工程，然后用历史工程的  Application  目录替换新工程的  Application  目录。

通过以上步骤，您就可以完成一个完整的端云一体化HarmonyOS应用的开发、调试和发布准备。这种模式极大地简化了云端开发的复杂性，让开发者可以更专注于业务逻辑创新。
[开发](https://lbs.amap.com/api)  HarmonyOS NEXT 地图SDK  开发指南  在地图上绘制  绘制点标记

# 绘制点标记最后更新时间: 2025年11月17日

点标记用来在地图上标记任何位置，例如用户位置、车辆位置、店铺位置等一切带有位置属性的事物。

## 绘制默认 Marker

绘制 Marker 的代码如下

```
let options: MarkerOptions = new MarkerOptions();
options.setPosition(new LatLng(39.992520, 116.336170));
let marker = aMap.addMarker(options);
```

![](https://a.amap.com/lbs/static/img/doc/doc_1712734659242_e8448.png)

#### Marker 常用属性

|   |   |
|---|---|
|名称|说明|
|setPosition /getPosition|设置/获取标记位置在地图上的经纬度值|
|setTitle /getTitle|设置/获取标记的标题|
|setSnippet/getSnippet|设置/获取标记的文字描述|
|setDraggable/getDraggable|设置/获取标记是否可拖拽|
|setVisible/getVisible|设置/获取点标记是否可见|
|setAnchor|设置标记的锚点比例。锚点标记图标接触地图平面的点。图标的左顶点为（0,0）点，右底点为（1,1）点，默认为（0.5,1.0）|

## 绘制自定义 Marker

可根据实际的业务需求，在地图指定的位置上添加自定义的 Marker。MarkerOptions 是设置 Marker 参数变量的类，自定义 Marker 时会经常用到。

下面以自定义 Marker 图标为例进行代码说明：

```
// add Marker
let options: MarkerOptions = new MarkerOptions();
let bitmapDes = await BitmapDescriptorFactory.fromRawfilePath(globalContext, "location_map_gps_locked.png");
if (bitmapDes) {
  options.setIcon(bitmapDes);
}
options.setTitle('标记'); //设置标记的标题
options.setSnippet('详细信息') //设置标记的文字描述
options.setPosition(new LatLng(39.992520, 116.336170));
let marker1 = this.aMap?.addMarker(options);
```

提示

设置 Marker 的图标时，相同图案 icon 的 Marker 最好使用同一个BitmapDescriptor对象以节省内存空间，

## 绘制多个 Marker

```
let options1: MarkerOptions = new MarkerOptions().setPosition(new LatLng(39.992520, 116.336170)).setIcon(new BitmapDescriptor($rawfile('location_map_gps_locked.png'), 'location_map_gps_locked', 100, 100));
let options2: MarkerOptions = new MarkerOptions().setPosition(new LatLng(40.02380181476392, 116.43124537956452)).setIcon(new BitmapDescriptor($rawfile('location_map_gps_locked.png'), 'location_map_gps_locked', 100, 100));
let markerOptionsList: ArrayList<MarkerOptions> = new ArrayList<MarkerOptions>()
markerOptionsList.add(options1);
markerOptionsList.add(options2);
let markers = aMap.addMarkers(markerOptionsList, false);
```

## 绘制动画效果 Marker

自地图 SDK V2.2.4 版本起，SDK 提供了给 Marker 设置动画的方法，具体实现方法如下：

```
let animation: Animation = new ScaleAnimation(0, 1, 0, 1);
const linearCurve: ICurve = { interpolate: (interpolate: number) => interpolate };
animation.setInterpolator(linearCurve);
//整个移动所需要的时间
animation.setDuration(1000);
//设置动画
this.growMarker.setAnimation(animation);
//开始动画
this.growMarker.startAnimation();
```

## 移除 Marker

```
aMap.removeOverlay(marker.getId());
```

## 可触发的 Marker 事件

#### Marker 点击事件

```
aMap.setOnMarkerClickListener((marker: Marker): boolean => {
  // marker 被点击的 marker 对象
  // 返回true表示已处理点击事件，不再继续传递；返回false则继续传递
  console.log(marker.getId());
  return true
})
```

#### Marker 拖拽事件

```
//当 marker 开始被拖动时回调此方法, 这个 marker 的位置可以通过 getPosition() 方法返回。
// 这个位置可能与拖动的之前的 marker 位置不一样。
// marker 被拖动的 marker 对象。
const onMarkerDragStart = (marker: Marker): void => {
  // 处理拖动开始
  // marker 被拖动的 marker 对象
  // marker 的位置可以通过 getPosition() 方法返回
}
const onMarkerDrag = (marker: Marker): void => {
  // 处理拖动中
  // marker 被拖动的 marker 对象
  // marker 的位置可以通过 getPosition() 方法返回
}
const onMarkerDragEnd = (marker: Marker): void => {
  // 处理拖动结束
  // marker 被拖动的 marker 对象
  // marker 的位置可以通过 getPosition() 方法返回
}

// marker 拖动事件监听接口实例
const dragListener: OnMarkerDragListener = new OnMarkerDragListener(onMarkerDragStart, onMarkerDrag, onMarkerDragEnd);

//给 aMap 设置标记拖动监听器 
aMap.setOnMarkerDragListener(dragListener)
```

## 关于 InfoWindow 的设置

InfoWindow 是点标记的一部分，默认的 Infowindow 只显示 Marker 对象的两个属性，一个是 title 和另一个 snippet。

![](https://a.amap.com/lbs/static/img/doc/doc_1712735251437_174a9.png)

#### 常用属性

|   |   |   |
|---|---|---|
|名称|参数类型|说明|
|setInfoWindowEnable(enabled)|boolean|设置 Marker 覆盖物的 InfoWindow 是否允许显示,默认为 true<br><br>true：允许显示,false：不允许显示|
|setInfoWindowOffset(offsetX, offsetY)|number|设置 Marker 覆盖物的 InfoWindow 相对 Marker 的偏移<br><br>offsetX：InfoWindow 相对原点的横向像素偏移量，单位：像素<br><br>offsetY：InfoWindow 相对原点的纵向像素偏移量，单位：像素|
|autoOverturnInfoWindow(autoOverturn)|boolean|设置Marker覆盖物的InfoWindow是否自动旋转<br><br>true：表示自动翻转,false：表示不自动翻转|
|showInfoWindow()||显示 InfoWindow|
|hideInfoWindow()||隐藏 InfoWindow|
# 绘制线最后更新时间: 2025年11月04日

地图上绘制的线是由 Polyline 类定义实现的，线由一组经纬度（LatLng 对象）点连接而成。

## 绘制一条线

与点标记一样，Polyline 的属性操作集中在 PolylineOptions 类中，添加一条线的示例如下：

```
let options: PolylineOptions = new PolylineOptions();
options.add(new LatLng(39.925539, 116.279037)); //追加一个点到线段的坐标集合
options.add(new LatLng(39.925539, 116.520285));
aMap.addPolyline(options);
```

也可以使用addAll方法追加一批点到线段的坐标集合

```
let options: PolylineOptions = new PolylineOptions();
let polylineOptionsList :ArrayList<LatLng> = new ArrayList<LatLng>()
polylineOptionsList.add(new LatLng(39.925539, 116.279037))
polylineOptionsList.add(new LatLng(39.925539, 116.520285))
options.addAll(polylineOptionsList)
aMap?.addPolyline(options);
```

![](https://a.amap.com/lbs/static/img/doc/doc_1712735500736_12bbe.png)

## 绘制虚线

示例如下

```
let options: PolylineOptions = new PolylineOptions();
options.add(new LatLng(39.925539, 116.279037));
options.add(new LatLng(39.925539, 116.520285));
aMap.addPolyline(options.setDottedLine(true).setColor(1125058090).setWidth(20));
```

![](https://a.amap.com/lbs/static/img/doc/doc_1712735519329_8ec87.png)

## 绘制线常用方法

|   |   |
|---|---|
|名称|说明|
|setColor|设置线段的颜色，需要传入32位的 ARGB 格式。默认：黑色( 0xff000000)|
|setDottedLine|设置是否画虚线，默认：false（画实线）画实线|
|setLineCapType|设置 Polyline 尾部形状|
|setLineJoinType|设置 Polyline 连接处形状|
|setTransparency|设置线段的透明度 0~1，默认：1（表示不透明）表示不透明|
|setVisible|设置线段的可见性。默认：可见|
|setWidth|设置线段的宽度，默认：10|
|setZIndex|设置线段Z轴的值|
|setGeodesic|设置线段是否为大地曲线，默认：false（不画大地曲线）|
# 绘制弧线最后更新时间: 2025年10月10日

地图上绘制的线是由 Arc 类定义实现的，线由一组三个经纬度坐标（LatLng对象）点连接而成圆弧。

## 第一步，绘制弧线

```
let x = 39.904979;
let y = 116.40964;
// 绘制一个经过乌鲁木齐经过北京到哈尔滨弧形
for (let i = 0; i < 10; i++) {
  let x_ = 0;
  let y_ = 0;
  x_ = Math.random() * 0.5 - 0.25;
  y_ = Math.random() * 0.5 - 0.25;
  let x_2 = 0;
  let y_2 = 0;
  x_2 = Math.random() * 0.5 - 0.25;
  y_2 = Math.random() * 0.5 - 0.25;
  let x_3 = 0;
  let y_3 = 0;
  x_3 = Math.random() * 0.5 - 0.25;
  y_3 = Math.random() * 0.5 - 0.25;
  // 数据准备
  let arcOptions: ArcOptions = new ArcOptions().point(
    new LatLng(x+x_, y+y_), new LatLng(x+x_3,y+y_3),
    new LatLng(x+x_2, y+y_2)).setStrokeColor(ColorUtil.colorStringToNumber("#ff0000"))
  // 绘制弧线并保存句柄
  this.arcList.push(this.aMap.addArc(arcOptions));
}
```

## 第二步，修改弧线属性

HeatmapTileProvider 是生成热力图的核心类，一些基础用法可参考如下代码：

```
// 通过句柄修改弧线的属性
this.arcList.forEach((item: Arc | undefined) =>{
  const colorNow = item?.getStrokeColor()
  if(colorNow == ColorUtil.colorStringToNumber('#00ff00')){
    item?.setStrokeColor(ColorUtil.colorStringToNumber('#ff0000'))
  }else{
    item?.setStrokeColor(ColorUtil.colorStringToNumber('#00ff00'))
  }
})
```

效果图如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1758608086230_8266e.png)
# 绘制面最后更新时间: 2025年11月04日

地图上的面分为圆形和多边形两种

## 绘制圆

圆形由 Circle 类定义实现，构造一个圆形需要确定它的圆心和半径，具体的示例代码如下：

```
let circleOptions: CircleOptions = new CircleOptions();
    circleOptions.setRadius(15000); //设置圆的半径，单位:米
    circleOptions.setCenter(new LatLng(39.996441, 116.411146)); //设置圆心经纬度坐标
    circleOptions.setFillColor(0xffff0000); //设置圆的填充颜色
    circleOptions.setStrokeColor(0xff00ff00); //设置圆的边框颜色

    let circleHoleOptions: CircleHoleOptions = new CircleHoleOptions();
    circleHoleOptions.setRadius(5000);
    circleHoleOptions.setCenter(new LatLng(39.996441, 116.411146));
    circleOptions.addHoles(circleHoleOptions); //添加空心洞的配置项
    aMap.addCircle(circleOptions)
```

![](https://a.amap.com/lbs/static/img/doc/doc_1712735656407_edcf9.png)

## 绘制多边形

多边形是由 Polygon 类定义的一组在地图上的封闭线段组成的图形，它由一组 LatLng 点按照传入顺序连接而成的封闭图形。与绘制线类似，面的属性操作集中在 PolygonOptions 中。

```
let polygonOptions: PolygonOptions = new PolygonOptions();
polygonOptions.add(new LatLng(39.781892, 116.293413));
polygonOptions.add(new LatLng(39.787600, 116.391842));
polygonOptions.add(new LatLng(39.733187, 116.417932));
polygonOptions.add(new LatLng(39.704653, 116.338255));
polygonOptions.setFillColor(0xFFFF0000);

let polygonHoleOptions: PolygonHoleOptions = new PolygonHoleOptions;
polygonHoleOptions.add(new LatLng(39.781892 - 0.02, 116.293413 + 0.02));
polygonHoleOptions.add(new LatLng(39.787600 - 0.02, 116.391842 - 0.02));
polygonHoleOptions.add(new LatLng(39.733187 + 0.02, 116.417932 - 0.02));
polygonHoleOptions.add(new LatLng(39.704653 + 0.02, 116.338255 + 0.02));
let list: ArrayList<PolygonHoleOptions> = new ArrayList();
list.add(polygonHoleOptions);
polygonOptions.setHoleOptions(list);
aMap.addPolygon(polygonOptions);
```

![](https://a.amap.com/lbs/static/img/doc/doc_1712735831426_97f74.png)
# 绘制图片图层最后更新时间: 2025年09月29日

## 简介

定义在地图上绘制一个 Ground 覆盖物（一张图片以合适的大小贴在地图上的图片层）

- 位置： 可以通过设置中心点或者图片区域来确定图片层的位置。
    
- 图片： 覆盖物的贴图。
    
- 角度： 图片从正北开始，顺时针方向旋转，中心点为锚点。
    
- Z轴 ： Z轴是控制地图覆盖物（overlay）之间的绘制层次的参数。这个参数能够控制Circles、Polygons、Polyline的绘制层次，但不会影响marker。Z轴数值越大的覆盖物（overlay）将会绘制在更上层。如果两个及两个以上覆盖物（overlay）的Z轴数值相同，则最后的绘制结果是随机的 。覆盖物（overlay）的默认为Z轴为0。
    
- 可见：这个属性表示了覆盖物是否可以显示在地图上。默认为可见。
    

![](https://a.amap.com/lbs/static/img/doc/doc_1758607654947_83b50.jpeg)

## 展示Ground覆盖物

#### 第1步 设置覆盖物属性

```
let options: GroundOverlayOptions = new GroundOverlayOptions();

let texture = await BitmapDescriptorFactory.fromRawfilePath(globalContext, 'groundoverlay.png');

if (texture) {
  options.image(texture); // 设置图片
}
options.position(new LatLng(39.936713,116.386475), 1); // 根据位置和宽设置ground覆盖物
let southwest: LatLng = new LatLng(39.935029, 116.384377)
let northeast: LatLng = new LatLng(39.939577, 116.388331)
let bounds: LatLngBounds = new LatLngBounds(southwest, northeast)
options.positionFromBounds(bounds); // 根据矩形区域设置ground覆盖物的位置
options
  .anchor(0.5, 0.5) // 设置图片的对齐方式
  .setTransparency(0.7) // 设置ground覆盖物的透明度
```

#### 第2步 添加覆盖物

```
// 添加一个groundOverlay
aMap.addGroundOverlay(options);
```

## 绘制Ground覆盖物常用方法

|   |   |
|---|---|
|名称|说明|
|anchor(anchorU: number, anchorV: number)|设置图片的对齐方式|
|position(location: LatLng \| undefined, width: number, height?: number)|根据位置和宽高设置ground覆盖物|
|positionFromBounds(paramLatLngBounds: LatLngBounds)|根据矩形区域设置ground覆盖物的位置|
|setBearing(bearing: number)|设置ground覆盖物从正北顺时针的角度|
|setZIndex(zIndex: number)|设置ground覆盖物的z轴指数|
|visible(visible: boolean)|设置ground覆盖物是否可见|
|setTransparency(transparency: number)|设置ground覆盖物的透明度|
# 绘制海量点图层最后更新时间: 2025年09月29日

在地图上加载显示海量点，支持高达十万级点位的流畅显示。

## 第 1 步：初始化 MapView 并获取 AMap 实例

通过 MapViewComponent 创建地图视图，并在回调中获取底层 AMap 对象，用于后续操作。

```
@Builder
buildMapMultiPointOverlay() {
  Stack() {
    MapViewComponent({ mapViewName: Constants.MAP_MULTIPOINTOVERLAY_FUNC })
  }
  .width('100%')
  .height('100%')
}

private mapViewCreateCallback = (mapview?: MapView, mapViewName?: string) => {
  if (!mapview || mapViewName !== Constants.MAP_MULTIPOINTOVERLAY_FUNC) return;

  this.mapView = mapview;
  this.mapView.onCreate();

  this.mapView.getMapAsync(async (map: AMap) => {
    this.aMap = map;
    await this.setupMultiPointOverlay(); 
  });
};
```

## 第 2 步：准备点位数据源

支持两种方式加载点位数据：

#### 方式一：从本地文件加载（推荐用于真实数据）

将经纬度数据以 CSV 格式保存在 resources/rawfile/point10w.txt 文件中，每行格式为：

经度,纬度 116.397026,39.90976 116.401,39.912 ...

```
private async loadPointItemsFromFile(): Promise<MultiPointItem[]>
```

#### 方式二：动态生成测试数据（用于调试）

可生成指定数量的随机点，中心坐标为中国北京附近。

```
const testPoints = this.generateTestPoints(10000);
```

## 第 3 步：创建 MultiPointOverlay 图层

配置 MultiPointOverlayOptions，设置图标、锚点及初始点集。

```
const overlayOptions = new MultiPointOverlayOptions();
overlayOptions.icon(bitmapDescriptor);        // 设置点图标
overlayOptions.anchor(0.5, 0.5);              // 图标中心对齐
overlayOptions.setMultiPointItems([]);        // 初始为空数组
this.multiPointOverlay = this.aMap.addMultiPointOverlay(overlayOptions);
```

其中：

|   |   |
|---|---|
|参数|说明|
|icon(BitmapDescriptor)|点的显示图标，建议尺寸较小以提升性能|
|anchor(x, y)|图标锚点位置，(0.5, 0.5) 表示居中对齐|
|setMultiPointItems(items)|设置要渲染的点列表|

## 第 4 步：加载并渲染点数据

调用 loadAndRenderPoints() 方法异步加载文件中的点数据，并更新到 MultiPointOverlay。

流程如下：

1. 读取 rawfile/point10w.txt 文件内容；
    
2. 解析每一行为 LatLng 坐标；
    
3. 构造 MultiPointItem 并绑定自定义数据；
    
4. 保存至 this.allPointItems（用于点击检测）；
    
5. 调用 multiPointOverlay.setItems(items) 更新视图；
    
6. 启用图层 .setEnable(true)。
    

## 第 5 步：实现地图点击交互

监听地图点击事件，在所有点中查找距离最近的一个，并用红色 Marker 高亮显示。

```
this.aMap.setOnMapClickListener(async (latLng: LatLng) => {
  let closestItem: MultiPointItem | null = null;
  let minDistSq = 0.1; // 阈值

  for (const item of this.allPointItems) {
    const dLat = item.getLatLng().latitude - latLng.latitude;
    const dLon = item.getLatLng().longitude - latLng.longitude;
    const distSq = dLat * dLat + dLon * dLon;
    if (distSq < minDistSq) {
      minDistSq = distSq;
      closestItem = item;
    }
  }

  if (closestItem) {
    // 显示/移动红色 Marker
    if (!this.marker) {
      const redIcon = await BitmapDescriptorFactory.defaultMarkerASync(globalContext, BitmapDescriptorFactory.HUE_RED);
      const options = new MarkerOptions();
      options.setIcon(redIcon);
      this.marker = this.aMap?.addMarker(options);
    }
    this.marker.setPosition(closestItem.getLatLng());
    this.marker.setZIndex(1000); // 置顶显示
  }
});
```

## 其他：生命周期管理

在页面销毁时释放资源：

```
aboutToDisappear(): void {
  this.isDestroy = true;
  MapViewManager.getInstance().unregisterMapViewCreatedCallback(this.mapViewCreateCallback);
  if (this.mapView) {
    this.mapView.onDestroy();
    this.mapView = undefined;
    this.aMap = undefined;
  }
}
```

![](https://a.amap.com/lbs/static/img/doc/doc_1758607787480_fb5c8.png)
# 点平滑移动最后更新时间: 2025年09月29日

功能说明：根据输入的关键点和时间参数，实现点的平滑移动效果。

使用场景：可应用到展示车辆行驶轨迹、用户移动轨迹等场景。

效果示例：

![](https://a.amap.com/lbs/static/img/doc/doc_1758607919295_18284.jpeg)

#### 如何实现点平滑移动

MovingPointOverlay 代码位置：

src/main/ets/com/amap/api/utils/overlay/MovingPointOverlay.ets

#### 相关接口

- 设置平滑移动的经纬度数组：public setPoints(List points):void
    
- 设置平滑移动的总时间：public setTotalDuration(int duration):void
    
- 设置移动Marker的图标 ：public setDescriptor(BitmapDescriptor descriptor):void
    
- 开始平滑移动 ：public startSmoothMove():void
    
- 停止平滑移动 ：public stopMove():void
    

代码调用示例:

```
// 读取轨迹点
    let points:ArrayList<LatLng> = this.readLatLngs();

    // 实例 MovingPointOverlay 对象
    if(this.smoothMarker == null && this.mAMap) {
      // 设置 平滑移动的 图标
      let descriptor = BitmapDescriptorFactory.fromRawfilePathSync(this.context,"icon_car.png")
      if(descriptor){
        this.marker = this.mAMap.addMarker(new MarkerOptions().setIcon(descriptor).setAnchor(0.5,0.5));
        if(this.marker)
          this.smoothMarker = new MovingPointOverlay(this.mAMap, this.marker);
      }
    }

    // 取轨迹点的第一个点 作为 平滑移动的启动
    let drivePoint:LatLng = points[0];
    let pair = SpatialRelationUtil.calShortestDistanceLatLng(points, drivePoint);
    if(pair && pair[0])
      points[pair[0]]=drivePoint;
    let subList = points.subArrayList(pair?.[0], points.length);

    // 设置轨迹点
    this.smoothMarker?.setPoints(subList);
    // 设置平滑移动的总时间  单位  秒
    this.smoothMarker?.setTotalDuration(40);
    this.smoothMarker?.startSmoothMove();
```
# 绘制热力图最后更新时间: 2025年11月17日

## 绘制热力图

热力图功能提供将业务数据展示在地图上，可以给使用者直观描述一个区域的人员，车辆等事物的热度情况。

#### 第一步，组织热力图数据

以下以本地模拟数据为例，简单说明 SDK 热力图需要的是经纬度点数组/列表数据。

示例代码如下：

```
// 第一步： 生成热力点坐标列表
let latlngs: LatLng[] = [];
let x = 39.904979;
let y = 116.40964;

for (let i = 0; i < 1; i++) {
  let x_ = 0;
  let y_ = 0;
  x_ = Math.random() * 0.5 - 0.25;
  y_ = Math.random() * 0.5 - 0.25;
  latlngs.push(new LatLng(x + x_, y + y_))
}
```

#### 第二步，构建热力图 HeatmapTileProvider

HeatmapTileProvider 是生成热力图的核心类，一些基础用法可参考如下代码：

```
// 第二步： 构建热力图 TileProvider
let builder: HeatMapBuilder = new HeatMapBuilder();
builder.setData(latlngs);
// 设置热力图绘制的数据
builder.setGradient(HeatMapController.ALT_HEATMAP_GRADIENT); // 设置热力图渐变，有默认值 DEFAULT_GRADIENT，可不设置该接口
// Gradient 的设置可见参考手册
// 构造热力图对象
let heatmapTileProvider: HeatmapTileProvider | undefined = builder.build();
```

#### 第三步，绘制热力图图层

通过 TileOverlay 绘制热力图，方法如下：

```
// 第三步： 构建热力图参数对象
let tileOverlayOptions: TileOverlayOptions = new TileOverlayOptions();
if (heatmapTileProvider) {
  tileOverlayOptions.tileProvider(heatmapTileProvider); // 设置瓦片图层的提供者
}
// 第四步： 添加热力图
this.tileOverlay = this.mAMap?.addTileOverlay(tileOverlayOptions);
```

a

效果图如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1758607988774_09dd8.png)

## 绘制蜂窝热力图

蜂窝热力图功能提供将业务数据展示在地图上，以蜂窝的形式给使用者直观展示热度情况。

#### 第一步，组织蜂窝热力图数据

以下以本地模拟数据为例，简单说明 SDK 热力图需要的是经纬度点数组/列表数据。

示例代码如下：

```
// 第一步： 生成热力点坐标列表，数据格式（119.518251,35.683927,1159）
let heatMapStr = Utils.uint8ArrayToString(HoneycombHeatMapController.readFileContentsFromAssets(getContext(), "heatmap/heatmap_honey.data"));
let heatMapStrs = heatMapStr.split("\n");
let weightlatlngs = new ArrayList<WeightedLatLng>();
for (let str of heatMapStrs) {
  let dataItem = str.split(",");
  if (dataItem && dataItem.length == 3) {
    weightlatlngs.add(new WeightedLatLng(new LatLng(Number.parseFloat(dataItem[1]), Number.parseFloat(dataItem[0])), Number.parseFloat(dataItem[2])))
  }
}
let colors = [
  ColorUtil.colorStringToNumber("#ecda9a"),
  ColorUtil.colorStringToNumber("#efc47e"),
  ColorUtil.colorStringToNumber("#f3ad6a"),
  ColorUtil.colorStringToNumber("#f7945d"),
  ColorUtil.colorStringToNumber("#f97b57"),
  ColorUtil.colorStringToNumber("#f66356"),
  ColorUtil.colorStringToNumber("#ee4d5a")
];
let startPoints = new Array<number>(colors.length);
for(let i = 0;i < startPoints.length; i++) {
  startPoints[i] = i * 1.0 / startPoints.length
}
```

#### 第二步，构建热力图 HeatMapLayerOptions

HeatMapLayerOptions 是生成热力图的核心类，一些基础用法可参考如下代码：

```
// 第二步： 构建蜂窝热力图 HeatMapLayerOptions
let heatMapLayerOptions = new HeatMapLayerOptions();

// 带权重的经纬度
heatMapLayerOptions.weightedData(weightlatlngs);

// 指定颜色和颜色变化索引
let gradient = new Gradient(colors, startPoints);
heatMapLayerOptions.gradient(gradient);
// heatMapLayerOptions.gradient(HeatMapLayerOptions.DEFAULT_GRADIENT);

// 大小和间隔
heatMapLayerOptions.size(6000);
heatMapLayerOptions.gap(300);

// 最大最小缩放级别
heatMapLayerOptions.setMinZoom(5);
heatMapLayerOptions.setMaxZoom(19);

// 整个覆盖物的透明度
heatMapLayerOptions.opacity(0.85);

// 热力图类型为蜂窝
heatMapLayerOptions.setType(HeatMapLayerOptions.TYPE_HEXAGON);

// 控制在底图文字的上面，默认底图文字级别是0
heatMapLayerOptions.setZIndex(1);
```

#### 第三步，绘制蜂窝热力图图层

通过 HeatMapLayerOptions 绘制热力图，方法如下：

```
this.layer = this.mAMap?.addHeatMapLayer(heatMapLayerOptions);
```

#### 第四步，注册地图点击事件，回调位置的热力情况

通过 设置点击事件，获取经纬度信息，通过经纬度获取位置的热力情况，方法如下：

```
// 获取指定位置的热力情况
this.mAMap?.setOnMapClickListener((latLng: LatLng) => {
  if (this.layer && this.mAMap && latLng) {
    let item: HeatMapItem | undefined = this.layer.getHeatMapItem(latLng);
    if (item) {
      let stringBuffer = ""
      stringBuffer += "热力中心："
      stringBuffer += (item.getCenter() + "\n");
      stringBuffer += "热力值："
      stringBuffer +=  (item.getIntensity() + "\n");
      let indexes = "";
      for(let integer of item.getIndexes()) {
        indexes += integer + ",";
      }
      stringBuffer += ("热力索引：" + indexes + "\n");
      stringBuffer += ("数据数量：" + item.getIndexes().length);
      this.updateHeatItemTv(stringBuffer.toString());
    } else {
      this.updateHeatItemTv("未找到热力信息");
    }


  }
})
```

a

效果图如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1763089128689_df426.png)
# 绘制3D模型最后更新时间: 2025年11月17日

```
public async addGL3DModel(): Promise<void> {
    // vertexData string
    let options = new GL3DModelOptions();
    let data = globalContext.resourceManager.getRawFileContentSync('obj/logistic_detail_3d_truck.obj');
    let decoder = util.TextDecoder.create('utf-8');
    let content = decoder.decodeWithStream(new Uint8Array(data));

    options.angle(50)
        .position(new LatLng(39.955436, 116.335769))
        .setAltitude(1000)
        .setFixDisplaySize(100, 100)
        .setFixedDisplaySizeEnabled(true)
        .setModelFixedLength(1000)
        .setVisible(true)
        .setZIndex(5)
            // .setSnippet("gl3dmodel")
            // .setTitle("amap3d")
        .vertexData(content)

    let texture = await BitmapDescriptorFactory.fromRawfilePath(globalContext,
        'obj/babel_order_logistic_detail_3d_truck_transport.png');
    if (texture) {
        options.textureDrawable(texture);
    }

    this.gl3DModel = this.aMap?.addGL3DModel(options);
    this.gl3DModel?.showInfoWindow();
}
```

![](https://a.amap.com/lbs/static/img/doc/doc_1763088367918_883dd.png)
# 轨迹纠偏最后更新时间: 2025年11月17日

轨迹记录、纠偏类需求强烈建议您使用高德开放平台提供的猎鹰SDK或者猎鹰服务API，后续版本的地图SDK会逐步停止轨迹纠偏接口的维护。

## 简介

轨迹纠偏可帮助您将您记录的行车轨迹点进行抽稀、纠偏操作，将轨迹匹配到道路上，提供平滑的绘制效果，并计算行驶里程（地图SDK V2.2.5以上支持）；也可以通过结合高德定位帮助您记录真实行车轨迹（地图SDK V2.2.5版本以上支持）。

值得注意的是，目前该功能只支持将驾车轨迹纠正到路上。

![](https://a.amap.com/lbs/static/img/doc/doc_1763088792929_539f7.png)

## 结合定位轨迹纠偏（自2.2.5版本起支持）

### 第 1 步 初始化LBSTraceClient

开始记录轨迹，每2s记录一次轨迹，每隔5个点合并请求一次纠偏并回调。

```
this.traceClient = LBSTraceClient.getInstance(getContext());
```

### 第 2 步 开启轨迹纠偏

```
this.traceClient.startTrace(this.traceStatusListener);//开始采集,需要传入一个状态回调监听。
```

### 第 3 步 解析返回结果

```
  traceStatusListener: TraceStatusListener = {
     onTraceStatus:(locations?:ArrayList<TraceLocation>,rectifications?:ArrayList<LatLng>,errorInfo?:string)=>{
     //locations 定位得到的轨迹点集，rectifications 纠偏后的点集，errorInfo 轨迹纠偏错误信息
    }
  }
```

### 第 4 步 结束轨迹纠偏

```
this.traceClient.stopTrace()//在不需要轨迹纠偏时（如行程结束），可调用此接口结束纠偏
```

## 自有轨迹纠偏

### 第 1 步，初始化LBSTraceClient

```
this.mTraceClient = new LBSTraceClient(getContext())
```

### 第 2 步，构造轨迹点数据 List

需要按照 TraceLocation 定义好的格式构造轨迹点 List。

TraceLocation 的信息通过下表中的方法设置：

需要您注意的是，

1、必填信息的缺失会导致纠偏失败，非必填信息的缺失会在一定程度影响最终纠偏结果，因此尽可能的多提供以下信息是确保绘制一条平滑轨迹的最佳方案。建议使用HarmonyOS定位SDK中高精度，且有速度和角度返回的位置点数据。

2、传入的经纬度点，必须是国内的坐标，轨迹纠偏功能不支持国外的坐标点的纠偏。

|   |   |   |   |
|---|---|---|---|
|方法名|参数说明|返回值说明|方法效果|
|setLongitude(mLongitude:number)|mLongitude：经度，必填。|void|设置经度。|
|setLatitude(mLatitude:number)|mLatitude：纬度，必填。|void|设置纬度。|
|setSpeed(mSpeed:number)|mSpeed：速度，必填。|void|设置速度。|
|setBearing(mBearing:number)|mBearing：方向角，必填。|void|设置方向角。|
|setTime(mTime:number)|mTime：时间，必填。|void|设置时间。|

### 第 3 步，进行轨迹纠偏

轨迹纠偏支持传入多种坐标系（高德、GPS原始坐标以及百度）的轨迹点数据，并且可支持多条数据同时纠偏。进行轨迹纠偏的方法如下：

|   |   |   |   |
|---|---|---|---|
|方法名|参数说明|返回值说明|方法效果|
|queryProcessedTrace|lineID： 用于标示一条轨迹，支持多轨迹纠偏，如果多条轨迹调起纠偏接口，则lineID需不同。<br><br>locations ： 一条轨迹的点集合。建议为一条行车GPS高精度定位轨迹。<br><br>type： 轨迹坐标系，目前支持高德 LBSTraceClient.TYPE_AMAP;<br><br>GPS LBSTraceClient.TYPE_GPS;百度 LBSTraceClient.TYPE_BAID。<br><br>listener ： 轨迹纠偏回调|void|进行轨迹纠偏，返回纠偏后的轨迹数据。|

```
this.mTraceClient.queryProcessedTrace(this.mSequenceLineID,this.mTraceList,this.mCoordinateType,this.traceListener)
```

### 第 4 步，获取纠偏后的数据

#### 1、实现 TraceListener 监听器。

TraceListener 监听器作为轨迹纠偏方法的参数传入后，通过其回调函数，获取纠偏点数据、轨迹的总距离。

#### 2、轨迹纠偏结束回调。

只要当前轨迹点纠偏全部成功就一定会进入 onFinished 回调。该回调方法的说明如下：

|   |   |   |   |
|---|---|---|---|
|方法名|参数说明|返回值说明|方法效果|
|onFinished|lineID：用于标示一条轨迹，支持多轨迹纠偏，如果多条轨迹调起纠偏接口，则lineID需不同。<br><br>linepoints：整条轨迹经过纠偏后点的经纬度集合。<br><br>distance：轨迹经过纠偏后总距离，单位米。<br><br>waitingtime：该轨迹中间停止时间，以GPS速度为参考，单位秒。|void|传入的轨迹点数据全部纠偏完成时回调。|

#### 3、轨迹纠偏失败回调。

当传入的轨迹点数据出现以下几种情况，会因为参数错误导致纠偏失败，进入 onRequestFailed 回调。

- 网络不连通。
    
- 原始轨迹数据只有1个点。
    

该回调方法的说明如下

|   |   |   |   |
|---|---|---|---|
|方法名|参数说明|返回值说明|方法效果|
|onRequestFailed|lineID：用于标示一条轨迹，支持多轨迹纠偏，如果多条轨迹调起纠偏接口，则lineID需不同。<br><br>errorInfo：轨迹纠偏失败原因。|void|轨迹纠偏发生错误时回调。|

#### 4、轨迹纠偏过程回调。

我们采用分段的方式处理轨迹数据，按分段的顺序，每完成一段轨迹数据的纠偏就会进 onTraceProcessing 回调。

采用分段方式有以下两个优势：

- 当轨迹点数据量大的时候，可减少处理整条轨迹数据的等待时间。
    
- 当有部分的轨迹数据不符合要求导致纠偏失败时，通过过程回调可看到已完成部分的结果。
    

该回调方法的说明如下：

|   |   |   |   |
|---|---|---|---|
|方法名|参数说明|返回值说明|方法效果|
|onTraceProcessing|lineID：用于标示一条轨迹，支持多轨迹纠偏，如果多条轨迹调起纠偏接口，则lineID需不同。<br><br>index：一条轨迹分割为多个段,标示当前轨迹段索引。<br><br>segments：一条轨迹分割为多个段，segments标示当前轨迹段经过纠偏后经纬度点集合。|void|一条轨迹分割为多个段，按索引顺序回调其中一段。|

```
  private traceListener:TraceListener = {
    /**
     * 轨迹纠偏失败回调
     */
    onRequestFailed:(lineID: number, errorInfo: string)=>{
      this.getUIContext().getPromptAction().showToast({ message: errorInfo})
      if (this.mOverlayList.hasKey(lineID)) {
        const overlay = this.mOverlayList.get(lineID)
        overlay.setTraceStatus(TraceOverlay.TRACE_STATUS_FAILURE)
        this.setDistanceWaitInfo(overlay)
      }
    },
    /**
     * 轨迹纠偏过程回调
     */
    onTraceProcessing:(lineID: number,index: number,segments: ArrayList<LatLng>)=>{
      if (!segments) {
        return
      }
      if (this.mOverlayList.hasKey(lineID)) {
        const overlay = this.mOverlayList.get(lineID)
        overlay.setTraceStatus(TraceOverlay.TRACE_STATUS_PROCESSING)
        overlay.add(segments)
      }

    },
    /**
     * 轨迹纠偏结束回调
     */
    onFinished:(lineID: number,linepoints:ArrayList<LatLng>, distance:number,waitingtime: number)=>{
      this.getUIContext().getPromptAction().showToast({ message: 'onFinished'})
      if (this.mOverlayList.hasKey(lineID)) {
        const overlay = this.mOverlayList.get(lineID)
        overlay.setTraceStatus(TraceOverlay.TRACE_STATUS_FINISH)
        overlay.setDistance(distance)
        overlay.setWaitTime(waitingtime)
        this.setDistanceWaitInfo(overlay)
      }
    }
  }
```

### 注意事项

1、作为地图SDK的功能，需要设置正确的高德Key才能保证轨迹纠偏功能的正确使用。

2、若您对纠偏结果存疑（例如：距离计算不准确，轨迹不正确等等），可将您的轨迹点转成标准的 JSON 格式文件，通过工单提交给我们（注意：我们只接受转成我们能验证格式的轨迹点数据）。

      a）标准的 JSON 格式文件可通过 http://tool.oschina.net/codeformat/json 转化。

      b）检查参数的字段名称是否与下表吻合，不一样请修改成一样。

|   |   |
|---|---|
|经度|lon|
|纬度|lat|
|时间（单位：毫秒）|loctime|
|速度（单位：Km/h）|speed|
|角度（单位：度）|bearing|

 c）通过工单提交给我们
 # 控件交互最后更新时间: 2025年11月17日

## 地图logo控件

高德地图的 logo 默认在左下角显示，不可以移除，但支持调整到固定位置。设置的方法是：

```
public setLogoPosition(position: number): void //设置“高德地图”Logo的位置
```

|   |   |
|---|---|
|名称|位置说明|
|AMapOptions.LOGO_POSITION_BOTTOM_CENTER|Logo位置（地图底部居中）|
|AMapOptions.LOGO_POSITION_BOTTOM_LEFT|Logo位置（地图左下角）|
|AMapOptions.LOGO_POSITION_BOTTOM_RIGHT|Logo位置（地图右下角）|
|AMapOptions.LOGO_MARGIN_LEFT|LOGO边缘MARGIN（左边）|
|AMapOptions.LOGO_MARGIN_BOTTOM|LOGO边缘MARGIN（底部）|
|AMapOptions.LOGO_MARGIN_RIGHT|LOGO边缘MARGIN（右边）|

## 指南针控件

指南针用于向 App 端用户展示地图方向，默认不显示。通过如下接口控制其显示：

```
public setCompassEnabled(enabled: boolean): void //设置指南针是否可见
```

![](https://a.amap.com/lbs/static/img/doc/doc_1763087640303_d199c.jpeg)

## 比例尺控件

比例尺控件（最大比例是1：10m,最小比例是1：1000Km），位于地图右下角，可控制其显示与隐藏，设置的方法是：

```
public setScaleControlsEnabled(enabled: boolean): void //控制比例尺控件是否显示
```

![](https://a.amap.com/lbs/static/img/doc/doc_1763087668619_6a878.png)
# 手势交互最后更新时间: 2025年11月17日

地图 SDK 提供了多种手势供用户与地图之间进行交互，如缩放、旋转、拖拽、倾斜。这些手势默认开启，如果想要关闭某些手势，可以通过 UiSettings 类提供的接口来控制手势的开关。

## 手势方法说明

#### 以下是控制手势生效与否的方法：

|   |   |
|---|---|
|名称|说明|
|setZoomGesturesEnabled(boolean)|设置缩放手势是否可用|
|setScrollGesturesEnabled(boolean)|设置拖拽手势是否可用|
|setRotateGesturesEnabled(boolean)|设置旋转手势是否可用|
|setTiltGesturesEnabled(boolean)|设置倾斜手势是否可用|
|setGestureScaleByMapCenter(boolean)|设置是否以地图中心点缩放|
|setAllGesturesEnabled(boolean)|设置所有手势是否可用|

#### 以下是检测手势是否生效的方法：

|   |   |
|---|---|
|名称|说明|
|isZoomGesturesEnabled()|缩放手势是否可用|
|isScrollGesturesEnabled()|拖拽手势是否可用|
|isRotateGesturesEnabled()|旋转手势是否可用|
|isTiltGesturesEnabled()|倾斜手势是否可用|
|isGestureScaleByMapCenter()|是否地图中心点缩放|

## 缩放手势

缩放手势可改变地图的缩放级别，地图响应的手势如下：

- 双击地图可以使缩放级别增加1 (放大)
    
- 两个手指捏/拉伸
    

以下是控制缩放手势开启关闭的代码：

```
aMap.getUiSettings()?.setZoomGesturesEnabled(boolean);
```

## 拖拽手势

您可以用手指拖动地图四处滚动（平移）或用手指滑动地图（动画效果），也可以禁用或开启平移（滑动）手势。

以下介绍控制拖拽手势开启关闭的方法，示例代码如下：

```
aMap.getUiSettings()?.setScrollGesturesEnabled(boolean);
```

## 旋转手势

您可以用两个手指在地图上转动，可以旋转地图，也可以禁用旋转手势。

以下介绍控制旋转手势开启关闭的方法，示例代码如下：

```
aMap.getUiSettings()?.setRotateGesturesEnabled(boolean);
```

## 倾斜手势

用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角，也可以禁用倾斜手势。

以下是控制倾斜手势开启关闭的代码：

```
aMap.getUiSettings()?.setTiltGesturesEnabled(boolean);
```

## 地图中心点缩放

用户可以设置地图缩放位置，可以以中心点缩放或在缩放位置缩放。

以下是控制地图中心点缩放开启关闭的代码：

```
aMap.getUiSettings()?.setGestureScaleByMapCenter(boolean);
```

## 所有手势是否可用

用户可以统一设置地图是否支持手势交互。

以下是控制所有手势是否可用的代码：

```
aMap.getUiSettings()?.setAllGesturesEnabled(boolean);
```

## 指定屏幕中心点的手势操作

在对地图进行手势操作时（滑动手势除外），可以指定屏幕中心点后执行相应手势。

指定屏幕中心点的接口如下，在AMap类中：

```
/**
 * 设置屏幕上的某个像素点为地图中心点。
 * <p>使用该方法设置后，地图将以所设置的屏幕坐标点为中心进行旋转、倾斜。同时， {@link #moveCamera(CameraUpdate) } 方法也将会以此坐标点为中心进行设置。
 *
 * @param x 屏幕像素点x轴坐标。
 * @param y 屏幕像素点y轴坐标。
 * @since v2.2.0
 */
public setPointToCenter(x: number, y: number): void
```

开启以中心点进行手势操作的接口如下，在UiSettings类中：

```
/**
 * 设置是否以地图中心点缩放 <br>
 * 注：优先级低于{@link AMap#setPointToCenter(int, int)}
 *
 * @param isGestureScaleByMapCenter true:以地图中心的进行缩放,false:不以地图中心的进行缩放
 * @since 1.0.0
 */
public setGestureScaleByMapCenter(isGestureScaleByMapCenter: boolean): void
```
# 调用方法交互最后更新时间: 2025年11月04日

方法交互的概念是从程序角度出发提出的。地图 SDK 提供了很多与地图交互的接口方法，例如：改变地图显示的区域（即改变地图中心点）、改变地图的缩放级别、设置地图的显示范围等。

## 改变地图旋转角度

方法交互的核心方法均依赖 AMap 类提供的这两个方法：animateCamera（带有动画效果），moveCamera（直接改变状态，没有动画效果）。

#### 带有动画效果：

```
aMap.animateCamera(CameraUpdateFactory.changeBearing(90)) //逆时针旋转90°
```

#### 不带有动画效果：

```
aMap.moveCamera(CameraUpdateFactory.changeBearing(90)) //逆时针旋转90°
```

## 改变地图的中心点

如果想改变地图中心点，可以通过 changeLatLng 方法，示例代码如下：

```
aMap.moveCamera(CameraUpdateFactory.changeLatLng(new LatLng(39.897743, 116.321349)))
```

## 改变地图的缩放级别

如果想改变地图的缩放级别，可以通过 zoomTo 方法，示例代码如下：

```
aMap.moveCamera(CameraUpdateFactory.zoomTo(12))
```

地图的缩放级别一共分为 18 级，从 3 到 20。数字越大，展示的图面信息越精细。

|   |   |
|---|---|
|名称|说明|
|zoomIn()|放大地图缩放级别，在当前地图显示的级别基础上加1|
|zoomOut()|缩小地图缩放级别，在当前地图显示的级别基础上减1|
|zoomTo(zoom)|设置地图缩放级别|
|newLatLngZoom(latLng, zoom)|设置地图中心点以及缩放级别|
|zoomBy(amount)|根据给定的增量调整地图级别，即在现有地图级别上加上该增量值|

## 设置地图显示范围

如果想将地图的显示范围设置在规定屏幕内，可以通过 newLatLngBounds 方法，示例代码如下：

```
aMap.moveCamera(CameraUpdateFactory.newLatLngBounds(new LatLngBounds(new LatLng(39.889863, 116.354148), new LatLng(39.946781, 116.437982)), 20))
```

除上述介绍的方法外，地图 SDK 支持：给地图设置一个新的状态、修改地图倾斜度等，具体可以查阅 [参考手册](https://a.amap.com/lbs-dev-yuntu/static/reference/harmonyosnext-sdk/map/docs/index.html)。
# 地图截屏功能最后更新时间: 2025年09月29日

地图 SDK 支持对当前屏幕显示区域进行截屏，可以对地图、覆盖物（包含信息窗口）、Logo进行截取屏幕，这其中不包括地图控件、Toast窗口。

详细示例如下：

```
this.aMap?.getMapScreenShot({
  onMapScreenShot: (mapScreenShot: PixelMap | undefined, status: number) => {

    this.image = mapScreenShot;
    let buffer: string = "";
    if (mapScreenShot) {
      buffer += "截屏成功 ";
    } else {
      buffer += "截屏失败 ";
    }
    if (status != 0) {
      buffer += "地图渲染完成，截屏无网格";
    } else {
      buffer += "地图未渲染完成，截屏有网格";
    }

    promptAction.showToast({ message: `${buffer}` });

  }
});
```
# 获取POI数据最后更新时间: 2025年09月15日

## 简介

高德提供了千万级别的 POI（Point of Interest，兴趣点）。在地图表达中，一个 POI 可代表一栋大厦、一家商铺、一处景点等等。通过POI搜索，完成找餐馆、找景点、找厕所等等的功能。地图 SDK 的搜索功能提供多种获取 POI 数据的接口，下文将逐一介绍。

## 关键字检索POI

根据关键字检索适用于在某个城市搜索某个名称相关的POI，例如：查找北京市的“肯德基”。

#### 1，创建回调监听

```
private poiSearchListener: OnPoiSearchListener = {
  onPoiSearched: (pageResult: PoiResult | undefined, errorCode: number) => {
    if (errorCode === AMapException.CODE_AMAP_SUCCESS) { 
    }
  },
  onPoiItemSearched: (poiItem: PoiItem | undefined, errorCode: number) => {}
};
```

#### 2，构建查询对象

```
this.poiQuery = new PoiQuery(this.keyword, "",  this.city);
this.poiSearch.setQuery(this.poiQuery);
```

#### 3，构造 PoiSearch 对象，并设置监听

```
this.poiSearch = new PoiSearch(this.context!, undefined);
this.poiSearch.setOnPoiSearchListener(this.poiSearchListener);
```

#### 4，调用 PoiSearch 的 searchPOIAsyn() 方法发送请求

```
this.poiSearch.searchPOIAsyn();
```

#### 5，通过回调接口 onPoiSearched 解析返回的结果，将查询到的 POI 以绘制点的方式显示在地图上。

#### 6，说明

1）可以在回调中解析result，获取POI信息。

2）result.getPois()可以获取到PoiItem列表，Poi详细信息可参考PoiItem类。

3）若当前城市查询不到所需POI信息，可以通过result.getSearchSuggestionCitys()获取当前Poi搜索的建议城市。

4）如果搜索关键字明显为误输入，则可通过result.getSearchSuggestionKeywords()方法得到搜索关键词建议。

5）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

效果图：

![](https://a.amap.com/lbs/static/img/doc/doc_1757930156326_83b50.jpeg)

## 周边检索POI
# 获取地址描述数据最后更新时间: 2025年09月15日

## 地理编码（地址转坐标）

#### 地理编码基本介绍

地理编码，又称为地址匹配，是从已知的结构化地址描述到对应的经纬度坐标的转换过程。该功能适用于根据用户输入的地址确认用户具体位置的场景，常用于配送人员根据用户输入的具体地址找地点。

结构化地址的定义： 首先，地址肯定是一串字符，内含国家、省份、城市、城镇、乡村、街道、门牌号码、屋邨、大厦等建筑物名称。按照由大区域名称到小区域名称组合在一起的字符。一个有效的地址应该是独一无二的。注意：针对大陆、港、澳地区的地理编码转换时可以将国家信息选择性的忽略，但省、市、城镇等级别的地址构成是不能忽略的。

注意：该功能可以返回一部分POI数据内容，但核心能力是完成结构化地址到经纬度的转换。

- POI关键字搜索，是根据关键词找到现实中存在的地物点（POI）。
    
- 地理编码是依据当前输入，根据标准化的地址结构（省/市/区或县/乡/村或社区/商圈/街道/门牌号/POI）进行各个地址级别的匹配，以确认输入地址对应的地理坐标，只有返回的地理坐标匹配的级别为POI，才会对应一个具体的地物（POI）。
    

根据给定的地理名称和查询城市，返回地理编码的结果列表。显示效果如图：

![](https://a.amap.com/lbs/static/img/doc/doc_1757930296840_4a47a.png)

实现步骤如下：

1、继承 OnGeocodeSearchListener 监听。

2、构造 GeocodeSearch 对象，并设置监听。

```

this.geocoderSearch = new GeocodeSearch(this.context)
this.geocoderSearch.setOnGeocodeSearchListener(this.onGeocodeSearchListener)
```

3、通过 GeocodeQuery(java.lang.String locationName, java.lang.String city) 设置查询参数，调用 GeocodeSearch 的 getFromLocationNameAsyn(GeocodeQuery geocodeQuery) 方法发起请求。

```
// 第一个参数表示地址，第二个参数表示查询城市，中文或者中文全拼，citycode、adcode，
let query = new GeocodeQuery(name, city) 
// 设置同步地理编码请求
this.geocoderSearch.getFromLocationNameAsyn(query) 
```

4、通过回调接口 onGeocodeSearched 解析返回的结果。

说明：

1）可以在回调中解析result，获取坐标信息。

2）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```

public onGeocodeSearched: (geocodeResult: GeocodeResult | undefined, errorCode: number): void => {
//解析geocodeResult获取坐标信息
}

```

## 逆地理编码（坐标转地址）

逆地理编码，又称地址解析服务，是指从已知的经纬度坐标到对应的地址描述（如行政区划、街区、楼层、房间等）的转换。常用于根据定位的坐标来获取该地点的位置详细信息，与定位功能是黄金搭档。

![](https://a.amap.com/lbs/static/img/doc/doc_1757930307013_fb5c8.png)

示例代码如下：

1、继承 OnGeocodeSearchListener 监听。

2、构造 GeocodeSearch 对象，并设置监听。

```
this.geocoderSearch = new GeocodeSearch(this.context)      this.geocoderSearch.setOnGeocodeSearchListener(this.onGeocodeSearchListener)
```

3、通过 RegeocodeQuery(LatLonPoint point, float radius, java.lang.String latLonType) 设置查询参数，调用 GeocodeSearch 的 getFromLocationAsyn(RegeocodeQuery regeocodeQuery) 方法发起请求。

```
// 第一个参数表示一个Latlng，第二参数表示范围多少米，第三个参数表示是火系坐标系还是GPS原生坐标系
let query =new ReGeocodeQuery(latLonPoint, 200, GeocodeSearch.AMAP) 
 // 设置异步逆地理编码请求
this.geocoderSearch.getFromLocationAsyn(query)
```

4、通过回调接口 onRegeocodeSearched 解析返回的结果。

说明：

1）可以在回调中解析result，获取地址、adcode等等信息。

2）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
public onReGeocodeSearched: (reGeocodeResult: ReGeocodeResult | undefined, errorCode: number): void => {
//解析reGeocodeResult获取地址描述信息
}
```

## 注意事项

请注意：使用上述功能需要下载地图SDK，导入搜索功能的har包。
# 获取行政区划数据最后更新时间: 2025年09月29日

根据县（区）级行政区划名称查询其下级区划的详细信息，如：中心点坐标、编码等等。

目前能查询到街道级别的信息，例如：中国>山东省>济南市>历下区>舜华路街道（国>省>市>区>街道）。

## 示例代码：

```
let search = new DistrictSearch(mContext);
let query = new DistrictSearchQuery();
query.setKeywords("朝阳区");//传入关键字
query.setShowBoundary(true);//是否返回边界值
search.setQuery(query);
search.setOnDistrictSearchListener(this);//绑定监听器
search.searchDistrictAnsy();//开始搜索
```

通过回调接口获取数据

```
public onDistrictSearched: (districtResult: DistrictResult | undefined): void => { 

//在回调函数中解析districtResult获取行政区划信息
//在districtResult.getAMapException().getErrorCode()=1000时调用districtResult.getDistrict()方法
//获取查询行政区的结果，详细信息可以参考DistrictItem类。

}
```

显示效果如图所示：

![](https://a.amap.com/lbs/static/img/doc/doc_1758606758258_4a47a.png)

## 注意事项

请注意：使用上述功能需要下载地图SDK，导入搜索功能的har包。
# 获取天气数据最后更新时间: 2025年09月15日

## 简介

通过天气查询，可获取城市的实时天气、今天和未来3天的预报天气，可结合定位和逆地理编码功能使用，查询定位点所在城市的天气情况。注意：仅支持中国部分地区数据（台湾省目前没有数据）返回。

天气查询是一个可用来改善app体验的功能，如：在跑步类app中加入天气的提醒；出行前了解天气情况以便安排行程。

天气查询的请求参数类为 WeatherSearch，city（城市）为必设参数，type（气象类型）为可选，包含有两种类型：WEATHER_TYPE_LIVE为实况天气；WEATHER_TYPE_FORECAST为预报天气，默认为 实况天气。

## 示例代码

实况天气的代码如下：

 第一步：设置查询条件及天气监听接口。

```
//检索参数为城市和天气类型，实况天气为WEATHER_TYPE_LIVE、天气预报为WEATHER_TYPE_FORECAST
et query = new WeatherSearchQuery(this.cityName, WeatherSearchQuery.WEATHER_TYPE_FORECAST)
this.weatherSearch = new WeatherSearch(this.context)
      this.weatherSearch.setOnWeatherSearchListener(this.weatherSearchListener)
this.weatherSearch.setQuery(query)
//异步搜索
this.weatherSearch.searchWeatherAsyn()
```

第二步：获取天气查询结果。

```

/**
  * 实时天气查询回调
  */
public onWeatherLiveSearched: (weatherLiveResult: LocalWeatherLiveResult | undefined, errorCode: number): void => {
      if (errorCode === AMapException.CODE_AMAP_SUCCESS) {
        if (weatherLiveResult && weatherLiveResult.getLiveResult()) {
          this.weatherLive = weatherLiveResult.getLiveResult()
        } else {
          ToastUtil.show(this.uiContext, '对不起，没有搜索到相关数据！')
        }
      } else {
        ToastUtil.showError(this.uiContext, errorCode)
      }
    }
```

截图效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1757930372283_4a47a.png)

## 注意事项

请注意：使用上述功能需要下载地图SDK，导入搜索功能的包。
# 获取公交数据最后更新时间: 2025年11月17日

## 公交站点查询

实现公交站点查询的步骤如下:

1、继承 OnBusStationSearchListener 监听。

2、通过 BusStationQuery(query: string, city: string)设置搜索条件。

```
// 第一个参数表示公交线路名，第二个参数表示公交线路查询，第三个参数表示所在城市名或者城市区号
this.busStationQuery = new BusStationQuery(search, this.getCityCode());
```

3、构造 BusStationSearch 对象，并设置监听，并调用 BusStationSearch 的 searchBusStationAsyn() 方法发起查询。

```
this.busStationSearch = new BusStationSearch(this.mContext, this.busStationQuery);
// 设置查询结果的监听
this.busStationSearch?.setOnBusStationSearchListener(this.busStationSearchListener); 
this.busStationSearch?.searchBusStationAsyn();
```

4、通过回调接口 onBusStationSearched 解析返回的结果。

说明：

1）可以在回调中解析result，获取公交站点信息。

2）result.getBusStations()可以获取到 BusStationItem 列表。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
  private busStationSearchListener: OnBusStationSearchListener = {
    onBusStationSearched: (result: BusStationResult, rCode: number) => {
      //ToDo
    }
  }
```

![](https://a.amap.com/lbs/static/img/doc/doc_1763087949254_4b7ff.png)

## 公交路线查询

### 线路名称查询

1、设置查询条件

根据 BusLineQuery(query: string, ctgr: BusSearchType, city: string) 创建一个 BusLineQuery 对象，并设置查询条件，再根据 BusLineSearch(act: Context, query: BusLineQuery) 创建一个 BusLineSearch 对象。查询类型参数 ctgr 此处设置为 BusLineQuery.SearchType.BY_LINE_NAME。

2、发送请求和接收数据

使用 BusLineSearch.searchBusLineAsyn() 搜索公交线路。在 OnBusLineSearchListener 的接口回调方法 onBusLineSearched: (busLinePagedResult: BusLineResult, resultID: number) => void处理返回结果。当根据线路名称搜索无结果时，会自动匹配关键字为途经点名称进行搜索。显示效果如图：

![](https://a.amap.com/lbs/static/img/doc/doc_1763087976935_a7c12.png)

![](https://a.amap.com/lbs/static/img/doc/doc_1763088009425_fcf62.png)

结果返回线路信息有线路 ID、公交类型、线路名称、坐标串、城市编码、首发站、末站。

发送请求

```
this.busLineQuery = new BusLineQuery(search, BusSearchType.BY_LINE_NAME,
  this.getCityCode()); // 第一个参数表示公交线路名，第二个参数表示公交线路查询，第三个参数表示所在城市名或者城市区号
this.busLineQuery.setPageSize(10); // 设置每页返回多少条数据
this.busLineQuery.setPageNumber(this.currentPage); // 设置查询第几页，第一页从0开始算起
this.busLineSearch = new BusLineSearch(this.mContext, this.busLineQuery); // 设置条件
this.busLineSearch?.setOnBusLineSearchListener(this.busLineSearchListener); // 设置查询结果的监听
this.busLineSearch?.searchBusLineAsyn(); // 异步查询公交线路名称
```

回调方法

```
private busLineSearchListener: OnBusLineSearchListener = {
  onBusLineSearched: (result: BusLineResult, rCode: number) => {
    //ToDo
  }
}
```

### 线路 ID 查询

获取公交线路的详细信息，可使用线路 ID 查询。结果返回线路信息有线路 ID、公交类型、线路名称、线路坐标、城市编码、首发站、末站、首班车时间、末班车时间、所属公交公司、全程里程、起步价、全程票价、矩形区域（外包矩形的左下与右上顶点）、线路沿途坐标。

1、参照线路名称查询步骤1设置查询条件。此时，查询类型参数 ctgr 此处设置为 BusLineQuery.SearchType.BY_LINE_ID。

2、发送请求和接收数据。可参考线路名称查询步骤2。可以根据得到的公交线路数据，使用 BusLineOverlay 画出公交线路图层，包括起终点和所有公交站点。另外也可以自定义 Marker 和 InfoWindow 的图标和信息。
# 驾车出行路线规划最后更新时间: 2025年09月15日

## 驾车出行路线规划

驾车路径规划可以根据起终点和驾车路线的数据，使用 DrivingRouteOverlay 画出驾车路线图层，包括起终点和转弯点。另外也可以自定义起终点和驾车转弯点的图标。

注意：地图SDK V1.0.0版本开始，SDK不再提供 com.amap.api.maps.overlay 包下的 overlay，已在官方demo中开源。

#### 第 1 步，初始化 RouteSearch 对象

```
routeSearch = new RouteSearch(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 DriveRouteQuery(fromAndTo: FromAndTo, mode: number, passedByPoints: ArrayList<LatLonPoint>, avoidpolygons: ArrayList<ArrayList<LatLonPoint>>, avoidRoad: string) 设置搜索条件，方法对应的参数说明如下：

- fromAndTo，路径的起点终点；
    
- mode，路径规划的策略，可选，默认为0-速度优先；
    
- passedByPoints，途经点，可选；
    
- avoidpolygons，避让区域，可选，支持32个避让区域，每个区域最多可有16个顶点。如果是四边形则有4个坐标点，如果是五边形则有5个坐标点。
    
- avoidRoad，避让道路，只支持一条避让道路，避让区域和避让道路同时设置，只有避让道路生效。
    

```
// fromAndTo包含路径规划的起点和终点，drivingMode表示驾车模式
// 第三个参数表示途经点（最多支持6个），第四个参数表示避让区域（最多支持32个），第五个参数表示避让道路
const query = new DriveRouteQuery(fromAndTo, RouteSearch.DrivingDefault, undefined,
      undefined, ""); // 第一个参数表示路径规划的起点和终点，第二个参数表示驾车模式，第三个参数表示途经点，第四个参数表示避让区域，第五个参数表示避让道路
```

#### 第 4 步，发送请求

使用类 RouteSearch 的 calculateDriveRouteAsyn(query: DriveRouteQuery) 方法进行骑行规划路径计算。

```
this.mRouteSearch.calculateDriveRouteAsyn(query);
```

#### 第 5 步，接收数据

在 OnRouteSearchListener 接口回调方法 onDriveRouteSearched(result: DriveRouteResult | undefined, rCode: number): DriveRouteResult 处理驾车规划路径结果。返回的信息中包括：路线的距离、高速费用（仅针对7座以下轿车）、路况情况等等。

说明：

1）可以在回调中解析 result，获取驾车的路径。

2）result.getPaths()可以获取到 DrivePath 列表，驾车路径的详细信息可参考 DrivePath 类。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
private onRouteSearchListener: OnRouteSearchListener = {
  onDriveRouteSearched: (result: DriveRouteResult | undefined, errorCode: number): void => {
  //todo: 处理result驾车路径信息
  },
  onRideRouteSearched: (result: RideRouteResult, errorCode: number): void => {
  },
  onWalkRouteSearched: (result: WalkRouteResult, errorCode: number) => {
  },
  onBusRouteSearched: (result: BusRouteResult, errorCode: number): void => {
  }
}
```

![](https://a.amap.com/lbs/static/img/doc/doc_1757930498029_4a47a.png)       ![](https://a.amap.com/lbs/static/img/doc/doc_1757930503438_fb5c8.png)

## 驾车出行路线规划V2

驾车路径规划可以根据起终点和驾车路线的数据，使用 DrivingRouteOverlay 画出驾车路线图层，包括起终点和转弯点。另外也可以自定义起终点和驾车转弯点的图标。

注意：地图SDK V1.0.0版本开始，SDK不再提供 com.amap.api.maps.overlay 包下的 overlay，已在官方demo中开源。

#### 第 1 步，初始化 RouteSearchV2 对象

```
routeSearch = new RouteSearchV2(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 DriveRouteQueryV2(fromAndTo: FromAndTo, mode: number, passedByPoints: ArrayList<LatLonPoint>, avoidpolygons: ArrayList<ArrayList<LatLonPoint>>, avoidRoad: string) 设置搜索条件，方法对应的参数说明如下：

- fromAndTo，路径的起点终点；
    
- mode，路径规划的策略，可选，默认为0-速度优先；
    
- passedByPoints，途经点，可选；
    
- avoidpolygons，避让区域，可选，支持32个避让区域，每个区域最多可有16个顶点。如果是四边形则有4个坐标点，如果是五边形则有5个坐标点。
    
- avoidRoad，避让道路，只支持一条避让道路，避让区域和避让道路同时设置，只有避让道路生效。
    

```
// fromAndTo包含路径规划的起点和终点，drivingMode表示驾车模式
// 第三个参数表示途经点（最多支持6个），第四个参数表示避让区域（最多支持32个），第五个参数表示避让道路
const fromAndTo = new FromAndTo(this.mStartPoint, this.mEndPoint);
    const query = new DriveRouteQueryV2(fromAndTo, DrivingStrategy.DEFAULT.getValue(), undefined,
      undefined, ""); // 第一个参数表示路径规划的起点和终点，第二个参数表示驾车模式，第三个参数表示途经点，第四个参数表示避让区域，第五个参数表示避让道路
    query.setShowFields(0b0010101)
```

#### 第 4 步，发送请求

使用类 RouteSearch 的 calculateRideRouteAsyn(RideRouteQuery query) 方法进行骑行规划路径计算。

```
this.mRouteSearch.calculateDriveRouteAsyn(query);
```

#### 第 5 步，接收数据

在 RouteSearch.OnRouteSearchListener 接口回调方法 void onDriveRouteSearched(DriveRouteResult result, int rCode) 处理驾车规划路径结果。返回的信息中包括：路线的距离、高速费用（仅针对7座以下轿车）、路况情况等等。

说明：

1）可以在回调中解析 result，获取驾车的路径。

2）result.getPaths()可以获取到 DrivePath 列表，驾车路径的详细信息可参考 DrivePath 类。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
private onRouteSearchListener: OnRouteSearchListenerV2 = {
  onDriveRouteSearched: (result: DriveRouteResultV2 | undefined, errorCode: number): void => {
    //todo: 处理result驾车路径信息，详情参考demo
  },
  onRideRouteSearched: (result: RideRouteResultV2, errorCode: number): void => {
  },
  onWalkRouteSearched: (result: WalkRouteResultV2, errorCode: number) => {
  },
  onBusRouteSearched: (): void => {
  }
}
```
# 步行出行路线规划最后更新时间: 2025年09月15日

## 步行出行路线规划

步行路径规划可以根据起终点和步行路线的数据，使用 WalkRouteOverlay 画出步行路线图层，包括起终点和转弯点。另外也可以自定义起终点和步行转弯点的图标。

#### 第 1 步，初始化 RouteSearch 对象

```
this.mRouteSearch = new RouteSearch(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 WalkRouteQuery(fromAndTo: FromAndTo) 设置搜索条件。其中：

- fromAndTo，路径的起终点；
    

```
//fromAndTo，路径的起终点；
const fromAndTo = new FromAndTo(this.mStartPoint, this.mEndPoint)
// 第一个参数表示路径规划的起点和终点
const query = new WalkRouteQuery(fromAndTo); 
//设置扩展字段,可选
query.setExtensions(RouteSearch.EXTENSIONS_ALL);
```

#### 第 4 步，发送请求

使用类 RouteSearch 的 calculateWalkRouteAsyn(WalkRouteQuery query) 方法进行步行规划路径计算。

```
this.mRouteSearch.calculateWalkRouteAsyn(query)
```

#### 第 5 步，接收数据

在 OnRouteSearchListener 接口回调方法中的 onWalkRouteSearched: (walkRouteResult: WalkRouteResult, errorCode: number) => void处理步行规划路径结果。返回的信息中您可以获得路段的距离、步行的预计时间、步行路段的坐标点、步行路段的道路名称、导航主要操作等信息。显示效果如下：

说明：

1）可以在回调中解析result，获取步行的路径。

2）result.getPaths()可以获取到 WalkPath 列表，步行路径的详细信息可参考 WalkPath 类。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站错误码对照表）

```
private onRouteSearchListener: OnRouteSearchListener = {
  onWalkRouteSearched: (result: WalkRouteResult, errorCode: number) => {
    //todo: 处理result步行路径信息
  },
  onDriveRouteSearched: () => {
  },
  onRideRouteSearched: () => {
  },
  onBusRouteSearched: () => {
  }
}
```

![](https://a.amap.com/lbs/static/img/doc/doc_1757930566550_10fb1.png)

## 步行出行路线规划V2

步行路径规划可以根据起终点和步行路线的数据，使用 WalkRouteOverlayV2 画出步行路线图层，包括起终点和转弯点。另外也可以自定义起终点和步行转弯点的图标。

#### 第 1 步，初始化 RouteSearchV2 对象

```
this.mRouteSearch = new RouteSearchV2(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 WalkRouteQueryV2(fromAndTo: FromAndTo) 设置搜索条件。其中：

- fromAndTo，路径的起终点；
    

```
//fromAndTo，路径的起终点；
const fromAndTo = new FromAndTo(this.mStartPoint, this.mEndPoint)
// 第一个参数表示路径规划的起点和终点
const query = new WalkRouteQueryV2(fromAndTo); 
//设置请求数据返回的字段
query.setShowFields(0b0010101)//对应'cost,navi,polyline'，可在网站api查询
//设置返回的步行路线数量
query.setAlternativeRoute(3)
```

#### 第 4 步，发送请求

使用类 RouteSearch 的 calculateWalkRouteAsyn(WalkRouteQuery query) 方法进行步行规划路径计算。

```
this.mRouteSearch.calculateWalkRouteAsyn(query)
```

#### 第 5 步，接收数据

在 OnRouteSearchListenerV2 接口回调方法中的 onWalkRouteSearched: (walkRouteResult: WalkRouteResultV2, errorCode: number) => void 处理步行规划路径结果。返回的信息中您可以获得路段的距离、步行的预计时间、步行路段的坐标点、步行路段的道路名称、导航主要操作等信息。显示效果如下：

说明：

1）可以在回调中解析result，获取步行的路径。

2）result.getPaths()可以获取到 WalkPath 列表，步行路径的详细信息可参考 WalkPath 类。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站错误码对照表）

```
private onRouteSearchListener: OnRouteSearchListenerV2 = {
  onWalkRouteSearched: (result: WalkRouteResultV2, errorCode: number) => {
    //todo: 处理result步行路径信息
  },
  onDriveRouteSearched: () => {
  },
  onRideRouteSearched: () => {
  },
  onBusRouteSearched: () => {
  }
}
```

![](https://a.amap.com/lbs/static/img/doc/doc_1757930573813_09dd8.png)
# 公交出行路线规划最后更新时间: 2025年09月29日

公交路径规划可以根据起终点和公交换乘的数据，使用 BusRouteOverlay 画出公交路线图层，包括起终点和换乘点。另外也可以自定义起终点和换乘点的图标。

目前支持跨城公交路线规划，提供不同城市之间的火车换成方案。

## 公交出行路线规划

#### 第 1 步，初始化 RouteSearch 对象

```
this.mRouteSearch = new RouteSearch(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 BusRouteQuery(fromAndTo: FromAndTo, mode: numer, city: string,  nightflag: number) 设置搜索条件。方法中的参数说明如下:

- fromAndTo，路径的起终点；
    
- mode，计算路径的模式，可选，默认为最快捷；
    
- city，城市名称/城市区号/电话区号，此项不能为空；当进行跨城查询时，该参数对应起点的城市；
    
- nightflag，是否计算夜班车，默认为不计算，0：不计算，1：计算，可选。
    

如果选择计算夜班车（nightflag=1），返回的夜班车数据将会排列在结果的前边。

如果存在地铁换乘出行，返回结果中还包括地铁的入站口和出站口信息。

如果是跨城公交出行，返回结果中包含火车信息。进行跨城公交查询时，还需调用 BusRouteQuery 的 setCityd(city: string) 方法设置终点城市。

```
// fromAndTo包含路径规划的起点和终点，RouteSearch.BusLeaseWalk表示公交查询模式
// 第三个参数表示公交查询城市区号，第四个参数表示是否计算夜班车，0表示不计算,1表示计算
let query = new BusRouteQuery(fromAndTo, RouteSearch.BusLeaseWalk, "010",0);
//query.setCityd("027");//终点城市区号
```

#### 第 4 步，发送请求

使用类 RouteSearch 的 calculateBusRouteAsyn( query: BusRouteQuery) 方法进行公交规划路径计算。

```
this.mRouteSearch.calculateBusRouteAsyn(query)
```

#### 第 5 步，接收数据

在 OnRouteSearchListener 接口回调方法 onBusRouteSearched( busRouteResult: BusRouteResult, rCode: number) 处理公交路径规划结果。

说明：

1）可以在回调中解析 result，获取驾车的路径。

2）result.getPaths()可以获取到 BusPath 列表，公交路径的详细信息可参考 BusPath 类。公交路径规划的一个路段（类 BusStep），必存在一段公交导航信息，最多包含一段步行信息。返回结果构成如下图所示：

![](https://a.amap.com/lbs/static/img/doc/doc_1758606981193_fb5c8.png)

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
private onRouteSearchListener: OnRouteSearchListener = {
  onBusRouteSearched: (result: BusRouteResult, errorCode: number): void => {
    //todo处理返回的公交路线结果
  },
  onRideRouteSearched: () => {
  },
  onWalkRouteSearched: () => {
  },
  onDriveRouteSearched: () => {
  }
}
```

 ![](https://a.amap.com/lbs/static/img/doc/doc_1758606998123_10fb1.png)     ![](https://a.amap.com/lbs/static/img/doc/doc_1758607002240_09dd8.png)

![](https://a.amap.com/lbs/static/img/doc/doc_1758607006813_8266e.png)

## 公交出行路线规划V2

公交路径规划可以根据起终点和公交换乘的数据，使用 BusRouteOverlayV2 画出公交路线图层，包括起终点和换乘点。另外也可以自定义起终点和换乘点的图标。

目前支持跨城公交路线规划，提供不同城市之间的火车换成方案。

#### 第 1 步，初始化 RouteSearchV2 对象

```
this.mRouteSearch = new RouteSearchV2(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 BusRouteQueryV2(fromAndTo: FromAndTo, mode: numer, city: string,  nightflag: number) 设置搜索条件。方法中的参数说明如下:

- fromAndTo，路径的起终点；
    
- mode，计算路径的模式，可选，默认为最快捷；
    
- city，城市区号，此项不能为空；当进行跨城查询时，该参数对应起点的城市；
    
- nightflag，是否计算夜班车，默认为不计算，0：不计算，1：计算，可选。
    

如果选择计算夜班车（nightflag=1），返回的夜班车数据将会排列在结果的前边。

如果存在地铁换乘出行，返回结果中还包括地铁的入站口和出站口信息。

如果是跨城公交出行，返回结果中包含火车信息。进行跨城公交查询时，还需调用 BusRouteQueryV2 的 setCityd(city: string) 方法设置终点城市。

```
// fromAndTo包含路径规划的起点和终点，RouteSearch.BusLeaseWalk表示公交查询模式
// 第三个参数表示公交查询城市区号，第四个参数表示是否计算夜班车，0表示不计算,1表示计算
let query = new BusRouteQueryV2(fromAndTo, RouteSearch.BusLeaseWalk, "010",0);
//query.setCityd("027");//终点城市区号
//query.setShowFields(0b0010101);//对应查询结果'cost,navi,polyline'字段展示，可在网站api查询
```

#### 第 4 步，发送请求

使用类 RouteSearchV2 的 calculateBusRouteAsyn( query: BusRouteQueryV2) 方法进行公交规划路径计算。

```
this.mRouteSearch.calculateBusRouteAsyn(query)
```

#### 第 5 步，接收数据

在 OnRouteSearchListenerV2接口回调方法 onBusRouteSearched( busRouteResult: BusRouteResultV2, rCode: number) 处理公交路径规划结果。

说明：

1）可以在回调中解析 result，获取驾车的路径。

2）result.getPaths()可以获取到 BusPathV2 列表，公交路径的详细信息可参考 BusPathV2 类。公交路径规划的一个路段（类 BusStepV2），必存在一段公交导航信息，最多包含一段步行信息。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
private onRouteSearchListener: OnRouteSearchListenerV2 = {
  onBusRouteSearched: (result: BusRouteResultV2, errorCode: number): void => {
    //todo处理返回的公交路线结果
  },
  onRideRouteSearched: () => {
  },
  onWalkRouteSearched: () => {
  },
  onDriveRouteSearched: () => {
  }
}
```

![](https://a.amap.com/lbs/static/img/doc/doc_1758607019334_f19c9.png)     ![](https://a.amap.com/lbs/static/img/doc/doc_1758607022899_9eb9c.png)

![](https://a.amap.com/lbs/static/img/doc/doc_1758607026447_602e8.png)
# 骑行出行路线规划最后更新时间: 2025年09月15日

## 骑行出行路线规划

从搜索功能1.0.0 版本开始支持骑行出行路线规划功能。

骑行路径规划可以根据起终点和骑行路线的数据，使用 RideRouteOverlay 画出骑行路线图层，包括起终点和转弯点。另外也可以自定义起终点和骑行转弯点的图标。

注意：地图SDK V1.0.0版本开始，SDK不再提供 com.amap.api.maps.overlay 包下的 overlay，已在官方demo中开源。

#### 第 1 步，初始化 RouteSearch 对象

```
this.mRouteSearch = new RouteSearch(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 RideRouteQuery(fromAndTo:FromAndTo,mode?:number) 设置搜索条件。参数：fromAndTo，路径的起终点；mode，计算路径的模式。可选，默认为“推荐路线及最快路线综合模式”。

```
const fromAndTo = new FromAndTo(this.mStartPoint, this.mEndPoint);
const query = new RideRouteQuery(fromAndTo);
query.setExtensions(RouteSearch.EXTENSIONS_ALL);
```

#### 第 4 步，发送请求

使用类 RouteSearch 的 calculateRideRouteAsyn(query:RideRouteQuery) 方法进行骑行规划路径计算。

```
this.mRouteSearch.calculateRideRouteAsyn(query)
```

#### 第 5 步，接收数据

在 RouteSearch.OnRouteSearchListener 接口回调方法 onRideRouteSearched: (result: RideRouteResult, errorCode: number): void  处理骑行规划路径结果。返回的信息中您可以获得预估的骑行距离、骑行的预计时间、骑行路段的道路名称、坐标点等信息。

说明：

1）可以在回调中解析result，获取骑行的路径。

2）result.getPaths()可以获取到 RidePath 列表，骑行路径的详细信息可参考 RidePath 类。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
  private onRouteSearchListener: OnRouteSearchListener = {
    onRideRouteSearched: (result: RideRouteResult, errorCode: number): void => {
      //解析result获取算路结果，可参考官方demo
    }
  }
```

显示效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1757930651341_8266e.png)       ![](https://a.amap.com/lbs/static/img/doc/doc_1757930656718_f19c9.png)

## 骑行出行路线规划V2

从搜索功能1.0.0 版本开始支持骑行出行路线规划功能。

骑行路径规划可以根据起终点和骑行路线的数据，使用 RideRouteOverlay 画出骑行路线图层，包括起终点和转弯点。另外也可以自定义起终点和骑行转弯点的图标。

注意：地图SDK V1.0.0版本开始，SDK不再提供 com.amap.api.maps.overlay 包下的 overlay，已在官方demo中开源。

#### 第 1 步，初始化 RouteSearch 对象

```
this.mRouteSearch = new RouteSearchV2(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setRouteSearchListener(this.onRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 RideRouteQueryV2(fromAndTo:FromAndTo) 设置搜索条件。参数：fromAndTo，路径的起终点

```
const fromAndTo = new FromAndTo(this.mStartPoint, this.mEndPoint);
const query = new RideRouteQueryV2(fromAndTo); query.setShowFields(0b0011111)
```

#### 第 4 步，发送请求

使用类 RouteSearchV2 的 calculateRideRouteAsyn(query:RideRouteQuery) 方法进行骑行规划路径计算。

```
this.mRouteSearch.calculateRideRouteAsyn(query);
```

#### 第 5 步，接收数据

在 RouteSearchV2.OnRouteSearchListener 接口回调方法 onRideRouteSearched: (result: RideRouteResult, errorCode: number): void  处理骑行规划路径结果。返回的信息中您可以获得预估的骑行距离、骑行的预计时间、骑行路段的道路名称、坐标点等信息。

说明：

1）可以在回调中解析result，获取骑行的路径。

2）result.getPaths()可以获取到 RidePath 列表，骑行路径的详细信息可参考 RidePath 类。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
private onRouteSearchListener: OnRouteSearchListenerV2 = {
    onRideRouteSearched: (result: RideRouteResultV2, errorCode: number): void => {
      //解析result获取算路结果，可参考官方demo
    }
  }
```

显示效果如下：

![](https://a.amap.com/lbs/static/img/doc/doc_1757930666140_9eb9c.png)       ![](https://a.amap.com/lbs/static/img/doc/doc_1757930670752_602e8.png)
# 货车出行路线规划最后更新时间: 2025年09月29日

从搜索功能1.0.1 版本开始支持货车出行路线规划功能，货车出行路线规划的具体策略可参见服务文档。

#### 第 1 步，初始化 RouteSearch 对象

```
this.mRouteSearch = new RouteSearch(this.mContext)
```

#### 第 2 步，设置数据回调监听器

```
this.mRouteSearch.setOnTruckRouteSearchListener(this.onTruckRouteSearchListener)
```

#### 第 3 步，设置搜索参数

通过 TruckRouteQuery(fromAndTo: FromAndTo, mode: number,passedByPoints:ArrayList<LatLonPoint>|null|undefined,truckSize: number) 设置搜索条件。

|   |   |
|---|---|
|参数|说明|
|fromAndTo|路径的起终点|
|mode|计算路径的模式（可选），默认为“躲避拥堵”|
|passedByPoints|途经点|
|truckSize|货车大小，默认轻型车|

```
const fromAndTo = new FromAndTo(this.mStartPoint, this.mEndPoint);
//设置车牌
fromAndTo.setPlateNumber("A000XXX");
fromAndTo.setPlateProvince("京");
const query = new TruckRouteQuery(fromAndTo,RouteSearch.TRUCK_AVOID_CONGESTION,null,RouteSearch.TRUCK_SIZE_HEAVY); 
//设置车辆信息
query.setTruckAxis(6)
query.setTruckHeight(3.9)
query.setTruckWidth(3)
query.setTruckLoad(45)
query.setTruckWeight(50)
```

#### 第 4 步，发送请求

使用类 RouteSearch 的calculateTruckRouteAsyn(truckQuery: TruckRouteQuery) 方法进行路线规划路径计算。

```
this.mRouteSearch.calculateTruckRouteAsyn(query)
```

#### 第 5 步，接收数据

在 RouteSearch.OnTruckRouteSearchListener 接口回调方法 onTruckRouteSearched:(result: TruckRouteRestult, errorCode: number)处理货车规划路径结果。返回的信息中您可以获得预估的货车路线距离、货车路线的预计时间、货车路线路段的道路名称、坐标点等信息。

说明：

1）可以在回调中解析result，获取货车的路径。

2）result.getPaths()可以获取到 TruckPath 列表，货车路线的具体方案的详细信息可参考 TruckPath 类。

3）返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）

```
private  onTruckRouteSearchListener:OnTruckRouteSearchListener = {

onTruckRouteSearched:(result: TruckRouteRestult, errorCode: number): void => {
      //解析result获取算路结果，可参考官方demo
      //建议通过TruckPath中getRestriction() 判断路线上是否存在限行

  }
```

![](https://a.amap.com/lbs/static/img/doc/doc_1758607160901_7afbb.png)
# 未来行程路线规划最后更新时间: 2025年09月15日

## 简介

自地图 SDK 搜索功能 1.0.0 版本起新增未来行程路线规划，简称ETD。 未来出行规划（ETD）服务已覆盖全国所有城市，可提供未来7天的出行路线规划。 

注意：下面介绍的功能使用的是地图SDK的搜索功能，需要在工程中导入

## 未来行程路线规划

#### 第一步，  初始化 RouteSearch 对象

```
this.mRouteSearch = new RouteSearch(this.mContext);
```

#### 第二步， 设置数据回调监听器

```
this.mRouteSearch?.setOnRoutePlanSearchListener(this.onRoutePlanSearchListener);
```

#### 第三步， 设置搜索参数

通过 DrivePlanQuery(RouteSearch.FromAndTo fromAndTo, int firstTime, int interval, int count) 设置搜索条件，方法对应的参数说明如下：

fromAndTo，路径的起点终点，必设。

firstTime，出发时间，第一个时间戳（unix时间戳，精确到秒)，必设；

interval，规划的时间间隔，单位为秒，必设；

count，规划时间点个数，最大48个，必设。

设置终点的父POIID，无父POI的情况留空即可：

DrivePlanQuery.setDestParentPoiID(destParentPoiID)

设置规划策略模式，可选，默认为速度优先；

DrivePlanQuery.setMode(int mode)

设置车辆类型，默认为普通汽车：

DrivePlanQuery.setCarType(int carType)

```
const fromAndTo = new FromAndTo(
    this.mStartPoint, this.mEndPoint);
    const time = Math.floor(Date.now() / 1000)
    const query = new DrivePlanQuery(fromAndTo, time + utils.queryFirstInterval * 60, utils.queryInterval * 60,
      48); // 第一个参数表示路径规划的起点和终点，第二个参数表示驾车模式，第三个参数表示途经点，第四个参数表示避让区域，第五个参数表示避让道路
```

#### 第四步，发送请求

 使用类 RouteSearch 的 calculateDrivePlanAsyn(DrivePlanQuery driveQuery) 方法进行骑行规划路径计算。

```
this.mRouteSearch?.calculateDrivePlanAsyn(query)
```

#### 第五步，接收数据

 在 RouteSearch.OnRoutePlanSearchListener接口回调方法 void OnRoutePlanSearchListener(DriveRouteResult result, int rCode) 处理驾车规划路径结果。返回的信息中包括：路线的距离、规划时间、路况情况等。

 说明：

- 可以在回调中解析 result，获取驾车的路径；

- result.getPaths()可以获取到 DrivePath 列表，驾车路径的详细信息可参考 DrivePlanPath 类；

- 返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）。

```
private onRoutePlanSearchListener: OnRoutePlanSearchListener = {
  onDriveRoutePlanSearched: (result: DriveRoutePlanResult | undefined, errorCode: number): void => {
    //解析result获取算路结果，可参考官方demo
  }
}
```
# 坐标转换最后更新时间: 2025年11月17日

## 经纬度坐标与屏幕像素坐标互转

屏幕像素坐标转经纬度坐标

```
map.getProjection()?.fromScreenLocation(new Point(10, 10), (coord) => {
console.log('地理坐标', coord)
});
```

经纬度坐标转屏幕像素坐标

```
map.getProjection()?.toScreenLocation(new LatLng(39.957957,116.369404),(coord)=>{
console.log('屏幕坐标', coord)
});
```

## 其他坐标系转到高德坐标系

支持GPS/Mapbar/Baidu等多种类型坐标在高德地图上使用。参见类CoordinateConverter。

```
  const converter = new CoordinateConverter(getContext(this).getApplicationContext())
  // CoordType.GPS 待转换坐标类型
   converter.from(CoordType.GPS)
  // sourceLatLng待转换坐标点
  converter.coord(sourceLatLng)
  // 执行转换操作
  const  desLatLng = converter.convert()
```
# 距离测量最后更新时间: 2025年09月29日

此功能可以在不请求驾车出行路线规划接口的同时完成距离计算。目前支持直线距离和驾车距离的测量。

#### 第1步，初始化DistanceSearch

```
const context: Context | undefined = this.getUIContext().getHostContext()
const distanceSearch = new DistanceSearch(context!);
```

#### 第2步，设置数据回调监听

```
distanceSearch.setDistanceSearchListener({
      onDistanceSearched: (distanceResult: DistanceResult, errorCode: number) => {
        if (errorCode === AMapException.CODE_AMAP_SUCCESS) {

        }
      }
    });
```

#### 第3步，设置搜索参数

```
const start0: LatLonPoint = new LatLonPoint(39.902896,116.42792);
const start1: LatLonPoint = new LatLonPoint(39.865208,116.378596);
const start2: LatLonPoint = new LatLonPoint(39.894914,116.322062);
const start3: LatLonPoint = new LatLonPoint(39.945261,116.352994);
const dest: LatLonPoint = new LatLonPoint(39.902896, 116.42792);

//设置起点和终点，其中起点支持多个
const latLonPoints: ArrayList<LatLonPoint> = new ArrayList<LatLonPoint>();
latLonPoints.add(start0);
latLonPoints.add(start1);
latLonPoints.add(start2);
latLonPoints.add(start3);

const distanceQuery = new DistanceQuery();
distanceQuery.setOrigins(latLonPoints);
distanceQuery.setDestination(dest);
distanceQuery.setType(DistanceSearch.TYPE_DRIVING_DISTANCE);
```

#### 第4步，发送请求

```
 distanceSearch.calculateRouteDistanceAsyn(distanceQuery);
```

#### 第5步，接收数据

在 DistanceSearch对象的setDistanceSearchListener方法中，设置OnDistanceSearchListener回调监听，处理距离测量结果。返回的信息中您可以获得预估的直线或驾车路线距离。

说明：

1. 可以在回调中解析distanceResult，距离测量结果
    
2. distanceResult.getDistanceResults()可以获取到DistanceItem列表，距离测量结果详细信息可参考 DistanceItem 类。
    
3. 返回结果成功或者失败的响应码。1000为成功，其他为失败（详细信息参见网站开发指南-实用工具-错误码对照表）
    

效果事例图：

![](https://a.amap.com/lbs/static/img/doc/doc_1758607241736_549cf.jpeg)
# 距离/面积计算最后更新时间: 2025年11月17日

地图SDK提供了很多计算方法，包括：计算亮点距离、矩形面积、坐标转换、判断点是否在圆或者多边形内等等，下面做简单介绍：

## 两点间的直线距离计算

根据用户指定的两个经纬度坐标点，计算这两个点的直线距离，单位为米。代码如下：

```
/**
 * 根据用户的起点和终点经纬度计算两点间距离，单位米。
 *
 * @param startLatlng 起点的坐标。
 * @param endLatlng   终点的坐标。
 * @return 返回两点间的距离，单位米。
 * @since 1.0.0
 */
public static calculateLineDistance(startLatlng: LatLng, endLatlng: LatLng):  number
```

## 面积计算

高德地图SDK支持计算矩形的面积。代码如下：

```
/**
 * 计算地图上矩形区域的面积，单位平方米。
 *
 * @param leftTopLatlng     矩形区域左上角坐标。
 * @param rightBottomLatlng 矩形区域右下角坐标。
 * @return 返回地图上矩形区域的面积，单位平方米。
 * @since 1.0.0
 */
public static calculateRectangleArea(leftTopLatlng: LatLng, rightBottomLatlng: LatLng):  numbe
```
# 常见问题最后更新时间: 2024年10月29日

### 如何获取AppID

请在当前应用的Ability中使用如下代码获取

```
let flag = bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_SIGNATURE_INFO;
let bundleInfo = bundleManager.getBundleInfoForSelfSync(flag)
let appId = bundleInfo.signatureInfo.appId;
```

### 如何确定鸿蒙开发环境是否兼容？

高德地图开放平台当前适配的鸿蒙版本为DevEco Studio: NEXT Beta1-5.0.3.800, SDK: API12 Release(5.0.0.65)，后续鸿蒙系统稳定版本也会持续适配
 HarmonyOS NEXT 地图SDK  开发指南  获取key

# 获取Key最后更新时间: 2024年07月12日

## 如何申请key

### 1、创建新应用

进入 [控制台](https://lbs.amap.com/dev/)，创建一个新应用。如果您之前已经创建过应用，可直接跳过这个步骤。

![](https://a.amap.com/lbs/static/img/doc/doc_1710840141913_9b267.png)

![](https://a.amap.com/lbs/static/img/doc/doc_1710840149435_8db7d.png)

### 2、添加新Key

在创建的应用上点击"添加新Key"按钮，在弹出的对话框中，依次：输入应用名名称，选择绑定的服务为“HarmonyOS平台”，输入AppID，如下图所示：

注意

 1个KEY只能用于一个应用（多渠道安装包属于多个应用），1个Key在多个应用上使用会出现服务调用失败。

![](https://a.amap.com/lbs/static/img/doc/doc_1710840101456_d2b5c.png)

在阅读完高德地图API服务条款后，勾选此选项，点击“提交”，完成 Key 的申请，此时您可以在所创建的应用下面看到刚申请的 Key 了。
如何获取AppID
请在当前应用的Ability中使用如下代码获取

let flag = bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_SIGNATURE_INFO;
let bundleInfo = bundleManager.getBundleInfoForSelfSync(flag)
let appId = bundleInfo.signatureInfo.appId;

注意事项
 1. 获取AppID之前需要先配置应用的签名信息，应用的签名信息配置请参考华为官网的配置应用签名信息指南

 2. 为了确保鉴权通过，请确保真机调试时使用的key是基于真机获取的appid申请的，而云真机调试时则应使用云真机appid对应的key，正确的appId形式为："包名_签名信息"， 例如：com.amap.demo_BGtGgVB3ASqU7ar1nHkwX4s0nIexDbEwqNrVoatUDs17GrClWC7V2/zhoYh6tFQHAd5DASWVTEAgvZfzrEGljjs=  使用远程真机运行应用/服务
更新时间: 2024-06-29 15:33
概述
说明
该特性在DevEco Studio V2.2 Beta1及更高版本中支持。

如果开发者没有真机设备资源，则不能很方便的调试和验证HarmonyOS应用，为方便开发者，DevEco Studio提供了Remote Device远程真机设备资源供开发者使用，减少开发成本。目前，远程真机支持Phone和Wearable设备，开发者使用远程真机调试和运行应用时，同本地物理真机设备一样，需要对应用/服务进行签名才能运行。

相比远程模拟器，远程真机是部署在云端的真机设备资源，远程真机的界面渲染和操作体验更加流畅，同时也可以更好的验证应用/服务在真机设备上的运行效果，比如性能、手机网络环境等。

前提条件
已注册成为华为开发者，并完成华为开发者实名认证。
已对应用/服务进行签名，具体签名指导请参考为应用/服务进行签名。
说明
需要注意的是，远程真机每次释放后重新申请，服务端分配的设备都不一样。因此，每次重新申请远程真机后，都需要对应用/服务重新进行签名。

操作步骤
在DevEco Studio菜单栏，单击Tools > Device Manager。
在Remote Device页签中，单击Sign In，在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录（查看登录授权常见问题）。


登录后，请单击界面的允许按钮进行授权。


在Single device中，单击设备运行按钮，启动远程真机设备（同一时间只能启动一个设备）。


单击DevEco Studio的Run > Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）。


DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在远程真机上。


使用模拟器运行应用/服务
# 为应用/服务进行签名

更新时间: 2024-06-29 15:33

针对应用/服务的签名，DevEco Studio为开发者提供了[自动签名](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section18815157237)方案，帮助开发者高效进行调试。也可选择[手动方式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section297715173233)对应用/服务进行签名，如果使用了需要[ACL](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section157591551175916)的权限，需采用手动方式进行签名。

## 自动签名

说明

使用自动签名前，请确保本地系统时间与北京时间（UTC/GMT +8.00）保持一致。如果不一致，将导致签名失败。

1. 连接真机设备，确保[DevEco Studio与真机设备已连接](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/run_phone_tablat-0000001064774652-V2)，真机连接成功后如下图所示：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122053.50477882195741200557373488333331:50001231000000:2800:0F89798BA768D203AF5517C43DE7399F262025C3DE77EA505067DC089A46E8AB.png?needInitFileName=true?needInitFileName=true)
    
    说明
    
    如果同时连接多个设备，则使用自动化签名时，会同时将这多个设备的信息写到证书文件中。
    
2. 进入**File > Project Structure > Project > Signing Configs**界面，勾选“Automatically generate signature”（如果是API 8和9工程，需同时勾选“SupportHarmonyOS”），即可完成签名。如果未登录，请先单击**Sign In**进行登录，然后自动完成签名。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122053.50156081952227115866238722513190:50001231000000:2800:27998361F195CD8549D15255A9E9C2FE21794DCEDEB2441338AB1F69E2E6CB19.png?needInitFileName=true?needInitFileName=true)
    
    签名完成后，如下图所示：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122053.11386993356801227145977274760708:50001231000000:2800:A388DEE679FA2583DB5EFAAD5064EFE59175B16E14F7E322BF39A9DA5E45A906.png?needInitFileName=true?needInitFileName=true)
    

## 手动签名

HarmonyOS应用/服务通过数字证书（.cer文件）和Profile文件（.p7b文件）来保证应用/服务的完整性。在申请数字证书和Profile文件前，首先需要通过DevEco Studio或命令行工具来生成密钥（存储在格式为.p12的密钥库文件中）和证书请求文件（.csr文件）。然后，申请调试数字证书和调试Profile文件。最后，将密钥（.p12）文件、数字证书（.cer）文件和Profile（.p7b）文件配置到工程中。

**基本概念**

- **密钥**：格式为.p12，包含非对称加密中使用的公钥和私钥，存储在密钥库文件中，公钥和私钥对用于数字签名和验证。
- **证书请求文件**：格式为.csr，全称为Certificate Signing Request，包含密钥对中的公钥和公共名称、组织名称、组织单位等信息，用于向AppGallery Connect申请数字证书。
- **数字证书**：格式为.cer，由华为AppGallery Connect颁发。
- **Profile文件**：格式为.p7b，包含HarmonyOS应用/服务的包名、数字证书信息、描述应用/服务允许申请的证书权限列表，以及允许应用/服务调试的设备列表（如果应用/服务类型为Release类型，则设备列表为空）等内容，每个应用/服务包中均必须包含一个Profile文件。

### 生成密钥和证书请求文件

**使用DevEco Studio生成密钥和证书请求文件**

1. 在主菜单栏单击**Build > Generate Key** **and CSR**。
    
    说明
    
    如果本地已有对应的密钥，无需新生成密钥，可以在**Generate Key**界面中单击下方的Skip跳过密钥生成过程，直接使用已有密钥生成证书请求文件。
    
2. 在**Key Store File**中，可以单击**Choose Existing**选择已有的密钥库文件（存储有密钥的.p12文件）；如果没有密钥库文件，单击**New**进行创建。下面以新创建密钥库文件为例进行说明。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122053.70466805707095822962363298057911:50001231000000:2800:861ADC59DACB8C5954BCA624A8F02BB02629E42E74F010AFD8381CAAC1A52373.png?needInitFileName=true?needInitFileName=true "点击放大")
    
3. 在**Create Key Store**窗口中，填写密钥库信息后，单击**OK**。
    
    - **Key Store File**：设置密钥库文件存储路径，并填写p12文件名。
    - **Password**：设置密钥库密码，必须由大写字母、小写字母、数字和特殊符号中的两种以上字符的组合，长度至少为8位。请记住该密码，后续签名配置需要使用。
    - **Confirm Password**：再次输入密钥库密码。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122053.60246509516314649690595766304828:50001231000000:2800:A1B467DF85EE66E048CDC9966182D8620DC3AB54780E59765CC175B72CAD6E2B.png?needInitFileName=true?needInitFileName=true)
    
4. 在**Generate Key** **and CSR**界面中，继续填写密钥信息后，单击**Next**。
    
    - **Alias**：密钥的别名信息，用于标识密钥名称。请记住该别名，后续签名配置需要使用。
    - **Password**：密钥对应的密码，与密钥库密码保持一致，无需手动输入。
    - **Validity**：证书有效期，建议设置为25年及以上，覆盖应用/服务的完整生命周期。
    - **Certificate**：输入证书基本信息，如组织、城市或地区、国家码等。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122053.02331423797292712485275517124396:50001231000000:2800:BC4802351659D8BFB3D3D40DA3E5A005E6BAC770D3394DDE6952FB0FF5BD96F0.png?needInitFileName=true?needInitFileName=true "点击放大")
    
5. 在**Generate Key** **and CSR**界面，设置CSR文件存储路径和CSR文件名。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.35063725452729867794466585398180:50001231000000:2800:ECF934552C715D384575D3A9090E549586CA7803FAF59FC4753B164467B0442F.png?needInitFileName=true?needInitFileName=true "点击放大")
    
6. 单击**OK**，创建CSR文件成功，可以在存储路径下获取生成的密钥库文件（.p12）和证书请求文件（.csr）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.58715805814288984929884740002922:50001231000000:2800:E8208E2E2E9432BAC7DE4E0035680E8C544B0CAC4FE15433AA4AAA47B3C71016.png?needInitFileName=true?needInitFileName=true)
    

**使用命令行工具生成证书请求文件**

使用Open JDK携带的Keytool工具生成证书请求文件。

1. 使用管理员身份运行命令行工具。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.39242153372040180603935381346116:50001231000000:2800:172E34521C8EBC0FDFBD2799A07E8A1921EF13EA6D92EF3714070D97C5ADA3F1.png?needInitFileName=true?needInitFileName=true)
    
2. 切换到keytool工具所在路径，路径为DevEco Studio安装目录下的jbr\bin目录。
3. 执行如下命令，生成公私钥文件。例如，生成的密钥库名称为idedemokey.p12，存储到D盘根目录下。
    
    1. keytool -genkeypair -alias "ide_demo_app" -keyalg EC -sigalg SHA256withECDSA -dname "C=CN,O=HUAWEI,OU=HUAWEI IDE,CN=ide_demo_app"  -keystore d:\\idedemokey.p12 -storetype pkcs12 -validity 9125 -storepass 123456Abc -keypass 123456Abc
    
    生成公私钥文件的参数说明如下：
    
    说明
    
    请记录**下alias、storepass**和**keypass**的值，在后续[手动配置签名信息](https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ide_debug_device-0000001053822404#section112371245115818)操作会使用到。
    
    - **alias**：密钥的别名信息，用于标识密钥名称。
    - **sigalg**：签名算法，固定为**SHA256withECDSA**。
    - **dname**：按照操作界面提示进行输入。
        - C：国家/地区代码，如CN。
        - O：组织名称，如HUAWEI。
        - OU：组织单位名称，如HUAWEI IDE。
        - CN：名字与姓氏，建议与别名一致。
    - **validity**：证书有效期，建议设置为9125（25年）。
    - **storepass**：设置密钥库密码，必须由大写字母、小写字母、数字和特殊符号中的两种以上字符的组合，长度至少为8位。请记住该密码，后续签名配置需要使用。
    - **keypass**：设置密钥的密码，请与**storepass**保持一致。
    
4. 执行如下命令，执行后需要输入**storepass**密码，生成证书请求文件，后缀格式为.csr。
    
    1. keytool -certreq -alias "ide_demo_app" -keystore d:\\idedemokey.p12 -storetype pkcs12 -file d:\\idedemokey.csr
    
    生成证书请求文件的参数说明如下：
    
    - **alias**：与上一步骤中输入的alias保持一致。
    - **file**：生成的证书请求文件名称，后缀为.csr。
    

### 申请调试证书和调试Profile文件

通过生成的证书请求文件，向AppGallery Connect申请调试证书和Profile文件，操作如下：

- 创建HarmonyOS应用/服务：在AppGallery Connect项目中，创建一个HarmonyOS应用/服务，用于调试证书和Profile文件申请，具体请参考[创建HarmonyOS应用](https://developer.huawei.com/consumer/cn/doc/distribution/app/agc-help-harmonyos-introduction-0000001172299745#section1098493513117)。
- 申请调试证书和Profile文件：在AppGallery Connect中申请、下载调试证书和Profile文件，具体请参考[申请调试证书和Profile文件](https://developer.huawei.com/consumer/cn/doc/distribution/app/agc-help-harmonyos-debugapp-manual-0000001177608893)。

### 手动配置签名信息

在DevEco Studio中配置密钥（.p12）文件、申请的调试证书（.cer）文件和调试Profile（.p7b）文件。

在**File >** **Project Structure >** **Project > Signing Configs**窗口中，去勾选“Automatically generate signature”（API 8和9工程请勾选“support HarmonyOS”），然后配置工程的签名信息。

- **Store File**：选择密钥库文件，文件后缀为.p12，该文件为[生成密钥和证书请求文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section462703710326)中生成的.p12文件。
- **Store Password**：输入密钥库密码，该密码与[生成密钥和证书请求文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section462703710326)中填写的密钥库密码保持一致。
- **Key Alias**：输入密钥的别名信息，与[生成密钥和证书请求文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section462703710326)中填写的别名保持一致。
- **Key Password**：输入密钥的密码，与[生成密钥和证书请求文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section462703710326)中填写的**Store Password**保持一致。
- **Sign Alg**：签名算法，固定为SHA256withECDSA。
- **Profile File**：选择[申请调试证书和调试Profile文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section15151840123413)中生成的Profile文件，文件后缀为.p7b。
- **Certpath File**：选择[申请调试证书和调试Profile文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section15151840123413)中生成的数字证书文件，文件后缀为.cer。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.12731644722529450194755342858884:50001231000000:2800:D24193CE3DB5FB3CA7589F46E1F5D33B8D4C430940C450644B7DB164AE36326C.png?needInitFileName=true?needInitFileName=true "点击放大")

### 使用ACL的签名配置指导

如果应用需要使用跨级别权限时，需使用ACL方式来申请对应权限。当前仅部分权限支持使用ACL方式申请，在[应用权限列表](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/permission-list-0000001544464017-V3)中标记“ACL使能：TRUE，可通过应用市场（AGC）申请”的为支持ACL的权限。

1. 申请进入ACL白名单。
    
    请提供[APP ID](https://developer.huawei.com/consumer/cn/doc/distribution/app/agc-help-appinfo-0000001100014694)发送到agconnect@huawei.com。收到邮件后，AGC运营审核通过后将进行白名单配置，审核周期一个工作日，请耐心等待。
    
2. 获取密钥和证书请求文件，请参见[生成密钥和证书请求文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#section462703710326)。
3. 申请调试证书，请参见[申请调试证书](https://developer.huawei.com/consumer/cn/doc/distribution/app/agc-help-harmonyos-debugapp-manual-0000001177608893#section13331154632718)。
4. 申请调试Profile。
    1. 登录[AppGallery Connect](https://developer.huawei.com/consumer/cn/service/josp/agc/index.html)，选择“我的项目”
    2. 找到您的项目，点击您创建的HarmonyOS应用/服务。
    3. 选择“HarmonyOS应用 > HAP Provision Profile管理”，进入“管理HAP Provision Profile”页面，点击右上角“添加”。![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.29413799238215313997375142521898:50001231000000:2800:8B39D8B1B890BC42C026936D048B0F699A9104C9C90E771BA944AA7CAD9EC4EC.png?needInitFileName=true?needInitFileName=true)
        
    4. 在弹出的“HarmonyAppProvision信息”窗口分别输入信息：
        
        - 名称：不超过100个字符。
        - 类型：选择“调试”。
            
            说明
            
            当前仅支持申请调试证书，类型请勿选择发布。
            
        - 选择证书：选择上一步得到用于调试的数字证书。
        - 选择设备：选择需要调试的设备，可选择一个或多个。
        - 申请受限权限：勾选需要申请使用的受限权限（需要先完成[申请进入ACL白名单](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/signing-0000001587684945-V2#ZH-CN_TOPIC_0000001622642277__li95073213217)，当开通ACL白名单后，才会出现配置项“申请受限ACL权限”）。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.52702827443308828590535057559785:50001231000000:2800:27A0ED12CBDD8D8DC8A7075978CEEFE91FE665288A66B240C26800F52B587D63.png?needInitFileName=true?needInitFileName=true)
        
    5. 调试Profile申请成功后 ，在“管理HAP Provision Profile”页面点击“下载”，获取Profile文件。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.79198506461177675087596924012233:50001231000000:2800:6C183F74D568A7460156DF45790EEBBEDEA11B3A5444E7A3937D2FFA5CA49086.png?needInitFileName=true?needInitFileName=true)
        
5. 在配置文件中添加权限信息。
    
    在需要使用权限的模块的module.json5文件中添加“requestPermissions”字段，并在字段下添加对应的权限名等信息，以权限“ohos.permission.ACCESS_IDS”为例。
    
    1. {
    2.   "module": {
    3.     ...
    4.     "requestPermissions": [{
    5.       "name": "ohos.permission.ACCESS_IDS",
    6.     }],
    7.     ...
    8.   }
    9. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.20817706163472292836845486884938:50001231000000:2800:F714E5F3BEE1DDAC393A40AEFF945A5004B1BCFBEC64594222F46AA63BB6A170.png?needInitFileName=true?needInitFileName=true)
    
6. 手动配置签名信息。
    1. 连接真机设备，确保[DevEco Studio与真机设备已连接](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/run_phone_tablat-0000001064774652-V2)。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.60192612111211114139374057783577:50001231000000:2800:5CA1A0E74B0A63DED62B5880E677B5C658F6684152722052C0C76635F5F05868.png?needInitFileName=true?needInitFileName=true)
        
    2. 点击DevEco Studio右上角的按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.60643838422786108032352000868374:50001231000000:2800:8532D951268B9BB0FC47D69B529AE0FD248862D2020D739978FB6FAA5EB0E501.png?needInitFileName=true?needInitFileName=true)打开“Project Structure”窗口，进入“Signing Config”页签，取消勾选“Automatically generate signature”。
        
        在“Signing”下分别配置密钥(.p12文件)、Profile(.p7b文件)和数字证书(.cer文件)的路径等信息。
        
        勾选“Show restricted permissions”，即可看到配置成功的权限。
        
        配置完毕后，点击“Apply”。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.86755368130278025525161476977652:50001231000000:2800:EBEC84A95F5C9E9872C905C55BECB076F3DD94CB6D8D60FC014C5063BED94490.png?needInitFileName=true?needInitFileName=true)
        
7. 进入工程级build-profile.json5文件，在“signingConfigs”下可查看到配置成功的签名信息，点击右上角的“Run”按钮运行应用/服务。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240629122054.96319838693952303370110692300620:50001231000000:2800:D473B9311BE4B594C70CCCE5A29D893B8C30C86654076BACDD9F8856F1BF39FA.png?needInitFileName=true?needInitFileName=true)
    # 自定义运行/调试配置

更新时间: 2025-12-16 15:58

## 配置应用可调试

应用是否支持调试，根据app.json5的debug字段和build-profile.json5的debuggable字段综合判断，app.json5的优先级高于build-profile.json5。

1. 在app.json5中配置debug字段：
    - true：应用支持调试。
    - false：应用不支持调试。
2. 如果没有配置debug字段，则根据build-profile.json5的debuggable字段判断应用是否支持调试。
    - true：应用支持调试。当[编译模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)不是release时，debuggable的缺省值是true，即支持调试。
    - false：应用不支持调试。当编译模式为release时，debuggable的缺省值是false，即不支持调试。

## 设置调试代码类型

点击**Run > Edit Configurations > Debugger**，选择相应模块，设置Debug type即可。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.05251535080832215078948574649549:50001231000000:2800:30D6C562BCBA892BC61AE236F3DAA34D422EABA9E9FDFBA7FC17FAA940668DB7.png)

工程调试类型默认为**Detect Automatically**，关于各调试类型的说明如下表所示：

**表1** 调试类型配置项
|调试类型|调试代码|
|:--|:--|
|**Detect Automatically**|新建工程默认调试器选项。根据工程模块及其依赖的模块涉及的编程语言，自动启动对应的调试器。|
|**ArkTS/JS**|- 调试ArkTS代码<br>- 调试JS代码|
|**Native**|仅调试C/C++代码|
|**Dual(ArkTS/JS + Native)**|调试C/C++工程的ArkTS/JS和C/C++代码|

## 设置HAP安装方式

在调试阶段，HAP在设备上的安装方式有2种，可以根据实际需要进行设置。

- 安装方式一：先卸载应用/元服务后，再重新安装，该方式会清除设备上的所有应用/元服务缓存数据。
    
    从DevEco Studio 4.1 Canary2版本开始，支持当代码无变化时，不进行推包安装。即根据模块有无变化来判断是否重新推送安装模块包，在运行调试时仅将有变化的模块及依赖它的模块重新推送安装至设备上。如entry依赖了HSP模块，当HSP模块有变化，运行调试时将同时推送安装HSP模块和entry模块。
    
- 安装方式二：采用覆盖安装方式，不卸载应用/元服务，该方式会保留应用/元服务的缓存数据。

设置方法如下：

单击**Run > Edit Configurations**，设置指定模块的HAP安装方式，勾选**Keep Application Data**，则表示采用覆盖安装方式，保留应用/元服务缓存数据。

说明

从DevEco Studio NEXT Developer Beta1开始，默认勾选“Keep Application Data”。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.36300365118801992255038682071625:50001231000000:2800:7290E0416AB2A3A517CB877DFC9BF90EBCA3532C3ED5304DCCAC217CAE1EED3C.png)

### 配置自定义调试参数

如果未进行自定义，将按默认配置安装和运行应用。如果开发者需要对应用安装、运行等流程增加参数配置，可在“Installation Options”和“Launch Options”下进行配置。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.67514111661176934296469635675625:50001231000000:2800:0F4EA7DBF5EF84278F232787AC9313C7382D431F364F6827D68E171CC48E6497.png)

- Installation Options
    - DebugLine Support：勾选Enable DebugLine表示在build产物中系统组件增加debugline属性，用于开启[ArkUI Inspector源码跳转](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arkui-inspector#section1226015494335)功能。
    - Install Flags：输入bm install命令相关的选项，请参见[bm install 参数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/bm-tool#%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4install)。如可以设置“-w 360”，表示将超时等待时间设置为360秒。
- Launch Options
    - Launch：指定在安装应用后启动的Ability。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.24599314596105348660936834744077:50001231000000:2800:EAFE6E541228F17D5AD1CCDF6C12256622FBCE9F8AC94639B1B1AD0A08E17456.png)
        
        - Nothing：只安装不启动任何Ability。
        - Default Ability：默认的EntryAbility。
            - Stage模型：module.json5文件中配置了“skills”属性的第一个ability；若无配置“skills”属性的ability，则取“mainElement”指定的ability（该ability需存在于“abilities”数组内）；若“mainElement”未指定，则取“abilities”数组内的第一个ability。
                
                ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.04480816525387713810749590819966:50001231000000:2800:0547D951C3EC08A7F2CAABC802F6D95A615414753C4B82E84CC9E1D737483476.png "点击放大")
                
            - FA模型：config.json文件中配置了“skills”属性的第一个ability；若无配置“skills”属性的ability，则取“mainAbility”指定的ability（该ability需存在于“abilities”数组内）；若“mainAbility”未指定，则取“abilities”数组内的第一个ability。
        - Specified Ability：工程中的UIAbility或ExtensionAbility。
            
            您可以在工程中添加UIAbility或ExtensionAbility，详细请查看[UIAbility开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability)或[ExtensionAbility开发指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/extensionability-overview)。
            
            ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.65128779760145425078448889561437:50001231000000:2800:6A747DCA4A0EB077B08566E5D6BEE726D55541EB7148F3358E4B4240A5678F04.png)
            
        
    - Launch Flags：输入aa start命令相关的选项，请参见[aa start 参数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/aa-tool)。

### 配置环境变量

如果开发者需要配置和管理应用开发环境，以及控制应用程序的行为，可在“Environment Variables”下配置环境变量。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.30970569447322836205653731312493:50001231000000:2800:2C02C2E017B9CC47CC3395ECA33489428F0DF66BFD2D5E9E410D89FFECD8B4BF.png)

点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.82780400681684534511177911710160:50001231000000:2800:66BF9914FF5AB9BC4D89FCEA38E70BFA9FF23C4A0F2F04B7261D5317DD6E4827.png)按钮，新增一行配置项。当前支持以下配置项：

- ASAN_OPTIONS：在运行时配置ASan的行为，包括设置检测级别、输出格式、内存错误报告的详细程度等，具体可配置的value请参见[配置参数](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-asan-detection#section1496994494018)。若开发者未配置log_exe_name、abort_on_error，DevEco Studio将自动填充。ASAN_OPTIONS是应用级别的，只在entry和feature模块中配置生效，HAR/HSP模块配置不生效。

说明

当配置Environment Variables后，“Keep Application Data”覆盖安装不生效。

环境变量配置完成后，需确保环境变量已勾选，勾选后点击**Apply**才可生效。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.25039853754113841696293631651571:50001231000000:2800:F4E8FE6AF731A6D0B4ABC38B1C338C0FFCB82EAB8832BC9DA22C7639FD421932.png)

## 自动映射WebView调试链接

当应用中含有需要调试的WebView组件页面时，可以通过浏览器的DevTools工具进行页面调试，具体可参考[使用DevTools工具调试前端页面](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-debugging-with-devtools)。调试WebView组件需要执行转发端口等繁琐的命令行操作，因此可以在DevEco Studio中勾选**Auto WebView Debug**，该操作会在应用启动后两分钟内自动监听可调试的WebView进程并完成端口转发。

该功能从DevEco Studio 5.0.5 Release版本开始支持。

设置方法如下：

单击**Run** **>** **Edit Configurations**，在**General**中，勾选**Auto WebView Debug**。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.94221597650603452178208899112725:50001231000000:2800:4BFE7311A9B1DC6072479168297B47CE0BAF9C1AFA1409B7FDC7798865AF6FD4.png "点击放大")

开启后，当检测到设备上有可调试的WebView组件进程时，会在Run面板中打印转发成功的端口，通过浏览器的Devtools工具连接该端口即可进行WebView调试。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.44462028095046506240721416514463:50001231000000:2800:55F91278E90164B9B2F061E7DEC4A39E7BBDAFDDFB65150369E95B1ECAFD7941.png)

## 多模块调试

### 安装多个模块

如果一个工程中同一个设备存在多个模块（如存在entry和feature模块），且存在模块间的调用时，在调试阶段需要同时安装多个模块的Hap包到设备中。此时，需要在**Deploy Multi Hap****/Hsp**中选择多个模块，启动调试时，DevEco Studio会将所有的模块都安装到设备上。

设置方法如下：

单击**Run > Edit Configurations**，在**Deploy Multi Hap****/Hsp**中，勾选**Deploy Multi Hap/Hsp Packages**，选择多个模块。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155821.50163144208524608556194159884070:50001231000000:2800:07DEB52E49F2D2F775B9308955A2EADCD2AE1C226A2F378C28B9E9C999488E3C.png)

### 自动安装依赖

如果一个工程中entry/feature/HSP模块直接依赖其他HAR/HSP模块（如entry模块依赖HSP模块）及间接依赖其他模块（如entry模块依赖HAR模块，HAR又依赖HSP模块）时，在调试阶段需要同时安装模块包及其所有依赖模块的包到设备中。此时，可以设置**Auto Dependencies**，启动调试时会自动将所有依赖的模块都安装到设备上。

设置方法如下：

单击**Run > Edit Configurations**，在**General**中，勾选**Auto Dependencies。**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.06163934810153526709658630706023:50001231000000:2800:36088F5EA79856FBD8D88771425D018868372DF45A1F2310DB61305C282A0F44.png)

在Before launch窗格中，您可以点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.26864856257750150952842881501496:50001231000000:2800:FDF37D33CC1F2F9E51A6CAFD269420798B92E4A22D3128C2C57E79F2572ACF1C.png)添加应用启动前的任务。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.94909566054396204065295264489032:50001231000000:2800:C43D9C72D5AFA8597C2EBD3F24B9D986B657CBDA1EFEF9861C480E3337B250C2.png)

也可以点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.95382109327572886916402550475459:50001231000000:2800:CFB47A926B1929990D684E6A33121B56B5C1E7E4C711C4165CE59D3CF7E1E9A3.png)移除任务。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.18631082489496593260295236017906:50001231000000:2800:78E5D80A168EDFBBDB044278A89B2B41F67F22943134DB0EFB89A7134CA584CB.png)

在勾选**Auto Dependencies**后，可以同时勾选**Deploy Multi Hap Packages**，从而达到推送所有包的效果。

[调试概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-device "调试概述")

[代码调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-debugging "代码调试")
# debug启动调试

更新时间: 2025-12-16 15:58

可以按照如下方式启动调试会话。

1. 如果需要设置断点调试，找到需要暂停的代码片段，点击该代码行的左侧边线，或将光标置于该行上并按Ctrl + F8（macOS为Command+F8）。如果无法添加断点，请查看FAQ[调试过程中无法添加断点](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-1)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.05299777397374082579247343096400:50001231000000:2800:38CF8CE78DBF04B224896C73B0753DCB85B989DD8A24BA6F1E89C085131636ED.png)
    
    设置断点后，调试能够在正确的断点处中断，并高亮显示该行。
    
2. 在设备选择框中，选择调试的设备。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.03410820868565388458511772403303:50001231000000:2800:E8769E07B8B0BE8F77D503930551E82234EC807336270980DA7F575D5DA0D81A.png)
    
3. 选择启动调试的配置，在模块选择框中选择需要调试的模块。也可以通过Edit Configurations[配置调试参数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-debug-configurations)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.71656565328467857741635323132142:50001231000000:2800:83C56FDB4B3910D558747AC5B057F621F38B29BBD90B82D16CA1EA3A4BD1E761.png)
    
4. 在工具栏中，单击Debug![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.57361355233592870985523029804645:50001231000000:2800:E71B87963582EF5FA51D6C4231F5051AB34940587D4EFCFC09F11C201B25765B.png)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.24942311262787797481165400491344:50001231000000:2800:221CAA7980CE67915CB5C655E9CFC8F90E2D356B45331D5AE24655D3E92E84F5.png)
    
    或者在工具栏中Run中选择Debug。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.83452694149875753721960888915490:50001231000000:2800:370B5A6EBE3E63F6CFBC845B2747C6049517275F44C43A52B4B5A3D9FFAAD07E.png)
    
5. 启动调试后，开发者可以通过[调试器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-debugger)进行代码调试。
    
    如有断点会在断点处高亮，并展示当前断点处的Frames和Variables。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.80116522823953581565568871305731:50001231000000:2800:C1AA91C7C8D0F94D794475E57286671A2D6D23AD4DFABD47A7ABE790E64863BB.png)
    

[调试场景说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-worker-taskpool "调试场景说明")

[attach启动调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-attach "attach启动调试")
# attach启动调试

更新时间: 2025-12-16 15:58

开发者也可以通过将调试程序attach到已运行的应用进行调试。

Attach Debugger和Debug的区别在于，Attach Debugger to Process可以先运行应用/元服务，然后再启动调试，或者直接启动设备上已安装的应用/元服务进行调试；而Debug是直接运行应用/元服务后立即启动调试。

## 前提条件

当前设备上被attach的应用代码和本地代码一致，且已提前进行构建生成必要的sourcemap文件。

## 使用约束

attach不支持的场景：

- 本地无源码。
- bundleName不匹配，将出现提示“The selected process does not match the bundlename of the current project!”，但不阻塞调试过程。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.73114077481453860636043888071662:50001231000000:2800:67DCA4CE21A0A76A819FC2994C7371F42B5358777505847BF5B74F8EE4C1E24F.png)
    

## 操作步骤

1. 在工具栏中，选择调试的设备，并单击**Attach Debugger to Process**![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.63044477518507369580277560067463:50001231000000:2800:5FDB2F964452655290CB98340D29C6E719535DC636D1AE3EC2CBCF16A384E509.png)启动调试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.91767915884664381134309666580988:50001231000000:2800:8A5D7B0D0CF8054226A5316A764B45057E80DC3E02FF6835FAE7CD3F4C84EB19.png)
    
2. 选择要调试的设备及应用进程，若应用bundlename与当前工程不一致，则需勾选Show all process。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.78603556288453363264571603394435:50001231000000:2800:4FB95B7CAFC5746B5A4DF2BE5440A3B72701BF59C71028D00213DCF0D471E410.png)
    
3. 选择需要使用的调试配置，或者使用默认配置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.82226769181215697777030686884832:50001231000000:2800:3AA3F0FD99B0FD4091FE317A58D6D326440A157AE803CC6DC2D5CF37653CA42E.png)
    
4. 选择需要调试的Debug type，若选择已创建的Run/Debug configuration进行attach调试，此时Debug type不可改变，只可在Run/Debug configuration界面修改。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.40695505433580850783724399851468:50001231000000:2800:3DEC5A38074055105CC51B86DE1FC0569CD2D281772C7CA6A007BF024B0B000A.png)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.39799376376528067338797915891644:50001231000000:2800:A7880BF1C44B2F2E7B24C1E61EF6A961BF1B95C3AC076D6FEE3BE41841CE5F8A.png)
    
5. 点击**OK**开始attach调试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.96912355714447237326032407246070:50001231000000:2800:A81F886E88F948C354F52FD403972796DC3F2923D563E5DFD6273FEA8088348E.png)
    

[debug启动调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-debug "debug启动调试")

[等待调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-attach-to-process "等待调试")
# 等待调试

更新时间: 2025-12-16 15:59

开发者可以通过将某个应用设置为“等待调试模式”，然后当开发者需要对应用进行调试时，拉起应用即可快速进入调试。

说明

- 应用设置为“等待调试模式”后，此时如果启动普通的debug调试，将会取消当前的等待调试模式。
- 设置“等待调试模式”前，需要将应用安装到设备上。

## 操作步骤

1. 在设备选择框中选择调试的设备，并单击Run > Attach to Process by Name。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.24050862801663983981898518211948:50001231000000:2800:F7378ECED829A79727C635A35FA415D8D51055BF3480FEE56BC09D0AF53911C6.png)
    
2. 选择需要设置为“等待调试模式”的应用（默认为当前工程），选择需要进行调试的调试类型。然后单击**Attach**，即可将该应用设置为“等待调试模式”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.16290623798309468020383080041823:50001231000000:2800:37F0899A02BE87A7494854929CF38B8FCA08B4109FAAC8F7A68A9CC873DD568C.png)
    
    此时会在DevEco Studio底部显示一个等待进度条，在应用被拉起之前，将一直处于等待状态。可通过进度条右侧的取消按钮进行取消。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.09706864972044916101854289974597:50001231000000:2800:823EF6DFBB7C25685710605378AAA2B84051DF228BA243D1DA3A63DC4BD01861.png)
    
3. 拉起设备端应用，此时将会进入调试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.11277678297905734708238427087795:50001231000000:2800:11BB8DDBB39EEF4D2C2EB03CB0C06345AB7AAD710F38A633A41741DCB40E98F5.png)
    

[attach启动调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-attach "attach启动调试")

[使用断点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-breakpoint "使用断点")
# 使用断点

更新时间: 2025-12-16 15:59

DevEco Studio ArkTS支持行断点、日志断点等多种不同类型的断点，这些断点可以触发不同的操作。

## 行断点

行断点是最常见的类型，用于在指定的代码行暂停应用的执行，在暂停时，您可以检查变量，对表达式求值，然后逐行执行，以确定运行时错误的原因。

如需添加行断点，请按以下步骤操作：

1. 找到您要暂停执行的代码行。
2. 点击该代码行的左侧边线，或将光标置于该行上并按**Ctrl + F8**（macOS为**Command+F8**）。
    
    当您设置断点时，相应的代码行旁边会出现一个红点，如图。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.66041234803610472673702907223668:50001231000000:2800:CCFC82ED1F65018EC66D5B38B4356631321F1D5EAC9C51316B7593E2608A670D.png)
    
    在设置的断点红点处，单击鼠标右键，在Condition中可以设置条件断点，此类断点仅会在满足特定条件时才会暂停应用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.44508183694538623887355544488469:50001231000000:2800:AB5555168BEF46FE938786F242923A613C3DBE2729CA21AADD3D93DF5BD5C718.png)
    
3. 点击Debug图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.71746235248221745541025608805587:50001231000000:2800:E972DE51E99AEEDB7DE5C9C6A4210891969C4AEF8221E20569ACDD27223B635A.png)，开始调试。如果您的应用已经在运行，请点击Attach Debugger to Process图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.24269294883831650157347293798583:50001231000000:2800:B11CD519814FB49F5F58395A3CABC2FDE133A804BF2C0FF269D5F874D273EC21.png)。
    
    当应用运行到代码处，会在代码处停住，并高亮显示。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.62785492361745841173516273834797:50001231000000:2800:3A8EBD81422BC9E8D873E0EE36CBF3801AE866B311F2C0CF32EE12BCD85EC4A2.png)
    

## 日志断点

在[BreakPoints](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-breakpoint#section168791742202819)某个断点的配置中，勾选以下类型的Log，可以使进程运行到断点时在Console窗口打印相应日志。

- 勾选**"Breakpoint hit"message**，程序运行到断点时，打印“Breakpoint reached”。
- 勾选**Stack trace**，程序运行到断点时，打印当前线程的堆栈。
- 勾选**Evaluate and log**，并添加表达式，程序运行到断点时，打印表达式的值。

说明

未勾选Enable的断点不会打印日志，未勾选Suspend execution的断点会打印日志，不满足所设置的Condition的断点不会打印日志。

## 临时断点

在[BreakPoints](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-breakpoint#section168791742202819)某个断点的配置中，勾选**Remove once hit**，该断点只生效一次，生效后该断点会被删除。

## 函数断点

从DevEco Studio 6.0.0 Beta2版本开始，支持在ArkTS代码中设置函数断点。

函数断点也叫方法断点或符号断点，使用函数名设置断点，当程序运行到对应函数时，中断进程。

在[BreakPoints](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-breakpoint#section168791742202819)中，点击**+ > ArkTS Symbolic Breakpoints**，在弹出窗口中填写函数名，添加函数断点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.25117331778974769211194958759464:50001231000000:2800:2BCF9F6B089A1592914D1CE9A14848953BFBE8628CD143F90A8639EA85435629.png) ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.12291682907223484147727742485433:50001231000000:2800:89FB724B626E5DFDBB8C5ECBADF3703771959FC1B0B9A24B32A6E100CED4362B.png)

说明

调试过程中如果命中在C++断点，则无法添加和移除ArkTS函数断点。

## 异常断点

异常断点会在应用执行时发生异常的地方暂停应用。

在[BreakPoints](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-breakpoint#section168791742202819)中，勾选**ArkTS/Js Exception Breakpoints**，开启异常断点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.43361606843815735145420178895973:50001231000000:2800:15BAF8B0D191F32CA436F9F7CBDFFDD125B384B7D87703ED607DEE873589C62D.png)

当调试应用程序中出现异常时，会在异常处高亮，并且代码左侧有![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155900.68052918347596524587840091276148:50001231000000:2800:23E571DB25B12FC5227AB7D56546129CCE6A80A4829C493E85691B03AA773EE8.png)标志，并展示当前Frames和Variable，以及错误信息。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155901.47750188718130393145352030065497:50001231000000:2800:5AE1C8F7B1B7502B5A92222A70C3AA681038DB76148F5FDBC7F064D8C29F061F.png)

## 断点管理

在设置的程序断点红点处，单击鼠标右键。然后单击**More**或按快捷键**Ctrl+Shift+F8**（macOS为**Shift+Command+F8**），可以管理断点。

或者在“Debug”窗口中点击**View Breakpoints** 图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155901.12364719037888770449655845620744:50001231000000:2800:9C3BBC6E8B1215BE83E266F7811C6D752DCA94F0AEAD47CE1D660CE3F256C530.png)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155901.74486975530343838900189854100458:50001231000000:2800:29B44F68F61BC97A97EA623A6783254CEAF60549CF6F699B2EE934D75FFC3B8F.png)

[等待调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-attach-to-process "等待调试")

[检查变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-variables "检查变量")
# 检查变量

更新时间: 2025-12-16 15:59

当应用停止在某个断点处时，您可以在"Debugger"窗口中查看当前的变量信息。当您在"Frame"窗格中选择某个帧之后，您可以在"Variable"窗格中检查变量。此外您还可以通过对变量进行计算。

如需向"Watches"列表中添加变量或表达式，请按以下步骤操作：在"Watches"窗口中输入表达式，然后点击Add to Watches 图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155901.08955024178086582616085180484050:50001231000000:2800:BD2AD12B63C391DAD70827DEBDA20D6D8D4BBC61EF9A0AB8C19834D32B5513C9.png)。

如需从"Watches"列表中移除某一项，点击鼠标右键，选择Remove Watches。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155901.93903102895767797385866849787611:50001231000000:2800:A13312BBCB91D342EB243DF3B1ACAC42B1B54CFBF26F9ADBA1B71D47B783E7F7.png)

[使用断点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-breakpoint "使用断点")

[反向调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-reverse "反向调试")
# 智能步入

更新时间: 2025-12-16 15:59

当编辑器上一行存在多个函数嵌套或调用时，开发者可以通过Smart Step Into的能力来步入到想要调试的函数内，如果在调试时想跳过某些文件，也可以自定义需要跳过的文件列表。

## 智能步入

1. 启动调试，如果断点所在的一行内存在多个方法调用，可以通过点击调试窗口的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155904.83721633853366279294288781854850:50001231000000:2800:7CC57D1799D04E0DF0612A1BC8C028F243D613496CCDB16D17B93E9F16A5252A.png)按钮或快捷键Shift + F7高亮展示可进入函数。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155904.41778122247500852307386029870605:50001231000000:2800:89BF4A9BF8C54129E162BA321FCFF74186E353932562A1E8ECD9E9BFFD41C4DD.png)
    
2. 点击其中一个函数即可步入。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155904.00971713803704502925397431442230:50001231000000:2800:DC4B304C7D94276499128A6A2814DF4D8C91E2EC5B061444B22C85C0A86ABA31.png)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155904.44220051720765874241716281347130:50001231000000:2800:932AD74DC2A377F8762C4940D74B488CEA13E3B609BA56A0DB53F4201FA39CF0.png)
    

## 过滤脚本文件

1. 点击**File > Settings**（macOS为**DevEco Studio > Preferences/Settings**） **>** **Build, Execution, Deployment > Debugger > Stepping**，勾选**Do not step into ArkTs scripts**， 可在调试时禁止智能步入某些脚本。使用工具栏按钮管理要跳过的脚本列表。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155904.53834438657326144479130705646258:50001231000000:2800:D115E762210F2575A138E14B8B18686593FA84BD87D7DF0917946B6DC3D0995B.png)
    
2. 单击 **+** 按钮可添加新的脚本过滤器。在打开的对话框中，输入要跳过的文件名称或使用通配符。例如，如果要始终跳过 JavaScript文件，请输入 *.js。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155904.20899738946813706683989464005347:50001231000000:2800:209E6363D100AB8DC5FA6E7B0AFB5C35D194E5093C0562ED10DFF00E1FED8182.png)
    

[打印表达式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-evaluate-log "打印表达式")

[查看异步函数堆栈](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-async-stack-traces "查看异步函数堆栈")
# 启动调试

更新时间: 2025-12-16 15:58

Native代码调试依赖LLDB调试器，关于LLDB调试器的介绍请参考[LLDB高性能调试器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/debug-lldb)。

在启动调试前，点击**Run > Edit Configurations**打开调试配置界面，在**Debugger**页签选择**Debug type**为Dual (ArkTS/JS + Native) 、Native 或Detect Automatically，设置调试代码类型为C/C++。

说明

- Detect Automatically类型会根据当前工程是否为native工程判断是否启动native调试。

- 如果调试时启用编译器优化，增加编译优化选项或使用[release编译模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)等，编译器会对编译后的汇编指令进行更改，从而使得代码运行更加高效。但优化后的指令难以与原始代码形成映射关系，可能会导致在调试的过程中出现异常或错误信息，例如局部变量信息被删除、无法正确跳转到期望的代码行等。因此，在调试的过程中需要关闭编译优化选项或者使用debug编译模式，避免因优化而导致的异常。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155853.85719001364658089476140931366606:50001231000000:2800:5271D07D3D8A6F7343502FB300DDF7483839AAA70004150651B168545F45FEA2.png)

**Debugger**页签中还支持自定义以下配置：

- **查看静态/全局变量：**勾选**Show static/global variables in the Variables Pane**，调试过程中变量列表会展示静态/全局变量。
- **符号表路径：**在**Symbol Directories**页签，点击**+**，可以添加符号表路径，即带有调试信息的so库。例如，您可以先编译带有调试信息的so库，然后将其调试信息裁减掉，在设备侧运行无调试信息的so库，调试时将带有调试信息的so库路径添加在这里，可以实现对该so库的调试。
- **预设调试器命令：**在**LLDB Startup Commands**页签和**LLDB Post Attach Commands**页签中预设lldb命令。在**LLDB Startup Commands**页签中的命令会在LLDB调试器启动之后立即执行，在**LLDB Post Attach Commands**页签中的命令会在LLDB调试器成功attach到进程之后执行。
    

配置完成后可启动Native代码调试，支持debug和attach模式启动调试，详细内容可参考[debug启动调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-debug)或[attach启动调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-arkts-attach)章节。

[Native代码调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-native "Native代码调试")

[使用断点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-native-breakpoint "使用断点")
# 使用断点

更新时间: 2025-12-16 15:58

点击**View Breakpoints** 图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.31719789399837380096688363459589:50001231000000:2800:6483401FAD7DC79CA84035552982D2AFFF0C10EECF26E3CBC444275353B0888F.png)可以打开断点管理界面，您可以在断点管理界面查看或更改您的断点。

- 勾选 Enable ，使能该断点。
- 勾选 Suspend execution ，使程序运行到断点时中断。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.58683832793066325456503711151067:50001231000000:2800:3555BB9FBBD262464A2C31C57ACDA7296844CDFB1D8DFF0ABFF04ABAF4C2C820.png)

## 条件断点

在某个断点的配置中，勾选 Condition ，并设置表达式作为条件，使程序运行到断点且满足设置的条件时才会中断进程。

## 日志断点

在某个断点的配置中，勾选以下类型的log，可以使进程运行到断点时在 console 窗口打印相应 log。

- 勾选“Breakpoint hit”message，程序运行到断点时，打印“Breakpoint reached”。
- 勾选 Stack trace，程序运行到断点时，打印当前线程的堆栈。
- 勾选 Evaluate and log，并添加表达式，程序运行到断点时，打印表达式的值。

说明

未勾选 Enable 的断点不会打印日志，未勾选 Suspend execution 的断点会打印日志，不满足所设置的 Condition 的断点不会打印日志。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.49521885036487076527077780953249:50001231000000:2800:115603371879108A3521FB347944F9329E72CAAF992C33FB7223DD9F2E9F5013.png)

## 临时断点

在某个断点的配置中，勾选 Remove once hit，该断点只生效一次，生效后该断点会被删除。

## 函数断点

也叫方法断点或符号断点，使用函数名设置断点，当程序运行到对应函数时，中断进程。

在断点管理界面中点击“+”->“Cpp Symbolic Breakpoints”，在弹出窗口中填写函数名和模块名（模块名可缺省），添加函数断点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.61335186504332180957496487615350:50001231000000:2800:4D5EED29C65B1B256DDAE6D56FF1DEF547A733A744A68F1D9A0DC0DFBA910666.png)

## 异常断点

异常断点可以使程序运行到抛异常或捕获异常的代码处停住。

说明

其他系统异常，如 SIGSEGV 等信号量异常会默认捕获并中断进程。

在断点管理界面中点选 “Cpp Exception Breakpoints” 下的 “Any exception”，勾选 Enable 使能异常断点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.95510098359798297711045449567350:50001231000000:2800:EA786C622C1B3B56C1DB5850694005489C8DA56F3E89CF9BBE978BF5D3AE486C.png)

## 数据断点

支持三种类型的数据断点，即变量被读、被写、被读写时中断进程。

在变量列表中对某一个变量右键，在菜单中选择添加数据断点。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.63659187239666251517155055320086:50001231000000:2800:82CE7AE7DE6DD7B7B0598A2E56E8F4F06EA375B7DC9549C8866292C238DD017A.png)

在断点管理界面进行查看和修改。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.08632548067836614609716546377862:50001231000000:2800:E2A4A3560E2A2CD85B51C9D32FCF7738FFE4DA85DC23FFD47AC3D635D90AD6EC.png)

说明

1. 数据断点支持的类型受硬件限制，支持设置数据断点的变量类型 size 不能超过硬件支持的范围；
2. 受硬件限制，最多同时设置 2 个数据断点；
3. 对局部变量设置的数据断点，需要在离开作用域时手动删除，否则会由于变量地址被重用导致进程中断。

[启动调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-native-enable "启动调试")

[检查变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-native-variables "检查变量")
# 检查变量

更新时间: 2025-12-16 15:58

调试时，在“Variables”页面查看变量，支持查看全局/静态变量、寄存器变量和局部变量。

## 查看全局/静态变量

点击“Edit Configurations...”打开调试配置，在 native 调试配置界面中勾选“Show static/global variables in the Variables Pane”，调试过程中变量列表会展示全局/静态变量。

## Simplify STL

在菜单栏点击“File > Settings（macOS为DevEco Studio > Preferences/Settings） > Build, Execution, Deployment > Debugger > C++ Debugger”，通过勾选“Display STL variables as visualization in the Variables Pane”在变量列表中展示简化后的 STL 变量值，或去掉勾选以展示其原始结构。

## 变量监视

在"Watches"列表中输入表达式，然后点击Add to Watches 图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.25080539865442102074782396034210:50001231000000:2800:2F629799201E3B9815C0D3B50E4CF7EBC2B1DDF52BD5753A06E2A718F596ADBB.png)，或在某个变量右键菜单中的“Add to Watches”添加监视的表达式，在每次程序停住之后会计算表达式的值。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.26402104392734593690035601369638:50001231000000:2800:88F726F16E56EF68E195FB930D7169BFEA39ACF285B1CB47AF48D90A8582B37A.png)

## 表达式求值

通过点击“Evaluate Expression...”按钮，或Watches 页面中的输入行中，输入表达式进行计算。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.81680174618710159388330145539094:50001231000000:2800:48C16C95DD386ECE0C951A93EE5690B2649846F26E193131455498DE1CD779C8.png)

## 查看十六进制视图

在“Variables”页面点击鼠标右键，弹出框中选择“Show As Hex Values”，此时页面中的整型变量会以十六进制进行展示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.42996152328753386732972108316490:50001231000000:2800:731BD1C03226A8053302181270A19CF0B2A08EA65AE90AE431BCEB48D644A974.png)

## 查看函数返回值

当使用“Step Out”从一个函数内步出后，变量列表中的“ReturnValues”会展示所步出函数的返回值。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.48070080590575625797176486844698:50001231000000:2800:0C911E3C223B5ACC6D4C7ED9D250664785817EBEAE8E3E81496A230A5E001AAC.png)

说明

- 无法查看长度超过64位的数据结构。
- 无法查看引用类型返回值。
- Step Out返回的位置存在断点时，无法查看函数返回值。

## 其他说明

对于特定类型的变量，还支持查看bitmap预览、查看较长的字符串等功能。

- ...View Bitmap：支持在调试时查看bitmap预览。

- ...View：支持展开查看较长的字符串。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155859.58996109801295554274191879491578:50001231000000:2800:5F23F5E9B44149D61F6E6352803123A223D9F0669B054776EE988386DE2B7C6A.png)

[使用断点](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-native-breakpoint "使用断点")

[汇编调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-native-disassembly "汇编调试")
# 开发者选项

更新时间: 2025-12-16 15:58

HarmonyOS系统上的“设置”包含开发者选项的界面，用于辅助HarmonyOS应用程序开发、测试及优化，面向开发人员提供商业发行版之外的功能（如API能力），提供更多的调试选项及能力；您可在该界面中通过配置选项来帮助您分析和调试应用，例如，您可以通过启用USB/无线调试进行应用调试、开启DFX稳定性相关选项获取更多应用的故障及性能信息、开启过度绘制等选项快速发现性能问题等等。

## 启用开发者选项

在Phone或Tablet上查看**设置 > 系统**中**开发者选项**是否存在，如果不存在，可在**设置 > _具体的设备名称_**中，连续七次单击**软件版本**，直到提示“开启开发者选项”，点击**确认开启**后输入PIN码（如果已设置），设备将自动重启，请等待设备完成重启。

## 禁用开发者选项

在Phone或Tablet上点击**设置 > 系统** **> 开发者选项**，关闭开发者选项开关，弹出提示框后点击确认关闭，设备会自动重启。

## 常规选项

- **充电温度限制**：防止手机充电时过热，用于对充电温度进行严格控制。
- **系统回退**：支持开发者将终端设备从HarmonyOS NEXT回退到HarmonyOS。

## 调试

- **USB调试**：如果开发者希望通过计算机侧命令对移动设备进行调测，需要启用USB调试，同时通过设备授权确认。开启并授权后，HarmonyOS设备才能连接到计算机进行调试，可用于在计算机和设备之间复制数据、在设备上安装或卸载调试应用、以及读取日志数据等。

- **无线调试**：通过Wi-Fi进行设备连接从而实现设备的调测，在开启无线调试后，可以查看设备的IP地址和端口，通过[DevEco Studio或hdc命令](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-device#section9315596477)进行设备连接。使用过程中需要确保您的设备与计算机在同一个Wi-Fi网络中，初次连接需要进行设备授权确认。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.11927119291776080171020431845205:50001231000000:2800:843931B00F37A9EED0D95C4AFE8406FE50AA234EA7D6A7B5EC1810E3A9FD38AC.png "点击放大")
    
- 清除受信任设备：针对之前授权过的所有计算机，撤销USB/无线调试的访问权限。

DFX稳定性配置选项包括：

- **系统trace跟踪**：可以将系统采集的trace落盘到本地文件，便于本地问题定位及故障上报。
- **冻屏信息日志**：稳定性在故障时会生成稳定性日志，提供更详细的日志信息。
- **系统资源泄漏日志**：稳定性在故障时会生成内存相关日志，用于定位资源泄漏问题，提供更详细的日志信息。

其他调试选项包括：

- **意图框架调试**：方便开发者在设备上验证意图框架，可以关闭部分校验机制并直接显示最近使用的意图。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.81773234257242762208488156114633:50001231000000:2800:5DC3026545CAB82E7C1E259DF6EC2D00B3D3B5E3818B84CD3D176EC12F84E634.png "点击放大")
    
- **显示刷新频率**：刷新频率是指显示器每秒钟更新画面的次数，可在屏幕左上方显示刷新率档位和RenderService实时帧率，更好地了解设备性能和屏幕表现，从而进行针对性的优化或调整。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.16621699820060918222544913433875:50001231000000:2800:BA21BCFE3BE280598FC98CD2D69C6BF79D236FDCDA3AAEA33DA63AB8EC56C0D1.png "点击放大")
    
- **关闭充电**：连接USB后默认充电，如果开发者希望不充电，需手动打开开关，插拔USB后可恢复默认充电状态。

## 网络

- **网络领航员**：开启网络领航员后，开发者可以选择预置的网络模拟场景或者自定义网络模拟场景进行网络验证，提升APP体验的测试及验证效率，具体使用方式请参考[网络领航员](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/network-navigator)。

## 输入

- **显示触摸操作：**开启开关后，当用户触摸屏幕时, 会有一个小圆点跟随手指移动，显示用户的触摸动作。
- **指针位置：**开启指针位置后，屏幕上会出现十字准线，可以显示指针（点按）位置。屏幕上方会显示一个条形，用于跟踪十字准线的坐标。移动指针时，该条形中的坐标会跟踪十字准线位置，且屏幕上会绘制出指针路径。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.58559922511969630330930933409484:50001231000000:2800:3770113E884DB1193C56BFA8A841E2CD6FE60FF85DB26BF3E7221963A0231A26.png "点击放大")
    

## 绘图

- **显示布局边界**：开启后可以显示应用的裁剪边界、外边距和设备上的其他界面结构，方便开发者查看控件布局、空白空隙及控件重叠等问题。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.57969270680465282979408242145298:50001231000000:2800:FBAB60B097F8CC19F5504736FC4A1936D23957F791D5887ED7D7631A7581AE30.png)
    

- **显示重绘刷新区域**：当点击、滚动屏幕或者系统自动刷新使得屏幕上的某块区域重新绘制时，该区域突出显示。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.27548776010297609318374738463235:50001231000000:2800:AA5E72FF738D8E70E2A36F64F978860E255BBD77772EAF477646D5C3F7715114.png)
    
- **缓存是否命中检测**：在一些属性动画的场景下，您可以使用renderGroup缓存提升属性动画性能；开启选项后，检测缓存未命中的场景，通过颜色标识。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.26268726514423388149327053529621:50001231000000:2800:B9DA1FAF907B567A613C2A738F5DE3A1D0C2E456D7968C86054CA6EF7B7BF6A1.png "点击放大")
    
- **过度绘制检测**：显示设备上的颜色编码，以便可视化相同像素在同一帧中绘制的次数，可视化会显示应用可能在哪里进行了不必要的渲染。过度绘制的程度可以通过颜色来表示。
- **过渡动画缩放**：设置过渡动画播放速度，便于开发者查看不同速度下的性能。缩放越小，速度越快。

## 应用

- **开发中元服务豁免管控**：嵌入式运行元服务能力默认是受限的，需要开发者申请权限才能使用。如果在申请权限之前的开发调试阶段想临时开启权限，可以通过开启本选项获取调试嵌入式元服务的权限。

[Hot Reload](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hot-reload "Hot Reload")

[布局分析](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arkui-inspector "布局分析")
# 布局分析

更新时间: 2025-12-16 15:58

开发者可以使用ArkUI Inspector，在DevEco Studio上查看应用在真机上的UI显示效果，并通过查看多次操作后的界面状态，快速分析定位UI界面存在的问题。

ArkUI Inspector支持的功能包括：

- 查看设备上应用的UI显示效果。
- 导出及导入应用UI界面快照，脱离设备查看UI显示效果。
- 在组件树上选择组件，UI界面自动框选对应组件，属性列表显示当前组件的属性信息。
- 在UI界面点击选择组件，组件树对应组件变化为选中状态，属性列表显示当前组件的属性信息。
- UI组件源码跳转，选中UI组件后点击源码跳转按钮即可跳转至源码位置。
- 在UI界面上选择Show Component Border，可查看当前页面上所有组件显示区域。
- 在组件树上选择自定义组件，属性列表显示当前组件配置的状态变量信息以及影响组件。
- 按照组件粒度3D展开应用，方便查看组件之间的嵌套、遮挡关系。

## 使用场景

针对界面较复杂的应用：

- 通过组件树查看组件的父子关系，检查是否存在冗余组件。
- 针对应用在真机或模拟器上运行出现UI界面显示异常，尤其经过多次界面复杂操作后产生的界面错误以及后台逻辑错误，进行问题分析定位。

## 使用约束

- 仅运行在前台的应用支持Inspector查看。
- 已通过USB或WLAN连接设备。
- 仅支持Stage工程。
- 仅支持全屏应用或者焦点在前台的窗口。
- 不支持应用市场上架的商用签名应用。

## 操作步骤

1. 在DevEco Studio下方点击**ArkUI Inspector**，打开ArkUI Inspector。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.44904173516017131412722663949599:50001231000000:2800:35C636689134E84343183DFEB6E9F2FCAAF40E6686D37E28CFD4913D5B6B8155.png)
    
2. 点击RUN![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.52997774335073682124856061942007:50001231000000:2800:44B0FA640858B53591778F7B5437841A7B90BD5098B52A69B173846440E9E32F.png)或者DEBUG![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.35156370534972925835627684911275:50001231000000:2800:524D719369BB0FAE34A441F616361F85CC5AA4FEB877CDFD65EFE3C4114587BD.png)按钮，将应用推包到设备上，在设备应用列表选择当前显示在设备前端的UI进程。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.03206796260568088352242594489079:50001231000000:2800:B1EF2C2E67108DA2FFC5940F4620E736F21EE9D5A3389A0189D5A294AC5E3D32.png)
    
3. ArkUI Inspector左侧为当前的组件树结构，中间栏显示当前设备的UI界面，右侧在选中组件的情况下为当前组件的属性信息。可以在左侧组件树上或在中间UI界面点击选择组件。当设备上UI发生变化时，可点击中间栏右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.18918526689863328371101462182968:50001231000000:2800:685145FEB324F73E27B6CD119471C3B9257413F63D8ED3515821A2027C9A1E76.png)按钮同步设备上的UI效果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.47493625358251712676705311256470:50001231000000:2800:3656E6D5A3DFF7E6CA0F6662751A177DC76A672702BBFE231D6CD7719B676899.png)
    
4. 在设备框，点击设备列表的最后一项**Stop inspector**，可断开与设备的连接。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.22328912251936632499171064511838:50001231000000:2800:6B980F52CF72A037CEC13043EA0F5BA9E16D6B20182B236D2FA312E2223235D4.png)
    

## 显示组件信息

- 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.23117530886231776888028191325519:50001231000000:2800:886148A1E38514961F09918C8F9F9F6F7165225AD3801A13A2D15D737E5106E9.png)，勾选**Show Tree Statistics**，可显示组件树组件信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.25832555001216170681536735947901:50001231000000:2800:1708CFDF10999F688B419C1073C030A472CA3E6610592E472D2CFD2EDE3DAE23.png)
    
- 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.75568552679935444051898101813516:50001231000000:2800:631920121653E177E993335D1CA73661F7B178EFCE73C30DA98FDDED454C1028.png)，勾选**Show Hidden Components**，可显示隐藏的组件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.04247680534793792600076314552049:50001231000000:2800:F5195E5B1E7F45A1C8297A86B611AB241AB96774DB4BD6C32A5848A134E00754.png)
    
- 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.50598708685659175944302126217606:50001231000000:2800:A9B7C2CFA6754420A649596D10F24BC9DBF5FC3F4056F58BDC7EF8C99AE7F629.png)，勾选**Show Custom Components**，可过滤自定义组件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.79792075252592340939755978928885:50001231000000:2800:6559582D7F9F7A1D527E14C5CBB8F366A298787DF19404447B9EB84650520286.png)
    
- 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.51655821434335293442260561178972:50001231000000:2800:2491FC98FA32768452D10BCB6C2D082E9F24910EA017622321D20D6464A71603.png)，勾选**Show System Components**，可过滤系统组件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.26595564147773551336706076534463:50001231000000:2800:1CDDE5493970ADD6BE6B47FEBC19997CBF89502DA5D8760A382A4AA8D17B6B46.png)
    

## 导入/导出UI界面快照

ArkUI Inspector支持导出及导入应用UI界面快照，脱离设备查看应用UI界面显示效果。

- 在中间栏点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.29971392320434329796225470464985:50001231000000:2800:F9430FB243BDE581C56F6100DFE348C3CB82896A29CB222DED5A4E2AC3E503AC.png)可以导入本地的应用UI界面快照。导入成功后将在DevEco Studio中打开该快照。
- 在中间栏点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.72247785462851528477082530206044:50001231000000:2800:16FD603C899A59F45B854F1B855D6D10AAF2EB04438649106618EBEAFDA7F2CD.png)可以将应用UI界面快照导出到本地。导出成功后将默认在DevEco Studio中打开该快照。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.60184613770540624287212779879719:50001231000000:2800:4AE7804DBF20CAEA8D956EA8F342729A77C8F5ED5F4D0C2FCE4BB552DDC804BB.png)

## UI组件源码跳转

1. 单击**Run > Edit Configurations**，勾选“**Enable DebugLine**”，点击**OK**保存后，重新运行工程，表示开启源码跳转功能。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.80658635726403905055546421596131:50001231000000:2800:5F8B3CDAE434073B6D2EB44E733EE2FD943B8EBC900D63B052591F26A3D70E0F.png)
    
2. 在ArkUI Inspector中，选中要进行源码跳转的UI组件，点击右侧的源码跳转，即可跳转到UI组件源码位置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.79211679995702572468792754991299:50001231000000:2800:AC32EF686B1C9DBA077D89C0DFF2E1AC7059553D1A6C9D01CBAA83193E228ACF.png "点击放大")
    

## 显示布局边框

在UI显示设置上，勾选“**Show Component Border**”，可显示当前页面所有组件的布局信息。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.17053560785247949310906877812831:50001231000000:2800:09580E279289CB45C70AD51459970AE97EE5D20537575B89484F2EF5775C518C.png)

## 查看UI组件的状态变量

点击自定义组件，可以查看自定义组件的状态变量，以及状态变量影响的下一层组件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.81878634436897010384591348005721:50001231000000:2800:7B2C88C7C0C590E16F2DA180B6198C0ED3F08E8E1582D8309317CCEE1AD55677.png)

## 3D展开应用

ArkUI Inspector支持将应用按照组件粒度进行3D展开，即UI界面能够在Z轴展开，方便查看组件之间的嵌套、遮挡关系。

该功能从DevEco Studio 6.0.0 Beta1版本开始支持，同时设备系统版本需要升级到API 20。

### 使用场景

- 点击图层可以精准选中和查看被遮挡的组件，可用于定位组件是否被遮挡等问题。
- 3D视图展示的图层均是组件树上参与渲染的组件，可帮助开发者判断组件是否需要进行渲染，例如过长的列表、不可见区域是否需要渲染，帮助开发者优化渲染性能。
- 对于页面复杂、小组件较多的场景，在组件树或者2D视图中难以选中，通过3D视图增加图层之间的距离，能够有效地突出小组件，使其更易于选中。

### 进入3D视图

点击3D View按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.09963512365247821737100900708863:50001231000000:2800:C2AAE34F9249A47920E10EEFAC9101E5B645B9749744A57ECEE10F25227560C2.png)，进入3D视图。首次进入3D视图会加载3D数据，请等待数据加载完成。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.42056755624252841179892046180572:50001231000000:2800:5665E097AD57942F76EC957BD4AEE0C172D314890CCF0043D33B85BBF040BF43.png)

### 基础操作

- 旋转视图：按住鼠标左键移动。
- 平移视图：按住鼠标右键移动。
- 放大/缩小视图：滚动鼠标滚轮。

### 隐藏前方图层

选中图层后，图层会显示蓝色边框，点击Hide Views in Front按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.01569344000280545959397319484899:50001231000000:2800:E7BC0A76957FED353525BB70E43283054F598D15B7A9A1900FA4E5409A1F4B08.png)，能够隐藏当前选中图层前方（朝向用户）的所有图层，避免不必要图层的干扰。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.82636104338977323701537820930714:50001231000000:2800:88A88F23021074314E9C841AA0687FC4119B7C6A7709D0F4BD9B45E22F118E3F.png)

### 隐藏后方图层

和隐藏前方图层类似，选中图层后，点击Hide Views Behind按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.46019875047749235930797060896114:50001231000000:2800:BADB43300DD4D6CDCCF16DBD7BBC4E27BCB4BE563B34C83A9591489382F75C3E.png)，能够隐藏当前选中图层后方的所有图层。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.17646247406117477800872193625718:50001231000000:2800:93724D7555C3DAB8691FA18E77FAEFA89D87B44B65CCB02600AA03ABC157D9AD.png)

### 恢复隐藏图层

点击Restore Hidden Views按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.73236950192734766415948085378311:50001231000000:2800:83E60744DF881ADFF26A4FC2B35C9A71553CA23325D411C16421A6B15498878B.png)，能够恢复所有隐藏的前方图层和后方图层。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.51968194687592262028895738530220:50001231000000:2800:9F5BAE27A3D10BFF4B86928941158A08C3CBD5BD4E4FBAFC8645F5412FFD3C89.png)

### 切换图层排列顺序

图层有两种排列顺序，id顺序和层级顺序。

- id顺序：默认顺序，即渲染的顺序，也是组件真实显示的顺序，图层的遮挡关系和实际应用一致，每个图层显示在一个Z轴平面上，但如果图层数量较多，会导致Z轴过长，操作不方便。
- 层级顺序：组件树上同一层级的组件，在3D视图中会显示在相同Z轴平面上，能够有效减少3D视图下Z轴长度。

切换方式：点击Switch to Layer Order/Switch to Id Order按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155830.64678523134245333055983116066459:50001231000000:2800:5352AB2B3C829AD9DC5DCA53E72EB6CDE52591C28B6FFF376CFC25EEE88375BC.png)，可以将图层的排列顺序分别切换至层级顺序/id顺序。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.82800083975871347927970045041213:50001231000000:2800:1CD092DFE60F09835F150C36205074D58E2F575143AD5B64BA79E2702395BEF9.png)

### 调节图层间距

鼠标悬浮在Adjust the Gap of Layers按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.77252564750072695446039817017197:50001231000000:2800:F95BB3B2CDD69B763D16AB2D52EAA39E08D90376D74358D4B138A3430A19B81C.png)上，出现一个拖动条，拖动后可调节图层间的距离，范围是0~100px。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.09464623838555334856468060367800:50001231000000:2800:C527259804EF3D24578FEA6F30D4333E1407D45C248455C1D4B7841DBD088518.png)

### 显示/隐藏图层边框

DevEco Studio默认给图层加了边框，此边框并非应用自身边框，便于查看透明图层。点击Hide Border按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.47987214280712197711737884154667:50001231000000:2800:47A6A4DB715C6DEE5711A43A283DAC72136C5BF45F57BAB88ACC57BEFAE6BCC3.png)或Show Border![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.86058655357632609932787233058394:50001231000000:2800:F06DD58FB06A94ADA6137BFAE765420F727A9F9135C5F25F46A04AC37816BA5A.png)可以隐藏或显示图层边框。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.71739302542685858203767073050266:50001231000000:2800:797647F1784D017E233D7B1E3B17248C040F081A78831ACC258E41FC89993459.png)

### 放大/缩小视图

点击Zoom In按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.08557728548176811392483973132441:50001231000000:2800:006B4ED17CCAFBD5FBFB29015C3B89AE4B9A96785DF96CF569E31C40E3B60E5A.png)或Zoom Out按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.79271294979066463888945739824237:50001231000000:2800:A5A0625B40D924C9C70144CF38D4A45EE85A25B0558AFC74CB9007B681AFCB70.png)，能够放大或缩小3D视图。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.54861666078112808050250437963493:50001231000000:2800:565E3714AD32C9FB29CA939C2459DEB96608F14E4728EB8C32E10F0FA7180A17.png)

### 自适应窗口

点击Zoom to Fit Screen按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.59595580544174390953903326281848:50001231000000:2800:A32F3BA644D5C7C3F049EB74E38DB1436A57B926AD8B498984ADB5617BAF76A4.png)，能够自动根据窗口大小，调整3D图层的缩放比例，并使3D视图回到区域中间。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.04653182054382704429676575173816:50001231000000:2800:EFBF391538CF0BC0AB9FC4615B4B761A328EFC3D1ECFE841A6ACC04522B493FE.png)

### 切换正面/侧面视图

DevEco Studio默认展示侧面视图，经过复杂的旋转后，可点击Switch to Front View按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.31033324702146878055361982778169:50001231000000:2800:52165BAAB53097820749D50785B31AAE40986378698293298E3FBE64531CB958.png)或Switch to Side View按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.80327099468782564634776233340676:50001231000000:2800:6DE73AF0CBEEBFC92711D0288BAA500574649B10AB4FBB5857A00207ED84151A.png)，将3D视图自动调整到预设的正面或侧面视角。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.55804211179576330747784643681565:50001231000000:2800:A695E0C0FD893DAFF1F460B713FDCE952CF7FF28F9037E579EFAD24D6B1E5400.png)

### 返回2D视图

点击2D View按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.65144736255002622923752853689131:50001231000000:2800:A20810E6721419B1D92FF069C6817998075FC5008239D54D7CF464AA0D2DEEB6.png)，可切换至2D视图。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155831.06447459200171309333280639311695:50001231000000:2800:190A7936B68AE25036166420831FB2FA81AEEB56078572BB10F9AF88449D05E5.png)

[开发者选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-developer-mode "开发者选项")

[访问设备文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-device-file-explorer "访问设备文件")
# 访问设备文件

更新时间: 2025-12-16 15:58

开发者可以使用Device File Browser，在DevEco Studio上如PC端操作一样，对设备文件进行新建、删除、上传、下载等操作，而无需使用命令行，提升开发效率，当前支持普通文件视图与应用沙箱视图两种模式。

## 使用场景

- 查看设备上的文件列表及基本信息。
- 在设备上搜索文件及文件夹。
- 在设备上新建、删除文件。
- 从PC本地上传文件到设备上，从设备上下载文件到PC本地。

## 使用约束

- 已通过USB或Wi-Fi连接设备。
- 不支持访问无权限目录，新建、删除、上传、下载文件受设备权限约束。
- 不支持文件拖拽。
- 不支持文件修改。如需对文件进行修改，需下载至PC，在本地修改后再上传至设备。
- 不支持上传文件或文件夹的快捷方式。
- 应用沙箱视图不支持模拟器设备。
- 只支持访问调试态应用的沙箱数据目录。
- 应用需为debug应用才可使用沙箱视图查看文件结构、对应用沙箱内的文件/文件夹进行新建、删除、上传或下载操作。

## 操作步骤

1. 在菜单栏单击**View > Tool Windows > Device File Browser**，打开Device File Browser。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.37468789936711271266840662532911:50001231000000:2800:191C0F0715AC3ACF25F96CBC73221BADB3529D4E21EF89475A89F10478B12378.png)
    
2. 从下拉列表中选择设备（设备需已连接）。
3. 选择设备后，显示文件/文件夹列表，可进行以下操作：
    
    1. 右键单击目录或文件，进行新建/删除操作。
    2. 右键单击**Save As**将选定的文件或目录下载到PC上，右键单击**Upload**将PC上的文件上传到设备指定目录。
        
        如果需要查看数据库文件，可以通过该方式将数据库文件（路径举例：data > app > el2 > 100 > database >项目名称 > entry > rdb > 数据库文件）下载到PC上，再通过其他工具进行可视化查看。
        
        说明
        
        从DevEco Studio 6.0.0 Beta2版本开始，支持使用快捷键**Ctrl或Shift+鼠标左键**（macOS为**Command或Shift+鼠标左键**），选中多个文件或目录下载到本地计算机。
        
    3. 焦点在Device File Browser框中，输入字母可以快速进行搜索。
    4. 双击某个文件可在DevEco Studio中将其打开。打开文件会默认下载文件到临时目录（%USER%\AppData\Local\Huawei\DevecoStudio{版本号}\device-file-browser\{设备名称}\{设备上的文件路径}），关闭文件后，临时文件将被删除。
    5. 如果通过命令行方式上传文件到设备后，需要右键对应文件夹，选择**Synchronize**后才可以在Device File Browser窗口中显示该文件。
    

## 可访问目录

当前Device File Browser可访问的文件夹有四种类型：[应用沙箱目录](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-sandbox-directory)、一般暂存区目录、日志目录、设备公共目录。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.26961211319980086764663306388162:50001231000000:2800:5F0EBE1CAEFC7DC9455F71899B2F5854C8865A660012FF35D061904D3AB0FC82.png)

### 应用沙箱目录

此目录用于存放应用自身相关的数据、资源文件等，有两种访问方式。

- **普通文件视图**
    
    普通文件视图将按照设备的真实物理路径显示当前设备上的文件结构。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.41846552182656451553129873395358:50001231000000:2800:3EFBEEE6468B809D310DBCC2BF4335D1E8EA196E0D4946A42A2A1D9705B6AF9D.png)
    
    应用沙箱在设备上的物理路径位于/data/app/{el1，el2}/100/{base，database}/{packageName}路径下。
    
    在普通文件视图下，el1目录下的文件仅具备查看文件目录结构的权限，无法执行新建、删除、上传或下载操作；与el1相比，el2目录下的文件允许下载，但其他操作仍无权限执行。
    

- **应用沙箱视图**
    
    应用沙箱视图会展示所有debug类型的应用，按照应用的沙箱文件路径显示应用的沙箱文件结构。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.90319668424777810895257699683629:50001231000000:2800:498E513A343C08B3C9B703FFECD044A64D1131D009ACD9C501F553977330CC1C.png)
    
    API 15以下的版本，当需要以沙箱视图查看应用的文件结构时，需在module.json5文件内配置ohos.permission.INTERNET开启网络权限，卸载并重新安装应用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.72273952937732553909061432796811:50001231000000:2800:0629CA2A7E709DDD7279AEA8E1AA22C2724333235EE13967A748794A280DF7EE.png)
    
    对应于物理路径，沙箱路径为/data/storage/{el1，el2}/{base，database}。
    
    在应用沙箱视图下，el1和el2目录下的文件均支持新建、删除、上传、下载操作。
    

### 一般暂存区目录

一般暂存区目录位于/data/local/tmp/路径下，支持新建、删除、上传、下载操作，在DevEco Studio进行调试、测试等操作时，将在此目录下生成相关的文件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.93031746243840096334571468480605:50001231000000:2800:8EA00BF4ABB07645C635AE5C378A89534D3FD53222683CF22E051BA84EFFE289.png)

### 日志目录

应用运行时的日志通过HiLog工具实时输出，此工具的输出缓存区一般为256K，超出大小的历史日志将会以压缩包的形式保存在/data/log/hilog/路径下。

当需要查看历史日志时，需要将此目录下的压缩包文件和数据字典压缩包文件hilog_dict.XXX.zip下载到本地计算机，然后使用[hilogtool工具](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hilog-tool)解析出对应的日志原文件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.34323350103314249542485317699595:50001231000000:2800:CFA225682090988863A599404B225BF2A667E0DB0F9D8B0103737A5F363F2B38.png)

### 公共目录

用户的桌面、文档、下载等公共目录位于/storage/media/100/local/files/Docs路径下，支持删除、上传、下载操作。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.50362142136366171456185839415482:50001231000000:2800:36E0185D4F57E33347BB93DE03848B0EB8B283053A42DB2C26A104CB99A92091.png)

## 特殊目录

设备上存在两个特殊的目录：faultlog目录和图库目录，这两个目录有下载权限，但没有查看权限，Device File Browser中无法显示这两个目录，但其下的文件可以通过hdc命令查看并导出。

### faultlog目录

当应用崩溃时，会在/data/log/faultlog/faultlogger路径下生成相关的崩溃日志，可通过以下方式查询并下载日志。

1. 执行命令，查询此路径下的崩溃日志文件列表。
    - 设备版本低于5.1.0.54时，执行以下命令。
        
        1. hdc shell hidumper -s 1201 -a "-p Faultlogger"
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.18594862907230795018897345355409:50001231000000:2800:16E0CEB37020F12F3E4814C75E2EF8B0CB243E50993177CEC65889704432B76F.png)
        
    - 设备版本为5.1.0.54及以上时，崩溃日志文件名时间戳新增了毫秒级信息，执行以下命令。
        
        1. hdc shell hidumper -s 1201 -a "-p Faultlogger %s -LogSuffixWithMs"
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.90309525147874068108460853632206:50001231000000:2800:FAF34F284FD2FA38C3AFA1B514E749FC54A12E60B76A83B9729B2A9390F55BAB.png)
        
2. 执行命令，查看指定的崩溃日志文件的内容。
    
    1. hdc shell hidumper -s 1201 -a "-p Faultlogger -f {filename}"
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.33341030590265677394043762535124:50001231000000:2800:6B4CCA4694E9B4FB94C7D3004B1E2FB7DFACB1B1D41FE28A68E45B4E02EF1BCA.png)
    
3. 执行命令，将文件保存到本地计算机指定的路径下。
    
    1. hdc file recv /data/log/faultlog/faultlogger/{filename} {path}
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.87622568180553227267784561519263:50001231000000:2800:15CD97812483AAE67FC41A61813169E376B3236F28E266EF68F4790F891B6614.png)
    

### 图库目录

图库目录中保存了录屏工具、照相机等系统应用生成的图片、视频文件，可通过以下方式将文件下载到本地计算机。

1. 在图库中查看文件名及后缀，例如a.mp4。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.73841135194020705690141213621920:50001231000000:2800:12B62534493B5152818C899425402B58C458090DCC05827DFC3DAD1190B340CF.png)
    
2. 查询文件路径，记录为{FilePath}。
    
    1. hdc shell mediatool query a.mp4 -u
    
    - 如果查询的结果中包含uri字段，则返回值第三行对应的文件路径不允许直接下载。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.72023128998606926973947084770506:50001231000000:2800:90736E9C667C6268F8917CEA0211B5699D46C9AB279549397C745BB9F9FB26BE.png)
        
        需要再执行如下命令，指定该uri，将文件复制到有下载权限的路径中（如/data/local/tmp）。
        
        1. hdc shell mediatool recv file://media/Photo/2/VID_1744944984_000/a.mp4 /data/local/tmp
        
        命令返回值第二行即为文件路径{FilePath}。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.74161621113061408550262502949199:50001231000000:2800:A18629DE9B1880E09EA01F323FE8148E705FACF46B9C4849DF618F0E710C768A.png)
        
    
    - 如果查询结果不包含uri字段，则返回值第二行即为文件路径{FilePath}。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.91160172548473361384121742118908:50001231000000:2800:F3A03B5F205D171FF087CC85E6303C951CCB70E9287A1FB4350ECDE72737F910.png)
        
3. 指定上一个步骤中获取到的文件路径{FilePath}，下载文件到本地。
    
    1. hdc file recv {FilePath} .\
    

## 命令行方式访问应用沙箱

可以通过命令行的方式访问debug应用的[沙箱目录](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-sandbox-directory#%E5%BA%94%E7%94%A8%E6%B2%99%E7%AE%B1%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9C%9F%E5%AE%9E%E7%89%A9%E7%90%86%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB)。

- 从API 15开始，支持通过hdc工具访问debug应用的沙箱目录，推荐开发者使用此种方式。更多关于命令行工具hdc的说明请参见[hdc工具使用指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdc)。
    1. 在设备侧启动应用。
        
        1. $ hdc shell aa start -a {abilityName} -b {bundleName}
        2. start ability successfully.
        
        - abilityName：应用的ability名称。
        - bundleName：调试应用包名。
        
    2. 通过命令访问沙箱文件目录，创建目录文件，删除指定目录下的文件。
        
        1. $ hdc shell -b {bundleName} ls -lZ -A "./data/storage/el2/base"          // 查看应用沙箱下/el2/base目录文件（返回文件全部信息）
        2. $ hdc shell -b {bundleName} ls -A "./data/storage/el2/base"          // 查看应用沙箱下/el2/base目录文件（仅返回文件名）
        3. $ hdc shell -b {bundleName} mkdir -p "./data/storage/el2/base/test"     // 在应用沙箱下/el2/base目录下创建test目录
        4. $ hdc shell -b {bundleName} rm -r "./data/storage/el2/base/test.txt"  // 在应用沙箱下/el2/base目录下删除test.txt文件
        5. $ hdc shell -b {bundleName} rm -r "./data/storage/el2/base/test"      // 在应用沙箱下/el2/base目录下删除test目录
        
    3. 通过命令往应用沙箱目录中发送文件，从沙箱目录中下载文件到本地计算机。
        
        1. $ hdc file send -b {bundleName} "D:\test.txt" "./data/storage/el2/base"    // 发送文件到设备沙箱目录/el2/base
        2. $ hdc file recv -b {bundleName} "./data/storage/el2/base/test.txt" D:\  // 从设备沙箱目录/el2/base下载文件到本地计算机
        
- API 15以下的版本，通过以下方式访问debug应用的沙箱目录。
    1. 在工程主模块下的module.json5文件下增加网络权限。
        
        1. "requestPermissions": [
        2.   {"name":  "ohos.permission.INTERNET"}
        3. ]
        
    2. 在设备侧(hdc shell)启动应用的bftpd服务，并查询端口号是否启动成功。
        
        1. $ aa process -b {bundleName} -a {abilityName} -p "/system/bin/bftpd -D -p {port}"  -S
        2. start native process successfully.
        3. $ ps -ef | grep bftpd
        4. 20020143     12254   613 0 11:52:53 ?     00:00:00 bftpd -D -p 9021   // 对应端口号的bftpd服务启动成功
        5. shell        13035 11901 10 11:54:44 ?    00:00:00 grep bftpd
        
        - bundleName：调试应用包名。
        - abilityName：应用的ability名称。
        - port：可用端口号。
    3. 通过命令访问沙箱文件目录，创建目录文件，删除指定目录下的文件。
        
        1. $ ftpget -p {port} -P guest -u anonymous localhost -l /data/storage/el2/base           // 查看应用沙箱下/el2/base目录文件（返回文件全部信息）
        2. $ ftpget -p {port} -P guest -u anonymous localhost -L /data/storage/el2/base           // 查看应用沙箱下/el2/base目录文件（仅返回文件名）
        3. $ ftpget -p {port} -P guest -u anonymous localhost -M /data/storage/el2/base/test      // 在应用沙箱下/el2/base目录下创建test目录
        4. $ ftpget -p {port} -P guest -u anonymous localhost -d /data/storage/el2/base/test.txt  // 在应用沙箱下/el2/base目录下删除test.txt文件
        5. $ ftpget -p {port} -P guest -u anonymous localhost -D /data/storage/el2/base/test      // 在应用沙箱下/el2/base目录下删除test目录（仅支持删除空目录）
        
    4. 通过命令往应用沙箱目录中发送文件，从沙箱目录中下载文件到本地。(/data/local/tmp/作为中转目录)
        
        1. $ hdc file send test.txt /data/local/tmp/test.txt    // 先发送文件到设备data/local/tmp目录
        2. $ ftpget -p {port} -P guest -u anonymous localhost -s /data/local/tmp/test.txt /data/storage/el2/base/test.txt  // 再推送到应用沙箱目录
        3. $ ftpget -p {port} -P guest -u anonymous localhost -g /data/local/tmp/test.txt /data/storage/el2/base/test.txt  // 先下载到设备的data/local/tmp目录
        4. $ hdc file recv /data/local/tmp/test.txt test.txt  // 再从设备中获取
        

## 常见问题

沙箱视图下，打开沙箱文件夹时报错：[Fail][E003001] Invalid bundle name。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155833.48969601204354098909966701228843:50001231000000:2800:8F1830C260347109ED66C8FD3B241A726FF77699B65EF90A220ECDB1CD829F0B.png)

可能是以下原因：

1. 应用不是debug应用，无法查看沙箱文件。
2. 应用安装后，未运行过或重启了设备，导致应用沙箱暂未挂载。此场景下先手动运行一遍应用，然后在报错目录右键点击**Synchronize**即可打开目录。

[布局分析](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arkui-inspector "布局分析")

[截屏](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-screenshot "截屏")
# 截屏

更新时间: 2025-12-16 15:58

在调试过程中，可以通过多种方式截取屏幕截图。

## 通过DevEco Studio截屏

1. 连接真机设备或模拟器，并在其中运行应用。
2. 在DevEco Studio底部切换到**Log**页签。
3. 点击左侧工具栏中![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.69687091258888757602006664080869:50001231000000:2800:8EA4025534C7615949426F003347CD6AC06A990F834DE2F59B58ABAE982944F5.png)，即可截取屏幕截图。
    
    截图的图片将直接显示在DevEco Studio中。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.36031977987249469716460807356625:50001231000000:2800:9BA7BBDBDF53682886C5CAE07EDADD6637F71A94DE6539549C46ABE3B57710C6.png)
    
4. （可选）在图片显示区域右击，选择**Copy Path/Reference...**可以查看截屏的本地存储路径或者在菜单栏下方查看本地存储路径。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.65293189892695582611848589766336:50001231000000:2800:4FE82599ADC92FECDD91371F57AFFBF58D633A1FBAD8B4BA8108641D69C29D98.png)
    

## 通过命令行方式截屏

hdc是可以用于调试的命令行工具，通过该工具可以实现截屏功能。更多关于命令行工具hdc的说明请参见[hdc工具使用指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdc)。

### 方式一：hdc shell snapshot_display

1. hdc shell snapshot_display -f /data/local/tmp/0.jpeg  // -f参数指定图片在设备上的存储路径，如不指定，会在命令执行完成后显示图片默认存储路径。
2. hdc file recv /data/local/tmp/0.jpeg  // 将图片从设备发送到本地目录，本示例将图片发送到当前执行hdc命令的目录。

### 方式二：hdc shell wukong special -p

wukong是系统稳定性测试工具，通过指定参数-p可以实现截图功能。更多关于稳定性测试工具wukong的说明请参见[wukong工具使用指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/wukong-guidelines)。

1. hdc shell wukong special -p

命令执行效果如下图所示，其中Report currentTestDir为结果存储路径，包含截屏图片。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.64257225131958985462695488785400:50001231000000:2800:78AADB5A8DE357262246ECF9FEED2FF094F9CEDF4CF352EE62C20CB351891E69.png)

通过hdc命令可以将该路径文件发送到本地，例如发送到当前执行hdc命令的目录。

1. hdc file recv /data/local/tmp/wukong/report/20231010_141610/  

[访问设备文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-device-file-explorer "访问设备文件")

[录屏](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-screen-recording "录屏")
# 录屏

更新时间: 2025-12-16 15:58

在应用开发过程中，可以使用录屏功能录制应用的运行状态，并通过录屏文件向他人展示正在开发的应用的各种功能效果。

## 使用约束

- 如果设置了锁屏密码，录屏开始前请解锁设备屏幕，锁屏状态下录屏应用无法正常拉起。
- 如果设置了锁屏密码，录屏时请保持设备的屏幕解锁状态，若录屏过程中锁屏将导致录屏应用退出。
- 模拟器不支持录屏。

## 通过DevEco Studio录屏

1. 连接真机设备，并在其中运行应用。
2. 在DevEco Studio底部切换到**Log**页签。
3. 点击左侧工具栏中![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.15253446610870876554806715481884:50001231000000:2800:8048A4007DBC1A3E28169A5D670B84B0737861FA660BD2281B1CA9D9286C8A5B.png)，即可开始录屏。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.17711686056523326397999210348786:50001231000000:2800:527BA21505E568267270A5BD7CBC8D4F810E017A7300E73F1CBDDF3E29E7B2B9.png)
    
4. 录屏时，需要先选择录屏文件的保存路径，开发者可使用默认路径或[设置自定义路径](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-screen-recording#section89111791511)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.09604807195730824691057560936887:50001231000000:2800:F07279080C379FE4128B0875A5C055A70DB4803D19E52BA486EFD7A11601662C.png)
    
5. 路径选择完毕后，点击**Start Recording**开始录屏。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.80775885933235364114245501774257:50001231000000:2800:A4FC06DA42E383C9280F569A3A72F864CFE89F3B7CDCF5938FC1C2B429C47CDD.png "点击放大")
    
6. 录制完操作流程之后，点击**Stop Recording**结束录屏。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.51344795032240748251432231241370:50001231000000:2800:73249A647ADF30FBE413AFB1D634A6C363F56E48CED70D9A8F9255A4DD17877C.png "点击放大")
    
7. 结束录屏后，录屏文件将会保存到之前选择的路径下，可以选择调用系统播放器播放视频文件或打开文件所在的文件夹。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.37518633995147849072729815049174:50001231000000:2800:1C9EB706B85FA0B10135AF8185258429BAD602DE6B3E64725C35AC33DCFF66F4.png "点击放大")
    

## 设置录屏自定义路径

1. 点击DevEco Studio底部**Log**页签，选择**HiLog >** **Settings** **>** **Record Screen**选项。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.92439636750837393871639095299195:50001231000000:2800:B92BD67947760F40C7FBC0CDB6E11F6E0DEF67B397371EE947830BABBB1E36DB.png)
    
2. 在弹出的界面选择自定义路径，当设置好路径并勾选“Use the selected path and auto-generated file name as defaults and don't ask again”选项后，录屏时将自动使用此时设置的路径以及以录屏时的时间戳构造的文件名作为录屏文件的保存地址及文件名。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.98195830475719637831862236686982:50001231000000:2800:7E543BF6E98CAEC9C89130CE0A2E6E1178E21C6AD326BA13E85706344FF223DE.png)
    

## 通过命令行方式录屏

hdc是可以用于调试的命令行工具，通过该工具可以实现录屏功能。更多关于命令行工具hdc的说明请参见[hdc工具使用指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hdc)。

1. 启动录屏。
    
    1. hdc shell aa start -b com.huawei.hmos.screenrecorder -a com.huawei.hmos.screenrecorder.ServiceExtAbility --ps "CustomizedFileName" "test.mp4"   // 指定录屏文件名称为test.mp4
    
2. 停止录屏。
    
    1. hdc shell aa start -b com.huawei.hmos.screenrecorder -a com.huawei.hmos.screenrecorder.ServiceExtAbility
    
3. 获取录屏文件位置，记录为{RecordFile}。
    
    1. hdc shell mediatool query test.mp4 -u
    
    - 如果查询的结果中包含uri字段，则返回值第三行对应的录屏文件路径不允许直接下载。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155835.74363063822582280327363045751388:50001231000000:2800:7D65278DBEEE1FCF494FF7A567476538CB863CD5F9FBFA42E6926995AD86673C.png)
        
        需要再执行如下命令，指定该uri，将录屏文件复制到有下载权限的路径中（如/data/local/tmp）。
        
        1. hdc shell mediatool recv "file://media/Photo/2/VID_1736853237_001/test.mp4" /data/local/tmp
        
        命令返回值第二行即为录屏文件路径{RecordFile}。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.33381382693733121288770518977600:50001231000000:2800:50E796E96C057D357410E8B1B046DB1D4C84A3BF6E0856498F351D239F974BF4.png)
        
    
    - 如果查询结果不包含uri字段，则返回值第二行即为录屏文件路径{RecordFile}。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.38442679035250001959427274812250:50001231000000:2800:AF9883A3C28B5E8FC1DF9B21574AD35A754738750AE2F9F665D8A7C18013D5F6.png)
        
    
4. 指定上一个步骤中获取到的录屏文件路径{RecordFile}，下载录屏文件到本地。
    
    1. hdc file recv {RecordFile} d:\test.mp4
    

[截屏](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-screenshot "截屏")

[日志与故障分析](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-log-and-fault-analysis "日志与故障分析")
# Instrument Test

更新时间: 2025-12-16 15:58

## 创建ArkTS测试用例

### 创建默认测试用例

1. 在工程目录下打开待测试模块（支持HAP、HAR、HSP模块）下的ets文件，将光标置于代码中任意位置，单击**右键 > Show Context Actions** **> Create Instrument Test**或快捷键**Alt+Enter** **（macOS为Option+Enter）> Create Instrument Test**创建测试类。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155853.71037953566613924824651532565168:50001231000000:2800:92D73528F2FEB8475D16C7C73C4C80915DFE83AA507BD6FFEB38E53E2D28337B.png)
    
2. 在弹出的Create Instrument Test窗口，输入或选择如下参数。
    
    - **Testing library**：测试类型，默认为DECC-ArkTSUnit，JS语言默认为DECC-JSUnit。
    - **ArkTS name**：创建的测试文件名称，测试文件中包含了测试用例。测试文件名称要求在工程目录范围内具有唯一性，仅支持字母、数字、下划线（_）和点（.）。
    - **Destination package**：测试文件存放的位置，建议存放在待测试模块的test目录下。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.79355550982314216654081761343234:50001231000000:2800:CC0997DE1C5E5387BE62861BAD8B2CC716E59738EB90D745CB764ECCC21B7761.png)
    
3. DevEco Studio在ohosTest/ets/test目录下自动生成对应的测试类。在测试类中，DevEco Studio会生成对应方法的用例模板，具体测试代码需要开发者根据业务逻辑进行开发，具体请参考[自动化测试框架使用指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkxtest-guidelines)。
    
    说明
    
    - 您也可以手动在ohosTest > ets > test文件夹下创建测试用例，手动创建后，需要在List.test.ets文件中添加创建的用例类。手动创建的工程或历史工程，ohosTest > ets > test文件夹下所有文件的文件名必须以.test.ets结尾，否则将在运行时弹窗提示“Error: Test files must end with '.test.ets'.”请点击**Fix**按钮，DevEco Studio将自动对ohosTest > ets > test目录下的文件名进行修改。
    - 首次在HarmonyOS设备上运行UI测试框架需要使用命令“hdc -n shell param set persist.ace.testmode.enabled 1”使能UiTest测试能力。
    

### 自定义Ability和Resources

从5.0.3.403版本开始，新创建的工程/模块的ohosTest目录下默认不创建testability、testrunner和resources目录，历史工程仍保留这些目录，如果新工程需要使用ability或resources能力，需要开发者自行创建。

说明

如果需要使用ability能力，需要同时创建testrunner目录及OpenHarmonyTestRunner.ets文件。

|   |   |
|---|---|
**表1** **新旧版本ohosTest目录对比**
|**新版本**|**历史版本**|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.37731037377480914087837759828959:50001231000000:2800:33379396A999F936C64534E85001AF3D86A4F54EE664FCF65388D8AA9E19F1C2.png)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.09411606899591125575752332039025:50001231000000:2800:E7B575164DCAF7C31872EA02EF78B92FF8F05A2A4800B24DC9DBF68C3D2A244B.png)|

1. 创建以下目录或文件，文件内容示例可在[运行Instrument Test测试用例](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-instrument-test#section1574003717165)后，在对应模块的build/{productName}/intermediates/src/ohosTest下查看，其中productName是当前生效的product，可以通过点击DevEco Studio右上方![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.50222300998424873493013414063312:50001231000000:2800:5895E0F7ECF6A8149687B15B480F079F37BE19A20968F3ED7FCA71949F287D3D.png)图标进行查看。
    
    - testability目录 > TestAbility.ets文件
    - testability目录 > pages目录 > Index.ets文件
    - testrunner目录 > OpenHarmonyTestRunner.ets文件
    - resources目录 > base目录 > element目录 > color.json文件
    - resources目录 > base目录 > element目录 > string.json文件
    - resources目录 > base目录 > profile目录 > test_pages.json文件
    
2. 在module.json5文件中补充ability配置字段mainElement、pages、abilities，关于字段的具体说明请参考[module.json5配置文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file)。
    
    1. {
    2.   "module": {
    3.     "name": "entry_test",
    4.     "type": "feature",
    5.     "description": "$string:module_test_desc",
    6.     "mainElement": "TestAbility",                                   // 对应下方abilities中的ability name。
    7.     "deviceTypes": [
    8.       "phone",
    9.       "tablet",
    10.       "2in1"
    11.     ],
    12.     "deliveryWithInstall": true,
    13.     "installationFree": false,
    14.     "pages": "$profile:test_pages",                                 // 对应resources目录 > base目录 > profile目录 > test_pages.json文件。
    15.     "abilities": [                                                  // 添加的ability的配置信息。
    16.       {
    17.         "name": "TestAbility",
    18.         "srcEntry": "./ets/testability/TestAbility.ets",
    19.         "description": "$string:TestAbility_desc",
    20.         "icon": "$media:icon",    // 确保引用的资源都存在
    21.         "label": "$string:TestAbility_label",
    22.         "exported": true,
    23.         "startWindowIcon": "$media:icon",
    24.         "startWindowBackground": "$color:start_window_background"
    25.       }
    26.     ]
    27.   }
    28. }
    

## 运行测试用例

### 运行模式

使用DevEco Studio运行测试用例前，需要将设备与电脑进行连接，将工程编译成带签名信息的HAP，再安装到真机设备或模拟器上运行，具体请参考[使用本地真机运行应用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-device)或[使用模拟器运行应用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-emulator)。

可以采用运行工程目录（test）、测试文件（如Ability.test.ets）、测试套件（describe）、测试方法（it）的方式来运行测试用例：

- 在工程目录中，单击**右键 > Run'测试文件名称'**，执行测试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.74435946629249987105593350149260:50001231000000:2800:8AC14CD9A33D72D1AF13735C039F139F05FE44C0F326F8C9411C4EE7B6942C6B.png)
    
- 打开测试文件，单击测试套件左侧按钮。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.27137107803582813149957145933769:50001231000000:2800:1B46FF41EEFE66F21BA1B9F43B64EED148CEE08CDFE7F450EA4C59B7BC8014B3.png)
    
- 如果要根据自定义的配置执行Instrument Test，在[创建测试用例运行任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-instrument-test#section65264166107)后，通过如下方式的其中之一，执行Instrument Test：
    - 在工具栏主菜单单击**Run > Run'测试名称'**。
    - 在DevEco Studio的右上角，选择测试任务，然后单击右侧的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.36699669634744520636849437722976:50001231000000:2800:2FDE2C202E4167B8E9C2BAA22AAD057684982892CDD795FCED0444C5EE2434DC.png)按钮，执行Instrument Test。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.69123812649949994363843381872720:50001231000000:2800:4A2D7BB9C3EC8DCD3047E62BCE654E00A500B7F73DD6DE69DE8C4A35875C3416.png)
        

执行完测试任务后，查看测试结果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.61987461213369039107593074997023:50001231000000:2800:0CEC204B51E11A9438D046A364CECA9796D4253D58223B82D7D5BC2404D0F717.png)

### 调试模式

调试模式相比运行模式增加了断点管理功能。在断点命中时，可以选择单步执行、步入步出、进入下个断点等方式进行调试，另外可以使用线程堆栈可视化、变量和表达式可视化功能，快速定位问题。

以文件级别为例，在添加断点之后，在工程目录中，选中文件，单击**右键 > Debug'测试文件名称'**，以调试模式执行测试任务。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.02265148799978505644305642503120:50001231000000:2800:1A4791965958231500E14DF229031479F0F0A7EC911C9F41A9D6DB47A20C9AED.png)

在断点命中时，下方将出现Debug窗口。开发者可在该窗口中进行断点管理与基础调试能力的可视化操作，在断点命中时可查看当前线程的变量和堆栈信息。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.44520157691078799807444229167053:50001231000000:2800:DCA765F1B301A2609A03A017284CD27CCF35B6AA89046218CA8DB5A85ADA342F.png)

断点命中时，在代码编辑器窗口单击右键，在弹出的菜单中将出现调试模式特有功能，如计算表达式、添加变量监视等。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.21345988622752254797824667884187:50001231000000:2800:890D521D50B26DB6B220C787648D4CD4C96EC683C0789F7F8EF3C61B7055E489.png)

在跳出所有断点后，测试结束，与运行模式相同，在测试窗口查看测试结果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.72929347528607275394908566600387:50001231000000:2800:225648A208F6017BB0C3A01F009D0BB5275BC6385DF0F50168DE0946396F29CF.png)

说明

DevEco Studio支持设置调试代码类型，具体请参考[设置调试代码类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-instrument-test#section0164586312)。

### 覆盖率统计模式

在Instrument Test运行的基础上支持代码覆盖率统计。

开发者可以自定义需要参与覆盖率测试的文件，具体配置方法请参考[配置覆盖率过滤文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-test#section13756446154)。

可以采用运行工程目录（test）、测试文件（如Ability.test.ets）、测试套件（describe）、测试方法（it）的方式来启动代码覆盖率的统计。

以文件级别为例，有两种方式启动测试：

- 方式一：在工程目录中，选中文件，单击**右键 > Run '测试文件名称' with Coverage**，执行测试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155854.63203634416311491838481071786597:50001231000000:2800:35B77B9C0B104AB626744368247BD560D2618648B6A3A58C06660794D8B1C762.png)
    
- 方式二：在DevEco Studio的右上角，选择测试任务，然后单击右侧的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.40678143179064075670963362480856:50001231000000:2800:4BA0257EB4309E91320D5045692832089FB2DF99E2F21BCC90B1E5329CC86762.png)按钮，执行测试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.28147573260846255359359131177096:50001231000000:2800:6C9039B63F2CFFC3531611A9F11AE204356D87A925ABB241CF60227444D85B82.png)
    

启动测试后，进行编译构建，底部将出现Cover窗口，构建结束后自动拉起Cover窗口，测试任务结束后，窗口中会打印测试报告的路径。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.12500086041998578775335662388582:50001231000000:2800:BE774BBEDB32210EAC0816992EA5B40FA52159CB208DB849D9F0625A3A18F7B7.png)

点击链接可打开报告，查看ArkTS代码覆盖率详情，关于覆盖率的计算方式请参考[查看覆盖率报告](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-test#section10394362109)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.13902018564317977193246179767586:50001231000000:2800:59AD271C768C7C673DD29EB2D8D8BCCA423068172D69C9AA6822FC2D3D91718D.png)

在Cover窗口中，单击rerun按钮可以按照之前的设置，重新执行覆盖率用例。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.99238791221706008215512126508442:50001231000000:2800:28DF7FBD52FDF3FB2BD307109C2C16BA39D4EC139FB29E80B3A8DCE7A08CD4FE.png)

## （可选）自定义测试用例运行任务

默认情况下，测试用例可直接运行，如果需要自定义测试用例运行任务，可通过如下方法进行设置。

1. 在工具栏主菜单单击**Run** > **Edit Configurations**进入Run/Debug Configurations界面。
2. 在**Run/Debug Configurations**界面，单击+按钮，在弹出的下拉菜单中，单击Instrument Test。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.03010544534899686431307389488449:50001231000000:2800:7A278EF384012720C9DAB017262F1F852570112DC97BE44C02E29A63BF48F943.png)
    
3. 根据实际情况，配置Instrument Test的运行参数。然后单击**OK**，完成配置。
    
    - 如果模块依赖共享包，请提前设置HAP安装方式，勾选“**Keep Application Data**”，则表示采用覆盖安装方式，保留应用/元服务缓存数据。
    - 如果工程中HAP/HSP模块直接依赖其他HSP模块（如entry模块依赖HSP模块）或间接依赖其他模块（如entry模块依赖HAR模块，HAR又依赖HSP模块）时，在测试阶段需要同时安装模块包及其所有依赖模块的包到设备中。此时，可以勾选“**Auto Dependencies**”，测试时会自动将所有依赖的模块都安装到设备上。该选项默认勾选。
    - 如果不涉及UI测试，勾选“**Only OhosTest Package**”，则只会推送OhosTest测试包到设备上，不会推送HAP/HSP包，可以缩短推包时间。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.78628309645147300436810490792586:50001231000000:2800:0702E889D374C5ECAE7D1DB66AD4C1AA4100AE30DADA1596535112A173EC24D1.png)
    

### 使用过滤条件筛选待运行的测试用例

1. 在用例编写时，通过配置it的第二个入参，为每个用例添加过滤参数。此参数用于为测试用例添加标注，不添加则参数默认为0表示未被标注。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.53597462860372823326449750710483:50001231000000:2800:D9C260CDFB4E4146A1639AC1B10C40277E37C4097A745EF1AD67577A5A0DEF20.png)
    
2. 打开**Run/Debug Configurations**窗口，点击Test Args![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.56646904986636770152735652700519:50001231000000:2800:428A96ED4584E6B5CB9E86CED252815BFED27D91296C15A1B63CEED5CD474B72.png)，打开**Test Args**界面，添加命令行参数。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.70779207507416709421011279938325:50001231000000:2800:2A23DE4477A9CB619ECB73D2DF9F0D4B8ACA32F0DE1C2CA342544DE0096DE919.png)
    
    例如将测试参数配置为level=1, size=medium
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.44397280251374281532603658754310:50001231000000:2800:10DA7B0D37784851D400A168E36883D47460C1F86033635F28EDD4E190275DAA.png)
    
    **表2** 参数规则参考
    |Key|含义说明|Value取值范围|
    |:--|:--|:--|
    |level|用例级别|"0","1","2","3","4", 例如：-s level 1|
    |size|用例粒度|"small","medium","large", 例如：-s size small|
    |testType|用例测试类型|"function","performance","power","reliability","security","global","compatibility","user","standard","safety","resilience", 例如：-s testType function|
    
3. 完成以上配置后，在运行此项配置对应的测试任务时，只运行过滤后的测试用例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.00627078419739861955785591604471:50001231000000:2800:4047281CB1425C37377F072377856FB819AF8AA2C6528E0DE511981806F05140.png)
    

### 设置调试代码类型

点击**Run > Edit Configurations**，打开**Run/Debug Configurations**窗口，选择Instrument Test，点击**Debugger**页签，设置Debug type。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.70044471029687074416358404992693:50001231000000:2800:5BA320D30C4C4BEE3837724454F8885F1F403BAFC56B1DC55A61BA82F98DC2F1.png)

调试类型Debug type默认为Detect Automatically，关于各调试类型的说明如下表所示：

|调试类型|调试代码|
|:--|:--|
|Detect Automatically|自动检测。根据工程模块及其依赖的模块涉及的编程语言，自动启动对应的调试器。<br><br>如果检测到是Native模块，出现两个调试窗口（PandaDebugger、Native）；如果不是Native模块，只出现PandaDebugger调试窗口。|
|ArkTS/JS|只调试ArkTS/JS，只出现PandaDebugger调试窗口。|
|Native|单独调试C++，只出现Native调试窗口。|
|Dual(ArkTS/JS + Native)|支持ArkTS/JS和C++混合调试，出现两个调试窗口（PandaDebugger、Native）。|

说明

调试C++代码时，当前模块及所有依赖的HSP模块的[Address Sanitizer配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-instrument-test#section8352185341915)要保持一致，若不一致，可能无法进入C++代码的断点处。

### ASan检测

Instrument Test针对C/C++方法提供ASan检测能力，关于ASan的介绍请参考[ASan检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-asan)，当前不支持JS语言。

1. 在运行/调试配置窗口，选择对应的Instrument Test，点击**Diagnostics**页签，勾选**Address Sanitizer**选项，勾选后，测试包和源码包均开启ASan能力。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.59396737197025542696582651954063:50001231000000:2800:483D2857620054490D4B5B2F622CBE433D541BE609C58FE339DE81B27496834A.png)
    
2. 如果有引用本地library，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_ASAN=ON”，表示以ASan模式编译so文件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.79134633746325064831403942354394:50001231000000:2800:5265AF2B8CD3A2A37376001D49A32FB0F114315E11AB18ED40E705ACE487924C.png)
    
3. 运行测试用例。
4. 当程序出现内存错误时，弹出ASan log信息，点击信息中的链接即可跳转至引起内存错误的代码处。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155855.84976891896994158429759260359274:50001231000000:2800:5E7D2B3743F41ADF24C6E76259D4C1A7CB3A4FA47A11553B746E07304410EF89.png)
    

## 测试C++代码

从DevEco Studio 6.0.0 Beta5版本开始，支持对C++代码进行测试，包括运行/调试C++测试代码、对C++代码进行覆盖率统计。

由于C++的测试so无法直接在设备上运行，需要通过Node-API的方式拉起，即通过ArkTS/JS语言拉起C/C++测试用例。

### 运行C++测试代码

1. 创建cpp测试目录，鼠标右键单击ohosTest目录，选择**New > C/C++ File(Napi)**，在ohosTest下生成cpp测试目录，以entry模块为例，目录结构如下。
    
    - **src > ohosTest > cpp > types**：用于存放C++的API接口描述文件。
    - **src > ohosTest > cpp > types** **> libentry_test > index.d.ts**：描述C++ API接口行为，如接口名、入参、返回参数等。
    - **src > ohosTest > cpp > types** **> libentry_test > oh-package.json5**：配置.so三方包声明文件的入口及包名。
    - **src > ohosTest > cpp > CMakeLists.txt**：CMake配置文件，提供CMake构建脚本。
    - **src > ohosTest > cpp > napi_init.cpp：**定义C++ API接口的文件**。**
    
    说明
    
    DevEco Studio生成的cpp测试目录中不包含C++测试框架，需要开发者自行选择开源测试框架使用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.79185100533044107230671008268550:50001231000000:2800:71F079F1500AD0BA2FC4454E26E76311513F14DD72519A2602264E13DBC0F532.png)
    
2. 通过ArkTS测试用例拉起C++测试，示例如下。
    
    1. // ArkTS测试文件Ability.test.ets
    2. import entryTest from 'libentry_test.so';
    3. export default function abilityTest() {
    4.   describe('ActsAbilityTest', () => {
    5.     ...
    6.     it('testNative', 0, () => {
    7.       hilog.info(0x0000, 'testTag', '%{public}s', 'testNative it begin');
    8.       let result = entryTest.runNativeTest();
    9.       hilog.info(0x0000, 'testTag', '%{public}s', result)
    10.       expect(result).assertContain("ended");
    11.     })
    12.   })
    13. }
    
3. 运行testNative测试用例，查看测试结果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.22927012906835269546822760950642:50001231000000:2800:EB2217424DA654D99305A5FB5FE4349D81EA122AF58D9D0FB19E2C5780BF2D0F.png)
    

### 收集代码覆盖率

DevEco Studio默认不收集C++代码覆盖率，需要通过以下方式开启。

1. 在测试目录下的CMakeLists.txt中添加以下代码，开启覆盖率编译插桩能力。
    
    1. set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-instr-generate -fcoverage-mapping")
    2. set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fprofile-instr-generate -fcoverage-mapping")
    
2. 在napi_init.cpp文件的RunNativeTest方法中，调用__llvm_profile_write_file方法，将覆盖率数据保存到设备的/data/storage/el2/base路径下的c++_coverage.profraw文件中，该路径和文件名不可修改，示例代码如下。
    
    1. extern "C" {
    2.     void __llvm_profile_set_filename(char *);
    3.     int __llvm_profile_write_file(void);
    4. }
    
    5. static napi_value RunNativeTest(napi_env env, napi_callback_info info)
    6. {
    7.     char filename[256];
    8.     snprintf(filename, sizeof(filename), "/data/storage/el2/base/c++_coverage.profraw"); // 覆盖率报告文件路径和文件名，不可修改
    9.     __llvm_profile_set_filename(filename);
    10.     // 开启测试
    11.     ...
    12.     // 结束测试，保存数据
    13.      __llvm_profile_write_file();
    14.     ...
    15. }
    
3. 运行覆盖率测试，选中ArkTS测试文件，单击**右键 >** **Run '测试文件名称' with Coverage**，执行测试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.13694241835484574500581829692996:50001231000000:2800:451925D4240D6DCEEAF846FBFDBF5CB07137E3650355904123A8E3881F940E56.png)
    
    启动测试后，进行编译构建，底部将出现Cover窗口，构建结束后自动拉起Cover窗口，测试任务结束后，窗口中会打印测试报告的路径。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.56083530655454155492760996806774:50001231000000:2800:2EC4E2C7845C3108711916953CA5E844DB85945E6A96CD92B9FFDF84B3ACDD5B.png)
    
    点击链接可打开报告，查看C++代码覆盖率详情。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155856.44858273803606940118462330082963:50001231000000:2800:1E246D44CBABD0B809097F8CF18DF04DB8F226F9E7619D88AD3273315100A1A9.png)
    

## 使用命令行执行测试Instrument Test

通过命令行方式执行Instrument Test，在工程根目录下执行命令：

1. hvigorw onDeviceTest -p module={moduleName} -p coverage={true|false} -p scope={suiteName}#{methodName} -p ohos-debug-asan={true|false}

- module：执行测试的模块，缺省默认是执行所有模块的用例。
- coverage：是否生成覆盖率报告，缺省默认是true。
    
    覆盖率测试报告路径：<module-path>/.test/default/outputs/ohosTest/reports/index.html
    
    如果开启了C++代码覆盖率测试，会生成C++代码的覆盖率报告，路径：<module-path>/.test/default/outputs/ohosTest/cpp_reports/index.html
    
- scope：格式为{suiteName}#{methodName}或{suiteName}，分别表示测试用例级别或测试套件级别的测试，缺省默认是执行当前模块的所有用例。
- ohos-debug-asan：是否启用ASan检测，缺省默认是false。从DevEco Studio 5.1.1 Beta1版本开始支持。
    
    ASan日志路径：<module-path>/.test/default/intermediates/ohosTest/coverage_data
    

说明

多个module和scope之间用逗号分隔。

测试结果文件：<module-path>/.test/default/intermediates/ohosTest/coverage_data/test_result.txt

[代码测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-test "代码测试")

[Local Test](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-local-test "Local Test")
# Local Test

更新时间: 2025-12-16 15:58

说明

当前不支持测试C/C++方法及系统API。

## 创建Local Test测试用例

1. 在工程目录下打开待测试模块（支持HAP、HAR、HSP模块）下的ets文件，将光标置于代码中任意位置，单击**右键 > Show Context Actions** **> Create Local Test**或快捷键**Alt+Enter****（macOS为Option+Enter） > Create Local Test**创建测试类。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.62784353128866190625003259441862:50001231000000:2800:2DAE2CC8C13CABA345FAEA1E16AEFBA158893AD78DEF6696022B59A2F6ECCB1B.png)
    
2. 在弹出的Create Local Test窗口，输入或选择如下参数。
    
    - **Testing library**：测试类型，默认为DECC-ArkTSUnit。
    - **ArkTS name**：创建的测试文件名称，测试文件中包含了测试用例。测试文件名称要求在工程目录范围内具有唯一性，仅支持字母、数字、下划线（_）和点（.）。
    - **Destination package**：测试文件存放的位置，建议存放在待测试模块的test目录下。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.59812640588633498748145716046093:50001231000000:2800:AAED9EF0D0849D505D49422F4F323A373BE3FAA45ED9B4EBEB81720FC4F7D69C.png)
    
3. DevEco Studio在test目录下自动生成对应的测试类。在测试类中，DevEco Studio会生成对应方法的用例模板，具体测试代码需要开发者根据业务逻辑进行开发，具体请参考[单元测试框架](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/unittest-guidelines)。
    
    说明
    
    您也可以手动在test文件夹下创建测试用例，手动创建后，需要在List.test.ets文件中添加创建的用例类。
    

## 运行Local Test测试用例

### 运行模式

可以采用运行工程目录（test）、测试文件（如Index.test.ets）、测试套件（describe）、测试方法（it）的方式来执行Local Test，各级别测试执行入口如下。

|   |   |
|---|---|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.55922596064694049544199605162133:50001231000000:2800:060159C070B376FE457AEB932695C20FEDF517001D2B031E32DB5B4DFFE19EB3.png)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.79018130742031979550132849669078:50001231000000:2800:DA94AC43D2808D8234BED5C293E0D74D4D57675F223E24192BCCA9F52BAE1C8E.png)|
|目录级|文件级|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.34070336877819009715471454361949:50001231000000:2800:AA7FE37F7DF53053233A1858046405DB7B84AE16E4850E0C39C6A6A58FDCD21E.png)|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.25617972684028414058463865781536:50001231000000:2800:A684255CC177A4B402FDC7AA2D4252428CDECF6E3B3E72D197263D6A8C65D3E9.png)|
|套件级|方法级|

以文件级别为例，在工程目录中，选中文件，单击**右键 > Run'测试文件名称'**，执行测试。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.25067201945429853802821462636333:50001231000000:2800:2A16B9687A5A939FD548B584640319BC3BD774F60CF521098AC79B2340367074.png)

也可以通过如下方式，执行Local Test：

- 在工具栏主菜单单击**Run > Run'测试名称'**。
- 在DevEco Studio的右上角，选择一项测试任务的配置，然后单击右侧的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.61115715689717720198761487490237:50001231000000:2800:87E7335CA048501200DE6A79A9842966A6ADBB538B03DA53F258B123D6A4BA59.png)按钮，执行Local Test。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155857.91915553896881409827924057283527:50001231000000:2800:88C75087493CC1D4848A7644C80473F9F5D25DC880B817EF6236FF7A426B9976.png)
    

执行完测试任务后，查看测试结果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.05997389337093943229210581629340:50001231000000:2800:B38FAB142B4ECEA25F02E7D79315F5C75BA394B413FDD1A8D15AC85E5DDD1832.png)

### 调试模式

调试模式相比运行模式增加了断点管理功能。在断点命中时，可以选择单步执行、步入步出、进入下个断点等方式进行调试，另外可以使用线程堆栈可视化、变量和表达式可视化功能，快速定位问题。

以文件级别为例，在添加断点之后，在工程目录中，选中文件，单击**右键 > Debug'测试文件名称'**，以调试模式执行测试任务。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.14751575915115948093931514476627:50001231000000:2800:FD2382757B3807CE7250DD275B62B4607EA74A51A1DCA59A7C183DBE5B8880B8.png)

在断点命中时，下方将出现Debug窗口。开发者可在该窗口中进行断点管理与基础调试能力的可视化操作，在断点命中时可查看当前线程的变量和堆栈信息。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.75032361237899778282391910154732:50001231000000:2800:BC84E94F69318A8F46F069A5F6A97131DC00EECCAD86540145782095825A42DD.png)

断点命中时，在代码编辑器窗口单击右键，在弹出的菜单中将出现调试模式特有功能，如计算表达式、添加变量监视等。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.47119569247939226276184078418128:50001231000000:2800:1714773FD069A59980C6C7A503290D94F13D6186E74941E330A69085A0B5A187.png)

在跳出所有断点后，测试结束，与运行模式相同，在测试窗口查看测试结果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.10931234090784712205881407217347:50001231000000:2800:75274EE7A3C5E2775D0504B25E1D95CBCF87463E098FD4B01575723CC68EB33E.png)

### 覆盖率统计模式

在LocalTest运行的基础上支持代码覆盖率统计，当前仅支持ArkTS工程。

开发者可以自定义需要参与覆盖率测试的文件，具体配置方法请参考[配置覆盖率过滤文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-test#section13756446154)。

如前所述，覆盖率统计模式也有多级别入口，以文件级别为例，有两种方式启动测试：

- 方式一：在工程目录中，选中文件，单击**右键 > Run '测试文件名称' with Coverage**，以覆盖率统计模式执行测试任务。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.84595656685645085992375362054174:50001231000000:2800:41D64610198CD5AF6B18AD8BEE317D785ED4F96CC93AB4823AEB202BFEEA6187.png)
    

- 方式二：在DevEco Studio的右上角，选择测试任务，然后单击右侧的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.00043420444010915815376930379731:50001231000000:2800:505FC3A6F5381E09CFAA3022A1CEFF33D66D8B61C9A5356EB5C9685F150E9C3B.png)按钮，执行测试。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.67610587198446885212880012980907:50001231000000:2800:9BC074BD8D630EEE0A249E5958B72192DD39AA9329D557341C209CFC4B4B295B.png)
    

启动测试后，进行编译构建，底部将出现Cover窗口，构建结束后自动拉起Cover窗口，测试任务结束后，窗口中会打印测试报告的路径。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.08183144723797050702209600375661:50001231000000:2800:12D970DFF16948CB51B3D04529D71AC46FA24FC14792E51B395D41B3B2FE1FC9.png)

点击链接可打开报告，查看代码覆盖率详情，关于覆盖率的计算方式请参考[查看覆盖率报告](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-test#section10394362109)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.32044739269171432580483418390434:50001231000000:2800:D2AE539C8733FD87D00D79612A0611E396B5CD0170347346607EF2E16CCA87AA.png)

在Cover窗口中，单击rerun按钮可以按照之前的设置，重新执行覆盖率用例。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.31215179019082885045049657511360:50001231000000:2800:F8B2ED5664DA21642317ED4B28D5AD97A4724A5D3A6B228EF860200957052D37.png)

## （可选）自定义测试用例运行任务

默认情况下，测试用例可直接运行。如果需要自定义测试用例运行任务，可通过如下方法进行设置。

1. 在工具栏主菜单单击**Run**>**Edit Configurations**，进入Run/Debug Configurations界面。
2. 在**Run/Debug Configurations**界面，单击**+**按钮，在弹出的下拉菜单中，单击**Local Test**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.54755863331996183655233911416710:50001231000000:2800:68768A8A5FFD7062730176B9F935764E5ACF874362EEF42070E92F0A18AD8C04.png)
    
3. 根据实际情况，配置Local Test的运行参数。 然后单击**OK**，完成配置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155858.98887370859358576701354096604982:50001231000000:2800:48FD61B387D5292745618969DBCDB4A6EA3708467F8FB4271C370A0C634935FC.png)
    

## 使用命令行执行Local Test

通过命令行方式执行Local Test，在工程根目录下执行命令：

1. hvigorw test -p module={moduleName} -p coverage={true | false} -p scope={suiteName}#{methodName}

- module：执行测试的模块。缺省默认是执行所有模块的用例。
- coverage：是否生成覆盖率报告，缺省默认是true。
    
    覆盖率测试报告路径：<module-path>/.test/default/outputs/test/reports/index.html
    
- scope：格式为{suiteName}#{methodName}或{suiteName}，分别表示测试用例级别或测试套件级别的测试，缺省默认是执行当前模块的所有用例。

说明

- 多个module和scope之间用英文逗号分隔。
- 暂不支持在Linux上执行该命令。

测试结果文件：<module-path>/.test/default/intermediates/test/coverage_data/test_result.txt

[Instrument Test](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-instrument-test "Instrument Test")

[Mock能力](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-test-mock "Mock能力")
# Mock能力

更新时间: 2025-12-16 15:58

在实际开发中，一些接口或者对象依赖于外部资源或复杂的逻辑，这些依赖在测试环境中难以复现，导致这些接口或者对象难以测试，此时，可以使用Mock能力，对这些接口或对象进行模拟。当前Instrument Test和Local Test均支持对模块进行Mock，对于调用系统模块API或外部依赖模块，使用import mock，对于本地模块，使用hamock/hypium插件包的mock接口或者import mock。

说明

仅API 11及以上版本的Stage工程支持。

## 系统模块/依赖模块Mock

通过import mock对系统模块API或依赖模块的方法进行Mock，在mock-config.json5配置文件中定义目标模块和Mock实现代码文件的映射关系，运行时import目标模块都将指向Mock实现代码。以系统API bluetoothManager为例，具体实现如下。

1. 在src/mock目录下新建一个ArkTS文件，例如bluetooth_manager.mock.ets，在这个文件内定义目标模块的Mock实现。
    
    1. // src/mock/bluetooth_manager.mock.ets
    2. enum BluetoothState {
    3.   /** Indicates the local Bluetooth is off */
    4.   STATE_OFF = 0,
    5.   /** Indicates the local Bluetooth is turning on */
    6.   STATE_TURNING_ON = 1,
    7.   /** Indicates the local Bluetooth is on, and ready for use */
    8.   STATE_ON = 2,
    9.   /** Indicates the local Bluetooth is turning off */
    10.   STATE_TURNING_OFF = 3,
    11.   /** Indicates the local Bluetooth is turning LE mode on */
    12.   STATE_BLE_TURNING_ON = 4,
    13.   /** Indicates the local Bluetooth is in LE only mode */
    14.   STATE_BLE_ON = 5,
    15.   /** Indicates the local Bluetooth is turning off LE only mode */
    16.   STATE_BLE_TURNING_OFF = 6
    17. }
    18. interface BluetoothInfo {
    19.   state: number
    20. }
    21. const MockBluetoothManager: Record<string, Object> = {
    22.   'getBluetoothInfo': () => {
    23.     return { state : BluetoothState.STATE_BLE_TURNING_ON } as BluetoothInfo;
    24.   },
    25. };
    26. export default MockBluetoothManager;
    
2. 在Mock配置文件src/mock/mock-config.json5中定义目标模块与Mock实现的映射关系。
    
    1. "@ohos.enterprise.bluetoothManager": {  // 待替换的模块名
    2.   "source": "src/mock/bluetooth_manager.mock.ets"  // Mock代码的路径，相对于模块根目录
    3. }
    
3. 在测试文件中编写如下代码。
    
    1. // bluetoothManager.test.ets
    2. import { describe, it, expect } from '@ohos/hypium';
    3. import { bluetoothManager } from '@kit.MDMKit';
    
    4. export default function mock_system_api() {   
    5.   describe('mock_system_api', () => {
    6.     /* mock系统API */
    7.     it('mock_system_api', 0, () => {
    8.       let bluetoothInfo = bluetoothManager.getBluetoothInfo({
    9.         bundleName: "com.example.myapplication"
    10.       })
    11.       expect(bluetoothInfo.state).assertEqual(4)
    12.     });
    13.   });
    14. }
    
4. 如果测试文件是手动创建的，需要将用例类mock_system_api添加到List.test.ets文件中。
    
    1. import mock_system_api from './bluetoothManager.test';
    
    2. export default function testsuite() {
    3.   mock_system_api();
    4. }
    
5. 执行测试，用例通过。

## 本地模块Mock

有两种方式可以对本地模块进行Mock，一是使用hamock/hypium插件包的mock接口，二是使用import mock。

### 使用hamock/hypium插件包的mock接口

以下例子通过mock接口模拟本地模块的某个方法，关于Mock的更多说明可以参考[mock能力](https://gitee.com/openharmony/testfwk_arkxtest#mock%E8%83%BD%E5%8A%9B)。

1. 在src/main/ets目录下新建一个ArkTS文件，例如ClassForMock.ets，并在其中导出一个类。
    
    1. export class ClassForMock {
    2.   constructor() {
    3.   }
    4.   method_1(arg: string) {
    5.     return '888888';
    6.   }
    7.   method_2(arg: string) {
    8.     return '999999';
    9.   }
    10. }
    
2. 在测试文件中编写如下代码。
    
    1. // afterReturnTest.test.ets
    2. import { describe, expect, it, MockKit, when } from '@ohos/hypium';
    3. import { ClassForMock } from '../../../main/ets/ClassForMock';
    
    4. export default function afterReturnTest() {
    5.   describe('afterReturnTest', () => {
    6.     it('afterReturnTest', 0, () => {
    7.       console.info("it begin");
    8.       // 1.创建一个mock能力的对象MockKit
    9.       let mocker: MockKit = new MockKit();
    10.       // 2.定义类ClassForMock，里面两个函数，然后创建一个对象classForMock
    11.       let classForMock: ClassForMock = new ClassForMock();
    12.       // 3.进行mock操作,比如需要对ClassForMock类的method_1函数进行mock
    13.       let mockFunc: Function = mocker.mockFunc(classForMock, classForMock.method_1);
    14.       // 4.期望classForMock.method_1函数被mock后, 以'test'为入参时调用函数返回结果'1'
    15.       when(mockFunc)('test').afterReturn('1');
    16.       // 5.对mock后的函数进行断言，看是否符合预期
    17.       // 执行成功案例，参数为'test'
    18.       expect(classForMock.method_1('test')).assertEqual('1'); // 执行通过
    19.     })
    20.   })
    21. }
    
3. 如果测试文件是手动创建的，需要将用例类afterReturnTest添加到List.test.ets文件中。
    
    1. import afterReturnTest from './afterReturnTest.test';
    
    2. export default function testsuite() {
    3.   afterReturnTest();
    4. }
    
4. 执行测试，用例通过。

### 使用import mock

使用import mock对本地模块进行Mock，操作步骤和系统模块/依赖模块的Mock类似，在mock-config.json5配置文件中定义目标模块和Mock实现代码文件的映射关系，运行时import目标模块都将指向Mock实现代码。以下例子对本地模块entry/src/main/ets/common/calc.ets中的sum函数进行Mock。

1. 在src/mock目录下新建一个common目录并创建一个ArkTS文件，例如calc.mock.ets，在这个文件内定义目标模块的Mock实现。
    
    1. // src/mock/common/calc.mock.ets
    2. export function sum() {
    3.   return "this is mock sum";
    4. }
    
    calc.ets的原始实现如下：
    
    1. // src/main/ets/common/calc.ets
    2. export function sum() {
    3.   return 1;
    4. }
    
2. 在Mock配置文件src/mock/mock-config.json5中定义目标模块与Mock实现的映射关系。
    
    1. {
    2.   "common/calc.ets": { // 本地模块只支持ets/xxx的相对路径，并需明确文件后缀
    3.     "source": "src/mock/common/calc.mock.ets"  // Mock代码的路径，相对于模块根目录
    4.   },
    5. }
    
3. 在测试文件中编写如下代码。
    
    1. // test_mock_local_method.test.ets
    2. import { describe, it, expect } from '@ohos/hypium'
    3. import { sum } from '../../../main/ets/common/calc';
    
    4. export default function test_mock_local_method() {
    5.   describe('test_mock_local_method', () => {
    6.     it("test_mock_local_method", 0, () => {
    7.       expect(sum()).assertEqual("this is mock sum")
    8.     })
    9.   })
    10. }
    
4. 如果测试文件是手动创建的，需要将用例类test_mock_local_method添加到List.test.ets文件中。
    
    1. import test_mock_local_method from './test_mock_local_method.test';
    
    2. export default function testsuite() {
    3.   test_mock_local_method();
    4. }
    
5. 执行测试，用例通过。

[Local Test](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-local-test "Local Test")

[黑盒覆盖率测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-test "黑盒覆盖率测试")
# 应用与元服务体检

更新时间: 2025-12-16 15:58

## 功能介绍

DevEco Studio提供了应用与元服务体检工具AppAnalyzer，用于对应用和元服务进行本地测试体检，并给出体检报告、分析指导以及修改建议，帮助开发者提升应用与元服务质量。在体检过程中，工具会收集应用或元服务的trace信息、代码栈、内存快照以及应用或元服务页面的截屏，并保存在本地工程目录.appanalyzer下，帮助开发者快速进行问题分析定位。

开发者可以通过DevEco Studio连接本地设备，自主遍历HarmonyOS应用或元服务的功能，快速进行自测试，查看测试结果及评分。当前支持以下几种体检模式。

- **规则体检**：支持兼容性、性能、功耗等多种测试类型，开发者可自主选择不同的规则进行测试，具体请参考[规则体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section16341371309)。
- **场景化体检**：开发者无需了解具体的规则，可以基于实际的应用场景、对特定的页面进行测试，测试结果可以更清晰地指导开发者对某个页面某个场景的某个指标进行优化，具体请参考[场景化体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section115121358308)。
- **上架前体检**：针对上架阻塞问题进行快速检测，提前发现可能影响上架的问题，检测完成之后可以选择上传检测结果，用于应用市场上架参考，提升上架效率，具体请参考[上架前体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section39507231624)。该功能从DevEco Studio 6.0.0 Beta1版本开始支持。

以上体检模式都是在AppAnalyzer中进行测试并生成体检报告，从DevEco Studio 6.0.0 Beta3版本开始，支持在[DevEco Testing](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/deveco-testing)中测试生成检测报告后，导入到AppAnalyzer进行诊断和分析，获得可能的故障原因并生成体检报告，具体请参考[导入DevEco Testing的检测报告进行诊断](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section19550112715455)。

从DevEco Studio 6.0.1 Beta1版本开始，针对高频的体检场景，AppAnalyzer提供预置的体检卡片，开发者可选择预置卡片快速进行体检，或者根据需要自定义卡片。

## 使用约束

当前仅phone类型的设备支持使用应用与元服务体检能力。

## 前置操作

1. 在进行规则体检、场景化体检或上架前体检之前，先要确保[DevEco Studio与真机设备已连接](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-device)，并根据[应用/元服务签名](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-signing)章节进行签名。
2. 如果使用DevEco Studio 6.0.0 Beta2之前的版本，需要先编译生成HAP或HSP。使用Beta2及以上的版本，无需提前编译。
3. 通过以下任意一种方式，打开AppAnalyzer。
    - 单击菜单栏**Tools >** **AppAnalyzer**，打开AppAnalyzer页面。
    - 在编辑窗口右侧的工具栏，点击**AppAnalyzer**或![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.88778240055221665504000576889120:50001231000000:2800:F62E5FAF35BE9A31963BF71FC37E7535179D76902610E7B3614257D4CE70EAEE.png)，打开AppAnalyzer页面。
4. 如果未配置Python环境，请根据界面提示，下载Python及三方库。或者点击AppAnalyzer底部**Python 配置**按钮进行配置。

## 规则体检

### 操作步骤（DevEco Studio 6.0.1 Beta1及以上版本）

1. 点击右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.54456142603752420761515203073019:50001231000000:2800:027EBD196221C7F2866DC768770E75912B86036B1E25B22FDDF4F34DF341CEBD.png)图标选择Product、Target和构建模式，点击**Apply**后，在AppAnalyzer的首页中可查看对应的编译产物和构建模式。关于Product、Target、构建模式的介绍请参考[配置多目标产物](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides)和[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.33097934532295072034152976516668:50001231000000:2800:8E48A83981BB895AEF73EB97398563CB5DF87EE8F07EFA7339C8883A2F894B6F.png)
    
2. 在**AppAnalyzer**页面，选择**规则体检**，选择预置的体检卡片，或根据需要自定义卡片。
    
    - 点击预置的体检卡片开始体检，如需查看卡片包含的体检规则，请点击卡片右上角的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.55658808974148834620757221650638:50001231000000:2800:719F443575842DE1B213636C51A48E5F9F0D43DD47E7AAB39FA04CD1DD50C2E1.png)按钮，规则详情请参考[规则总览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-all-rules)。
    - 如果需要自定义体检规则，点击**+**，选择自动/手动测试和体检规则，部分规则可修改单次录制时长，请根据界面提示进行修改。
    
    说明
    
    以下体检规则不支持在编译模式为release下运行，请把编译模式切换到debug再重新检测：组件树节点数目过大、执行函数耗时过长、渲染界面耗时过长、ForEach中item数量过大。
    
3. 开始体检后，请等待AppAnalyzer完成构建、签名、安装等操作。
    - 如果是自动测试，根据界面提示，登录应用账号后点击继续按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.16230443902213754826657684710201:50001231000000:2800:73C08C0A0BD3769EF6864018F78B06DC0B7012787A9C3CE49B791975DF3013A1.png)，继续测试；或者无需登录账号，直接点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.23958198239215943116517753681200:50001231000000:2800:8A47378D65A6BD3A978464A48D9D07438C50225C07830463EDDC4EC15E4D2D31.png)按钮继续测试。
    - 如果是手动测试，根据界面提示，点击开始按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.87602858679335116308028472265502:50001231000000:2800:9C5336886BA2F31E6ADBA086C4E9F6DC1ADAE79077ADCD58965D241033ADF827.png)开始录制，并手动遍历应用/元服务的功能。如果在录制时间范围内未遍历完成，可继续点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.37103791082329451863503186628148:50001231000000:2800:0092F581DDE0649E4C8DE0B0619C85F8488B546B0B1A564EB71C27FE5C15B863.png)按钮，进行多次遍历，遍历完成后点击结束按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.84932922963712893723857421306755:50001231000000:2800:A6C07385FC9FE3CCCE80E8373548263590F2CE34B914012504E45AF42350CF63.png)。
4. 查看测试报告，包含以下内容。
    
    - **源文件、调优文件（包含trace文件和调用栈文件）或snapshot文件、时间戳等**：点击源文件可跳转到问题源码，点击调优文件或snapshot文件支持直接拉起性能分析工具Profiler并导入性能检测的问题数据进行调优分析，点击时间戳可以打开Profiler并定位到问题发生的时间范围。
    - **分析文档**：点击链接可跳转至官网文档，参考文档对检测出来的问题进行分析。
    - **优化建议**：针对检测出来的问题，给出对应的最佳实践，点击链接可跳转至官网文档。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.16660621543940693917634084426521:50001231000000:2800:E5BC7EED75D0BEA95A3DD637B5888EC6CD96D097280007B9CEF244F15245974D.png)
    

### 操作步骤（DevEco Studio 6.0.1 Beta1以下版本）

1. 如果使用DevEco Studio 6.0.0 Beta2及以上的版本，支持在体检过程中自动编译构建打包。点击右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155822.34048015175478917421617230556374:50001231000000:2800:6AE9DF58037BA7037D98D4D91614DD1F47864938CA2E61801A2EC076D0AAB89D.png)图标选择Product、Target和构建模式，关于Product、Target、构建模式的介绍请参考[配置多目标产物](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides)和[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)。
2. 在**AppAnalyzer**页面，选择**规则体检**，选择自动或手动方式，**模块**选择框选择HarmonyOS应用/元服务工程模块。
    
    - 自动方式：体检时无需手动遍历，AppAnalyzer会自动检测。
    - 手动方式：体检时需要根据提示手动遍历HarmonyOS应用/元服务的功能。
    
    说明
    
    - 如果使用DevEco Studio 6.0.0 Beta2之前的版本，只有已经完成签名编译打包的模块才能被选中。
    - 支持同时添加多个模块，要求所有模块的“bundleName”相同，且多个模块中只能包含一个entry。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.11266640035007940920836240108274:50001231000000:2800:58FD7E826518896B71FE183EE4EBADFC57AAF1CF3361AD309C776859CB20539A.png)
    
3. 选择待测试的规则，规则详情请参考[规则总览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-all-rules)，然后在**AppAnalyzer**页面底部单击**开始**按钮，开始测试。部分测试规则依赖Python，请根据AppAnalyzer的指引，下载Python及三方库。在测试过程中，请保持连接的设备为解锁亮屏状态。
    
    说明
    
    - 请勿在测试完成前点击结束，如果提前结束测试会导致测试结果不准确。
    - 支持Python3.9~3.12版本，推荐使用Python 3.11.7版本。
    - 部分规则体检会进行投屏，如果测试过程中同时使用其他投屏工具，如DevEco Testing，可能会对UX测试的投屏造成干扰。如果投屏中断或不同步，可点击左上角刷新按钮重新投屏。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.19395944813300396216671131994604:50001231000000:2800:85B2042A67CB88FFCA5EB7F8CC52BA9E9D1EFB79BA1E106EFF272A662F67AE58.png)
    
4. 如果是手动方式，在安装应用/元服务完成后，需要根据提示手动遍历HarmonyOS应用/元服务的功能。手动遍历完成后点击**结束**按钮停止测试任务，等待数据解析完成后，查看测试结果如下。
    
    - 测试报告：检测结果的汇总信息，点击**详情链接**可跳转到对应的详情报告
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.11327676233278567020238621822248:50001231000000:2800:F69496B72CC3249098CD719D569C5F096B3982451CD2152B36D13B6F213534CF.png)
        
    - 详情报告：只包含检测失败的规则，给出详细的测试结果、相关的定位文件和对应的优化建议。
        
        - **源文件、调优文件（包含trace文件和调用栈文件）或snapshot文件、时间戳等**：点击源文件可跳转到问题源码，点击调优文件或snapshot文件支持直接拉起性能分析工具Profiler并导入性能检测的问题数据进行调优分析，点击时间戳可以打开Profiler并定位到问题发生的时间范围。
        - **分析文档**：点击链接可跳转至官网文档，参考文档对检测出来的问题进行分析。
        - **优化建议**：点击链接可跳转至官网文档，参考文档对检测出来的问题进行优化。
        - **Code Linter**：在“最佳实践测试”项目中，可直接在拉起Code Linter的同时，传递有问题的代码文件名，自动执行代码检查。在“快速性能测试”和“性能测试”项目中，因无代码文件名等信息，部分检测规则不支持自动执行代码检查，仅支持拉起Code Linter。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.16596605028187798869534865587458:50001231000000:2800:FE6EAA4F536F776A7ACC61A3BC8E3CBB9D3C685615C7DC869A1162BC00537C7F.png)
        
    

### 评分方法和规则

AppAnalyzer会根据体检结果计算出最后评分，满分为100分。

- **DevEco Studio 6.0.1 Beta1及以上版本，评分规则如下，具体体检规则请参考****[规则总览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-all-rules)****。**
    
    规则基础得分：如果有成功的则基础分数为60分，否则基础分数为0
    
    规则系数得分：(成功次数 / 总次数) * 40 + (告警次数 / 总次数) * 0.6 * 40
    
    规则得分：规则基础得分 + 规则系数得分
    
    分类得分 = sum(分类下的规则得分) / 分类下的规则个数
    
    总分 = sum(分类得分) / 分类个数
    
    说明
    
    如果规则未执行，该规则得分是100分。
    
- **DevEco Studio 6.0.1 Beta1以下版本，评分规则如下：**
    
    评分 = sum(检测通过的体检项权重）/ sum(体检项权重）* 100
    
    各体检项检测规则及权重请参考[规则总览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-all-rules#section878882265416)。
    

## 场景化体检

### 操作步骤（DevEco Studio 6.0.1 Beta1及以上版本）

1. 点击右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.90399051112025936166685315570596:50001231000000:2800:C19E50B65C5580E7D90247D15CF4E68D1B7C15C230CA8547AF0A3088B4FEBD8C.png)图标选择Product、Target和构建模式，点击**Apply**后，在AppAnalyzer的首页中可查看对应的编译产物和构建模式。关于Product、Target、构建模式的介绍请参考[配置多目标产物](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides)和[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.54426660924058338972841840060398:50001231000000:2800:7C63676AADCC78825E7A05A41B0D315A589B2A8B0D67D0F3DE186452E5A7861B.png)
    
2. 在**AppAnalyzer**页面，选择**场景化体检**，选择预置的体检卡片，或根据需要自定义卡片。
    - 点击预置的体检卡片开始体检，如需查看卡片包含的体检场景，请点击卡片右上角的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.67577133528490186154593249688449:50001231000000:2800:1B137E91FB729753481B2D8E0C59D482FFA2FE64F97D9CFD51473D0C3964FD59.png)按钮，不同场景对应的检测指标请参考[评分方法和指标](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section179917512311)。
    - 如果需要自定义体检场景，点击**+**，选择自动/手动测试和体检场景，部分场景可修改单次录制时长/测试总时长，请根据界面提示进行修改。
3. 开始体检后，请等待AppAnalyzer完成构建、签名、安装等操作。
    - 如果是自动测试，根据界面提示，登录应用账号后点击继续按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.14654216739736421355197520468980:50001231000000:2800:49BD18D3FB9E709BA8100CFD6AABEA6DE45FD65D2FC1320CBE6FC9BF50BB1FDE.png)，继续测试；或者无需登录账号，直接点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.70252305706302326305471543594694:50001231000000:2800:171ABDE94B019068C5B0B4346F86208E0B9175D668D2C059C4D03FDCF2D25FAE.png)按钮继续测试。
    - 如果是手动测试，根据界面提示，点击开始按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.48059379055100845517803358308505:50001231000000:2800:7E6BD2548971624EF24C7C77D626E543848344ED61A8CA1DA52455DEB3E6BEC9.png)开始录制，并手动遍历应用/元服务的功能。如果在录制时间范围内未遍历完成，可继续点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.89540321403378584307257056096281:50001231000000:2800:868052EDF58F3B77998E81CCBE99749D05BE3948861A89ACDA6080ED443648C1.png)按钮，进行多次遍历，遍历完成后点击结束按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.45369736083345534930727152620624:50001231000000:2800:FE409836D7A2FBB3DFA1012C4C79B7524D8275E5BB0F715961D5EE6F1ADBABC6.png)。
4. 查看测试报告，包含以下内容。
    
    - **源文件、调优文件（包含trace文件和调用栈文件）或snapshot文件、时间戳等**：点击源文件可跳转到问题源码，点击调优文件或snapshot文件支持直接拉起性能分析工具Profiler并导入性能检测的问题数据进行调优分析，点击时间戳可以打开Profiler并定位到问题发生的时间范围。
    - **分析文档**：点击链接可跳转至官网文档，参考文档对检测出来的问题进行分析。
    - **优化建议**：点针对可能的故障原因，给出对应的最佳实践，点击链接可跳转至官网文档。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.29358052328371913033924859339966:50001231000000:2800:93DC5803D621EEB779034BA4E0B155BD5BAEF5D1C63D0F83421DA49E55226559.png)
    

### 操作步骤（DevEco Studio 6.0.1 Beta1以下版本）

1. 如果使用DevEco Studio 6.0.0 Beta2及以上的版本，支持在体检过程中自动编译构建打包。点击右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155823.36666358957766341014601105511939:50001231000000:2800:464ACDC6BEC4B15E3E93B6E1D9DB17C5548DD1FF2B03FD029D666214AE3519AB.png)图标选择Product、Target和构建模式，关于Product、Target、构建模式的介绍请参考[配置多目标产物](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-customized-multi-targets-and-products-guides)和[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)。
2. 在**AppAnalyzer**页面，选择**场景化体检**，选择**自动**或**手动**方式，**模块**选择框选择HarmonyOS应用/元服务工程模块。
    
    - 自动方式：体检时无需手动遍历，AppAnalyzer会自动检测。自动方式下还需要选择具体的运行时长。
    - 手动方式：体检时需要根据提示手动遍历HarmonyOS应用/元服务的功能。
    
    说明
    
    - 如果使用DevEco Studio 6.0.0 Beta2之前的版本，只有已经完成签名编译打包的模块才能被选中。
    - 支持同时添加多个模块，要求所有模块的“bundleName”相同，且多个模块中只能包含一个entry。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.99129164432109913297870581219627:50001231000000:2800:DFC15C05D8055FFE0520E5B8CA050D68D5A5E44E830AFC32322448342E42D502.png)
    
3. 勾选体检场景，不同场景对应的检测指标请参考[评分方法和指标](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section179917512311)，然后在**AppAnalyzer**页面底部单击**开始**按钮，开始测试。首次测试时，请根据AppAnalyzer的指引，下载Python及三方库，或者登录开发者账号并自动签名音频辅助检测APP。在测试过程中，请保持连接的设备为解锁亮屏状态。
    
    说明
    
    - 请勿在测试完成前点击结束，如果提前结束测试会导致测试结果不准确。
    - 支持Python3.9~3.12版本，推荐使用Python 3.11.7版本。
    
4. 如果是手动方式，在安装应用/元服务完成后，需要根据提示手动遍历HarmonyOS应用/元服务的功能。手动遍历完成后点击**结束**按钮停止测试任务，等待数据解析完成后，查看测试结果如下。
    
    - 测试报告：检测结果的汇总信息，默认展示告警和失败的检测结果，检测标准请参考[评分方法和指标](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section179917512311)，点击**详情链接**可跳转到对应场景的详情报告。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.55010987355780821516144429389617:50001231000000:2800:C8D622F5432380A5A3C10686F730E0EF7CEDBD5D0245727CF2E0E6D19BDAF2DA.png)
        
    - 详情报告：给出详细的测试结果、相关的定位文件和对应的优化建议。
        
        - **开始/结束页面、时间戳、调优文件（包含trace文件和调用栈文件）或snapshot文件等**：点击开始/结束页面可跳转到问题源码，点击时间戳可以打开性能分析工具Profiler并定位到问题发生的时间范围，点击调优文件或snapshot文件支持直接拉起Profiler并导入性能检测的问题数据进行调优分析。
        - **分析文档**：点击链接可跳转至官网文档，参考文档对检测出来的问题进行分析。
        - **优化建议**：针对可能的故障原因，给出对应的最佳实践，点击链接可跳转至官网文档。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.12074174138344501734759219246230:50001231000000:2800:604F71E5AC21B642FA77CA0ADC2FF70E98080B40586524A195B6562D842B47D7.png)
        

### 评分方法和指标

AppAnalyzer会根据体检结果计算出总分，满分为100分，具体指标请参考[表2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#table16267340145013)。

- **DevEco Studio 6.0.1 Beta1及以上版本，评分规则如下：**
    
    指标基础得分：如果有成功的则基础分数为60分，否则基础分数为0
    
    指标系数得分：(成功次数 / 总次数) * 40 + (告警次数 / 总次数) * 0.6 * 40
    
    指标得分：指标基础得分 + 指标系数得分
    
    分类得分 = sum(分类下的指标得分) / 分类下的指标个数
    
    总分 = sum(分类得分) / 分类个数
    

- **DevEco Studio 6.0.0 Beta3/Beta5/Release版本，评分规则如下**：
    
    指标基础得分：如果有成功则基础得分为60分，否则基础得分为0
    
    指标系数得分：(成功次数 / 总次数) * 40 + (告警次数 / 总次数）* 0.6 * 40
    
    指标得分：指标基础得分 + 指标系数得分
    
    总分 = sum(指标得分) / 指标个数
    
- **DevEco Studio 6.0.0 Beta3以下版本，评分规则如下：**
    
    根据检测结果，某个场景的某个指标的评分规则：
    
    - 成功：得1分，达到人因体验最佳标准，详情请参考[应用体验建议](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/experience-suggestions-overview)。
    - 告警：得0.6分，体验未达到人因最佳，建议继续优化。
    - 失败：得0分，体验非常差，请继续优化，否则可能影响上架。
    
    总分是多个场景多个指标多个页面的平均值，示例如下：
    
    **表1** 评分方法示例
    |场景|子场景|指标/检测项|页面|测试次数|达标情况|得分|总分|
    |:--|:--|:--|:--|:--|:--|:--|:--|
    |页面间转场|router或者navigation页面跳转|响应时延|A->B|第一次|成功|1|(1+0.6+0.6+0+0.6+1+0+0.6)/8*100=55|
    |第二次|告警|0.6|
    |B->C|第一次|告警|0.6|
    |第二次|失败|0|
    |完成时延|A->B|第一次|告警|0.6|
    |第二次|成功|1|
    |B->C|第一次|失败|0|
    |第二次|告警|0.6|
    

各体检场景对应的检测指标如下表所示：

**表2** 场景化体检指标
|体检类别|场景|子场景|检测指标/检测项|应用或元服务场景|自动或手动方式|
|:--|:--|:--|:--|:--|:--|
|性能|页面间转场|router或者navigation页面跳转|[点击响应时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section118706211961)|应用，元服务|自动，手动|
|[点击完成时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section2406192820717)|
|[转场卡顿率](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-frame-rate#section1591383182619)|
|页面滑动|页面滑动（仅支持List、Grid、WaterFlow这三个组件实现的页面滑动）|[滑动响应时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section1767913186810)|应用，元服务|自动，手动|
|[滑动卡顿率](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-frame-rate#section159268494256)|
|冷启动|冷启动|[完成时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section58771582411)|应用，元服务|自动，手动|
|页面内转场|swiper滑动转场|[滑动响应时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section1767913186810)|应用，元服务|自动，手动|
|[滑动卡顿率](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-frame-rate#section159268494256)|
|[起播时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section1140562816186)|
|tabs点击转场|[点击响应时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section118706211961)|
|[点击完成时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section2406192820717)|
|tabs滑动转场|[滑动响应时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section1767913186810)|
|[滑动卡顿率](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-frame-rate#section159268494256)|
|web场景<br><br>（从DevEco Studio 6.0.0 Beta2版本开始支持）|web页面跳转|[点击响应时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section118706211961)|应用，元服务|自动，手动|
|[点击完成时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section2406192820717)|
|web页面滑动|[滑动响应时延](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay#section1767913186810)|
|[滑动卡顿率](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-frame-rate#section159268494256)|
|兼容性|音频播控服务<br><br>（从DevEco Studio 5.1.0 Release版本开始支持）|播控中心音频控制场景|[播控中心控制音频播放检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|应用|手动|
|[播控中心控制音频暂停检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|[播控中心控制歌曲切换上一首检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|[播控中心控制歌曲切换下一首检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|[播控中心控制歌曲播放进度条拖动检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|[播控中心控制歌曲循环播放检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|[播控中心控制歌曲收藏检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|音频焦点切换<br><br>（从DevEco Studio 5.1.0 Release版本开始支持）|来电接听场景|[音频焦点变化事件响应检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section256142914530)|应用|手动|
|VoIP通话场景|
|闹钟场景|
|导航场景|
|语音助手播报场景|
|静音播放场景|
|非静音播放场景|
|普通录音场景|
|音频设备控制<br><br>（从DevEco Studio 5.1.0 Release版本开始支持）|耳机控制音频场景|[耳机控制音频播放检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|应用|手动|
|[耳机控制音频暂停检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|[耳机控制歌曲切换上一首检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|[耳机控制歌曲切换下一首检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section12303131815311)|
|耳机断开场景|[耳机断开事件响应检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-specification#section256142914530)|

## 上架前体检

### DevEco Studio 6.0.1 Beta1及以上版本

1. 在**AppAnalyzer**页面，选择**上架前体检**，点击预置的体检卡片，在弹框中选择待上架的产物和调试签名。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.93800342672691919176574949750040:50001231000000:2800:3FBB062A87128FEC4DC1121C4230A107C6E2AA1F295ED3F92816CEF731AE36F0.png)
    
2. 该体检模式无法自定义测试方式和体检规则，默认勾选所有规则，这些规则是[规则体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-all-rules)的子集。单击底部的**开始体检**按钮，等待AppAnalyzer完成构建、签名、安装等操作。
3. 安装完成后，根据提示登录账号，开始进行测试。在测试过程中，请保持连接的设备为解锁亮屏状态。
4. 测试完成后，查看测试报告如下。
    - 如果测试分数是100分，可点击右上角**报告同步AG**按钮，弹出弹框，确认后点击**OK**，上传本次的检测报告，用于应用市场上架参考。上传报告后，无法再次上传报告。
        
        说明
        
        如需上传报告，请在体检结束后上传，[历史报告](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section52734271806)中无法上传报告。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.11963213939295672840468356155649:50001231000000:2800:3361F3F69613606D5EA9E3E885D36080148A62E03EA684B1F1C05169E426781D.png)
        
    - 如果测试分数不是100分，无法上传报告，可根据详情报告中的信息，对问题进行分析优化，详情报告的具体内容可参考[规则体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#li75699128469)。

### DevEco Studio 6.0.1 Beta1以下版本

1. 在**AppAnalyzer**页面，选择**上架前体检**，弹出上架前检测配置的弹框，选择待上架的产物和调试签名。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.99249917846937790522437472821115:50001231000000:2800:C42EE4188501CD981D30CFAF8EB5EDBEACD4247F085B5DF54E0464683DFCEA28.png)
    
2. 该体检模式无法自定义测试方式、模块和体检规则，默认勾选所有规则，这些规则是[规则体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-all-rules)的子集。单击底部的**开始**按钮，等待AppAnalyzer完成构建、签名、安装等操作。
3. 安装完成后，根据提示登录账号，开始进行测试。在测试过程中，请保持连接的设备为解锁亮屏状态。
4. 测试完成后点击**结束**按钮停止测试任务，等待数据解析完成后，查看测试结果如下。
    - 如果测试分数是100分，可点击右上角**报告同步**按钮，弹出弹框，确认后点击**OK**，上传本次的检测报告，用于应用市场上架参考。上传报告后，无法再次上传报告。
        
        说明
        
        如需上传报告，请在体检结束后上传，[历史报告](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section52734271806)中无法上传报告。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.16192937037509095130777814896971:50001231000000:2800:C12400B46612F7A738C67567FE277D29A2478ACEE509BCBE4D7FCF44AFEE564B.png)
        
    - 如果测试分数不是100分，无法上传报告，可根据详情报告中的信息，对问题进行分析优化，详情报告的具体内容可参考[规则体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#li131614342254)。

## 导入DevEco Testing的检测报告进行诊断

### 操作步骤（DevEco Studio 6.0.1 Beta1及以上版本）

1. 点击AppAnalyzer页面底部**体检历史**按钮，点击右上角的**导入报告**按钮，根据界面提示，确保即将导入的检测报告满足相关要求。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.93119314688362588447467881977245:50001231000000:2800:1D0CDB65F08259F711C2C45C832C294ECCE8BE42B010E84B2B9F1F3D25DC4CA9.png)
    
2. 从本地选择一个zip文件，该文件是在DevEco Testing中测试并生成的，具体操作方式请参考[性能基础质量测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/specialized-testing#section12324184817324)或[场景化性能测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/specialized-testing#section8642101711299)。点击**确认**后，请等待AppAnalyzer导入数据并对问题进行诊断分析。AppAnalyzer仅支持对DevEco Testing中的部分指标进行诊断，具体请参考[检测指标](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section1274133632120)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.34008651518144863182784011532143:50001231000000:2800:E96B407031CB446A51F63CDFED8AF690F3CA655E2420009779E2A90B3E91EA38.png)
    
3. 诊断完成后，查看测试报告如下。
    
    - **源文件、调优文件（包含trace文件和调用栈文件）或snapshot文件、时间戳等**：点击源文件可跳转到问题源码，点击调优文件或snapshot文件支持直接拉起性能分析工具Profiler并导入性能检测的问题数据进行调优分析，点击时间戳可以打开Profiler并定位到问题发生的时间范围。
    - **分析文档**：点击链接可跳转至官网文档，参考文档对检测出来的问题进行分析。
    - **优化建议**：点针对可能的故障原因，给出对应的最佳实践，点击链接可跳转至官网文档。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.19772264117396864669919164263170:50001231000000:2800:088310D175024C4D9E14D249A128C1A39384090E40818F67D1F910E5E9D92234.png)
    
    说明
    
    由于DevEco Testing和AppAnalyzer在检测能力、检测方法以及场景识别上存在差异，所以通过DevEco Testing检测并导入AppAnalyzer诊断和直接通过AppAnalyzer检测并诊断，检测和诊断结果会出现不一致的情况。
    

### 操作步骤（DevEco Studio 6.0.1 Beta1以下版本）

1. 点击菜单栏**Tools >** **AppAnalyzer**，打开AppAnalyzer页面，点击底部**历史记录**按钮，进入历史记录页面。
2. 点击右上角的**检测报告导入**按钮，首次测试时，请根据AppAnalyzer的指引，下载Python及三方库，并根据界面提示，确保即将导入的检测报告满足相关要求。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.07872161746684331611237890110276:50001231000000:2800:2F080041DE4525997F3E44BB2E2A0609F4050CE321159F0DE2343BBD44F9D2A2.png)
    
3. 从本地选择一个zip文件，该文件是在DevEco Testing中测试并生成的，具体操作方式请参考[性能基础质量测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/specialized-testing#section12324184817324)或[场景化性能测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/specialized-testing#section8642101711299)。点击**确认**后，请等待AppAnalyzer导入数据并对问题进行诊断分析。AppAnalyzer仅支持对DevEco Testing中的部分指标进行诊断，具体请参考[检测指标](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer#section1274133632120)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155824.61298021104333145593276463634069:50001231000000:2800:697EFC5DACB4BFB5B4B1D018DCC114D11E1B647A99D07CD9BB53A4BC3D35D7EF.png)
    
4. 诊断完成后，查看测试结果如下。
    
    - 测试报告：测试结果的汇总信息，点击**详情链接**可跳转到对应场景的详情报告。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.00327405491263743538594927876781:50001231000000:2800:6359FA2610F9FB8370A6200A20A0E45C4D7F074C86AD3D6EC8BA721F563F05B9.png)
        
    - 详情报告：给出详细的测试结果、可能的故障原因和对应的优化建议。
        
        - **开始/结束页面、时间戳、调优文件（包含trace文件和调用栈文件）或snapshot文件等**：点击开始/结束页面可跳转到问题源码，点击时间戳可以打开性能分析工具Profiler并定位到问题发生的时间范围，点击调优文件或snapshot文件支持直接拉起Profiler并导入性能检测的问题数据进行调优分析。
        - **分析文档**：点击链接可跳转至官网文档，参考文档对检测出来的问题进行分析。
        - **优化建议**：针对可能的故障原因，给出对应的最佳实践，点击链接可跳转至官网文档。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.20021687281547991068005054751023:50001231000000:2800:294933337A40CFB4C582691D64D0D0634D7099268690E3442DA6F296A1C193A7.png)
        
    
    说明
    
    由于DevEco Testing和AppAnalyzer在检测能力、检测方法以及场景识别上存在差异，所以通过DevEco Testing检测并导入AppAnalyzer诊断和直接通过AppAnalyzer检测并诊断，检测和诊断结果会出现不一致的情况。
    

### 检测指标

AppAnalyzer会将DevEco Testing测试用例的操作归类为以下场景，仅支持对部分指标进行诊断，具体如下。

|场景|检测指标|
|:--|:--|
|页面间转场|点击响应时延|
|点击完成时延|
|转场卡顿率|
|页面滑动|滑动响应时延|
|滑动卡顿率|
|冷启动|完成时延|
|页面内转场|滑动响应时延|
|点击响应时延|
|点击完成时延|
|滑动卡顿率|
|起播时延|

## 查看历史报告

### DevEco Studio 6.0.1 Beta1及以上版本

1. 在DevEco Studio中，点击菜单栏**Tools >** **AppAnalyzer**，弹出AppAnalyzer页面。
2. 点击底部**体检历史**按钮，可查看最近15次的体检报告卡片，点击卡片可跳转至详细的体检报告。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.40853323515691375765254667463498:50001231000000:2800:9D6A090BB3F6B5BBF805AEF259B4C7E1BC21F83DA09E56DCEA0C88A439F0CD84.png)
    

### DevEco Studio 6.0.1 Beta1以下版本

1. 在DevEco Studio中，点击菜单栏**Tools >** **AppAnalyzer**，弹出AppAnalyzer页面。
2. 点击底部**历史记录**按钮，可查看最近15次的体检报告记录，点击时间戳可跳转至详细的体检报告。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.35221659010173341716562950790331:50001231000000:2800:4F6E00BEB47C2D09045152E4F2A96C51B11A9BB8528ACEC661FBDDEF95B467BA.png)
    

[黑盒覆盖率测试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-test "黑盒覆盖率测试")

[应用/元服务体检规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-rules "应用/元服务体检规则")
# 规则总览

更新时间: 2025-12-16 15:58

以下是AppAnalyzer规则体检的所有规则，对应用/元服务进行体检的指导请参考[应用与元服务体检](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer)。

## DevEco Studio 6.0.1 Beta1及以上版本

### 功能兼容性

**表1**
|体检规则|规则详情|应用或元服务规则|
|:--|:--|:--|
|安装无兼容性问题|应用/元服务在其配置支持运行的对应软件版本/设备类型上成功安装。|应用，元服务|
|启动无兼容性问题|应用/元服务正常启动，进入首页界面。|应用，元服务|
|卸载无残留|应用/元服务在其配置支持运行的对应软件版本/设备类型上成功卸载，卸载无残留(包括文件、数据和进程)。|应用，元服务|
|运行无兼容性问题|应用/元服务要求在其支持的OS版本/设备类型上运行不会出现崩溃、冻屏无响应、无法返回等问题。|应用，元服务|
|元服务静默登录华为账号|元服务涉及账号体系和登录能力时，需规范使用华为账号能力进行静默登录，用户界面不能出现“登录”、“注册”、“退出登录”、“注销账号”描述。|元服务|
|元服务场景化Button组件使用规范|禁止底部页签自定义封装场景化button组件，即用户点击tab页签时，不能直接拉起button功能页面：快速验证手机号Button、选择头像Button、打开授权设置页Button、打开APP Button、选择收货地址Button、选择发票抬头Button、地图选点Button。|元服务|
|合理设计申请手机号授权功能|业务场景涉及华为账号快速验证手机号button使用时，需规范使用开放能力，不能用户一进入元服务就引导用户关联账号（必须）；不允许在页面只放置一个关联按钮/授权手机号按钮而没有其他功能（推荐）|元服务|
|元服务包结构应符合规范|元服务App Pack包中，同一个设备上必须有且仅有一个Entry Hap；不允许包含任何Feature类型的Hap包，可以包含一个或者多个Shared类型的Hsp包，也可以不包含。|元服务|
|应用要支持64位so文件|如果APP集成native so，则要求提供64位so。|应用|
|元服务内所有包总和大小不超过10MB|单个元服务内所有包文件的大小总和不能超过10MB|元服务|
|应用/元服务的显示名称有意义|应用和元服务安装之后的显示名称，在系统语言是中英文和默认语言名字都需要有意义，不可以是默认值或者通用无意义的值。|应用，元服务|
|卡片isDefault字段不可缺省|卡片isDefault不可缺省，每个应用或元服务有且只有一个默认卡片。|应用，元服务|
|卡片描述以索引展现|卡片description字段需要用索引方式填写。|应用，元服务|
|卡片描述有意义|卡片的描述不能是通用值，应该为displayName的详解。|应用，元服务|
|卡片的显示名称有意义|卡片的显示名称取值可以是名称内容，也可以是对名称内容的资源索引，不可以是通用无意义的值，E.g.widget\card\小组件。|应用，元服务|
|使用App Linking实现支持通过链接拉起应用的功能|如果涉及通过链接拉起应用的功能，建议使用App Linking的方式支持该功能。|应用|

### 性能

**表2**
|体检规则|规则详情|应用或元服务规则|
|:--|:--|:--|
|[动态内存峰值占用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-peak-dynamic-memory-usage-0417)|应用/元服务完成操作后，各类应用在后台的内存占用峰值应≤ 1300MB；应用完成操作后切换到后台，静置3min以后采集内存占用。|应用，元服务|
|[前台场景内存峰值占用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-peak-foreground-memory-usage-0418)|应用/元服务前台场景峰值内存占用：应用在前台且亮屏使用规程的内存占用应≤ 1500MB。|应用，元服务|
|[后台CPU占用峰值](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-peak-background-cpu-usage-0420)|应用/元服务后台CPU占用峰值：应用/元服务切换到后台等待3min后，开始采集3min内CPU Load < 5%。|应用，元服务|
|[点击操作完成快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-completion-for-click-0404)|应用内点击操作完成时延应≤ 900毫秒；时间起点：点击离手；时间终点：转场页面所有占位符加载完成。|应用，元服务|
|[滑动过程流畅](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-smooth-for-swipe-0413)|应用的滑动过程卡顿率≤ 5ms/s；满帧30FPS的游戏类、地图类和视频类的应用帧率应≥ 29FPS。|应用，元服务|
|[转场操作流畅](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-smooth-for-transition-0414)|应用的应用内转场过程卡顿率≤ 0ms/s；滑动过程卡顿率：动效时间内累计丢帧时间/动效时长。|应用，元服务|
|[节点数超过500过多](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-render-node-limit-0430)|后端Render Server在每帧数据里处理的节点数不应该超过500，否则会造成CPU使用过高，引发帧时延过高，从而导致丢帧。|应用，元服务|
|[点击操作响应快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-response-for-click-0403)|应用内点击操作响应时延应≤ 100毫秒；时间起点：点击离手；时间终点：界面发生变化。|应用，元服务|
|[滑动操作响应快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-response-for-swipe-0405)|应用内滑动操作响应时延应≤ 80毫秒；时间起点：手指滑动；时间终点：界面发生变化。|应用，元服务|
|序列化反序列化耗时长|使用TaskPool/Worker并发能力时候，会检测对象和方法在跨线程传递时序列化和反序列化的耗时；序列化和反序列化耗时应 ≤ 8ms。|应用，元服务|
|启动加载完成快|各类应用的冷启动首帧完成时延应 ≤ 1100毫秒；时间起点：桌面图标点击离手；时间终点：应用首页铺满全屏并且所有占位符加载完成。|应用，元服务|
|组件树节点数目过大|避免过大组件树节点数目。建议一个页面使用少于1000个组件树节点，节点树深度少于30层，子节点数不大于60个。|应用，元服务|
|执行函数耗时过长|避免执行函数耗时过长。函数执行时间是指函数在一次同步执行中消耗的时间，比如生命周期回调、事件处理函数的同步执行时间。建议单个函数执行周期内运行时间不超过15毫秒。|应用，元服务|
|渲染界面耗时过长|避免渲染界面耗时过长。建议单次渲染时间不超过500ms。渲染界面的耗时过长会让用户觉得卡顿，体验较差，出现这一情况时，需要校验下是否同时渲染的区域太大；页面中单个组件的渲染时间不超过15ms。|应用，元服务|
|ForEach中item数量过大|ForEach性能。ForEach中item数量要小于50。|应用，元服务|
|单帧属性数量更新内容限制|在高帧率场景单帧更新属性数量建议滑动场景不超过300个，非滑动场景不超过1500个。|应用，元服务|
|单帧脏组件数量限制|高帧率场景更新组件数量（含布局更新）建议滑动场景不超过30个，非滑动场景单帧更新组件数不超过500个。|应用，元服务|
|web组件初始化耗时长|避免web组件初始化耗时过长。在web页面加载场景下，web组件初始化时间不超过60ms。|应用，元服务|
|web执行js耗时|避免web页面js执行耗时过长。在web页面加载场景下，web页面单个js编译和执行时间不超过30ms，单个js函数调用时间不超过30ms，总体js编译和执行时间不超过300ms，总体js函数调用时间不超过130ms。|应用，元服务|
|UI线程IO执行耗时长未并行化|避免UI线程中执行文件IO耗时过长。UI主线程中，不应出现执行IO函数超过8.3毫秒，如果出现需要进行IO并行化改造。|应用，元服务|
|UI线程应用自身方法耗时长|UI线程应用自身方法耗时长检测。应用自身方法耗时长会导致丢帧。|应用，元服务|
|web主资源下载耗时长|避免web主资源下载耗时过长。在web页面加载场景下，web主资源下载时间不超过300ms。|应用，元服务|
|web子资源下载耗时长|避免web子资源下载耗时过长。在web页面加载场景下，web单个子资源下载时间不超过200ms。|应用，元服务|
|在线短视频类应用快速切换播放起播快|短视频起播时延，从用户滑动屏幕抬手后，到短视频第二帧画面(非封面帧)显示时间不应该超过700ms。|应用|
|相机拍照完成快|相机从拍照开始到生成可预览照片的完成时延不应超过1000ms。如果超过，建议使用分段式拍照。|应用|

### UX

**表3**
|体检规则|规则详情|应用或元服务规则|
|:--|:--|:--|
|布局基础要求(大屏)|设备在折叠/展开或横竖屏切换时，应用中的图片、视频等界面元素应避免出现错位/截断/变形等问题。|应用，元服务|
|图标文字大小适中|文字/图标物理大小建议：<br><br>展开态文字/图标大小为折叠态的1~1.2倍 (推荐)<br><br>不建议大于1.2/1.5倍 (必须)<br><br>不建议一排图标数量过多导致信息过密，折叠屏上建议一排不超过8个图标|应用，元服务|
|弹出框大小适中|展开态弹出框高度为折叠态的1~1.2倍 (推荐)，不建议高度大于1.2倍 (必须)。|应用，元服务|
|宫格图片信息量适中|宫格图片控件占比要求（控件高度/屏幕高度）：<br><br>1）单行图片高度不要太矮，不要低于屏幕高度的1/10，不要超过屏幕高度的2/5；<br><br>2）若宫格聚合图片整体作为信息流内容的配图，则建议整体高度不要低于屏幕高度的1/2，不要超过屏幕高度的2/3。|应用，元服务|
|广告图信息量适中|广告图控件占比要求（控件高度/屏幕高度）：<br><br>1）折叠屏展开态横竖屏时，广告图的图片高度不要超过一屏幕的1/2。|应用，元服务|
|上下图文信息量适中|1）上下图文结构中，建议信息流场景的图片左对齐，阅读场景的图片居中对齐。<br><br>2）图片的物理尺寸：折叠屏上展开态图片的放大倍数建议不超过1.2倍。<br><br>图片放大不超过1.2/1.5倍且满足控件高度占比要求 (推荐)；<br><br>图片放大倍数不超过1.2/1.5倍或满足控件高度占比要求 (必须)。<br><br>3）在折叠屏展开态等宽屏设备上最好通过延伸布局、挪移布局等方式让图文进行合理布局，避免图片过高。上下图文控件高度占比要求如下：<br><br>首页入口型的上下图文，不建议使用长图，宽图或方图的最大高度不要超过屏幕高度的1/3;<br><br>首页信息流结构的上下图文，图片最大高度不超过屏幕高度的2/5;<br><br>详情页内容型的上下图文，最大高度不要超过屏幕高度的3/5。|应用，元服务|
|边距适中|一般不建议用边距的方式来控制信息量，左右边距的留白不要太大。<br><br>同一个应用内不同的页面建议保持相同的边距。<br><br>同一个应用在不同端上，可以根据设备屏幕的宽度进行适量的边距调整。|应用，元服务|

### 功耗

**表4**
|体检规则|规则详情|应用或元服务规则|
|:--|:--|:--|
|后台进程CPU负载约束（长时任务）|应用或元服务后台CPU运行：后台进程持续10分钟CPU负载不得高于10%；(8核负载，即总负载为80%)|应用，元服务|
|后台进程CPU负载约束（短时任务）|应用后台CPU运行：后台进程任务期间CPU负载不得高于8%；(8核负载，即总负载为64%)|应用|
|无长时任务的应用退到后台不允许有BT扫描|无长时任务的应用或元服务退到后台不允许有蓝牙扫描|应用，元服务|
|无长时任务的应用退后台禁止使用麦克风或扬声器|无长时任务的应用或元服务退后台禁止使用麦克风或扬声器|应用，元服务|
|无长时任务的应用退后台禁止使用定位服务|无长时任务的应用或元服务退后台禁止使用定位服务|应用，元服务|
|应用退后台禁止使用传感器|应用或元服务退后台禁止使用传感器，前台使用时根据业务尽量使用once()接口监听结果|应用，元服务|
|后台合理使用音频播放|后台合理使用音频播放|应用，元服务|
|无长时任务的应用退后台对应资源释放，不能有持锁|无长时任务的应用退后台对应资源释放，不要直接或者间接持running lock锁|应用|
|音乐类应用设置正确的音乐类型|音乐类应用设置正确的音乐类型（如果应用或元服务为非音乐类，请忽略本次报错）|应用，元服务|
|应用处于前台不可见动效不使用资源，及时停止|应用处于前台不可见动效不使用资源，及时停止|应用，元服务|

### 安全

**表5**
|体检规则|规则详情|应用或元服务规则|
|:--|:--|:--|
|不对外交互的Ability的exported属性需要显式设置为false|不对外交互的Ability其exported或visible属性禁止设置为true|应用，元服务|
|对外交互的Ability应设置合理的访问权限|对外交互的Ability应设置合理的访问权限|应用，元服务|
|DataShareExtensionAbility权限检查|DataShareExtensionAbility内接口设置合理的读写访问权限|应用，元服务|
|应用权限申请遵循最小化原则|权限申请满足最小化原则，禁止申请不必要的、新版本废弃的权限|应用，元服务|
|动态公共事件接收器进行访问权限控制|对涉及敏感功能的公共事件进行访问权限控制|应用，元服务|
|应用软件应包含的签名信息需要真实有效|应用/元服务证书所有者的CN、OU、O、C字段不能为空|应用，元服务|
|三方SDK使用安全合规的版本|应用/元服务引入的三方SDK的版本号，在GIIC/信通院上属于安全合规的范围内|应用，元服务|
|非预期文件打包检测|检测应用/元服务包体文件目录是否存在.c/.h/.cpp/.cs/.java/.rs/.py/.go/.ets/.js/.ts非预期格式的文件|应用，元服务|

### 稳定性

**表6**
|体检规则|规则详情|应用或元服务规则|
|:--|:--|:--|
|应用/元服务崩溃|应用/元服务运行过程中无崩溃故障。|应用，元服务|
|应用/元服务卡死|应用/元服务运行过程中无冻屏卡死故障。|应用，元服务|
|内存泄露|检测出引起内存泄露的代码，提供代码堆栈日志下载。|应用，元服务|

## DevEco Studio 6.0.1 Beta1以下版本

### UX测试

仅API 20及以上版本的折叠屏手机可以进行UX测试。

**表7**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|布局基础要求(大屏)|设备在折叠/展开或横竖屏切换时，应用中的图片、视频等界面元素应避免出现错位/截断/变形等问题。|应用，元服务|5|
|图标文字大小适中|文字/图标物理大小建议：<br><br>展开态文字/图标大小为折叠态的1~1.2倍 (推荐)<br><br>不建议大于1.2/1.5倍 (必须)<br><br>不建议一排图标数量过多导致信息过密，折叠屏上建议一排不超过8个图标|应用，元服务|5|
|弹出框大小适中|展开态弹出框高度为折叠态的1~1.2倍 (推荐)，不建议高度大于1.2倍 (必须)。|应用，元服务|4|
|宫格图片信息量适中|宫格图片控件占比要求（控件高度/屏幕高度）：<br><br>1）单行图片高度不要太矮，不要低于屏幕高度的1/10，不要超过屏幕高度的2/5；<br><br>2）若宫格聚合图片整体作为信息流内容的配图，则建议整体高度不要低于屏幕高度的1/2，不要超过屏幕高度的2/3。|应用，元服务|4|
|广告图信息量适中|广告图控件占比要求（控件高度/屏幕高度）：<br><br>1）折叠屏展开态横竖屏时，广告图的图片高度不要超过一屏幕的1/2。|应用，元服务|4|
|上下图文信息量适中|1）上下图文结构中，建议信息流场景的图片左对齐，阅读场景的图片居中对齐。<br><br>2）图片的物理尺寸：折叠屏上展开态图片的放大倍数建议不超过1.2倍。<br><br>图片放大不超过1.2/1.5倍且满足控件高度占比要求 (推荐)；<br><br>图片放大倍数不超过1.2/1.5倍或满足控件高度占比要求 (必须)。<br><br>3）在折叠屏展开态等宽屏设备上最好通过延伸布局、挪移布局等方式让图文进行合理布局，避免图片过高。上下图文控件高度占比要求如下：<br><br>首页入口型的上下图文，不建议使用长图，宽图或方图的最大高度不要超过屏幕高度的1/3;<br><br>首页信息流结构的上下图文，图片最大高度不超过屏幕高度的2/5;<br><br>详情页内容型的上下图文，最大高度不要超过屏幕高度的3/5。|应用，元服务|4|
|边距适中|一般不建议用边距的方式来控制信息量，左右边距的留白不要太大。<br><br>同一个应用内不同的页面建议保持相同的边距。<br><br>同一个应用在不同端上，可以根据设备屏幕的宽度进行适量的边距调整。|应用，元服务|5|

### 功能和兼容性

**表8**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|应用/元服务支持在当前OS版本/设备类型安装|应用/元服务在其配置支持运行的对应软件版本/设备类型上成功安装。|应用，元服务|5|
|应用/元服务支持在当前OS版本/设备类型启动|应用/元服务正常启动，进入首页界面。|应用，元服务|5|
|应用/元服务支持在当前OS版本/设备类型卸载|应用/元服务在其配置支持运行的对应软件版本/设备类型上成功卸载，卸载无残留(包括文件、数据和进程)。|应用，元服务|4|
|应用/元服务在当前OS版本/设备类型运行稳定|应用/元服务要求在其支持的OS版本/设备类型上运行不会出现崩溃、冻屏无响应、无法返回等问题。|应用，元服务|3|
|元服务静默登录华为账号|元服务涉及账号体系和登录能力时，需规范使用华为账号能力进行静默登录，用户界面不能出现“登录”、“注册”、“退出登录”、“注销账号”描述。|元服务|4|

### 规格约束

**表9**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|元服务包结构应符合规范|元服务App Pack包中，同一个设备上必须有且仅有一个Entry Hap；不允许包含任何Feature类型的Hap包，可以包含一个或者多个Shared类型的Hsp包，也可以不包含。|元服务|5|
|设备类型检测<br><br>（从DevEco Studio 6.0.0 Beta2版本开始下线）|在一个应用/元服务包中，每个hap包必须明确支持的设备类型，不能为空。|应用，元服务|5|
|应用要支持64位so文件|如果APP集成native so，则要求提供64位so。|应用|4|
|元服务内所有包总和大小不超过10MB|单个元服务内所有包文件的大小总和不能超过10MB。|元服务|2|
|卡片isDefault字段检测|卡片isDefault不可缺省，每个应用或元服务有且只有一个默认卡片。|应用，元服务|3|
|卡片description字段检测|卡片description字段需要用索引方式填写。|应用，元服务|4|
|应用链接跳转检测|如果涉及通过链接拉起应用的功能，建议使用App Linking的方式支持该功能。|应用|3|
|元服务禁止使用so文件<br><br>（从DevEco Studio 6.0.0 Beta2版本开始下线）|元服务禁止集成native so，禁止使用so文件。|元服务|4|

### 性能

**表10**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|[应用/元服务内点击操作响应快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-response-for-click-0403)|起点：点击离手；<br><br>终点：界面发生变化；<br><br>应用/元服务内点击操作响应时延应≤ 100毫秒。|应用，元服务|3|
|[应用/元服务内点击操作完成快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-completion-for-click-0404)|时间起点：点击离手；<br><br>时间终点：转场页面所有占位符加载完成；<br><br>应用/元服务内点击操作完成时延应≤ 1600毫秒。|应用，元服务|3|
|[应用/元服务内滑动操作响应快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-response-for-swipe-0405)|时间起点：手指滑动；<br><br>时间终点：界面发生变化；<br><br>应用/元服务内滑动操作响应时延应≤ 80毫秒。|应用，元服务|3|
|[应用/元服务内滑动过程流畅](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-smooth-for-swipe-0413)|应用/元服务的滑动过程卡顿率≤ 5ms/s；<br><br>满帧30FPS的游戏类、地图类和视频类的应用帧率应≥ 29FPS。|应用，元服务|3|
|[应用/元服务内转场操作流畅](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-smooth-for-transition-0414)|应用/元服务内转场过程卡顿率≤ 0ms/s；<br><br>滑动过程卡顿率：动效时间内累计丢帧时间/动效时长。|应用，元服务|3|
|[应用/元服务动态内存峰值占用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-peak-dynamic-memory-usage-0417)|应用/元服务完成操作后，各类应用在后台的内存占用峰值应≤ 1300MB；<br><br>应用完成操作后切换到后台，静置3min以后采集内存占用。|应用，元服务|3|
|[应用/元服务前台场景内存峰值占用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-peak-foreground-memory-usage-0418)|应用/元服务前台场景峰值内存占用：应用在前台且亮屏使用过程的内存占用应≤ 1500MB。|应用，元服务|3|
|[应用/元服务后台CPU占用峰值](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-peak-background-cpu-usage-0420)|应用/元服务后台CPU占用峰值：应用切换到后台等待3min后，开始采集3min内CPU Load < 5%。|应用，元服务|3|
|[图形渲染服务处理节点数小于500](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-render-node-limit-0430)|后端Render Server在每帧数据里处理的节点数不应该超过500，否则会造成CPU使用过高，引发帧时延过高，从而导致丢帧。|应用，元服务|1|

### 最佳实践

说明

以下体检规则不支持在编译模式为release下运行，请把编译模式切换到debug再重新检测：避免过大组件树节点数目、避免执行函数耗时过长、避免渲染界面耗时过长、ForEach性能检测。

**表11**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|避免过大组件树节点数目|避免过大组件树节点数目。<br><br>建议一个页面使用少于1000个组件树节点，节点树深度少于30层，子节点数不大于60个。|应用，元服务|2|
|避免执行函数耗时过长|避免执行函数耗时过长。<br><br>函数执行时间是指函数在一次同步执行中消耗的时间，比如生命周期回调、事件处理函数的同步执行时间。建议单个函数执行周期内运行时间不超过15毫秒。|应用，元服务|2|
|避免渲染界面耗时过长|避免渲染界面耗时过长。<br><br>建议单次渲染时间不超过500ms。渲染界面的耗时过长会让用户觉得卡顿，体验较差，出现这一情况时，需要校验下是否同时渲染的区域太大；页面中单个组件的渲染时间不超过15ms。|应用，元服务|2|
|ForEach性能检测|ForEach性能。<br><br>ForEach中item数量要小于50。|应用，元服务|2|
|单帧属性数量更新内容限制|在高帧率场景单帧更新属性数量建议滑动场景不超过300个，非滑动场景不超过1500个。|应用，元服务|2|
|单帧脏组件数量限制|高帧率场景更新组件数量（含布局更新）建议滑动场景不超过30个，非滑动场景单帧更新组件数不超过500个。|应用，元服务|2|
|web组件初始化耗时检测|避免web组件初始化耗时过长。<br><br>在web页面加载场景下，web组件初始化时间不超过60ms。|应用，元服务|2|
|web执行js耗时检测|避免web页面js执行耗时过长。<br><br>在web页面加载场景下，web页面单个js编译和执行时间不超过30ms，单个js函数调用时间不超过30ms，总体js编译和执行时间不超过300ms，总体js函数调用时间不超过130ms。|应用，元服务|2|
|UI线程IO执行耗时长未并行化检测|避免UI线程中执行文件IO耗时过长。<br><br>UI主线程中，不应出现执行IO函数超过8.3毫秒，如果出现需要进行IO并行化改造。|应用，元服务|2|
|UI线程应用自身方法耗时长检测|避免UI线程中的函数耗时过长。<br><br>UI主线程中，不应出现函数超过8.3毫秒。|应用，元服务|2|
|web主资源下载耗时检测|避免web主资源下载耗时过长。<br><br>在web页面加载场景下，web主资源下载时间不超过300ms。|应用，元服务|2|
|web子资源下载耗时检测|避免web子资源下载耗时过长。<br><br>在web页面加载场景下，web单个子资源下载时间不超过200ms。|应用，元服务|2|
|短视频起播时延检测|时间起点：从用户滑动屏幕抬手后；<br><br>时间终点：到短视频第二帧画面(非封面帧)；<br><br>显示时间≤ 700毫秒|应用|2|
|相机拍照完成时延检测|相机从拍照开始到生成可预览照片的完成时延不应超过1000ms。<br><br>如果超过，建议使用分段式拍照。<br><br>注意：请授予相机的权限|应用|2|
|应用/元服务非预期文件打包检测<br><br>（从DevEco Studio 6.0.0 Beta3版本开始支持）|检测应用/元服务包体文件目录是否存在.c/.h/.cpp/.cs/.java/.rs/.py/.go/.ets/.js/.ts非预期格式的文件。|应用，元服务|2|

### 功耗

**表12**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|后台进程CPU负载约束（长时任务）|应用或元服务后台CPU运行：后台进程持续10分钟CPU负载不得高于10%；(8核负载，即总负载为80%)。|应用，元服务|1|
|后台进程CPU负载约束（短时任务）|应用后台CPU运行：后台进程任务期间CPU负载不得高于8%；(8核负载，即总负载为64%)。|应用|1|
|合理使用蓝牙资源|无长时任务的应用或元服务退到后台不允许有蓝牙扫描。|应用，元服务|1|
|合理使用麦克风或者扬声器|禁止后台无长时任务的应用或元服务使用麦克风或扬声器。|应用，元服务|1|
|合理使用GPS资源|无长时任务的应用或元服务退后台禁止使用定位服务。|应用，元服务|1|
|合理使用sensor资源|应用或元服务退后台禁止使用传感器，前台使用时根据业务尽量使用once()接口监听结果。|应用，元服务|1|
|后台合理使用音频播放<br><br>（从DevEco Studio 6.0.0 Beta3版本开始支持）|应用或元服务在后台开启音频播放，禁止不写入数据或者写入静音数据等类似恶意行为|应用，元服务|2|
|后台合理使用系统资源|无长时任务的应用退后台对应资源释放，不要直接或者间接持running lock锁。|应用|1|
|音乐类应用或元服务设置正确的音乐类型<br><br>（从DevEco Studio 6.0.0 Beta3版本开始支持）|音乐类应用或元服务设置正确的音乐类型，走对应的系统低功耗方案|应用，元服务|2|
|应用或元服务处于前台不可见动效不使用资源，及时停止<br><br>（从DevEco Studio 6.0.0 Beta3版本开始支持）|应用或元服务在前台，不允许有RS绘制空跑|应用，元服务|4|

### 快速性能

**表13**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|页面内点击操作完成时延快速检测|时间起点：点击离手；<br><br>时间终点：转场页面所有占位符加载完成；<br><br>应用内点击操作完成时延应≤ 1600毫秒。|应用|3|
|页面内滑动过程流畅性快速检测|应用的滑动过程卡顿率≤ 5ms/s；<br><br>满帧30FPS的游戏类、地图类和视频类的应用帧率应≥ 29FPS。|应用|3|
|页面转场操作流畅性快速检测|应用的应用内转场过程卡顿率≤ 0ms/s；<br><br>滑动过程卡顿率：动效时间内累计丢帧时间/动效时长。|应用|3|
|页面内节点数超过500过多快速检测|后端Render Server在每帧数据里处理的节点数不应该超过500，否则会造成CPU使用过高，引发帧时延过高，从而导致丢帧。|应用|1|
|页面内白块检测|应用内页面检测到白块，需要避免快速滑动场景下因数据来不及加载而出现白块。|应用|1|
|页面内点击操作响应时延快速检测|起点：点击离手；<br><br>终点：界面发生变化；<br><br>应用内点击操作响应时延应≤ 100毫秒。|应用|3|
|页面内滑动响应时延快速检测|时间起点：手指滑动；<br><br>时间终点：界面发生变化；<br><br>应用内滑动操作响应时延应≤ 80毫秒。|应用|3|
|避免页面内UI容器组件超出屏幕过多|避免滑动类容器组件区域超出屏幕显示范围10%。<br><br>滑动类容器组件的渲染范围与容器大小相同，超出屏幕的不可见部分为冗余渲染。<br><br>在页面切换的场景，过多的冗余渲染，可能会让用户觉得页面切换慢，响应不及时。<br><br>建议将滑动类容器组件的大小和位置限定在屏幕显示范围内。<br><br>如果因为嵌套滚动等效果，必须超出屏幕的，可以考虑使用分帧多次加载数据的方式，优先渲染可见部分，提升页面切换性能。|应用|1|
|应用冷启动完成时延检测|应用首页铺满全屏并且所有占位符加载完成。|应用|3|
|避免序列化反序列化耗时长|使用TaskPool/Worker并发能力时候，会检测对象和方法在跨线程传递时序列化和反序列化的耗时；<br><br>序列化和反序列化耗时应 ≤ 8ms。|应用|3|

### 安全

**表14**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|Ability可见性设置检测|不对外交互的Ability其exported或visible属性禁止设置为true。|应用，元服务|2|
|Ability权限设置检测|对外交互的Ability应设置合理的访问权限。|应用，元服务|2|
|DataShareExtensionAbility组件权限检测|必须对DataShareExtensionAbility内接口设置合理的读写访问权限。|应用，元服务|2|
|权限申请最小化原则检测|权限申请满足最小化原则，禁止申请不必要的、新版本废弃的权限。|应用，元服务|2|
|公共事件接收器权限访问控制检测|对涉及敏感功能的公共事件进行访问权限控制。|应用，元服务|2|
|应用/元服务签名完整性检测<br><br>（从DevEco Studio 6.0.0 Beta2版本开始下线）|应用/元服务需保证签名完整性。|应用，元服务|2|
|应用/元服务签名信息检测<br><br>（从DevEco Studio 6.0.0 Beta5版本开始下线）|应用/元服务证书所有者的CN、OU、O、C字段不能为空。|应用，元服务|2|
|三方SDK使用经GIIC联盟认证过的安全合规的版本|应用/元服务引入的三方SDK的版本号，在GIIC/信通院上属于安全合规的范围内。|应用，元服务|5|

### 稳定性

**表15**
|体检规则|规则详情|应用或元服务规则|权重|
|:--|:--|:--|:--|
|应用/元服务崩溃检测|应用或元服务运行过程中无崩溃故障。|应用，元服务|2|
|应用/元服务卡死检测|应用或元服务运行过程中无冻屏卡死故障。|应用，元服务|4|
|应用/元服务内存泄漏检测|检测出引起内存泄漏的代码，提供代码堆栈日志下载。|应用，元服务|4|

[应用/元服务体检规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-rules "应用/元服务体检规则")

[点击操作响应快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-response-for-click-0403 "点击操作响应快")
# 点击操作响应快

更新时间: 2025-12-16 15:58

## 规则详情

应用内点击操作响应时延应≤ 100毫秒；时间起点：点击离手；时间终点：界面发生变化。

## 检测逻辑

- 开始时间：点击离手，如图标记1；关键字：H:DispatchTouchEvent，其中type=1。
- 结束时间：泳道开始时间，如图标记2。
    
    如图展示的是H:ABILITY_OR_PAGE_SWITCH泳道，其他转场泳道标记如下：
    
    H:APP_TRANSITION_FROM_OTHER_APP
    
    H:APP_TRANSITION_TO_OTHER_APP
    
    H:APP_SWIPER_NO_ANIMATION_SWITCH
    
    H:APP_TABS_NO_ANIMATION_SWITCH
    
    H:APP_TABS_FLING
    
- 备注：由于trace的响应时延小于用户实际感知的时延，所以目前点击类算法会补偿20ms。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155843.59587272847767533171689805758000:50001231000000:2800:1C3D2925361F65D54ED10DA87E86D2403838025A2C307D03B420AB2111C89545.png)

## 计算逻辑

时延=结束时间 - 开始时间，小于等于100ms。

[规则总览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer-all-rules "规则总览")

[点击操作完成快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-completion-for-click-0404 "点击操作完成快")
# 点击操作完成快

更新时间: 2025-12-16 15:58

## DevEco Studio 6.0.1 Beta1及以上版本

### 规则详情

应用内点击操作完成时延应≤ 900毫秒；时间起点：点击离手；时间终点：转场页面所有占位符加载完成。

### 检测逻辑

点击后，缓存本次操作与下次操作前的截图，检测图片中的页面是否加载完成。页面加载检测逻辑为：

1. 利用光流法对下次操作前的多张截图进行检测，判断出轮播区与视频区。
2. 检测非轮播区与非视频区是否加载完成：默认下一次操作前页面已经加载完成，并以下次操作前的最后一张截图为目标图片，利用二分法在缓存的图片中搜索。
    
    说明
    
    若页面出现第二次刷新行为时，将以第二次刷新后呈现的页面作为加载完成页面（即目标图片），首次刷新结果不作为参考。
    
    1. 如果检索图片的非轮播区与非视频区和目标图片不存在像素差异，则判断非轮播区与非视频区加载完成；
    2. 若存在像素差异，则进一步判断差异区域是否有内容填充，如果所有差异区域均有内容填充，则判断非轮播区与非视频区加载完成。
3. 若上一步判断非轮播区与非视频区加载完成，再根据是否有内容填充判断轮播区与视频区是否加载完成。
4. 若上一步判断轮播区与视频区加载完成，则该检索图片加载完成，利用二分法继续向前搜索，找到第一张加载完成的图片。

### 计算逻辑

以点击时刻为准，若第一张加载完成图片的时间小于等于900ms，则检测通过；若大于900ms，小于等于1600ms，则检测告警；若大于1600ms，则检测失败。

## DevEco Studio 6.0.1 Beta1以下版本

### 规则详情

时间起点：点击离手；时间终点：转场页面所有占位符加载完成；应用/元服务内点击操作完成时延应≤ 1600毫秒。

### 检测逻辑

点击后，经过1600ms后截图，检测图片是否存在白块。白块检测逻辑为：AppAnalyzer通过真实应用训练的白块检测AI模型，进行页面白块识别。例如：如下左图输入到白块检测AI模型后，可以识别到白块位置，如下右图。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155846.36336058397784865391573585353593:50001231000000:2800:E4A6FE4370DD1A3B9205420ECE0A11027FDB0C9D1F4F221D374E3EB33333B4C9.png)![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155846.17634908371335897047316145550656:50001231000000:2800:25BC558005B14A84ED871DFBF4AB17CCD45820D7D6C926BA967A0DC4A1F7C9EA.png)

### 计算逻辑

点击后，经过1600ms后截图，截图页面查找白块数量为0，则检测通过。

[点击操作响应快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-response-for-click-0403 "点击操作响应快")

[滑动操作响应快](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-quick-response-for-swipe-0405 "滑动操作响应快")

# 工具概述

更新时间: 2025-12-16 15:58

DevEco Studio AI辅助编程工具（CodeGenie）支持智能问答、代码生成、页面生成、万能卡片生成、单元测试用例生成、代码智能解读、编译报错智能分析、智慧调优、应用UI生成、意图装饰器生成、小艺智能体创建、MCP配置、自定义Agent等能力，帮助开发者更高效的开发应用。

## 使用方式

在DevEco Studio右侧边栏点击**CodeGenie**或输入快捷键**Alt/Option+U**，可以进入DevEco CodeGenie。

点击**Sign in** ，跳转华为账号登录页面。授权登录完成后返回DevEco Studio，提示登录成功后，点击**Agree**，同意隐私安全政策及使用条款后开始体验。

若使用非最新版本的DevEco CodeGenie，可通过[下载中心](https://developer.huawei.com/consumer/cn/download/deveco-codegenie)获取并使用相关功能，具体请参考[插件获取及安装](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie#section18337533718)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.39625816370431868841764960913913:50001231000000:2800:D7EC0CF071F81540518A86CD5DC1F76112E567C794807541B5F8528E6DA63064.png "点击放大")

## 插件获取及安装

如需在历史版本DevEco Studio中使用最新版本的CodeGenie功能，可通过访问[下载中心](https://developer.huawei.com/consumer/cn/download/deveco-codegenie)获取最新CodeGenie插件版本，并根据下载中心页面**工具完整性**指导进行完整性校验。安装包存放路径不能包含中文字符。

安装压缩包**无需解压**，下载完成可直接依照下方步骤进行安装。

1. 在DevEco Studio菜单栏，点击**File > Settings**（macOS为**DevEco Studio > Preferences****/****Settings**）**> Plugins**，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.00572828778474956956404756256230:50001231000000:2800:9DFCD76163BBFC133BC795CA586118842362BF80E2D46A6C38CC07683D50D0D7.png) **> Install Plugin from Disk…**安装本地插件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.06669953243125917655350037949406:50001231000000:2800:A42DCAF28649BAC06778404AB1F79BE19D87A061BD37C42A7DD67F033B3F3460.png "点击放大")
    
2. 在弹出的文件选择窗口中，选择**未解压的插件****包**的存放位置，点击**OK**确认安装插件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.25425579809569873889731742802269:50001231000000:2800:FB107F5686D3EE38DD561A276CE9D86B6202D3BCE2DBCAD9365ED8B27D27D0FB.png)
    
3. 点击**Restart IDE**，重新启动DevEco Studio。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.93576603089994142263845458348691:50001231000000:2800:56963821A780080C58B97F72E8E187D2A6A06F9E4188AB9120AA4C2C5ECE2561.png)
    
4. 在DevEco Studio右侧边栏点击**CodeGenie**进入DevEco CodeGenie，完成登录并开始体验。

[版本说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-releasenote "版本说明")

[智能问答](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-knowledge "智能问答")
# 智能问答

更新时间: 2025-12-16 15:58

CodeGenie基于生成式搜索能力，通过查询生成、内容优选服务高效理解用户意图，问答交互式地获取编码相关知识。

## 对话示例

在对话区域输入需要查询的问题，开始问答。示例如下：

- ArkTS如何实现多线程？
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.39210445286469584378085637675217:50001231000000:2800:45289906DDCEC60BE3BAA5B4A2A6EE55F4C047505CA86ACF8AE9F23B30005E41.gif)
    

## 上下文问答

在对话框中输入**@**符号选择**Files**，或点击上方**@****Add Context** > **Files**，可指定对单个或多个代码文件进行分析。

点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.32638765690231786962836138991984:50001231000000:2800:42C81C8AAAF4464BB5F9E2B76FCFE3DC9A6E3C7F7DDCD5DF65F481492D35731F.png)图标开启光标上下文功能，该功能可识别光标位置和选中的代码片段，让CodeGenie分析指定文件和选中的代码片段。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.36585291529802253466876795787297:50001231000000:2800:83C3D6705F3C3D0F84B853E203C042502BE571A1D5777FE02B0D757EEBEAC60E.gif)

## 指定风格的上下文问答

从DevEco Studio 6.0.0 Beta5开始，CodeGenie允许用户导入设计文档和代码等文件形成文档集，多个文档集组合成本地知识库。智能问答时，根据用户输入内容检索本地知识库以提升AI生成的能力。

1. 点击**File > Settings****...**（macOS为**DevEco Studio > Preferences/Settings**） **> CodeGenie** **> Knowledge >** **Docs**，或在DevEco Studio右侧边栏点击**CodeGenie**（或输入快捷键**Alt/Option+U**） **>** **@****Add Context** **> Docs > Set Local Knowledge Base**，进入配置页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.77668514795431472034674323381753:50001231000000:2800:88218A05DDFB10BBBC23A064CAC5AE970DF1A6295313205ADDCF2139A59632E7.png "点击放大")
    
2. 首次打开时，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.94337169514638504065345934668871:50001231000000:2800:95C5E65C819B55FFB25E04D88E16E00F597D4A2F941863387BB23EDA8FBE282A.png)按钮，填写相关信息，创建文档集。
    
    - **Knowledge Base Path**：知识库保存路径。在同一个路径下保存的文档集，会形成一个知识库。
    - **Document set name**：文档集名称。
    - **Description**：可选，文档集描述。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.67434971444170372222029999254245:50001231000000:2800:9B0BD8FB371EEA995CCC33796BBB3058AB9D4F386C4356678E9250DBAF26591E.png "点击放大")
    
3. 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.01885316712140837063716743825647:50001231000000:2800:B97537E6AB2BED8C112EB11DE814735FCB9E8C4A0F9E453256FE71A675B04FC7.png)按钮，添加文档集中的文件，添加成功的文件在下方展示。
    
    说明
    
    1. 支持的文件格式：txt、md、json、html、cpp、ets、ts、js。
    2. 单个文档集中文件个数：不超过1000个。
    3. 单个文件大小：不超过10M。
    4. 单个知识库中文档集个数：不超过20个。
    5. 单个知识库大小：不超过50M。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.05970841606115227635614818008108:50001231000000:2800:67AAFE412C730861BB42B8513E203FEED596718FCC6C74C9A9F4B5158CF46375.png "点击放大")
    
4. 点击“**OK**”，完成本地知识库配置和同步，在DevEco Studio页面下方**Storing document set**可查看同步进度。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.51383362839413061822674121132715:50001231000000:2800:DAD203166A829163DC18B2EA2E758ECF4BBB98B3A3FC5B852E9425B8BAEDD9ED.png "点击放大")
    
5. 同步完成后，在对话框中输入**@**符号选择**Docs** ，或点击上方**@****Add Context** **> Docs** ，选择需要的文档集。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.26443670399151121381907066289231:50001231000000:2800:03F29576C1776C4C79464E653BD901CBA2EB95322124234DC5E0EDDE6E7DA667.png)
    
6. 选择代码文件进行上下文问答，具体请参考[上下文问答](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-knowledge#section1464704715252)。

[工具概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie "工具概述")

[代码生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-code-edit "代码生成")
# 自然语言代码生成

更新时间: 2025-12-16 15:58

安装CodeGenie后，在对话框内输入代码需求描述，将根据描述智能生成代码，生成内容可一键复制或一键插入至编辑区当前光标位置，以及生成内容可与文件内容可快速对比和采纳。

提问问答和代码修改逻辑不同，若更换代码生成方式，需要重新开启对话框。

## 提问问答

### 操作步骤

在对话区域输入代码需求描述，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.39506999457203446374365007293261:50001231000000:2800:C61A9D3A110724ADA73E434604C58D9927B790454A69EB5A95ABD84D01448DBE.png)发送，将自动生成符合要求的代码段，生成内容可一键复制![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.49506576690380625618246419551089:50001231000000:2800:0C3F478ABC3CFA256C3377E3CE733C88A6CECF62A05D9496BAE94C7C565B3A47.png)或一键插入![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.87666815588454523642823608140091:50001231000000:2800:59A494EB85493B3AA0465D516BDEE2CD22C874EE412426F62AA4CDB8C30B29AC.png)至编辑区当前光标位置。

### 示例

使用ArkTs语言写一段代码，在页面中间部分插入Swiper组件，其中有3个Image组件，其图片资源名分别为app.media.phone，app.media.watch，app.media.glasses。这些Image组件的宽度撑满父布局，高度为600，图片缩放类型为保持图片宽高比不变，将图片完全显示在边界内。 Swiper组件设置为自动播放，播放时间间隔为2秒。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.14230259043000039258740152636060:50001231000000:2800:7364E5FFFDC4A1CE821EE8AD942F0EF37A816545F1D9E26FBFF46BCA2635524A.gif)

## 代码修改

从DevEco Studio 6.0.1 Beta1开始，支持选择文件后，再输入代码需求描述，生成内容与文件内容可快速对比和采纳。

**操作步骤**

1. 点击**@Add Context >** **Files**选择需要修改的文件，在对话框输入代码修改描述。
2. 在生成内容中，点击文件路径，打开代码对比页面。点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.73485244976619489847887176584589:50001231000000:2800:B7B0AC5670D145D124F587B12B2A0116A0C1EB85482D279056303315D42CAFD2.png)，快速采纳修改后的代码。

**示例**

新增如下代码段：使用ArkTs语言写一段代码，在页面中间部分插入Swiper组件，其中有3个Image组件，其图片资源名分别为app.media.phone，app.media.watch，app.media.glasses。这些Image组件的宽度撑满父布局，高度为600，图片缩放类型为保持图片宽高比不变，将图片完全显示在边界内。 Swiper组件设置为自动播放，播放时间间隔为2秒。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.87276853669456754249680091927730:50001231000000:2800:A5BD2A3AD894E802B0F0DA1ABE48464D55E25DDA338DDCB7FDF4B9A99B9D4F77.gif)

[代码生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-code-edit "代码生成")

[编辑区代码生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-edit-area-code-generation "编辑区代码生成")
# 编辑区代码生成

更新时间: 2025-12-16 15:58

CodeGenie提供Inline Edit能力，支持在ArkTS文件的编辑窗口中通过自然语言进行问答，基于上下文智能生成代码片段，提升代码可读性。

1. 当前有以下两种方式唤醒Inline Edit对话框：
    
    - 在代码编辑区域，右键选择**CodeGenie > Inline Edit**（或使用快捷键**Alt+I**，macOS中为**Command+I**），唤醒Inline Edit对话框。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155810.21214501951273164595320332582692:50001231000000:2800:DDB6018999A07493B859DA49F85904C50CDB5EA22F019F9CBD5F402F8BF0300A.png)
        
    - 选中一段代码，点击**Inline Edit（**或使用快捷键**Alt+I**，macOS中为**Command+I）**浮框，唤醒Inline Edit对话框。
        
        如未出现浮框，可在**File** > **Settings** > **CodeGenie** > **Code Generation**（macOS中为**DevEco Studio** > **Preferences/Settings** > **CodeGenie** > **Code Generation**）中取消勾选**Hide Inline Edit Overlay**选项。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155810.16351220869033844341787114274047:50001231000000:2800:E6308E0841491B28932FE851BD5A2B6B9C9E23436CB4B7FEF7451D1137A1B10D.png)
        
    
2. 在对话框中输入所需要的代码功能描述，在键盘输入回车开始生成。点击**Stop Generation**，可中断本轮代码生成过程。
3. 生成完毕将在编辑区展示本轮生成的代码内容，并通过不同颜色体现与当前代码的对比差异。
    
    - 绿色区域：新生成的代码内容。
    - 蓝色区域：对现有代码进行修改的内容。
    - 红色区域：删除的代码内容。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155810.76361817503060222058592614981970:50001231000000:2800:51B3C5A320FDADE75A83C43486FB81C7647E62AA314F133DCA4939D0C5DD979A.png)
    
    点击Inline Edit对话框中**Accept All**（或使用快捷键**Alt+Enter**），接受当前生成的全部内容；点击界面中Accept区域（或使用快捷键**Shift+Ctrl+Y**，macOS上为**Shift+Command+Y**），分段逐一接受并保留生成内容；点击界面中Reject区域（或使用快捷键**Shift+Ctrl+N**，macOS上为**Shift+Command+N**），分段逐一拒绝并删除当前生成内容。
    
4. 点击Inline Edit对话框中**刷新/****Regenerate**，将根据当前描述重新生成代码片段。如需开始新一轮问答，点击**Further Edit**（或使用快捷键**Ctrl+K**，macOS上为**Command+K**），重新进行输入。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155810.48396912325789378327701620511269:50001231000000:2800:1E1277A09CC5423C6412421EB1B92B7A9C97E37726A401B742BC8D6D56FB4001.png)
    

[自然语言代码生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-natural-language-code-generation "自然语言代码生成")

[编辑区代码续写](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-continuation "编辑区代码续写")
# 编辑区代码续写

更新时间: 2025-12-16 15:58

利用AI大模型分析并理解开发者在代码编辑区的上下文信息或自然语言描述信息，智能续写符合上下文的ArkTS或C++代码片段。

## 使用约束

- 建议编辑区已有较丰富上下文，能够使AI模型对编程场景有一定理解的情况下进行续写。若编辑器中内容较少，AI模型可能无法有效理解用户的意图并生成相应的代码。
- AI模型反馈需满足规则：光标上文10行内，有效代码行数超过5行（排除单独{}、（）、[]括号行、空行、纯注释行场景）。

## 续写设置

进入**File > Settings...**（macOS为****DevEco Studio > Preferences/Settings****） **>** **CodeGenie > Code Generation**页面勾选**Enable code generation**，开启代码续写功能。如果已经熟悉了CodeGenie常用的快捷键，想要更加沉浸的体验，可以在该页面勾选**Do not disturb** **mode**，隐藏代码生成工具栏及快捷键提示。

根据编码习惯，选择**Enable snippet generation**（片段续写）和**Enable inline generation**（行内续写），以及设置续写时延。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155810.91014231183767580932507879532017:50001231000000:2800:2046B88C3816A89A0A08D296297FC69FCC2F13BD6440A4448F3E296BB8FBB2EE.png)

## 续写触发和采纳

### 续写触发

不同代码续写类型的触发方式：

- **Enable inline generation**（行内续写）：在编码时稍作停顿，CodeGenie将在当前代码行即时续写代码。
- **Enable snippet generation**（片段续写）：输入回车，将出现CodeGenie根据上下文生成的代码片段。
- 在编辑区输入**Alt+C**快捷键（macOS上为**Option+C**）触发代码续写。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155810.44158317919903958591327007299998:50001231000000:2800:B735A1D00919E6A4822632D4BCA58E346F67004E3BCE73C9DACA08123DED5D80.png)

### 续写采纳

续写内容采纳方式**：**

- 可通过按**Ta****b**键采纳该内容。
- **Ctrl + ↓（**macOS中为Command + ↓**）**逐行采纳该内容。
- **Ctrl + →****（**macOS中为Option + →**）**逐单词采纳该内容。
- 通过按**ESC**键忽略该内容。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155810.81541792728264274902624956143256:50001231000000:2800:32FF51255D3D1E7EB6A367416C079A7B4D4191F9F90C8D1267774DB869359EEE.png "点击放大")

CodeGenie续写常用快捷键如下：

|   |   |   |
|---|---|---|
|**操作**|**macOS**|**Windows**|
|触发多行代码续写|Enter、Option+C|Enter、Alt+C|
|触发单行代码续写|Option+X|Alt+X|
|采纳续写生成的代码|Tab|Tab|
|忽略续写生成的代码|Esc|Esc|
|查看上一个代码续写结果|Option +[|Alt + [|
|查看下一个代码续写结果|Option + ]|Alt + ]|
|重新生成代码内容（最多支持重新生成5次）|Option + R|Alt + R|
|展示CodeGenie面板|Option + U|Alt + U|
|代码逐行采纳|Command + ↓|Ctrl + ↓|
|代码逐单词采纳|Option + →|Ctrl + →|

[编辑区代码生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-edit-area-code-generation "编辑区代码生成")

[页面生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-page-generation "页面生成")
# 页面生成

更新时间: 2025-12-16 15:58

支持通过自由输入、快捷模板、上传页面参考图片三种方式，生成应用/元服务可用的页面代码，生成结果支持实时预览，帮助开发者快速完成页面搭建。

从DevEco Studio 6.0.1 Beta1开始，在输入框新增页面生成的入口。

1. 点击页面右侧菜单栏CodeGenie图标完成登录后，可以通过如下两种方式进入页面生成窗口：
    
    - 在输入框左下角下拉框选择**Generate UI Code。**
    - 在输入框输入"/"调出命令，**选择Generate UI Code**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.37899854363634460916197085360858:50001231000000:2800:DAE659555A31BABBAD2827E5B166101C94DAF7724EEACABE56B4DE6AE47285DE.png)
    
2. 输入需要生成的页面主题及要求，或者使用快捷模板，勾选下方的行业领域和常用功能标签，或者直接上传一张页面参考图片。当前支持对美食、旅游、购物、新闻和教育五大垂域进行页面生成。点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.08904527358628733019814869069179:50001231000000:2800:47C994FE3A6912012DB2B6FF693238F68795E3BB648CA2F3A255F620F6B50F53.png)图标，等待生成完成。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.77671871858057631438708887700656:50001231000000:2800:C25C4BF276E15B53A1A3185BADF9C4A3E63EC8A57B163A897D1C5FB22849D28B.png)
    
3. 支持通过多轮对话新增或修改页面及页面中的关键字等具体信息，点击历史对话中的**回到本次**可以回退到之前的页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.42568713344840175533321964192921:50001231000000:2800:51C7D7DFCBF5333107048199BA4D24972F6AA49193E3C094E6771F6666D56125.png)
    
4. 点击**Save to Project**，在弹窗中设置页面名称及指定页面所保存的模块。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155803.73718004928772760402784802255135:50001231000000:2800:0BF1EA8EA6ACE5A0F40323FCA50E58D5CE2690DEDC31C4A1F6BB92937985A2F1.png)
    
5. 点击**Next**将生成的代码文件及资源保存至工程中。弹窗中绿色文件为新增，蓝色文件表示该文件存在更改，点击**Finish**完成添加。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.97941845046018337392857286423472:50001231000000:2800:5C44E8B0DC44AC1DD88629FB2ED0E8D538FC58DE5AF8568077C92C78B8C550C7.png)
    

[编辑区代码续写](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-continuation "编辑区代码续写")

[万能卡片生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-service-widget "万能卡片生成")
# 万能卡片生成

更新时间: 2025-12-16 15:58

基于AI大模型理解开发者的卡片需求信息，通过对话式的交互智能生成HarmonyOS万能卡片工程。

从DevEco Studio 6.0.1 Beta1开始，在输入框新增卡片生成的入口。

## 使用约束

1. 建议从以下维度描述卡片需求：
    
    |   |   |   |   |
    |---|---|---|---|
    |**序号**|**建议描述维度**|**说明**|**举例**|
    |1|卡片用途|卡片的用途/业务场景，比如电商购物、娱乐、生活服务类等。|例如“电商购物卡片”、“娱乐类卡片”。|
    |2|卡片功能|卡片包含的组件，如图标、标题、按钮等。<br><br>组件的状态信息，如图标主题、标题内容、按钮显示的文字等。|例如“新品上市主标题”、“商品搜索按钮”、“热门电影子板块入口”等。|
    |3|卡片尺寸|HarmonyOS官网提供的四种卡片尺寸：1*2（微卡片）、2*2（小卡片）、2*4（中卡片）、4*4（大卡片）。<br><br>卡片尺寸为非必选项，AI会根据前两个维度描述的信息，智能选择效果最佳的尺寸。|例如“2*2尺寸的卡片”、“中卡片”等。|
    
2. 当前不支持在生成卡片预览图后，继续描述需求进行增量修改。

## 万能卡片生成

1. 点击页面右侧菜单栏CodeGenie图标，完成登录后，在对话区域输入"/"调出命令，选择**Service Widget**；或者在输入框左下角下拉框选择**Service Widget**，输入万能卡片的需求，并点击发送。开发者可以根据模型提示进行多轮交互，不断完善需求。
    
    DevEco Studio 6.0.0 Beta1之前的版本，请在对话区域下拉框中选择**Service Widget**后输入需求。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.90055281857429496579991497853291:50001231000000:2800:7BA4D0D217F3E3BCBE1AEE84095BFAF02D871EA81102AE828DDD4D2ADC701281.png)
    
2. 需求描述完成后，智能生成卡片（1~3张）及预览效果图。生成效果示例**：**
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.46862714473214117987143973612649:50001231000000:2800:EB9335F3CA865AB52A3CA5972A5DB35A2CA72D2C25E62C894D0646AEF615E9DF.gif)
    

## 万能卡片保存

1. 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.35829114144451643615663106752318:50001231000000:2800:F108444F53BD392B810AE589F8457173B8B389B1201319C6B13CE63589EC2446.png)，可查看生成卡片的UI代码、配置信息和下载静态资源文件。
2. 保存卡片工程有两种方式：
    
    方式一：使用代码/配置查看窗口的“复制”、“插入”或“创建文件”等按钮，手动保存卡片代码和配置信息。
    
    方式二：点击“保存工程”按钮，自动保存卡片工程，卡片代码、配置、静态资源文件等会自动保存到工程对应目录中。默认勾选保存逻辑代码，逻辑代码用于配置卡片事件及卡片数据等信息，具体请参考[自定义配置逻辑代码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-service-widget#section17840955102711)。
    
    **流程示例：**
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.62144146362529816922158656797406:50001231000000:2800:E610221E3345282729B687938995DCF0AEF35DA16F8C444513D673A54A6FFF90.gif)
    
    工程保存完成后，工程中会新增如下卡片相关文件：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.78669133311067880204280622134939:50001231000000:2800:354F4D1D07C2445641CB495852CEE3B19CE0FA888EBE03C3F56C44B355831640.png "点击放大")
    

## 自定义配置逻辑代码

逻辑代码包含实现卡片数据交互和卡片事件两类。

- 卡片数据交互：触发卡片页面刷新。应用工程生成的卡片数据交互，可通过数据库或网络请求两种方式来触发卡片页面刷新；对于元服务工程生成的卡片，数据交互为通过网络请求方式触发卡片页面刷新。
- 卡片事件：使用router事件跳转到指定的UIAbility、使用call事件拉起UIAbility到后台、使用message事件刷新卡片内容。

### 目录结构

在module > src > main > ets 路径下， formcommon目录用于存放生成卡片的逻辑代码。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.10801164919811015619983100975459:50001231000000:2800:DE1002E1C3697F5EAC60D926FC39D1CF4D9292218737AFD838E4195BA11B44B7.png "点击放大")

- formsetting：存放用户可配置的文件。
    - formsetting > formdbsetting：自定义配置以数据库方式进行卡片刷新的相关参数。
        - formdbsetting > formdbinfo：存放包含卡片信息的Info.ets文件，可在Info.ets文件中，添加卡片刷新所需要的具体的数据，后续会读取该文件并将数据存入数据库中。
        - UserSettings.ets：可以自定义卡片刷新时从数据库获取数据的规则、数据解析规则、message内容刷新规则。
    - formsetting > formhttpsetting：自定义配置以网络请求方式进行卡片刷新的相关参数。
        
        - formhttpsetting > formhttpinfo：存放包含卡片信息的Info.ets文件，可在Info.ets文件中添加获取卡片刷新数据的URL。
        - UserSettings.ets：可以自定义卡片刷新时从URL获取数据的规则、数据解析规则、message内容刷新规则。
        
        说明
        
        如需使用网络请求方式刷新卡片页面，需在EntryFormAbility.ets文件中将FormDbUpdate的接口注释掉，并将启用FormHttpUpdate接口。
        
    - formsetting > FormAction.ets：配置卡片事件。
- utils：存放工具类的目录，用户不可修改，如果修改再次生成逻辑代码时utils目录会被刷新。

### 自定义配置卡片事件

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.95144948463757429705539500984042:50001231000000:2800:FA243BC8ADA6E6EA3A535632CD394741E99D9166B31F2FC02D14E28592ED11AC.png)

1. 在FormAction.ets文件中，配置触发卡片router事件时具体的页面分发规则。

2. 在EntryAbility.ets文件的onWindowStageCreate方法中，会插入页面分发接口的调用，示例如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.57911601396064550514255247095175:50001231000000:2800:FDF1BD6C9F50C846FE40A79484DA0E516F9D4EA1B1F7B0191D13E28AD60B350E.png)

此接口默认插入到方法开头，可根据当前工程onWindowStageCreate逻辑来将此接口移动至合适的位置，保证页面能正常跳转。

[页面生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-page-generation "页面生成")

[单元测试用例生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ut-generation "单元测试用例生成")
# 单元测试用例生成

更新时间: 2025-12-16 15:58

根据选中的ArkTS方法名称，CodeGenie支持自动生成对应单元测试用例，提升测试覆盖率。

1. 点击页面右侧菜单栏CodeGenie图标，完成登录后，在ArkTS文档中，光标放置于方法名称上或框选完整的待测试方法代码块，右键选择**CodeGenie > Generate UT**，开始生成单元测试用例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.58189234260664143023001615282197:50001231000000:2800:471D565DA709E8F59C2493919A7096320D4C17CF0DFE84774B66DC6BCC0FFC3C.png)
    
2. 在问答对话区生成单元测试用例后，点击回答代码中右上角的**New File**按钮，弹出文件另存为框，填写文件名称后点击**OK**按钮保存。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.48417628946510576210462323793328:50001231000000:2800:C0A9AA25CACA55DA34D4BB1DCDC3950C6FCDB39881B3BF77B8D362A90D7E98AF.gif)
    
3. 生成的单元测试用例文件被保存在待测函数所在模块下的**ohosTest/ets/test**目录，目录结构和待测函数保持一致。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.02601561430312160018211004122825:50001231000000:2800:176A28EC7E2E891AA090089D6DE2962C4EC3BDFDB6E22B22CC6005173F08A739.png)
    
4. 运行单元测试用例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155804.65865040794601244859188435432121:50001231000000:2800:24870E85A580360D3BF40CFE0F5B7CA1FE389E74ED331566B0FB9EEAEAAAE3AB.gif)
    

说明

- 最多支持解读30000字符以内的代码片段。ArkUI代码、生命周期函数、@Extend/@Styles/@Builder修饰的函数、private修饰的私有函数不支持生成单元测试用例。
- 使用该功能需先完成CodeGenie登录授权，具体请参考[工具概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie)。

[万能卡片生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie-service-widget "万能卡片生成")

[代码智能解读](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-explain-code "代码智能解读")
# 代码智能解读

更新时间: 2025-12-16 15:58

CodeGenie提供智能AI能力对框选的代码片段进行逐条解释，总结代码段含义，帮助开发者提升阅读代码的速度和效率。

选中.ets文件或者.cpp文件中需要被解释的代码行或代码片段，右键选择**CodeGenie > Explain Code**，开始解读当前代码内容。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.96016815469775060135200038974101:50001231000000:2800:CBB61EB7830BAD7079EA92C1FD3942CA300655D264166CE664F547039FBA4FF3.png)

说明

- 最多支持解读30000字符以内的代码片段。
- 使用该功能需先完成CodeGenie登录授权，具体请参考[工具概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codegenie)。

[单元测试用例生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ut-generation "单元测试用例生成")

[编译报错智能分析](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-compilation-error-analysis "编译报错智能分析")
# 编译报错智能分析

更新时间: 2025-12-16 15:58

当DevEco Studio构建ArkTS工程出现失败时，CodeGenie能够对错误进行智能分析，提供错误原因及修复方案，帮助开发者快速解决编译构建问题。

1. 如需开启编译报错智能分析和自动修复，进入**File > Settings**（macOS为****DevEco Studio > Preferences/Settings****） **> CodeGenie** **> General**页面，勾选**Enable AI-Fixed For Build Errors**和**Allow AI Edit Local File**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.87378798198293053704839973701837:50001231000000:2800:8123C1DD59AC9511F2CBDCDE49AC8F472D6025950E0025837AAC58431E6CEDF1.png)
    
2. 当ArkTS工程出现构建报错时，点击报错信息后方**Add To Chat**图标，CodeGenie将自动引用构建报错信息，开发者可在输入框中选择对当前报错修复任务进行补充指令，帮助开发者进行定制化修复，使修复更准确，如"当前工程为API19工程，注意兼容性"，"不修改工程代码"，"仅需给出分析即可"，"不进行编译验证"等，点击或回车发送对话后，CodeGenie会分析该报错及开发者输入信息，并提供可能的错误原因，针对语法错误问题将参考开发者诉求，提供恰当的修复方案。
    
    若弹窗提醒"Please sign in to access DevEco CodeGenie"，请先登录CodeGenie后，再次点击**Add To Chat**图标查看解决方案。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.41088095566754345766119381494972:50001231000000:2800:45BED6F762B001F3D63950627D15BA760F1F5291DA3E6EB4E00E7845F6BEBC99.png)
    
3. CodeGenie分析后，点击编辑区**Accept**（或使用快捷键**Shift+Ctrl+Y**），接受AI提供的修复方案；或者点击**Reject**（或使用快捷键**Shift+Ctrl+N**）拒绝；或者点击右侧对话窗口中**Accept All****/Reject All**按钮，快速接受/拒绝所有修改。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.24915857193191497720506632914534:50001231000000:2800:CF75CC7DA1DD94D5132E5C5CDB53E4B4C0F1583640BE2495C83364FE8E4803CF.png)
    

[代码智能解读](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-explain-code "代码智能解读")

[智慧调优](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ai-profiler "智慧调优")
# 智慧调优

更新时间: 2025-12-16 15:58

DevEco Studio提供智慧调优能力，支持通过自然语言交互，分析并解释当前实例或项目中存在的性能问题，帮助开发者快速定位影响性能的具体原因。该功能从DevEco Studio 6.0.0 Beta1版本开始支持。

注意

从DevEco Studio 6.0.0.828版本开始，支持对Allocation内存分配问题和Snapshot内存堆快照问题进行智慧调优分析。

1. Profiler工具中已集成智慧调优能力，首次使用请先根据界面提示完成CodeGenie授权登录。当前支持两种开启方式：
    
    方式一：若Launch/Frame/Allocation/Snapshot模板已录制完成，点击Session窗口中该条会话上的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.35234527929513430807148546521824:50001231000000:2800:F7D727DE50787C32F8265BD0D7E54A6BD6C8F1CD319531FB1CE17B92C6108ED4.png "点击放大")图标，开始智慧调优分析。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.10383760938255574165008128711002:50001231000000:2800:8807B5E0A37C9EA4AFD918FDE479E74A37B9D911A2E2D2137B96227688E99A2E.png "点击放大")
    
    方式二：切换到Assistant窗口，点击**Create Session**/**Open File**按钮，录制新调优任务或导入已有的调优数据文件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.81101724002952657210812741091995:50001231000000:2800:0522A6FBDE8ACA4A4F7A6B11B5730A7958014ED8BE9C3647618EE963D37780E2.png "点击放大")
    
2. 以第二种创建方式举例，在Assistant页面，点击**Create Session**按钮，选Launch/Frame/Snapshot/Allocation分析模板。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.04361089090032195212060526373143:50001231000000:2800:8216AC50C2591A34757ADFC3B6685BB573F62E245AEC30EF75768C1EEB31A664.png "点击放大")
    
3. 录制新的调优任务或导入本地已有的调优数据文件，当前支持导入的文件类型包括.insight、.heapsnapshot、.rawheap。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.24225919991108103607072020576081:50001231000000:2800:D48C3030B43A6B7B1590BCEF89E28AD2ED6D08D20B8B74340582126FA5D6D64E.png "点击放大")
    
4. 等待AI分析完成各阶段耗时情况。可以左键选中阶段名称，点击**Analyze**，进一步分析该阶段的具体耗时信息，或点击**View Lane**，在右侧查看具体的泳道信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.25098554667601581757821277397564:50001231000000:2800:980A88F9C08A288391796B9013C0D1E6659786578E4354AFB3C11821AE358FA5.png "点击放大")
    
5. 点击分析后，逐步深入挖掘当前阶段具体耗时场景，找到影响性能的可能原因。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.72361926648401147213882971825973:50001231000000:2800:743138E91935FF333CA93FC27BD850F7AA05A08B6BE28AD3E80BBBED78D2C2B5.png "点击放大")
    
6. 若使用Snapshot模板对堆快照问题进行分析时，支持在对话框中选择单个Snapshot分析，或选择两个Snapshot进行对比分析。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155805.12622100829178607716521714909258:50001231000000:2800:8B11FBE21B6D5CE7034EB7FDF2B7C4E32E23B6758570F5FE01D48DB005064C99.png "点击放大")
    

[编译报错智能分析](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-compilation-error-analysis "编译报错智能分析")

[应用UI生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-generator "应用UI生成")
# 应用UI生成

更新时间: 2025-12-16 15:58

UI Generator用于快速生成可编译、可运行的HarmonyOS UI工程，支持基于已有UI布局文件（XML），快速生成对应的HarmonyOS UI代码，其中包含HarmonyOS基础工程、页面布局、组件及属性和资源文件等。

## 使用约束

建议使用DevEco Studio 5.0.3.700及以上版本。

## 启用插件

1. 在DevEco Studio菜单栏，点击**File > Setting****s...**（macOS为**DevEco Studio > Preferences****/Settings**）**> Plugins**，在Installed列表中找到UI Generator插件，点击**Enable**启用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.65548821931489775039081818297163:50001231000000:2800:6BCBBC7A0309FAAA5BCEC0383FD8252147B98EABC45EF1F297FF13F0DFD121A5.png "点击放大")
    
2. 单击OK并关闭设置窗口，插件启用成功。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.29020442165300382579783289771299:50001231000000:2800:447DBD4EB6C69D6A1D865054BBC24997D8580C85F6864F6D1F5F2BC177054D7A.png "点击放大")
    

## 开始使用

1. 在菜单栏点击**Tools > Generate Project From...**打开UI Generator工具，首次使用需要阅读并确认用户协议，确认后可继续使用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.36835105630323132017740937405033:50001231000000:2800:A3D20C528EE918E4FC82543F9AC6F6A57442354413D0425BD84638B7C134F5C4.png "点击放大")
    
2. 输入待配置项路径，点击Next进入下一步。
    
    |待配置项|说明|
    |:--|:--|
    |Installation package path|待转换的APK应用包的路径，请提供未混淆的Debug版本应用包。|
    |SDK path|等于或高于编译应用包所使用版本的SDK路径。|
    |Git Bash path|Git Bash工具存放路径。若本地已下载安装Git Bash，插件将自动获取其路径。|
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.61847163293808862209395233027530:50001231000000:2800:ABFAC713CDC88064B7E1C1C5CE8FD669BC4012E4758D761F931EFC2F471BC933.png "点击放大")
    
3. 选择将要生成的XML页面（可在搜索框进行搜索），勾选后点击向右箭头将选中的XML导入至右侧。点击Next开始生成。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.81765957574090974635749425889051:50001231000000:2800:2A6FA1B9B9F3E0EE2F9CFE45E8572925AE5570052839168E965D5BD673252238.png)
    
4. 配置输出工程待配置项，点击Finish进行生成。
    
    |待配置项|说明|
    |:--|:--|
    |Destination Path|生成新工程的保存路径(默认生成到用户目录下UIGenerationProjects，用户可根据需要自行更改)|
    |Compatible SDK|生成的新工程所使用的SDK版本|
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.71006940814728895865445451042970:50001231000000:2800:62BBAB6EFC70D5B963EC27611F0C47326E113A415868BBB956A7CA3026F12276.png)
    
5. （可选）如果所选XML无有效根节点，需要选择根节点信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.93572008742751576314494398250302:50001231000000:2800:4AE776E9FE5D832240815925896C6F0C9DD2212DF487D7E514421373F1AA9370.png)
    
6. 点击Finish，在弹窗中点击确认，打开新工程，生成的页面位于entry > src > main > ets > pages目录下，可以在Previewer中查看页面预览效果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.89903223845725357685691263378137:50001231000000:2800:B3333EDEE94ED979E0701EDEFD9F15CEAB689366A940068DD5CFC69D31D0D12A.png)
    
7. 生成的新工程内的entry > src > main > resources目录包含文本、图像、颜色资源。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.91528662809782029651008474714580:50001231000000:2800:B6F9272419EBF5CB3A9951F7924E5CB7DEFCDA6FCBC82FDD76AEE796073B6FD0.png "点击放大")
    
8. 不支持生成的组件、属性会以注释的形式给出，方便后续定位修改。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.40399654418658014039619211567614:50001231000000:2800:E7C2BBC55F608727BCFBBA274D8FA866E9CDC867F9ECBADB670F552A56687755.png)
    
    更多操作指导，请参考视频课程：[毕方HarmonyOS UI代码生成工具](https://developer.huawei.com/consumer/cn/training/course/live/C101731322888995220)。
    

[智慧调优](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ai-profiler "智慧调优")

[意图装饰器生成和小艺智能体创建](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-intent2 "意图装饰器生成和小艺智能体创建")
# 意图装饰器生成和小艺智能体创建

更新时间: 2025-12-16 15:58

通过装饰类或方法可以将应用的功能定义为"意图"，然后将应用功能以"意图"形式集成至系统入口。用户通过系统入口（如语音助手、智能推荐卡片）触发意图执行，即可便捷使用应用提供的功能。

从DevEco Studio 6.0.0 Beta2开始，CodeGenie支持生成意图装饰器，帮助开发者更快更高效的将功能转换为意图和生成智能体。

## 使用约束

- 使用API 20及以上版本。
- 仅支持使用团队账号登录时，添加意图插件。个人加入目标团队方式具体可参考[添加成员](https://developer.huawei.com/consumer/cn/doc/app/agc-help-manageaccount-0000002306610129#section151241455193313)。
- 应用在AGC已注册，具体可参考[创建HarmonyOS应用](https://developer.huawei.com/consumer/cn/doc/app/agc-help-create-app-0000002247955506#section1772711713288)。

## 意图装饰器分类

CodeGenie提供了几类意图装饰器，开发者可根据业务场景进行选择，具体请参考[意图装饰器定义](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-insightintentdecorator)：

- @InsightIntentLink装饰器：在class头部或内部位置唤起意图装饰器，在class上方插入生成的代码。
- @InsightIntentPage装饰器：在@Component头部/struct结构体内部/选中整个结构体区域唤起意图装饰器，在@Entry上方插入生成的代码。
- @InsightIntentFunction装饰器：在类中静态方法区域唤起意图装饰器，在class上方插入@InsightIntentFunction，在class内部插入@InsightIntentFunctionMethod生成内容。
- @InsightIntentForm装饰器：在继承FormExtensionAbility的class头部或内部唤起意图装饰器，在class上方插入生成的代码。
- @InsightIntentEntry装饰器：在直接继承InsightIntentEntryExecutor的class头部或内部唤起意图装饰器，在class上方插入生成的代码。

### @InsightIntentLink装饰器

1. 打开module.json5文件，配置**abilities > skills > uris**字段。uri格式要求请参考[应用链接说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-uri-config)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.33065984050088490227713560840678:50001231000000:2800:138558112D0AE45ABEE7345614E2452D7D452E898620CE2C865E4964C65A53E9.png "点击放大")
    
2. 在class头部或内部位置，右键选择 **CodeGenie > Insight Intent > Link Insight Intent**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.82555913484651378064251145444946:50001231000000:2800:1F809ED4A3930E96ED5B4E325D31541C5251D3263C3ED3153655793C49B218C3.png)
    
3. 意图装饰器自动添加至CodeGenie对话框中，可选择输入或不输入提示词，CodeGenie根据代码上下文分析输出结果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155806.63963707222217156253896194863685:50001231000000:2800:998EA935240AA6BB37B7D15D173E6FCDD0CA0D96BFE5E0E1E05C77CB6684E395.png)
    
4. 生成结果后，点击对话框中生成代码块右上方的**插入**按钮，在class上方插入生成的代码。开发者可基于结果微调，实现意图调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.35670137631711494841621915722723:50001231000000:2800:119E5B2C66FDF6E91E2323C6BBADCBB3AB12C05D773E0C73D97447FF9A59A613.png)
    

### @InsightIntentPage装饰器

基于组件导航（Navigation）的子页面使用，@Component和struct需成对出现。

1. 在@Component头部\struct结构体内部\选中整个结构体区域，点击**右键 > CodeGenie > Insight Intent > Page Insight Intent**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.35095075088180508719231688808997:50001231000000:2800:5597BF6ED3B79069EF0E2DF6819429A9A85E760F374C088ABABFBE9507745CEE.png)
    
2. 意图装饰器自动添加至CodeGenie对话框中，可选择输入或不输入提示词，CodeGenie根据代码上下文分析输出结果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.02534056947231919644753525146411:50001231000000:2800:D79B0A6D2E7CFB171B45675AD7BC15E2FC6D8380001F65F4CDA022BAAEF1AEA3.png)
    
3. 生成结果后，点击对话框中生成代码块右上方的**插入**按钮，在@Entry上方插入生成的代码。开发者可基于结果微调，实现意图调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.26863884269662202062138888007035:50001231000000:2800:410B410043370C6BD33F12180D6460D1D12218E986C1E6BB224DEDD92B8E901B.png)
    

### @InsightIntentFunction装饰器

1. 在类中静态方法区域，右键选择 **CodeGenie > Insight Intent > Function Insight Intent**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.15216303037582487298566006119979:50001231000000:2800:00A1437B1AB6F01F7937C79FB5FD9460A6E8925DC1C528994253CCDF6A9345EC.png)
    
2. 意图装饰器自动添加至CodeGenie对话框中，可选择输入或不输入提示词，CodeGenie根据代码上下文分析输出结果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.73284059339527546233242898186690:50001231000000:2800:874C2E2E8D05DC0FDB20F73A7945BD1D791FBCBC5E4F976024EDAAA1CBAE7B68.png)
    
3. 生成结果后，点击对话框中生成代码块右上方的**插入**按钮，在class上方插入@InsightIntentFunction，在class内部插入@InsightIntentFunctionMethod生成内容。开发者可基于结果微调，实现意图调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.43909362706923728873831737863635:50001231000000:2800:08E91ABB98830362FEA03F16D3AD0160E91EEB1C7763D3BCE1EAB4A95F955A0E.png)
    

### @InsightIntentForm装饰器

1. 基于FormExtensionAbility使用，在继承FormExtensionAbility的class头部或内部，右键选择**CodeGenie > Insight Intent > Form Insight Intent**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.38579495238505551731665022758021:50001231000000:2800:D76C13A0B5B8ADFAB59328302566B8F0917FD7BE5448D1229A1EEDF0AAAE50E2.png)
    
2. 意图装饰器自动添加至CodeGenie对话框中，可选择输入或不输入提示词，CodeGenie根据代码上下文分析输出结果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.28739640547581607007584441177248:50001231000000:2800:F2D1969174C3E0C3333945B578FD4184E7C698189D7E746D622F97264C1F3DA6.png)
    
3. 生成结果后，点击对话框中生成代码块右上方的**插入**按钮，在class上方插入生成的代码，开发者可基于结果微调，实现意图调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.17824952255263923627040546956538:50001231000000:2800:92D892750EAD40AD527D60C05FBBD9283EC9D594722926F9F7BB4585E0F39ABB.png)
    

### @InsightIntentEntry装饰器

1. 基于InsightIntentEntryExecutor使用，在直接继承InsightIntentEntryExecutor的class头部或内部，右键选择**CodeGenie > Insight Intent > Entry Insight Intent**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.58917673732246176174052344209283:50001231000000:2800:1450BE85DFB0AEE6131B325AB15A5B21120268F7F6E701DCC1FFEC5E1A8E680A.png)
    
2. 意图装饰器自动添加至CodeGenie对话框中，可选择输入或不输入提示词，CodeGenie根据代码上下文分析输出结果。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155807.93467728469808293218069467921452:50001231000000:2800:19E73F1F774794FDD490699A3BE6B0E08836119D4B5B497E08A75C19B4684E04.png)
    
3. 生成结果后，点击对话框中生成代码块右上方的**插入**按钮，在class上方插入生成的代码，开发者可基于结果微调，实现意图调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.84508538687129574652931001753755:50001231000000:2800:29BDA7701B0736A5B00616125B8AC924503E2061DC597C3060559CD666FB5185.png)
    

## 添加意图插件和创建小艺智能体

1. 点击DevEco Studio右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.15857181349897981734041890509106:50001231000000:2800:31548AA78CA90B319EED0B8D532E60367C96C061C71373EFF3E0CD361F0E0600.png)图标登录个人账号，再切换至个人所在的团队账号。
    
    说明
    
    - 个人账号需要完成实名认证，具体请参考[实名认证](https://developer.huawei.com/consumer/cn/doc/start/rna-0000001062530373)。
    - 如下企业开发者账号为某团队账号名称。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.40324293909717114140832920420276:50001231000000:2800:EA1529D029F6D442983BF17455BECD31858344C07C03138FEE1BEF616D9548E7.png)
    
2. 在意图注解代码块内部任意位置，右键选择**CodeGenie > Add Intent Plugin**。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.77229017168783685583863824857045:50001231000000:2800:A98161EA96FFBAC2191AC83ACB2AFBD26CADFB7D245413C3CEFBD7B13850F4EF.png)
    
3. 在DevEco Studio菜单栏点击**View > Tool Windows > Application Agent** ，打开内嵌的小艺智能平台。
4. 在小艺智能体平台[创建智能体](https://developer.huawei.com/consumer/cn/doc/service/quick-start-0000002469548009)，[内嵌插件](https://developer.huawei.com/consumer/cn/doc/service/develop-plug-ins-0000002435989648)，连接[真机测试和调试](https://developer.huawei.com/consumer/cn/doc/service/list-of-user-groups-for-real-machine-testing-0000002471264273)。更多具体操作可参考[鸿蒙智能体](https://developer.huawei.com/consumer/cn/doc/service/developer-guide-0000002469667881)。

[应用UI生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-ui-generator "应用UI生成")

[模型上下文协议（MCP）配置和自定义智能体创建](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-mcp-agent "模型上下文协议（MCP）配置和自定义智能体创建")
# 模型上下文协议（MCP）配置和自定义智能体创建

更新时间: 2025-12-16 15:58

从DevEco Studio 6.0.1 Beta1开始，CodeGenie支持用户添加模型和自定义Agent，增强AI问答能力，提升AI辅助编程和分析能力。自定义过程包括模型上下文协议（Model Context Protocol，简称MCP）配置、模型（Model）配置、智能体（Agent）配置和调用。

## MCP配置

为确保MCP Server正常启动，需要安装npx和uvx。其中，npx依赖于Node.js，建议使用Node.js的LTS版本；uvx是基于Python的快速执行工具，建议安装Python 3.9 以上的版本。

1. 点击页面右侧菜单栏CodeGenie图标，完成登录后。点击界面右上方**Settings**![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.79399837734290294833106434943741:50001231000000:2800:AFDED3C4AC7C47AC53DB518B25B6C7297BBEF4B47E6361F80411D1AEFED4DEFA.png)按钮，选择**MCP** **Settings**，进入配置页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.72660631895507192962116546701328:50001231000000:2800:17BEF967BD1A361C75DD2D1100629A7D95D34C43B622264D33CD7E562916C5B7.png)
    
2. 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.29998127211795055766087488504231:50001231000000:2800:B73278B632E97C910F689CF2EEA45A1D810E183605542F662C473FD7B804768A.png)按钮，添加MCP工具。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.12754286381992009003692392882986:50001231000000:2800:965E424A9DA089B51398B93FD3CAFAB4DD113DD3CE9F375E70637414C09B9A84.png "点击放大")
    
3. 在编辑框中填写MCP工具的配置信息，填写完成后点击**Add**。
    
    说明
    
    MCP Server支持三种通信方式：Stdio 、Server-Sent Events (SSE) 和Streamable HTTP。
    
    Stdio方式支持配置cmd、args和env字段，SSE和Streamable HTTP方式支持配置url字段。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.27917168930654885591243118130236:50001231000000:2800:A33F87438FF9A67C5F869CD350460B29D24B8CFFFF3D87BF036D720CE544139A.png "点击放大")
    
4. 在**Added Tools**列表中，展示所有MCP工具信息，包括名称、连接状态、启用状态。同时，将鼠标悬浮在工具上会显示三个操作按钮：刷新、编辑和删除，方便开发者管理工具。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.38728420778932256562179803343110:50001231000000:2800:2CA96EF2377DE64FB52D2B4B0F3A4B7308C437D2EB74BD16B573AFCE9D49B90F.png "点击放大")
    
    - 名称：MCP工具名称，如Context7、Time。
    - 连接状态：工具连接状态，包括“成功”、“失败”和“连接中”三种状态。
    - 启用状态：工具是否已启用。
    

## 模型配置

CodeGenie支持通过OpenAI-API协议接入第三方模型，为自定义Agent提供多样化的模型选择。

1. 点击界面右上方**Settings**![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.89588830110483455802059875260347:50001231000000:2800:7E3FAD47287D0B0AB81E1AB483F2D36084F9B112582228C5FB53E8CC3DA43711.png)按钮，选择**Model Settings**，进入配置页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.79371217749344070943109623835473:50001231000000:2800:02A403C096D79A9F4A0E33024D1DAB5AF495873FFFF757B85A999CEDF3C0803D.png "点击放大")
    
2. 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.36145489045709924364923767747550:50001231000000:2800:E1A70EBDFCE2893659ED428A2EC919227C0B70DF5BBD413D569131CFE91B9EF4.png)按钮，填写相关信息。点击**Add**，校验成功的模型将被添加到列表中。
    
    - **Name**：模型名称。
    - **Url**：模型的访问地址。
    - **API Key**：模型的访问密钥。
    - **Model**：模型的标识。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155808.20387206560223675924646379807912:50001231000000:2800:BBBAF771C7DA06BECBF52F611D333B9626E743383C5054749B31AC382B273806.png "点击放大")
    
    说明
    
    当前仅支持添加遵循OpenAI-API规范的模型。
    
3. 在**All Models**下展示所有添加成功的模型。将鼠标悬浮在模型上会显示两个操作按钮：编辑、删除，方便开发者管理模型。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.39713896236722942826058444571162:50001231000000:2800:B2A3104E15B5B85459E118E524B0BB1FEED3FFA658EB512FA2D84D7C8270710F.png "点击放大")
    

## Agent配置

1. 点击界面右上方**Settings**![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.58835943038554794215058497982761:50001231000000:2800:3E6ACB5833038E4F5E5258D4622C6FABD476254FD128E371A35A4F471D338A2C.png)按钮，选择**Agent** **Settings**；或者在输入框左下角下拉框选择**Create Agent**，进入配置页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.64747677277233396695727713625717:50001231000000:2800:212C27D8B7DF176E193A08BE8B518D2BF9FE5139D6B24F589FCB4DCD4009257E.png)
    
2. 点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.59423524774716222886173917598028:50001231000000:2800:5525271F8F8CC6410BE4FAB45312034218611DCA9AEDE992C27C8A9862018FDD.png)按钮，填写自定义Agent的相关信息。点击**Add**，将创建自定义Agent。
    
    - **Name**：必填，自定义Agent的名称。
    - **Prompt description**：可选，自定义Agent的提示词。
    - **Added Tools**：可选，添加MCP工具。具体请参考[MCP配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-mcp-agent#section1918313413580)。
    - **Select Model**：必填，选择需要使用的模型。具体请参考[模型配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-mcp-agent#section13929843125813)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.51923835524154178334624660575775:50001231000000:2800:9104D99B8883B283A9D38EC6B94F83DC297E5F7AD20B10FE8B9F420E785B9020.png "点击放大")
    
3. 在**All Agents**下展示所有内置（HarmonyOS Ask、Generate UI Code、Service Widget）和自定义的Agent（如figma2code）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.54389600254228336148663334075469:50001231000000:2800:7396C93733D4B858A59093D924A520C79B669A7C6B86F65BC1154CF4D86867F6.png "点击放大")
    

## Agent调用

1. Agent配置完成后，在对话区域输入"/"调出命令，选择自定义的Agent（如figma2code）；或者在输入框左下角HarmonyOS Ask处下拉框中选择自定义的Agent（如figma2code）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.71077672159407185925065722746287:50001231000000:2800:2FADAFF58608890A48D16E2B3B48D71A230EDC3B54490F0BC18FCB94F34DCDB5.png)
    
2. 选择自定义的Agent后，在右侧可以切换模型，默认使用[配置Agent时添加的模型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-mcp-agent#li163941335173012)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.94486940142222648384336974722185:50001231000000:2800:BE69898F6DD06241EC15ED263FF11DC89420512E79E9A334910735648E10B46C.png "点击放大")
    
3. 根据业务需要，进行智能问答、代码生成、代码智能解读等，CodeGenie将会调用自定义的Agent和选择的模型生成内容。若Agent已添加MCP工具，界面会有授权弹框。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155809.35107141411565079387258108313090:50001231000000:2800:8BD8BC3C75CCFF5D3A1A17361C50709C100BA4E4EB99B4DFD90375B0C872744B.png "点击放大")
    

[意图装饰器生成和小艺智能体创建](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-intent2 "意图装饰器生成和小艺智能体创建")
# 代码阅读

更新时间: 2025-12-16 15:58

DevEco Studio支持使用多种语言进行应用/元服务的开发，包括ArkTS、JS和C/C++。在编写应用/元服务阶段，可以通过掌握代码编写的各种常用技巧，来提升编码效率。

## 代码高亮

支持对代码关键字、运算符、字符串、类、标识符、注释等进行高亮显示，您可以打开**File >** **Settings**（macOS为**DevEco Studio > Preferences/Settings**）面板，在**Editor > Color Scheme**自定义各字段的高亮显示颜色**。**默认情况下，您可以在**Language Defaults**中设置源代码中的各种高亮显示方案，该设置将对所有语言生效；如果您需要针对具体语言的源码高亮显示方案进行定制，可以在左侧边栏选择对应的语言，然后取消“Inherit values from”选项后设置对应的颜色即可。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.55793846381857229995764470701701:50001231000000:2800:2E5A5B7CCCDF50FBB0913644C497D5FD761C47EDD8C22A2EBA9A7E01A645E90C.png)

## 代码跳转

在编辑器中，可以按住**Ctrl**键（macOS为**Command**键），鼠标单击代码中引用的类、方法、参数、变量等名称，自动跳转到定义处。若单击定义处的类、变量等名称，当仅有一处引用时，可直接跳转到引用位置；若有多处引用，在弹窗中可以选择想要查看的引用位置。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.63618931333778065962535257173942:50001231000000:2800:D65FA585C661144E7EF6581C9AE49ADCBB8939ACC16DCF5B548223D830A9D910.gif)

## 跨语言跳转

DevEco Studio支持在声明或引用了Native接口的文件中（如d.ts）跨语言跳转其对应的C/C++函数，从而提升混合语言开发时的开发效率。您可以选中接口名称单击右键，在弹出的菜单中选择**Go To > Implementation(s)**（或使用快捷键**Ctrl+Alt+B**，macOS为****Command**+Option+B**）实现跨语言跳转。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.71373681220834104557178323945009:50001231000000:2800:A4B180BC62EA5032C313C04F19B5BB10A96587F04FF9CC0998441175B7A0FFA9.png)

## 代码格式化

代码格式化功能可以帮助您快速的调整和规范代码格式，提升代码的美观度和可读性。默认情况下，DevEco Studio已预置了代码格式化的规范，您也可以个性化的设置各个文件的格式化规范，设置方式如下：在**File > Settings > Editor > Code Style**（macOS为**DevEco Studio > Preferences/Settings > Editor > Code Style**）下，选择需要定制的文件类型，如ArkTS，然后自定义格式化规范即可。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.16329194822549896992039190206755:50001231000000:2800:7EE5F89906F25DAFE4EF2A67B655D2495976013C9E227D42823E6536DA95F8C6.png)

在使用代码格式化功能时，您可以使用快捷键**Ctrl + Alt + L**（macOS为**Option+Command +L**） 快速对选定范围的代码进行格式化。

如果部分代码片段不需要进行自动的格式化处理，可以通过如下方式进行设置：

1. 在**File > Settings >Editor > Code Style**（macOS为**DevEco Studio > Preferences/Settings > Editor > Code Style**），单击“Formatter”，勾选“Turn formatter on/off with markers in code comments”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.09996085863851917698354522404883:50001231000000:2800:342549C2864DE419C1D19195A56D1B05DB8E5F65E9EE215AF100F16B79E789E9.png)
    
2. 在不需要进行格式化操作的代码块前增加“//@formatter:off”，并在该代码块的最后增加“//@formatter:on”，即表示对该范围的代码块不需要进行格式化操作。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.22904740543453308084488360797272:50001231000000:2800:FB28E4BA87FB2C617BC4B06278C6163BF4AAA78264ABE82977D7AD6CD6495936.png)
    

若工程已配置code-linter.json5文件，选中code-linter.json5文件右键选择**Apply CodeLinter Style Rules**，代码格式化规则将与已配置的code-linter.json5文件中相关规则保持一致。code-linter.json5文件配置请参考[配置代码检查规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter#section19310459444)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.13962796186983438671513957543316:50001231000000:2800:98BABFFE420232661D5E0C2BD2066748CDCF5D968E7932C352D9903DAF6DAC21.png)

## 代码折叠

支持对代码块的快速折叠和展开，既可以单击编辑器左侧边栏的折叠和展开按钮对代码块进行折叠和展开操作，还可以对选中的代码块单击鼠标右键选择折叠方式，包括折叠、递归折叠、全部折叠等操作。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.54123183833636914569587723128581:50001231000000:2800:D9BB4398F09A2388A0D37E9D5945AE14224D0039A402ECF74C7523C28484139A.gif)

## 代码快速注释

支持对选择的代码块进行快速注释，使用快捷键**Ctrl+/**（macOS为**Command+/**）进行快速注释。对于已注释的代码块，再次使用快捷键**Ctrl+/**（macOS为**Command+/**）取消注释。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.52269967820794203328067030953752:50001231000000:2800:0F6A7A0846CBA0EA411BE7B088081A2BA714210900392B5E5A3A12C11E8F101A.gif)

## 代码结构树

使用快捷键**Alt + 7 / Ctrl + F12**（macOS为**Command+7**）打开代码结构树，快速查看文件代码的结构树，包括全局变量和函数，类成员变量和方法等，并可以跳转到对应代码行。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.33802706465282221407810978599664:50001231000000:2800:0C4C9A37A804F7DC37B434EE5CAC7C228CC2D6ACD495982B038B1F2210763FCB.png)

## 代码引用查找

提供Find Usages代码引用查找功能，帮助开发者快速查看某个对象(变量、函数或者类等)被引用的地方，用于后续的代码重构，可以极大的提升开发者的开发效率。

使用方法：在要查找的对象上，单击鼠标**右键 > Find Usages**或使用快捷键**Alt +F7**（macOS为**Option +** **F7**）。可点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.43850679545629570757025215534062:50001231000000:2800:20B1E8C6AE383D2BB56111FAD7528F54E6DBB74F5058912F86FCF4BDCC8D4677.png)图标查看变量赋值位置，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.40350248621917781363483225098225:50001231000000:2800:D2F6589FC4C75657C7467E848D462E6839448864B47FD7A2C68EA819269E9FA5.png)图标查看变量引用情况。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.61072211834754943629298177686677:50001231000000:2800:5025D22258734F1BA5FC23FD902596D50C7453D249D7A0E892FC57377E47876A.png)

## 函数注释生成

DevEco Studio支持在函数定义处，快速生成对应的注释。在函数定义的代码块前，输入**“/**”+回车键**，快速生成注释信息。

说明

C++文件同时支持使用**“//!”+回车****键**快速生成注释。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.95964021375914694526768466349311:50001231000000:2800:08704FD6805A1F0C03CC1C20BF84C37DE34D6FA543CCDDC51FA870430BA6595C.gif)

## 代码查找

通过对符号、类或文件的即时导航来查找代码。检查调用或类型层次结构，轻松地搜索工程里的所有内容。通过连续点击**两次****Shift**快捷键，打开代码查找界面，在搜索框中输入需要查找内容，下方窗口实时展示搜索结果。单击查找的结果可以快速打开所在文件的位置。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.70392028919436437928141141124049:50001231000000:2800:A316310F1B0E185611A2547D5825F07B552236E30D179AC9FD420AB6BB196C04.png)

## 快速查阅API接口及组件参考文档

在编辑器中调用ArkTS/JS API或组件时，支持在编辑器中快速、精准调取出对应的参考文档。

可在编辑器中，鼠标悬停在需要查阅的接口或组件，弹窗将显示当前接口/组件在不同API版本下的参数等信息，单击弹窗右下角**Show in API Reference**，或选中接口或组件，右键点击**Show in API Reference**，可以快速查阅更详细的API文档。

说明

DevEco Studio集成了离线版API参考类文档，最新版本请参考官网[HarmonyOS API参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/development-intro-api)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.06619960316746808765756248835690:50001231000000:2800:75205A62010B2D88BAAB6091340490C12A8100D77E23D7B45A20B25F92C69344.gif)

在弹窗中可以查看：

1. 使用的API是否涉及权限申请或仅支持在测试框架下使用。
2. 使用的接口状态。**deprecated**标签表示即将废弃的API接口，可使用**useinstead**标记的API进行替代，请开发时关注。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.60722823309940392536618142657986:50001231000000:2800:257A73F7232BB0945CC31920F65E3EBB3F345D5DAF30B489053EC8233DDCD840.png)

## Optimize Imports功能

使用编辑器提供的Optimize Imports，可以快速清除未使用的import，并根据设置的规则对import进行合并或排序。选择文件或目录，使用快捷键**Ctrl+Alt+O**（macOS为**Control+Option+O**），或单击菜单栏**Code > Optimize Imports**。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.04417644980725135208750315860957:50001231000000:2800:556D17B8F9B8706DBC572F85BBE54FF9C3368D3C9D50F8304B9097572F980D72.gif)

如需修改优化配置，进入**File > Settings**（macOS为****DevEco Studio > Preferences/Settings****） **> Editor > Code Style**，选择开发语言（当前以ArkTS为例），在**Imports**标签页中，可选择在优化时是否需合并来自同一模块的import，是否需要对同一条import语句导入的元素进行排序，或对多条import语句按模块排序。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.49274950250803798012018561868665:50001231000000:2800:EF12505FBE1784E3134709D989E7DCF1B196670D99A1AC742AC6E123432A6F8E.png)

## API变更查询

从DevEco Studio 5.1.0 Release版本开始，DevEco Studio中支持查询、对比从某个选定的SDK版本开始，当前工程中使用到的ArkTS API是否存在行为变更，并提供相应适配指导链接，帮助开发者完成工程代码适配修改。

从DevEco Studio 5.1.1 Release版本开始，支持对C API的变更情况进行查询，提供跨版本查询能力。

### 使用约束

- API废弃情况不在API变更查询的扫描范围。
- ArkTS API函数调用过程中，当开发者使用的API存在泛型参数和包含extends或keyof关键字时，不支持变更查询。示例如下：
    
    1. // API定义
    2. interface ProgressInterface {
    3.   <Type extends keyof ProgressStyleMap>(options: ProgressOptions<Type>): ProgressAttribute<Type>;   //包含extends或keyof关键字不支持变更查询
    4. }
    5. // API调用
    6. Progress({ value: 10, type: ProgressType.Capsule })
    7. .style({content:'Install'})
    

- 使用C++语法实现的API函数变更时不支持查询。示例如下：
    
    1. template <class _Rep, class _Period>
    2. cv_status condition_variable::wait_for(unique_lock<mutex>& __lk,const chrono::duration<_Rep, _Period>& __d)  //C++语法实现的API函数不支持查询
    
- 特殊调用方式下，不支持API变更查询。示例如下：
    
    1. // 反例：函数指针方式
    2. int (*sigptr)(int, const struct sigaction *__restrict, struct sigaction *__restrict) = &sigaction;
    3. sigptr(NULL,NULL);
    4. // 反例：回调方式
    5. callback(sigaction);
    6. // 反例：自定义宏
    7. #define MySig sigaction
    8. MySig(NULL,NULL);
    

### 操作步骤

**使用DevEco Studio 6.0.0 Release及以上版本，按以下步骤操作：**

1. 在菜单栏点击**Tools > API Change Assistant**，编辑区下方的API Change Assistant页签中，支持按模块查看API变更情况，选择需要对比的SDK版本号范围，点击**Start Scan**开始扫描。
    
    说明
    
    API变更查询以选择的起始版本为基线，查询当前工程中所使用的API是否存在行为变更。如选择的SDK版本为5.0.0(12) Release 到 6.0.0(20) Release，查询的是5.0.1(13) Beta3到6.0.0(20) Release版本相比5.0.0(12) Release的API变更。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155814.04823140067382971162881224238984:50001231000000:2800:297A7139514707B6FDF6518361FDB7DF02F2B7F1A1364DB1B60EEB7382BDAA0A.png)
    
2. 点击扫描结果中的代码地址，跳转到相应的代码编写位置；如需更多指导可点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.81927884384662294176258282236091:50001231000000:2800:47FF2AE287E04D5E1287600F1DEBBFF0AF0AC667181E54B2A84608AE4D95AE64.png)链接图标，跳转至版本说明文档中查看详情；修改完后可点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.49544952359884277714712367607618:50001231000000:2800:DB35FCE855A9C4415C5DD036580DBC4D8A79CA2557C74D9A1DDF3A6C814AD4C0.png)图标，标注已修改。同时，可通过如下入口搜索或筛选API变更扫描结果、导出扫描结果数据等。
    
    - **Search**：支持在Search框中输入API名称或文件路径，对扫描结果搜索。
    - **API Version**：通过选择API版本，对扫描结果筛选。
    - **Language**：通过ArkTS或C语言，对扫描结果筛选。
    - **API ID**：通过行为变更的API接口，对扫描结果筛选。
    - **Fix Status**：API变更扫描结果的修复情况，All表示所有，Fixed表示已修复，Unfixed表示未修复。通过修复情况，对扫描结果筛选。
    - **Scan Again**：重新扫描。
    - **Export**：选择位置后，导出API变更扫描结果数据。
    - **Settings**：设置在扫描API时，可使用的最大堆内存的大小，默认值为3072MB。当工程代码量较大导致扫描缓慢时，可以调整该参数。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.46455829001184763732561904018133:50001231000000:2800:737A847395488E616341389CAFD2D5EF21683F4116F7955A6435E15CED21F5DD.png)
    

**使用DevEco Studio 6.0.0 Release以下版本，按以下步骤操作：**

1. 在菜单栏点击**Tools > API Change Assistant**，编辑区下方的API Change Assistant页签中，支持按模块查看API变更情况，选择需要对比的SDK版本号范围，点击**Start Scan**开始扫描。
    
    说明
    
    API变更查询以选择的起始版本为基线，查询当前工程中所使用的API是否存在行为变更。如选择的SDK版本为5.0.0(12) Release 到 6.0.0(20) Release，查询的是5.0.1(13) Beta3到6.0.0(20) Release版本相比5.0.0(12) Release的API变更。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.79602746279938159138696208265267:50001231000000:2800:FD7597A64A9A17466A69382A198812CC1B901967C6290A2CB70A2C6A9BCED4CE.png)
    
2. 点击Code Location中的代码地址，跳转到相应的代码编写位置；如需更多指导，可点击Guidance link中的链接，跳转至版本说明文档中查看详情。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.05304521910626909959189944962660:50001231000000:2800:CCB8EB1A1DC524C11DB05258BAF893C4308C3EFA4D674B94C8D87FEF7F06EE7B.png)
    
3. 点击**Export**，选择API变更的存放位置后导出变更数据；点击**Scan Again**可重新进行扫描。通过右侧**Settings**按钮，可以设置在扫描API时，可使用的最大堆内存的大小，默认值为3072MB，当工程代码量较大导致扫描缓慢时，可以调整该参数。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.27515999406637827163195229590179:50001231000000:2800:AF4602A67C84A9A8C4C4E89A1F5C64C5C03FAE345D1B4EC7B58BEF943525B594.png)
    

## 父/子类快速跳转

编辑器支持快速跳转至当前接口、类、方法、属性的子类/父类。点击代码编辑区域左侧的Gutter Icons（装订线图标）可以跳转到对应的父/子接口或类。如有多个继承关系，在弹窗的文件列表中选择需要查看的接口/类即可。

- ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.21683369012155015225034754854779:50001231000000:2800:00C21AE782FD874F9B845740A49C8321A3C46195F9AF9D70F5750DB2C758F5F1.png)Implemented：支持跳转到对应的实现类或子接口及其对应的属性/方法。
- ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.96292990282831021323969438561427:50001231000000:2800:59FA7D5573CA1E362D65E2F4395AB49C55424DEEFB5586EF23C5F92A4851EF0C.png)Implementing：支持跳转到对应的父接口或父接口的属性/方法。
- ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.24943069327191330310420888302976:50001231000000:2800:00EABBD920B88131F3B7BC3E483F04006967F7A1ACFDAEA65A2FB071FDD3B68D.png)Overridden：支持跳转到对应的子类或子类的属性/方法。
- ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.79463949661524918363182171086985:50001231000000:2800:70A5A3EB3D24FB5E869A5836FB710B9DBA1E6839F8A7E1AB484F5574B08DB7C7.png)Overriding：支持跳转到对应的父类或父类的属性/方法。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.11325842705664198902482028877232:50001231000000:2800:86D2A77D43D08A1EC433E9032DA55C7E378FE3DB55B194A421F4FA7FBFE462C2.png "点击放大")

本功能默认开启，可以通过菜单栏进入**File > Settings**（macOS为****DevEco Studio > Preferences/Settings****） **> Editor > General > Gutter Icons**，通过勾选或取消勾选Implemented、Implementing、Overridden、Overriding四项可以开启或关闭该功能。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.83716898412222641798795820577325:50001231000000:2800:8BDA19919B0FC04FEE2DA342C130CE953C155F6A2A6688805FED6F200299ADFD.png)

## 查看接口/类的层次结构

编辑器支持查看当前接口/类父类或子类的层次结构。选中或将光标放置于类/接口名称处，使用**快捷键Ctrl+H**（macOS为**Control+H**），或在菜单栏**Navigate**页签下选择**Type Hierarchy**，在弹出的Hierarchy窗口中查看接口/类的继承关系结构。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.04338246410114482095317208952917:50001231000000:2800:CCC67C1D07B408C1CE67FD4B5F18261B57FA156D64F524B65805E8B5F9548CDE.png)

Hierarchy窗口按钮功能：

|图标|功能|
|:--|:--|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.20536200852929940431225431740909:50001231000000:2800:D41E4A064C74733B5E98F4A560887583DEEFFCD25506B577AE109AD212F052BC.png)|显示所选类的父类和子类。<br><br>该功能不支持查看接口的继承关系。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.08083623997370497431944911922809:50001231000000:2800:81BE8A319005952EC2367021D2090D174816F83584EE21FD7770E1C2B4C7836B.png)|显示当前类/接口的父类。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.34231208731692566463909827960950:50001231000000:2800:02D26ECC1535905AAC21790BBA6643FD818707A362447CD59FBE11E7B0625242.png)|显示当前类/接口的子类。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155815.46310411411238333086126010538933:50001231000000:2800:E7281E30F4E28AAE6338697399214A119E3D098943A3581B3035BB1B5EA37A87.png)|按字母顺序对继承关系结构树中的所有同级元素进行排序。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.67355044482673543915747781797907:50001231000000:2800:BC02CCEE1BEEF91E7C64C95446CBA113323A4A7620F9CE48063293D3D1F96E04.png)|更新显示所有的类/接口的继承关系结构。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.79892156472793137454040903749974:50001231000000:2800:6DE82222446B750BA9B1E224876074F968E50FDBC38911DA3026727EAF4CB3CE.png)|默认双击结构树中类/接口名称时，编辑窗口将跳转至所选类/接口所在的代码位置。勾选该选项后，单击结构树中类/接口名称，即可跳转访问。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.73804363673184752100436609457962:50001231000000:2800:1E2AAC1B7C438A4C6CEDC109D118BED0D0C025C53D70D1D424C5A7C71B5483BC.png)<br><br>![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.11574297128945582979053831515337:50001231000000:2800:1899BECFDBBF6589E7889D259E45948D1B39CAD88B0C435671EA47245766B360.png)|展开/折叠继承关系结构。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.85711670832213670881175431976634:50001231000000:2800:55BDAD4DDAC8D68082484E05184233888A20149FE93EAFA8719B67698EEB0BE7.png)|锁定当前Hierarchy窗口显示于编辑窗口上。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.33672365698734846408575870038966:50001231000000:2800:759F00880C4FA3DD5F137AF4B6667F07BBB2DA5E6AECE893F981E5C70F1114F7.png)|将类/接口的继承关系结构导出到文本文件中。|
|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.12204325865435859200851618849702:50001231000000:2800:0577256AA1713504BCAA0F4AA947428628A86A58BB84DD3D876DE83594D2A9C9.png)|关闭工具窗口。|

## 添加嵌入提示

从DevEco Studio 6.0.0 Beta2 版本开始，在编辑时启用Inlay Hints嵌入提示功能，可以提供有关参数名称、类型等代码说明信息，提升代码可读性。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.28212585779875942065092896083241:50001231000000:2800:B08659A75809705A47C647095D4E92C95086FBC4A2933BDD7E0BFB7F5B8DD4A1.png)

进入**File > Settings**（macOS为**DevEco Studio > Preferences****/Settings**） **> Editor >** **Inlay Hints**，配置勾选希望展示的变量名称、属性、参数、返回值类型，点击**OK**后生效。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.29130822285033714759026201689827:50001231000000:2800:F4E543EA5717381FEE367A612B65920E0BCFF4BC8EB4929BB0D48D0560578BE7.png)

## Copy Reference

从DevEco Studio 6.0.0 Beta2 版本开始，在编辑页面选中代码行或类、方法、参数、变量等名称，右键选择**Copy / Paste Special > Copy Reference**，将自动复制定义处的地址。复制成功的地址可以在双击**Shift**弹出的搜索框中进行搜索，帮助开发者快速找到该接口的定义位置。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155816.04131768213643987462643481600457:50001231000000:2800:CBFEC2635EE8689C961F17C36B54DFB85B724BF12A571C53790CE0F334C68CFD.gif)

[代码编辑](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-edit "代码编辑")

[代码生成/补全](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-completion "代码生成/补全")
# 代码生成/补全

更新时间: 2025-12-16 15:58

## 代码自动补全

提供代码的自动补全能力，编辑器工具会分析上下文，并根据输入的内容，提示可补全的类、方法、字段和关键字的名称等，支持模糊匹配。

自动补齐功能默认按最短路径进行排序，如仅需按照最近使用过的类、方法、字段和关键字等名称提供补全内容排序，可以在**File > Settings**（macOS为**DevEco Studio > Preferences/Settings**） **> Editor > General > Code Completion** 中勾选“Sort suggestions by recently used”。

说明

若已勾选代码补齐按最近使用排序但未生效，请检查**Code Completion**页面，确保“Sort suggestions alphabetically”已取消勾选。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155820.41462658947546364564569033761012:50001231000000:2800:C9736BA0A567DFF56C19080042522209C6C1318088355D03CC9035FB4DA1FB15.png)

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155820.53322605085139737106573327954588:50001231000000:2800:29C04A7C5C5D4C0A0214CDC042B66896226DE013E55745315F6BDC6F35C2B363.gif)

## 快速覆写父类

DevEco Studio提供Override Methods，辅助开发者根据父类模板快速生成子类方法，提升开发效率。将光标放于子类定义位置，使用**快捷键Ctrl+O**（macOS为**Control+O**），或右键单击**Generate**...，选择**Override Methods**，指定需要覆写的对象（方法、变量等），点击**OK**将自动生成该对象的覆写代码。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155820.72523851087964981001198374325590:50001231000000:2800:4A828A39E3944C876BA87CFFB97D744F24F08FD4F56CB2CB0724645F4CEBA30A.gif)

## 快速生成构造器

编辑器支持为类快速生成一个对应的构造函数。

在类中使用**快捷键Alt+Insert**（macOS为**Command+N**），或单击鼠标右键选择**Generate**...，在弹窗中选择**Constructor**，选择一个或多个需要生成构造函数的参数，点击**OK**。若选择**Select None**，则生成不带参数的构造器。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155820.87398985563013627368950953653217:50001231000000:2800:3109CECA6ACDBAAF3D64192EAEBC68B49FD8BBB82BC69754B95E70A93BB90F1F.gif)

## 快速生成get/set方法

编辑器支持为类成员变量或对象属性快速生成get和set方法。

将光标放置在当前类中，单击右键选择**Generate...>Getter and Setter**，或者使用快捷键**Alt+Insert**（macOS为**Command+N**），在菜单中选择**Getter and Setter**，完成方法快速生成。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155820.30879999937710712265106892869095:50001231000000:2800:74F9B9A54E1B160F17CA788F51619710B7589FA2F7F9865C1F6D3C0B9BFF357C.gif)

## 快速生成声明信息到Index文件

编辑器支持将HSP和HAR模块中变量、方法、接口、类等需要对外暴露的信息，通过**Generate...>Declarations**功能，批量在Index.ets文件中进行声明，便于其他模块调用。

在HSP或HAR模块内的文件编辑界面，单击右键选择**Generate...>****Declarations**，或者使用快捷键**Alt+Insert**（macOS为****Command+N****），在菜单中选择**Declarations**，按住快捷键Ctrl并选择需要声明的变量名、方法名、接口名、类名等，即可在模块的Index.ets文件中批量生成相应的声明信息。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155820.67153971327325989523251380782535:50001231000000:2800:FEF3966C673C52307E3848FF4FA2B03EAE9AA0384287980AD2D39AEAE20F2425.gif)

[代码阅读](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-editer-overview "代码阅读")

[代码检查](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-check "代码检查")
# 代码实时检查及快速修复

更新时间: 2025-12-16 15:58

## 实时检查

编辑器会实时的进行代码分析，如果输入的语法不符合编码规范，或者出现语义语法错误，将在代码中突出显示错误或警告，将鼠标放置在错误代码处，会提示详细的错误信息。

从DevEco Studio 4.0 Release版本开始，当compileSdkVersion≥10时，编辑器代码实时检查支持ArkTS性能语法规范检查。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.51644457988068556568716610339328:50001231000000:2800:5D120B30B1E10EAE158E3698D1CF814C0354B97B5F9DD178F50ED6ACD0A0CE24.png)

说明

当前compileSdkVersion≥10且arkTSVersion≥1.1(默认)时，ArkTS严格类型检查支持实时检查。

## 代码快速修复

DevEco Studio支持代码快速修复能力，辅助开发者快速修复ArkTS或C++代码问题。

**查看告警信息：**使用双击**Shift**快捷键打开文件查询框，输入**problems**打开问题工具面板；双击对应告警信息，可以查看告警的具体位置及原因。

**快速修复：**将光标放在错误告警的位置，可在弹出的悬浮窗中查看问题描述和对应修复方式；单击**M****ore actions**可查看更多修复方法。或是在页面出现灯泡图标时，可点击图标并根据相应建议，实现代码快速修复。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.02628668742678220436647154767731:50001231000000:2800:BEBE28DC70648A151ED1501354DC51FBF726A9B2E832C1AE4A8C618993A8D263.png)

## C++快速修复使用演示

下面通过示例展示C++代码中快速修复功能的使用方法。

### 填充switch语句

编辑器支持快速修复方式，对C++代码自动补齐switch条件表达式缺失的case条件，提升编码效率。

光标悬浮在switch表达式的条件变量处，点击灯泡图标，在下拉菜单中选择**Create missing switch cases**，完成缺失的case条件补充。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.70524785700756562786863956535535:50001231000000:2800:55F6EDF3F65CE5CE94BAEA0C4E1E917E77BE853F6ADA9FE20E76B39E8EE9DADD.gif)

### 使用auto替换类型

编辑器中可以用 auto 替换 iterator，new expression，cast expression的声明类型。光标悬浮在类型名称处，点击灯泡图标，在下拉菜单中选择**Replace the type with 'auto****'**完成替换。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.63977127721012003937395433181824:50001231000000:2800:24CFB8BF055CDCE5E21ED243671E5A1745E76127EA250558D4C965EC826F2911.gif)

### 用?:三元操作符替换if-else

编辑器中支持将if-else语句替换为?:三元操作符。光标放在if表达式的条件处，左侧出现黄色灯泡图标，点击灯泡图标，在下拉菜单中选择**Replace 'if else' with '?:'**完成替换。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.02531543582968147146358158176493:50001231000000:2800:62CF7A4012AF0BE047938B329EA204857D801B4F0ECAD8178D9062173E6BCB31.gif)

### 从使用处生成构造函数

如使用了未定义的构造函数，可通过quickfix方式快速生成相应的构造函数定义。点击构造函数名称，左侧出现红色灯泡后，点击灯泡图标选择**Create new constructor 'xxx'**生成构造函数。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.92155143344781087835313976631518:50001231000000:2800:1EF06ACA01DEE2DA473432D637487A85C2DA4E5103816A032302C8EFAF71A8A0.gif)

### 将变量拆分为声明和赋值

光标点击需要拆分的变量，左侧出现黄色灯泡后，点击灯泡图标选择**Split into declaration and assignment**，将变量的声明赋值语句拆分成声明语句和赋值语句。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.71386813896792568324685437189057:50001231000000:2800:FE5B5F8B4DBAA2E3B53ED87F2BFEEF3FE465C1968AA690F58DE509050839151E.gif)

[代码检查](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-check "代码检查")

[Code Linter代码检查](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter "Code Linter代码检查")
# Code Linter代码检查

更新时间: 2025-12-16 15:58

Code Linter支持对模块内文件或文件夹中的代码进行最佳实践/编程规范方面的检查。检查规则支持配置，配置方式请参考[配置代码检查规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter#section19310459444)。

开发者可根据扫描结果中告警提示手工修复代码缺陷，或者执行一键式自动修复，在代码开发阶段，确保代码质量。

## 配置代码检查规则

新建工程时，工程根目录下默认创建code-linter.json5配置文件，可对代码检查的范围及对应生效的检查规则进行配置。若使用历史工程进行开发，可在工程中右键选择**Code Linter > Generate Config File**创建code-linter.json5配置文件。

其中files和ignore配置项共同确定了代码检查范围，ruleSet和rules配置项共同确定了生效的规则范围。具体配置项功能如下：

**files**：配置待检查的文件名单，如未指定目录，将检查当前被选中的文件或文件夹中所有的.ets文件。

**ignore**：配置无需检查的文件目录，其指定的目录或文件需使用相对路径格式，相对于code-linter.json5所在工程根目录，例如：build/**/*。

**ruleSet**：配置检查使用的规则集，规则集支持一次导入多条规则。规则详情请参见[Code Linter代码检查规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codelinter-rule)。目前支持的规则集包括：

- 通用规则@typescript-eslint
- 安全规则@security
- 性能规则@performance
- 预览规则@previewer
- 一次开发多端部署规则@cross-device-app-dev
- ArkTS代码风格规则@hw-stylistic
- 正确性规则@correctness
- 兼容性规则@compatibility
    
    说明
    
    - 以上规则集均分为all和recommended两种规则集。all规则集是规则全集，包含所有规则；recommended规则集是推荐使用的规则集合。all规则集包含recommended规则集。
    - 不在工程根目录新建code-linter.json5文件的情况下，Code Linter默认会检查@performance/recommended和@typescript-eslint/recommended规则集包含的规则。
    

**rules**：可以基于ruleSet配置的规则集，新增额外规则项，或修改ruleSet中规则默认配置，例如：将规则集中某条规则告警级别由warn改为error。

**overrides**：针对工程根目录下部分特定目录或文件，可配置定制化检查的规则。

**extRuleSet**：配置需要检查的自定义规则，具体请参考：[自定义规则开发指南](https://gitcode.com/openharmony-sig/homecheck/blob/master/document/developer/ExtRule%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.md)。该字段从DevEco Studio 5.1.0 Release版本开始支持。

1. {
2.   "files":   //用于表示配置适用的文件范围的 glob 模式数组。在没有指定的情况下，应用默认配置
3.   [
4.     "**/*.js", //字符串类型
5.     "**/*.ts"
6.   ],
7.   "ignore":  //一个表示配置对象不应适用的文件的 glob 模式数组。如果没有指定，配置对象将适用于所有由 files 匹配的文件
8.   [
9.     "build/**/*",    //字符串类型
10.     "node_modules/**/*"
11.   ],
12.   "ruleSet":       //设置检查待应用的规则集
13.   [
14.     "plugin:@typescript-eslint/recommended"    //快捷批量引入的规则集, 枚举类型：plugin:@typescript-eslint/all, plugin:@typescript-eslint/recommended, plugin:@cross-device-app-dev/all, plugin:@cross-device-app-dev/recommended等
15.   ],
16.   "rules":         //可以对ruleSet配置的规则集中特定的某些规则进行修改、去使能, 或者新增规则集以外的规则；ruleSet和rules共同确定了代码检查所应用的规则
17.   {
18.     "@typescript-eslint/no-explicit-any":  // ruleId后面跟数组时, 第一个元素为告警级别, 后面的对象元素为规则特定开关配置
19.     [
20.       "error",              //告警级别: 枚举类型, 支持配置为suggestion, error, warn, off
21.       {
22.         "ignoreRestArgs": true   //规则特定的开关配置, 为可选项, 不同规则其下层的配置项不同
23.       }
24.     ],
25.     "@typescript-eslint/explicit-function-return-type": 2,   // ruleId后面跟单独一个数字时, 表示仅设置告警级别, 枚举值为: 3(suggestion), 2(error), 1(warn), 0(off)
26.     "@typescript-eslint/no-unsafe-return": "warn"            // ruleId后面跟单独一个字符串时, 表示仅设置告警级别, 枚举值为: suggestion, error, warn, off
27.   },
28.   "overrides":      //针对特定的目录或文件采用定制化的规则配置
29.   [
30.     {
31.       "files":   //指定需要定制化配置规则的文件或目录
32.       [
33.         "entry/**/*.ts"   //字符串类型
34.       ],
35.       "excluded":
36.       [
37.         "entry/**/*.test.js" //指定需要排除的目录或文件, 被排除的目录或文件不会按照定制化的规则配置被检查; 字符串类型
38.       ],
39.       "rules":   //支持对overrides外公共配置的规则进行修改、去使能, 或者新增公共配置以外的规则; 该配置将覆盖公共配置
40.       {
41.         "@typescript-eslint/explicit-function-return-type":  // ruleId: 枚举类型
42.         [
43.           "warn",     //告警级别: 枚举类型, 支持配置为error, warn, off; 覆盖公共配置, explicit-function-return-type告警级别为warn
44.           {
45.              "allowExpressions": true    //规则特定的开关配置, 为可选项, 不同规则其下层的配置项不同
46.           }
47.         ],
48.         "@typescript-eslint/no-unsafe-return": "off"   // 覆盖公共配置, 不检查no-unsafe-return规则
49.       },
50.       "extRules": {     //支持对overrides外自定义规则集配置的规则进行修改、去使能; 该配置将覆盖自定义规则配置
51.         "@extrulesproject/foreach-args-check": "off"   // 覆盖自定义规则配置, 不检查@extrulesproject/foreach-args-check规则
52.       }
53.     }
54.   ],
55.   "extRuleSet": [     //自定义规则集的配置
56.     {
57.         "ruleSetName": "extrulesproject",     //自定义规则库的名称。格式为@group/packagename或者packagename，全局唯一。除@和/外，group和packagename只能包含小写字母、数字、下划线（_）和中划线(-)。总长度小于等于128个字符。另外，group和packagename必须以字母开头，不能作为ArkTS的保留关键字
58.         "packagePath": "D:\\checker\\extrulesproject-1.0.0.tgz",     //自定义规则安装包路径，需使用绝对路径
59.         "extRules": {     //自定义规则名称以及告警等级，枚举值为: 3(suggestion), 2(error), 1(warn), 0(off)
60.           "@extrulesproject/foreach-args-check": 1
61.         }
62.     }
63.   ]
64. }

## 通过DevEco Studio进行代码检查

### 操作方法

在已打开的代码编辑器窗口单击右键点击**Code Linter**，或在工程管理窗口中鼠标选中单个或多个工程文件/目录，右键选择**Code Linter** **> Full Linter**执行代码全量检查。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155839.47490233893867987363368971531769:50001231000000:2800:DFE09494630ADCF4B6BC7AEBC1118BACF43C526833046F0698330DCBFC27D850.png)

如只需对Git工程中增量文件（包含新增/修改/重命名）进行检查，可在commit界面右下角点击齿轮图标，选择**Incremental Linter**执行增量检查。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155839.64268922873188670973109422009006:50001231000000:2800:6497AF66E4CCE25C8BFBAFDC3C0FA183C2DCE121013522762817EAE725699E1F.png "点击放大")

说明

- 若未配置代码检查规则文件，直接执行Code Linter，将按照默认的编程规范规则对.ets文件进行检查。
- Code Linter不对如下文件及目录进行检查：
    - src/ohosTest文件夹
    - /src/test文件夹
    - node_modules文件夹
    - oh_modules文件夹
    - build文件夹
    - .preview文件夹
    - hvigorfile.ts文件
    - hvigorfile.js文件
    - BuildProfile.ets文件

### 查看和处理代码检查结果

扫描完成后，在底部工具面板查看检查结果。勾选**Defects**中不同告警等级，可分别查看对应告警级别的信息。点击**Filter by scene**下拉菜单，可以筛选不同规则的检查结果。双击某条告警结果，可以跳转到对应代码缺陷位置；选中告警结果时，可以在右侧**Defect Description窗口**查看告警对应的规则详细说明，其中包含正向和反向示例，并根据其中的建议修改代码；搜索规则时，可设定是否全词匹配和大小写敏感。

单击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155839.93777549902695147390533091114765:50001231000000:2800:04EEACFDDB9950148FCA5686001E02845E579F136E105B56CFBD085534E1ABD9.jpg)图标，查看可修复的代码规则，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155839.82774331669380336897910129325028:50001231000000:2800:4E6AEA3E9513451DC3AAECA90366EFA8789A1D6EB5A343346F00594C3081567C.png)代码修复图标，可以一键式批量修复告警，并刷新检查结果。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155839.92699980928420615289927680058351:50001231000000:2800:3660164F7C1407FDBFD4447CCC3E5C3149D703A477DC0CB428544BA18F03C674.png)

**屏蔽告警信息**：

- 在某些特殊场景下，若扫描结果中出现误报，点击单条告警结果后的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155839.41916082364855691138081859881454:50001231000000:2800:AE19987348D57631B1EF20302FDA2B21F44351E3D0372B7653860ABB02A94FE8.jpg)**Ignore**图标**，**可以忽略对告警所在行的code linter检查；或勾选文件名称或多条待屏蔽的告警，点击左侧工具面板**Ignore**图标批量执行操作；
- 在文件顶部添加注释/* eslint-disable */可以屏蔽整个文件执行code linter检查，在eslint-disable 后加入一个或多个以逗号分隔的规则Id，可以屏蔽具体检查规则；
- 在需要忽略检查的代码块前后分别添加/* eslint-disable */和/* eslint-enable */添加注释信息，再执行**Code Linter，**将不再显示该代码块扫描结果；在待屏蔽的代码行前一行添加/* eslint-disable-next-line */，也可屏蔽对该代码行的Code Linter检查。

如需恢复忽略的报错信息，可以直接删除该行上方的注释，重新执行**Code Linter**检查。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155839.77135754907521365229523770254007:50001231000000:2800:9F492086FCE05076B9EDD9E5618CC465A8C34A0C7DEF3FB7463700CD2FC993BD.png)

**导出检查结果**：点击工具面板左侧![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.64679103406679925518123024218608:50001231000000:2800:E76D18DA6E85DA0FD0097BE67905B85D69C4215B3940C473D6DC12B816C926DE.jpg)导出按钮，即可导出检查结果到excel文件，包含告警所在行，告警明细，告警级别等信息。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.19099670782063087233834545846978:50001231000000:2800:C6896737D7F878798233C727C372278B35B18B1FFB60760FE9C5C7E7695AC3A6.png)

## 通过命令行进行代码检查

从DevEco Studio 6.0.1 Beta1开始，支持通过命令行方式进行代码检查。在DevEco Studio安装包\deveco-studio\plugins\codelinter\run目录下打开cmd或者bash窗口，执行如下命令：

1. node ./index.js [options] [dir] 

options：可选配置，具体请参考[表codelinter命令行配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-command-line-codelinter#table25697717185)。

dir：待检查的工程根目录，可选，默认为当前上下文目录。

说明

使用命令行检查时，需要依赖于Node.js环境，本地安装的Node.js版本和DevEco Studio中tools目录下的Node.js版本需要保持一致。

## 实践说明

以@typescript-eslint/no-restricted-syntax（使用某类语法时，codelinter告警）、@typescript-eslint/naming-convention（命名风格校验）和@hw-stylistic/file-naming-convention（检查代码文件的命名风格）三个规则为例，介绍codelinter配置文件的使用方法。

### 示例1：调用类Foo下bar方法时，Code Linter告警

**在配置文件中定义规则**

在ArkTS工程中，pages/Index.ets文件下增加以下用例：

1. class Foo {
2.   static bar() {}
3. }

4. Foo.bar();

在工程根目录下新建code-linter.json5文件（文件名不可修改），新增以下配置：

1. {
2.   "rules": {
3.     "@typescript-eslint/no-restricted-syntax": [
4.       // 告警级别: 枚举类型, 支持配置为error, warn, off
5.       "error",
6.       {
7.         // selector属性必选，配置要禁用的语法
8.         // 可通过特定DSL筛选待限制的语句，CallExpression表示方法调用表达式，后面的中括号里面是筛选条件（根据语法树Node节点来确定）
9.         // 其中callee.object.name根据指定的名称筛选调用方法的对象（class，namespace或module），以上示例中为"Foo"
10.         // callee.property.name则根据指定的名称筛选被调用的方法，以上示例中为"bar"
11.         "selector": "CallExpression[callee.object.name='Foo'][callee.property.name='bar']",
12.         // message属性可选，配置要展示的报错信息
13.         "message": "Foo.bar() is not allowed"
14.       }
15.     ]
16.   },
17. }

说明

如需在code-linter.json5文件中配置其他字段，请参见[配置代码检查规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter#section19310459444)。

**执行代码检查**

对pages/Index.ets文件执行代码检查，检查结果如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.84980670044908349910628089991199:50001231000000:2800:7C96BCDBA8CBA949ABFB866DC82BAE3ADC387AFB63CAC65D925536D8D552DB47.png)

### 示例2：对类名Foo的命名风格校验

**在配置文件中定义规则**

在ArkTS工程中，pages/Index.ets文件下增加以下用例：

1. class foo {    //此处构造一个命名风格错误的示例，foo为错误使用类名，正确类名应为Foo
2.   bar() {} 
3. }

在工程根目录下新建code-linter.json5文件，新增以下配置：

1. {
2.   "rules": {
3.     "@typescript-eslint/naming-convention": [
4.       "error",
5.       {
6.         // selector属性必选，配置要检查的语法，这里配置的class表示检查自定义组件名
7.         "selector": "class",
8.         // format属性必选，配置期望的命名风格，支持枚举值，这里配置的PascalCase表示大驼峰风格
9.         "format": ["PascalCase"],
10.         // custom属性可选，配置用户自定义的命名风格
11.         "custom": {
12.           // regex属性必选，配置具体的正则
13.           "regex": "^[a-zA-Z]+$",
14.           // match属性必选，配置为true表示正则未命中时报错；配置为false表示正则命中时报错
15.           "match": true
16.         }
17.       }
18.     ]
19.   },
20. }

**表1** 字段说明
|字段名称|参数说明|是否必选|类型|支持配置的参数|
|:--|:--|:--|:--|:--|
|selector|配置要检查的语法|是|字符串、字符串数组|- variable：变量<br>- function：函数<br>- parameter：参数<br>- parameterProperty：参数属性<br>- accessor：get/set方法<br>- enumMember：枚举成员<br>- classMethod：类方法<br>- structMethod：自定义组件中的方法<br>- objectLiteralMethod：对象方法<br>- typeMethod：接口方法<br>- classProperty：类属性<br>- structProperty：自定义组件中的属性<br>- objectLiteralProperty：对象属性<br>- typeProperty：接口属性<br>- class：类<br>- struct：自定义组件<br>- interface：接口<br>- typeAlias：类型别名<br>- enum：枚举<br>- typeParameter：泛型参数<br>- default：包含以上所有的类型<br>- variableLike：包含variable，function，parameter<br>- memberLike：包含classProperty，structProperty，objectLiteralProperty，typeProperty，parameterProperty ，enumMember，classMethod，objectLiteralMethod，typeMethod，accessor<br>- typeLike：包含class，struct，interface，typeAlias，enum，typeParameter<br>- method：包含classMethod，structMethod，objectLiteralMethod，typeMethod<br>- property：包含classProperty，objectLiteralProperty，typeProperty|
|format|配置期望的命名风格|是|字符串数组|- camelCase：小驼峰命名风格，比如getName，getID（支持连续大写字母），不支持下划线<br>- strictCamelCase：严格小驼峰命名风格，除了不支持连续大写字母（getID），其他的和camelCase相同<br>- PascalCase：大驼峰命名风格，比如Foo，CC，除了要求第一个字母大写，其他的和camelCase相同<br>- StrictPascalCase：大驼峰命名风格，除了不支持连续大写字母（CC），其他的和PascalCase相同<br>- snake_case：小写字母+下划线+小写字母的命名风格，比如a_a，不支持_a，a_a_<br>- UPPER_CASE：大写字母+下划线+大写字母的命名风格，比如A_A，不支持_A，A_A_|
|custom|配置用户自定义的命名风格|否|对象|- regex：属性必选，配置具体的正则<br>- match：属性必选，配置为true表示正则未命中时报错，配置为false表示正则命中时报错|
|leadingUnderscore/trailingUnderscore|配置是否允许以下划线开头/以下划线结尾的命名风格|否|字符串|- allow：允许以一个下划线开头/结尾的命名风格，比如_name<br>- allowDouble：允许以两个下划线开头/结尾的命名风格，比如__name<br>- allowSingleOrDouble：允许以一个或者两个下划线开头/结尾的命名风格（allow+allowDouble）<br>- forbid：禁止以下划线开头/结尾的命名风格，比如_name，__name<br>- require：必须是以下划线开头/结尾的命名风格，比如_name，__name<br>- requireDouble：必须是以两个下划线开头/结尾的命名风格，比如__name|
|prefix/suffix|配置固定前缀/后缀的命名风格。如果前缀/后缀未匹配则报错|否|字符串数组|用户自定义前缀/后缀|
|filter|过滤特定的命名风格，检查或者不检查正则命中的命名|否|对象|配置格式与custom相似<br><br>match：设置为true表示只检查正则命中的名字，设置为false表示不检查正则命中的名字<br><br>regex：设置过滤的正则<br><br>说明<br><br>支持直接配置一个字符串，这个字符串配置的是regex，此时match相当于配置的是true。|
|modifiers|匹配修饰符，只有包含特定修饰符的命名才会检查|否|字符串数组|- abstract：匹配abstract关键字<br>- override：匹配override关键字<br>- private：匹配private关键字<br>- protected：匹配protected关键字<br>- static：匹配static关键字<br>- async：匹配async关键字<br>- const：匹配const关键字<br>- destructured：匹配解构语法<br>- exported：匹配export关键字<br>- global：匹配全局声明<br>- #private：匹配私有符号#<br>- public：匹配public级别的访问修饰符<br>- requiresQuotes：匹配字符串类型的命名，并且 字符串中包含特殊字符<br>- unused：匹配未使用的声明|
|types|匹配类型，只有特定类型的名字才会检查|否|字符串数组|- array：数组类型<br>- boolean：布尔类型<br>- function：函数类型<br>- number：数字类型<br>- string：字符串类型|

说明

以上配置的参数有校验优先级：filter > types > modifiers > validate leading underscore > validate trailing underscore > validate prefix > validate suffix > validate custom > validate format。

**执行代码检查**

对pages/Index.ets文件执行代码检查，检查结果如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.80685508632458589785440438521836:50001231000000:2800:B79785E5529436F53EBF4F57E5759250D49F56B1D964A791D7B5C7E34A194F9D.png)

### 示例3：检查代码文件的命名风格

**在配置文件中定义规则**

在ArkTS工程中，pages目录下新建test.ets文件；

在工程根目录下新建code-linter.json5文件，新增以下配置：

1. {
2.   "rules": {
3.     "@hw-stylistic/file-naming-convention": [
4.       // 告警级别：枚举类型，支持配置为error，warn，off
5.       "error",
6.       {
7.         // selector属性可选，支持配置为code或者resources
8.         // code表示检查代码文件的命名风格
9.         // resources表示检查资源文件的命名风格
10.         "selector": "code"
11.       }
12.     ]
13.   },
14. }

说明

如果selector属性不配置，默认检查代码文件和资源文件的命名风格。

**执行代码检查**

对pages/test.ets文件执行代码检查，检查结果如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.74087431053028422253786277388507:50001231000000:2800:093A6727EA9D37EEB8EF3659396B5B16BE47FF16C0B504ED04BAA5083D7EC7EB.png)

[代码实时检查及快速修复](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-realtime-check "代码实时检查及快速修复")

[Code Linter代码检查规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codelinter-rule "Code Linter代码检查规则")
# recommended推荐规则清单

更新时间: 2025-12-16 15:58

## 通用规则推荐规则集@typescript-eslint/recommended

|   |   |
|---|---|
|@typescript-eslint/await-thenable|不允许对不是“Thenable”对象的值使用await关键字（“Thenable”表示某个对象拥有“then”方法，比如Promise）。|
|@typescript-eslint/consistent-type-imports|强制使用一致的类型导入风格。|
|@typescript-eslint/explicit-function-return-type|函数和类方法需要显式的定义返回类型。|
|@typescript-eslint/explicit-module-boundary-types|导出到外部的函数和公共类方法，需要显式的定义返回类型和参数类型。|
|@typescript-eslint/no-dynamic-delete|不允许在computed key表达式上使用“delete”运算符。|
|@typescript-eslint/no-explicit-any|不允许使用“any”类型。|
|@typescript-eslint/no-for-in-array|禁止使用 for-in 循环来遍历数组元素。|
|@typescript-eslint/no-this-alias|禁止将“this”赋值给一个变量。|
|@typescript-eslint/no-unnecessary-type-constraint|不允许在泛型中使用不必要的约束条件。|
|@typescript-eslint/no-unsafe-argument|不允许将any类型的值作为函数的参数传入。|
|@typescript-eslint/no-unsafe-assignment|禁止将“any”类型的值赋值给变量和属性。|
|@typescript-eslint/no-unsafe-call|禁止调用“any”类型的表达式。|
|@typescript-eslint/no-unsafe-member-access|禁止成员访问“any”类型的值。|
|@typescript-eslint/no-unsafe-return|函数禁止返回类型为“any”的值。|
|@typescript-eslint/prefer-literal-enum-member|要求所有枚举成员都定义为字面量值。|

## 安全规则推荐规则集@security/recommended

|   |   |
|---|---|
|@security/no-commented-code|不使用的代码段建议直接删除，不允许通过注释的方式保留。|
|@security/no-unsafe-aes|该规则禁止在AES加密算法中使用不安全的ECB加密模式。|
|@security/no-unsafe-dh|该规则禁止使用不安全的DH密钥协商算法。|
|@security/no-unsafe-dh-key|该规则禁止使用不安全的DH密钥。|
|@security/no-unsafe-dsa|该规则禁止使用不安全的DSA签名算法。|
|@security/no-unsafe-dsa-key|该规则禁止使用不安全的DSA密钥。|
|@security/no-unsafe-ecdsa|该规则禁止在ECDSA签名算法中使用不安全的SHA1摘要算法。|
|@security/no-unsafe-hash|该规则使用禁止不安全的哈希算法。|
|@security/no-unsafe-mac|该规则禁止在MAC消息认证算法中使用不安全的哈希算法。|
|@security/no-unsafe-rsa-encrypt|该规则禁止使用不安全的RSA非对称加密算法。|
|@security/no-unsafe-rsa-key|该规则禁止使用不安全的RSA密钥。|
|@security/no-unsafe-rsa-sign|该规则禁止不安全的RSA签名算法。|
|@security/no-unsafe-3des|该规则禁止使用不安全的3DES加密模式。|

## 性能规则推荐规则集@performance/recommended

|   |   |
|---|---|
|@performance/foreach-args-check|建议在ForEach参数中设置keyGenerator。|
|@performance/high-frequency-log-check|不建议在高频函数中使用Hilog。|
|@performance/hp-arkts-no-use-any-export-current|避免使用export * 导出当前module中定义的类型和数据。|
|@performance/hp-arkts-no-use-any-export-other|避免使用export * 导出其他module中定义的类型和数据。|
|@performance/hp-arkui-avoid-update-auto-state-var-in-aboutToReuse|避免在aboutToReuse中对自动更新值的状态变量进行更新。|
|@performance/hp-arkui-combine-same-arg-animateto|建议动画参数相同时使用同一个animateTo。|
|@performance/hp-arkui-load-on-demand|建议使用按需加载。|
|@performance/hp-arkui-no-func-as-arg-for-reusable-component|避免使用函数作为复用的自定义组件创建时的入参。|
|@performance/hp-arkui-no-state-var-access-in-loop|避免在for、while等循环逻辑中频繁读取状态变量。|
|@performance/hp-arkui-no-stringify-in-lazyforeach-key-generator|在使用LazyForEach进行组件复用的key生成器函数里，不要使用stringify。|
|@performance/hp-arkui-replace-nested-reusable-component-by-builder|建议使用@Builder替代嵌套的自定义组件。|
|@performance/hp-arkui-set-cache-count-for-lazyforeach-grid|建议在Grid下使用LazyForEach时设置合理的cacheCount。|
|@performance/hp-arkui-suggest-cache-avplayer|建议缓存AVPlayer实例减少起播时延。|
|@performance/hp-arkui-suggest-reuseid-for-if-else-reusable-component|建议使用reuseId标记不同结构的组件构成。|
|@performance/hp-arkui-suggest-use-effectkit-blur|建议使用effectKit.createEffect实现模糊效果。|
|@performance/hp-arkui-use-grid-layout-options|建议在指定位置时使用GridLayoutOptions提升Grid性能。|
|@performance/hp-arkui-use-local-var-to-replace-state-var|建议使用临时变量替换状态变量。|
|@performance/hp-arkui-use-object-link-to-replace-prop|建议使用@ObjectLink代替@Prop减少不必要的深拷贝。|
|@performance/hp-arkui-use-onAnimationStart-for-swiper-preload|建议Swiper预加载机制搭配 OnAnimationStart 接口回调使用。|
|@performance/hp-arkui-use-reusable-component|建议复杂组件的定义，尽量使用组件复用。|
|@performance/hp-arkui-use-scale-to-replace-attr-animateto|建议组件布局改动时使用图形变换属性动画。|
|@performance/hp-arkui-use-transition-to-replace-animateto|建议组件转场动画使用transition。|
|@performance/hp-ffrt-no-use-std|禁止在FFRT worker中使用std::xxx等同步接口。|
|@performance/no-high-loaded-frame-rate-range|不允许锁定最高帧率运行。|
|@performance/start-window-icon-check|启动页图标分辨率建议不超过256 * 256。|
|@performance/waterflow-data-preload-check|建议对waterflow子组件进行数据预加载。|
|@performance/web-on-active-check|使用了Web预渲染技术的应用，建议在预渲染完成后（onFirstMeaningfulPaint），调用停止渲染接口（onInactive）。|
|@performance/gif-hardware-decoding-check|在使用@ohos/gif-drawable库解码gif图片时，建议开启硬解码，提升gif加载性能。|
|@performance/no-use-any-import|使用import的方式引入对应的模块时，建议按需引用使用到的变量代替“import *”的方式，以减少 .ets文件的执行耗时和文件中所有export变量的初始化过程。|
|@performance/avoid-overusing-custom-component-check|当在应用中使用自定义组件时，可以优先使用@Builder函数代替自定义组件，@Builder函数不会在后端FrameNode节点树上创建一个新的树节点，有助于缩短页面的加载和渲染时长。|
|@performance/bad-deep-clone-check|避免使用不合理深拷贝，如JSON.parse(JSON.stringify(foo))和_.cloneDeep(foo)。|
|@performance/reuse-date-instances-check|用于检测在循环或调用频繁的方法中重复创建Date对象，建议开发者重用现有实例或使用时间戳进行计算，减少创建Date成本。|
|@performance/crypto-replacement-check|对于三方库@ohos/crypto-js所提供的大部分接口，SDK（@ohos.security.cryptoFramework）中有对应的系统原生实现。建议使用系统原生接口。|
|@performance/monitor-invisible-area-in-image-animation|使用ImageAnimation实现帧动画时，建议显式调用monitorInvisibleArea接口。在动画组件不可见时，会停止动画播放，减少无效的冗余动画带来的负载恶化。|
|@performance/datashare-query-unrelease-check|建议使用DataShareHelper的query接口查询数据得到结果后，应及时关闭，避免造成内存泄露。|
|@performance/update-state-var-between-animatetos-check|如果多个animateTo之间存在状态更新，会导致执行下一个animateTo之前又存在需要更新的脏节点，可能造成冗余更新。因此不建议在两次animateTo之间进行状态变量更新。|

## 预览规则集@previewer/recommended

|   |   |
|---|---|
|@previewer/mandatory-default-value-for-local-initialization|如果组件的属性支持本地初始化，需要设置一个合法的不依赖运行时的默认值。|
|@previewer/no-page-method-on-preview-component|禁止在非路由组件上实例化onPageShow、onPageHide、onBackPress等页面级方法。|
|@previewer/no-unallowed-decorator-on-root-component|对于@Entry组件，不允许使用@Consume、@Link、@ObjectLink、@Prop注解；对于@Preview组件，建议使用一个定义了完整的、合法的、不依赖运行时的默认值的父组件作为预览该组件的容器。|

## 一次开发多端部署规则推荐规则集@cross-device-app-dev/recommended

|   |   |
|---|---|
|@cross-device-app-dev/color-contrast|文本和背景之间的颜色对比度至少为4.5:1以确保可读性。|
|@cross-device-app-dev/color-value|颜色值应当使用“$r”从color.json中引用，以适配不同的系统颜色模式，禁止使用固定的值。|
|@cross-device-app-dev/font-size|字体大小要求至少为8fp以便于阅读。|
|@cross-device-app-dev/font-size-unit|字体大小单位建议使用fp，以适配系统字体设置。|
|@cross-device-app-dev/grid-columns-span|不推荐开发者将栅格中所有的GridCol子组件只设置span属性，且值与父组件的columns属性相等。|
|@cross-device-app-dev/grid-span-value|在栅格布局组件GridCol中，span和offset不建议使用小数。|
|@cross-device-app-dev/sidebar-navigation|对于2in1和tablet设备，应将Tabs组件设置为侧边导航栏。|
|@cross-device-app-dev/size-unit|组件通用属性width、height和size，应当使用vp作为单位，以适配不同设备屏幕宽度。|
|@cross-device-app-dev/touch-target-size|组件通用属性responseRegion点击热区需满足最小尺寸要求。|
|@cross-device-app-dev/one-multi-breakpoint-check|一多特性必须使用系统断点判断是否开启，不能通过设备类型、设备方向或是否可折叠等属性来判断。|

## ArkTS代码风格规则推荐规则集@hw-stylistic/recommended

|   |   |
|---|---|
|@hw-stylistic/array-bracket-spacing|强制数组“[”之后和“]”之前加空格。该规则仅检查.ets文件类型。|
|@hw-stylistic/brace-style|强制大括号和语句位于同一行。该规则仅检查.ets文件类型。|
|@hw-stylistic/comma-spacing|强制数组元素和函数中多个参数之间的逗号后面加空格，逗号前不加空格。该规则仅检查.ets文件类型。|
|@hw-stylistic/curly|条件语句和循环语句的逻辑代码必须写在大括号中。该规则仅检查.ets文件类型。|
|@hw-stylistic/file-naming-convention|强制代码文件和资源文件保持一致的命名风格。|
|@hw-stylistic/indent|强制switch语句中的case和default缩进一层。该规则仅检查.ets文件类型。|
|@hw-stylistic/keyword-spacing|在关键字前后强制加空格。该规则仅检查.ets文件类型。|
|@hw-stylistic/max-len|强制代码行最大长度为120个字符。该规则仅检查.ets文件类型。|
|@hw-stylistic/no-multi-spaces|不允许出现连续多个空格，除非是换行。该规则仅检查.ets文件类型。|
|@hw-stylistic/no-tabs|禁止使用tab作为缩进，推荐使用空格。该规则仅检查.ets文件类型。|
|@hw-stylistic/object-property-newline|强制对象属性换行。|
|@hw-stylistic/one-var-declaration-per-line|变量声明时，要求一次仅声明一个变量。该规则仅检查.ets文件类型。|
|@hw-stylistic/operator-linebreak|强制运算符位于代码行末。|
|@hw-stylistic/quotes|强制字符串使用单引号。|
|@hw-stylistic/semi-spacing|强制分号之前不加空格。|
|@hw-stylistic/space-before-blocks|强制在“{”之前加空格。|
|@hw-stylistic/space-before-function-paren|在函数名和“(”之间强制不加空格。该规则仅检查.ets文件类型。|
|@hw-stylistic/space-infix-ops|强制运算符前后都加空格。|

[规则变更说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codelinter-rules-change "规则变更说明")

[通用规则@typescript-eslint](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-typescript-eslint "通用规则@typescript-eslint")
# @typescript-eslint/adjacent-overload-signatures

更新时间: 2025-12-16 15:59

建议函数重载的签名保持连续。

## 规则配置

1. // code-linter.json5
2. {
3.   "rules": {
4.     "@typescript-eslint/adjacent-overload-signatures": "error",
5.   }
6. }

## 选项

该规则无需配置额外选项。

## 正例

1. export declare function bar(): void;
2. export declare function foo(a: string): void;
3. export declare function foo(a: number, b: number): void;
4. export declare function foo(a: number, b: string, c?: string): void;

## 反例

1. export declare function foo(a: string): void;
2. export declare function bar(): void;
3. export declare function foo(a: number, b: number): void;
4. export declare function foo(a: number, b: string, c?: string): void;

## 规则集

1. plugin:@typescript-eslint/all

Code Linter代码检查规则的配置指导请参考[Code Linter代码检查](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter)。

[通用规则@typescript-eslint](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-typescript-eslint "通用规则@typescript-eslint")

[@typescript-eslint/array-type](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide_array-type "@typescript-eslint/array-type")
# @typescript-eslint/array-type

更新时间: 2025-12-16 15:59

定义数组类型时，建议使用相同的样式。比如都使用T[]或者都使用Array<T>。

## 规则配置

1. // code-linter.json5
2. {
3.   "rules": {
4.     "@typescript-eslint/array-type": "error"
5.   }
6. }

## 选项

详情请参考[typescript/array-type 选项](https://typescript-eslint.nodejs.cn/rules/array-type#options)。

## 正例

1. const x: string[] = ['a', 'b'];
2. const y: readonly string[] = ['a', 'b'];

3. export { x, y };

## 反例

1. const x: Array<string> = ['a', 'b'];
2. const y: ReadonlyArray<string> = ['a', 'b'];

3. export { x, y };

## 规则集

1. plugin:@typescript-eslint/all

Code Linter代码检查规则的配置指导请参考[Code Linter代码检查](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter)。

[@typescript-eslint/adjacent-overload-signatures](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide_adjacent-overload-signatures "@typescript-eslint/adjacent-overload-signatures")

[@typescript-eslint/await-thenable](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide_await-thenable "@typescript-eslint/await-thenable")
# @performance/avoid-overusing-custom-component-check

更新时间: 2025-12-16 15:59

当在应用中使用自定义组件时，可以优先使用@Builder函数代替自定义组件，@Builder函数不会在后端FrameNode节点树上创建一个新的树节点，有助于缩短页面的加载和渲染时长。

## 规则配置

1. // code-linter.json5
2. {
3.   "rules": {
4.     "@performance/avoid-overusing-custom-component-check": "warn",
5.   }
6. }

## 选项

该规则无需配置额外选项。

## 正例

1. // 1. 自定义@Builder函数组件
2. @Builder
3. function UserCardBuilder(name: string, age?: number, avatarImage?: ResourceStr) {
4.   Row() {
5.     Row() {
6.       Image(avatarImage)
7.         .size({ width: 50, height: 50 })
8.         .borderRadius(25)
9.         .margin(8)
10.       Text(name)
11.         .fontSize(30)
12.     }

13.     Text(`年龄：${age?.toString()}`)
14.       .fontSize(20)
15.   }
16.   .backgroundColor(DEFAULT_BACKGROUND_COLOR)
17.   .justifyContent(FlexAlign.SpaceBetween)
18.   .borderRadius(8)
19.   .padding(8)
20.   .height(66)
21.   .width('80%')
22. }

23. @Component
24. export struct UserCardList {
25.   @State users: User[] = getUsers();

26.   aboutToAppear(): void {
27.     let message = 'hello world';
28.   }

29.   build() {
30.     List({ space: 8 }) {
31.       ForEach(this.users, (item: User) => {
32.         ListItem() {
33.           // 2. 使用@Builder函数
34.           UserCardBuilder(item.name, item.age, item.avatarImage)
35.         }
36.       }, (item: User) => item.id)
37.     }
38.     .alignListItem(ListItemAlign.Center)
39.   }
40. }

## 反例

1. import { util } from '@kit.ArkTS';

2. interface User {
3.   id: string;
4.   name: string;
5.   age?: number;
6.   avatarImage?: ResourceStr;
7.   // introduction: string;
8.   // ...
9. }

10. // 构造数据
11. const DEFAULT_BACKGROUND_COLOR = Color.Pink;
12. const getUsers = () => {
13.   const USERS: User[] = [{
14.     id: '1',
15.     name: '张三',
16.   }, {
17.     id: '2',
18.     name: '李四',
19.   }, {
20.     id: '3',
21.     name: '王五',
22.   }];
23.   return Array.from(Array(30), (item: User, i: number) => {
24.     return {
25.       id: util.generateRandomUUID(),
26.       name: USERS[i%3].name,
27.       avatarImage: $r('app.media.avatar'),
28.       age: 18 + i
29.     } as User;
30.   });
31. }

32. // 用户卡片列表组件
33. @Component
34. export struct UserCardList {
35.   @State users: User[] = getUsers();

36.   build() {
37.     List({ space: 8 }) {
38.       ForEach(this.users, (item: User) => {
39.         ListItem() {
40.           UserCard({ name: item.name, age: item.age, avatarImage: item.avatarImage })
41.         }
42.       }, (item: User) => item.id)
43.     }
44.     .alignListItem(ListItemAlign.Center)
45.   }
46. }

47. // 用户卡片自定义组件
48. @Component
49. struct UserCard {
50.   @Prop avatarImage: ResourceStr;
51.   @Prop name: string;
52.   @Prop age: number;

53.   build() {
54.     Row() {
55.       Row() {
56.         Image(this.avatarImage)
57.           .size({ width: 50, height: 50 })
58.           .borderRadius(25)
59.           .margin(8)
60.         Text(this.name)
61.           .fontSize(30)
62.       }

63.       Text(`年龄：${this.age.toString()}`)
64.         .fontSize(20)
65.     }
66.     .backgroundColor(DEFAULT_BACKGROUND_COLOR)
67.     .justifyContent(FlexAlign.SpaceBetween)
68.     .borderRadius(8)
69.     .padding(8)
70.     .height(66)
71.     .width('80%')
72.   }
73. }

## 规则集

1. plugin:@performance/recommended
2. plugin:@performance/all

Code Linter代码检查规则的配置指导请参考[Code Linter代码检查](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter)。

[性能规则@performance](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-performance "性能规则@performance")

[@performance/bad-deep-clone-check](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-bad-deep-clone-check "@performance/bad-deep-clone-check")
# 代码重构

更新时间: 2025-12-16 15:58

## ArkTS/TS代码重构

### Refactor-Extract代码提取

在编辑器中支持将函数内、类方法内等区域代码块或表达式，提取为新方法/函数（Method）、常量（Constant）、接口（Interface）、变量（Variable）或类型别名（Type Alias）。准确便捷的将所选区域代码从当前作用域内进行提取，提升编码效率。选中所需要提取的代码块，右键单击**Refactor**，选择需要提取的类型。

说明

Refactor-Extract代码提取为类型别名（Type Alias）能力仅TS语言支持。

方法/函数（Method）支持选中代码块或完整语句进行提取：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155826.49022535093655416612873057744047:50001231000000:2800:BB86021E9B699BF40870741353AC44371767580FF1D68715A91F6821D0000F44.gif "点击放大")

在ArkTS语言中，支持将组件调用代码块提取为@Builder装饰器装饰的方法，组件属性调用表达式可提取为@Styles或@Extend装饰器装饰的方法。

**使用方式**：选中需要提取的组件或属性，右键单击**Refactor**，选择**Extract Method...**，组件私有属性可提取为@Extend装饰的方法，通用属性可提取为@Styles或@Extend装饰的方法。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155826.73452895376985694816662106846887:50001231000000:2800:3F4F0E470FAF62895F5B33DDF4EEF0586CD48E9BEA30AE1E0E32730F0B2E7B5D.gif "点击放大")

常量（Constant）支持选中单行表达式进行提取：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155826.60116824233546059101907897644125:50001231000000:2800:FD9070C4BEDC10FD60CB08FD1B8EBE4C992A093871ED9CC9AD7BB7E48188C4F7.gif "点击放大")

接口（Interface）支持选中对象自变量进行提取：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.16285274227542455425799190239872:50001231000000:2800:B278A4DE7A2B444672EBC7B30F3F9F0039F1BFCDABCC48741E698A65B7C7C29B.gif "点击放大")

支持选中表达式提取为变量（Variable）：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.68349739984860553407929253737559:50001231000000:2800:49109AB7CA3FCF5E4DAF2C4AEDAD6CB789C41B15EA490FBEDBF4DE7B89C9D174.gif "点击放大")

### Refactor-Convert代码转换

编辑器内提供Convert重构能力，支持Convert between named imports and namespace imports等高频转换操作，辅助开发者高效重构代码，提升代码质量。

**表1** Refactor-Convert功能支持清单
|功能|说明|使用方法|支持转换的源码类型|
|:--|:--|:--|:--|
|Convert to class|将JS源码中的function转换为符合ES6标准的类|点击或选中function名，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。<br><br>说明<br><br>若当前工程中已引用该方法，执行Convert to class后，在Find Usages中可查看引用的具体位置，点击**Do Refactor**可忽略冲突并执行转换；也可以逐条修改引用位置的代码后，重新执行上述操作。|JS|
|Convert to anonymous function|将箭头函数转换为匿名函数|选中箭头函数赋值变量，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|JS/TS|
|Convert to named function|将箭头函数转换为普通函数|选中箭头函数赋值变量，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|JS/TS/ArkTS|
|Convert to arrow function|将匿名函数转换为箭头函数|选中匿名函数赋值变量，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|JS/TS/ArkTS|
|Convert default export to named export|支持named export和default export相互转换|完整选中export default语句，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|JS/TS/ArkTS|
|Convert named export to default export|完整选中export语句，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|
|Convert named imports to namespace import|支持在命名import和命名空间import形态间转换|完整选中import语句，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|JS/TS/ArkTS|
|Convert namespace import to named imports|完整选中命名空间import语句，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|
|Convert to template string|将字符串转换为模板字面量|选中字符串或完整表达式，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|JS/TS/ArkTS|
|Convert to optional chain expression|将判空逻辑转换为可选链式调用|选中连续判空表达式，右键单击**Refactor** > **Convert**，或使用快捷键**Ctrl+Alt+Shift+R**（macOS为**Option+Shift+Command+R**），在弹窗中选择转换的方式。|JS/TS/ArkTS|

### Refactor-Rename代码重命名

代码编辑支持Rename功能，可以快速更改变量、方法、对象属性等相关标识符及文件、模块的名称，并同步到整个工程中对其进行引用的位置。

**使用方式**：选中需要重新命名的标识符（变量、类、接口、自定义组件等），右键单击**Refactor**，选择**Rename...**（或使用**快捷键Shift+F6**），在弹框中输入新的标识符名称，并在**Scope**中选择替换的范围，点击**Refactor**完成重新命名。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.14273555172832627488801407784255:50001231000000:2800:DE9F56A594C0C9BED6B95EBEE69348C517B19AFABAD3EEAB992F1B5610488386.png "点击放大")

代码编辑支持筛选并过滤不需要rename的引用位置。在**Rename...**弹窗中点击**Preview**，在弹出预览窗口中，用户选中无需Rename的选项，单击右键菜单**Exclude****/Remove**进行过滤/删除，完成筛选后点击左下角**Do Refactor**，重新执行Rename操作。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.46555380986117187177514818473986:50001231000000:2800:BAAE590B910492E7C47F1B9C2E18B00F0DA965EB22F8FA375761C74439869C7C.png)

说明

若ArkTS文件中存在C++接口调用，使用Rename进行重命名时，C++文件中涉及的函数名也会被重命名。

### Move File

在文件中单击右键，选择**Refactor > Move File...**，在弹窗中输入或点击**...**选择指定的目录，点击**Refactor**，可将当前文件移动至该目录下。勾选**Search for references**，可查找并更新工程中对该文件的引用；勾选**Open in editor**，可在编辑器中查看移动的文件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.02331824426647524008535864577034:50001231000000:2800:837B076B93BC2BE1BBF3F38766A526ECD2183E55609B8A99A0E976333F18072D.png)

### Safe Delete

编辑器支持Safe Delete功能，帮助您安全地删除代码中的标识符对象（变量、函数或类等）或删除指定文件。在删除前，编辑器将先在代码中搜索对该对象的引用，如果存在引用，编辑器将提示您进行必要的检查和调整。

**使用方式**：在编辑器内选中需要删除的标识符对象或在工程目录选择待删除的文件，右键单击**Refactor**，选择**Safe Delete**，单击**OK**将自动检查当前对象在代码中被引用的情况，点击**View Usages**可查看具体使用的代码内容，点击**Delete Anyway**将直接删除该对象的定义。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.77508326582698788012554990324108:50001231000000:2800:5E3BC1476701436005BCEFBCE4E354FE07886F9B4F1F9E5687AF1B39B9A1E6BA.png)

## C++代码重构

编辑器提供C++代码重构能力，当前支持展开宏、交换if分支、移动函数体到声明处等使用场景下的重构能力，提升开发效率。

### 展开宏

支持在当前宏引用处展开宏。将光标移动至需要展开的宏，右键单击**Refactor**，选择**Inline**，展开此处引用的宏。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.13928331545671811889587250413089:50001231000000:2800:56B6EE8C1387EAAB2EF6A11690600C8EB600ED8676B9B94033142DF43C2CE529.gif)

### 交换if分支

编辑器支持在选中if-else完整代码块的情况下，实现对if-else代码块的位置交换，并对条件取反。

**使用约束**

- 需要重构的代码块必须为完整的if-else代码结构，{}不能省略；
- if-else中的statement包含嵌套if-else语句时，只反转最外层的if-else语句。对于if() -else if()-else() 结构，仅支持对最后一层if-else结构进行交换；
- 不支持赋值语句的判断条件取反。

**使用方式**

编辑器内选择需要转换的代码区域，右键单击**Refactor**，选择**Swap If Branches**，对原有if条件取反，并交换if-else原代码块顺序。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.28255951378684252142163205613681:50001231000000:2800:1541B74CB1AF89C844B929C6C76EB47383FFC5FF2D46CC3A6B23E820DABADA0C.gif "点击放大")

### 移动函数体到声明处

编辑器支持将函数体从源文件移动到头文件中，提高代码可读性。编辑器内选中函数名，右键单击**Refactor**，选择**Move to Declaration**，源文件中的函数实现将移动至头文件中。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.65641361127853246153815383140606:50001231000000:2800:5B3547B56C3D94E99035B16B56BBB1AFE2D7FDCC7B9ACC417FF9778A2EECC413.gif)

### 移动函数体到实现处

在编辑器内将光标放在或选中函数名，右键单击**Refactor**，选择**Move to Implementation**，选择移动到的文件，将函数定义移动到该文件。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.88541307712326242695005643690369:50001231000000:2800:84944F1AB7703AB0275C173A6DD3FF580648D7C7FD70885C00F0F967CC27CE94.gif)

### 将语句转为原始字符串

编辑器提供重构能力，支持将带有 \n, \t, \", \\, \'五类转义字符的字符串转换为原始字符串。当前仅支持标准字符串，不支持 u8""等其他字符串。

在编辑器内选择字符串代码区域，右键单击**Refactor**，选择**Convert To Raw String**，将语句转换为原始字符串。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.24250375005446060852397256899911:50001231000000:2800:FFC0F490D957F719B14F5DDAB4D5737D57B156CF932E1EF661FD0473D6E9F7F4.gif "点击放大")

### 定义构造函数

编辑器提供重构能力，支持为类的成员变量生成默认的构造函数。

**规格限制**

1. 不支持未初始化成员变量的类
2. 不支持在(class标识符，类名，大括号)以外的位置触发
3. 不支持类已存在有入参的构造函数

**使用方法：**在类的定义的类名处，右键单击**Generate****...**，选择**Constructor**，在弹框中点击**Define**，为成员变量定义一个构造函数。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.30651038603470256838317742690156:50001231000000:2800:5355B0EE828E1D1587E11D63D91EBD504371CE44B152626860F5FB0752A80500.gif)

### 提取表达式到变量

在编辑器内，选中需要提取的表达式范围，右键单击**Refactor**，选择**Extract Variable**，支持提取表达式到变量。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.37890255211998637795786338220407:50001231000000:2800:0FC2715D51B14DBCD8E75459B81D23E895D8E2CB3376AA7A7B25E3EAF2700097.gif "点击放大")

### 移除namespace

光标停留在需要移除的namespace处，右键单击**Refactor**，选择**Remove Using Namespace**进行移除，可以避免命名冲突，提高代码可读性。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.32081974922383203616066452341737:50001231000000:2800:C1BF9DE43DFDFAA601BE2DC7E239DE9BE27FDDC70D7D59019B3D7F120CB65982.gif)

### 添加using声明

编辑器内，光标停留在需要添加using声明处，右键单击**Refactor**，选择**Add Using**完成使用using定义类型别名。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.85794539507220706442713279369505:50001231000000:2800:9EB0D8DB3D5ADCA087CF07C58E97D7B74C9599157A431A9A276C6E3CEE6BEE71.gif)

### auto自动展开

在auto关键字处右键单击**Refactor**，选择**Expand Auto Type**，可以使用推断类型替换auto类型。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.84905912206252110704814497031184:50001231000000:2800:2E756D1490351FCE288D2BD1D29706F64F3095E3928D36462D0A9ABB9C2C8A7A.gif)

### 声明隐式成员

编辑器支持在类中声明隐式复制/移动成员。光标停留在需要生成的类处，右键单击**Generate**..., 选择**Copy/Move Members**。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155827.98366212492452129567436272916642:50001231000000:2800:40DD5A5A1E8A18F2FCA65B2154F53328F66032DD7A712C81A345A336D544A0AF.gif)

[@compatibility/api-compatibility-check](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-api-compatibility-check "@compatibility/api-compatibility-check")

[生成ArkTSDoc文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arktsdoc "生成ArkTSDoc文档")
# 文档生成

更新时间: 2025-12-16 15:58

DevEco Studio支持通过Generate ArkTSDoc功能，将代码文件中变量、方法、接口、类等需要对外暴露的信息快速生成相应的参考文档。

说明

- 当前支持对工程或目录下.ets/.ts/.js/.md格式文件生成ArkTSDoc文档。
- 文件中export的变量、方法、接口、类等将生成相应的ArkTSDoc文档，未export的对象不支持生成。
- 若选择对工程/目录整体导出ArkTSDoc文档，生成后的ArkTSDoc文档目录和原目录结构一致。

## ArkTSDoc生成步骤

1. 在菜单栏选择**Tools >** **Generate ArkTSDoc...**进入ArkTSDoc生成界面。
2. 设置生成ArkTSDoc的范围，可选择整个工程、某个模块或目录、单个文件进行导出。在Output directory中指定导出ArkTSDoc的存储路径。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.99954337472192475316632370457663:50001231000000:2800:57E13244D8F6F848EEC472668097B4C1C3BE60B949E6C3BD141A894FC72BBF34.png)
    
3. 若勾选**Open generated documentation in browser**选项，在生成ArkTSDoc后，将自动打开相应页面查看生成的文档。配置完毕后点击Generate，开始扫描并生成ArkTSDoc文档。
    
    生成的ArkTSDoc左侧文档目录和原工程目录结构一致，右侧可点击跳转到当前文件包含的某个变量、方法、接口或类的文档位置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.87426465960446058547178862104505:50001231000000:2800:229045D0645BEEC43378D15012A3D6DBA3FF12618DAB7921E0D4FA46A6518940.png "点击放大")
    
    若没有勾选**Open generated documentation in browser**选项，在生成ArkTSDoc后，DevEco Studio右下角弹出对应提示框，可以点击Go to Folder跳转到生成的ArkTSDoc文件夹，用浏览器打开文件夹中index.html文件即可查看ArkTSDoc文档。
    

## 生成效果示例

**注释格式要求：**当前仅支持“/** */”文档注释格式；支持param等[标准标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arktsdocs-standard-label)和myTag等自定义标签生成相应文档。

1. /**
2.  * Prints "log" logs.
3.  *
4.  * @param { string } message - Text to print.
5.  * @myTag
6.  * @since 11
7.  */

**代码示例：**

1. /**
2.  * Defines the demo class
3.  *
4.  * @since 11
5.  */
6. export class Demo {
7.     /**
8.      * Prints "log" logs.
9.      *
10.      * @param { string } message - Text to print.
11.      * @myTag
12.      * @since 11
13.      */
14.     static log(message: string): void {

15.     }
16. }

**ArkTSDoc文档生成结果：**

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.76205190042778908656080672074238:50001231000000:2800:EB070C992DEC405453B0B73800AA7B153739A6C14685A0B15BEE1112221025BA.png "点击放大")

[生成ArkTSDoc文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arktsdoc "生成ArkTSDoc文档")

[标准标签](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arktsdocs-standard-label "标准标签")
# 快速插入场景化代码片段

更新时间: 2025-12-16 15:58

DevEco Studio提供Kit Assistant能力，支持通过拖拽方式将基础的场景化的控件/代码片段插入ArkTS工程中，减少高频场景代码的编写时间。

1. 在菜单栏点击**View > Tool Windows > Kit Assistant**，或使用快捷键**Alt + K**（macOS为**O****ption + K**），进入Kit Assistant页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155832.12230800685510099307764188651059:50001231000000:2800:87A1BE141AFEE411FA275156DF8BFEF47B8265B159EA0DF725C578C382D9868D.png)
    
2. 在左侧目录中支持搜索、查看不同Kit提供的场景化控件或代码片段。Kit Assistant面板右侧展示该控件的使用约束、适用场景等详细信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155832.93575197090796849944374495624278:50001231000000:2800:490CC6725ED466B7093F4CAF949F26BE25588A3A9AFECA6F1BC5C11473846090.png)
    
3. 在目录中点击选中需要的控件或功能代码，并拖拽至.ets文件中适当位置，即可在当前位置插入相应的代码片段。
    
    说明
    
    若当前编辑器打开的文件或所在的模块，存在某些Kit能力不支持的设备类型/API版本/工程模型，或某些Kit能力或控件不支持在元服务工程中使用，则Kit Assistant目录中该Kit能力或控件将置灰并无法成功拖拽。
    

[{@link}](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arktsdoc-link "{@link}")

[跨语言代码编辑](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-cross-language-code-editing "跨语言代码编辑")
# 跨语言代码编辑

更新时间: 2025-12-16 15:58

## 生成胶水代码函数框架

DevEco Studio提供跨语言代码编辑功能。当开发者需要使用NAPI封装暴露给ArkTS/JS的接口时，在Cpp头文件内，通过右键Generate > NAPI，快速生成当前函数或类的胶水代码函数框架。

1. 检查当前Cpp工程entry > src > main > cpp路径下，是否已包含napi_init.cpp文件。如不存在该文件，请在头文件（头文件支持类型：.hpp，.hxx，.hh，.h）中，将光标放置在任意函数名/类名处（当前支持bool，int，string，void，float，double，std::array，std::vector等参数类型），单击右键选择Generate > NAPI，生成胶水代码框架文件napi_init.cpp。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.43362592170512304396284955907345:50001231000000:2800:D5F4CCB2264C92C3CE31A0005A5C4C4C43ED642273B12F8159C6AFD9EC7BF3F6.png "点击放大")
    
2. 若工程中已存在或创建完成napi_init.cpp文件，请在头文件中需要被调用的函数/类名处，单击右键选择Generate > NAPI，将在napi_init.cpp文件napi_property_descriptor字段中分别注册对应的函数/类的信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.36819935608805017435718568257266:50001231000000:2800:3D82FE05551CCC785C5F067116043368CF1E50F88F238103FFDC6445A4BD2261.png)
    
3. 在napi_init.cpp文件中TODO位置，补充相应的功能实现代码。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.96339174745906713645396482675607:50001231000000:2800:F92A7B3E64EE1EDE72473D0AF253353FC3ECDF45E34119D90A8AAE5F34DF30FA.png)
    

## 跨语言快速生成函数定义

当前支持在跨语言的d.ts文件中，通过Generate native implementation功能，一键生成C++文件中对应函数定义。

将光标悬浮在未定义的函数名处，在悬浮窗中点击**Generate native implementation**，或点击页面上出现的红色灯泡图标，选择**Generate native implementation**，生成函数定义。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.76230325134255389739941420933678:50001231000000:2800:9EC87736D3DD114B15847EC22F815F5725C42C0CCD796992E620F188A4A22E08.gif)

[快速插入场景化代码片段](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-kit-assistant "快速插入场景化代码片段")

[界面预览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-01 "界面预览")
# 查看ArkTS/JS预览效果

更新时间: 2025-12-16 15:58

预览器支持ArkTS/JS应用/元服务“实时预览”和“动态预览”。

说明

- 预览支持Phone、Tablet、2in1、Car、Wearable、TV设备的ArkTS工程，支持LiteWearable和Wearable设备的JS工程。
- 预览器功能依赖于电脑显卡的OpenGL版本，OpenGL版本要求为3.2及以上。
- 预览时将不会运行Ability生命周期。
- 从DevEco Studio 6.0.0 Beta3版本开始，HAP/HSP引用HSP时支持预览，HAR模块引用HSP不支持预览，请直接在HSP内预览或为该HSP[设置Mock实现](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-mock)。
- 预览场景下，不支持通过相对路径及绝对路径的方式访问resources目录下的文件。
- 预览不支持组件拖拽。
- 部分API不支持预览，如Ability、App、MultiMedia等模块。
- Richtext、Web、Video、XComponent组件不支持预览。
- 不支持调用C++库的预览。
- har在被应用/元服务使用时真机效果有区别，真机上实际效果应用不显示menubar，元服务显示menubar，但预览器都以不显示menubar为准。若开发har模块时，请注意被元服务使用时预览器效果与真机效果的不同。

- **实时预览**：在开发界面UI代码过程中，如果添加或删除了UI组件，您只需**Ctrl+S**进行保存，然后预览器就会立即刷新预览结果。如果修改了组件的属性，则预览器会实时（亚秒级）刷新预览结果，达到极速预览的效果（当前版本极速预览仅支持ArkTS组件。支持部分数据绑定场景，如@State装饰的变量）。实时预览默认开启，如果不需要实时预览，请单击预览器右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.57952324375102495685401349773931:50001231000000:2800:3281D6F2FC0F38CF85E86BE4FBD11F861E92E4AF9E075A13B5C4779D1E913047.png)按钮，关闭实时预览功能。
    
    说明
    
    开发者修改resources/base/profile目录下的配置文件（如main_pages.json/form_config.json），不支持触发实时预览，开发者需要点击重新加载![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.89029645711339110154970820557918:50001231000000:2800:A44428850141A9F71564E3451A230F6591310333B32D380DA32EEC41B3CF7AD0.png)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.09577558805742612600307217215358:50001231000000:2800:4DB06DA16982FFD468E7C4F27F95571801554BDD6DA846B0507CB3E06D82B621.gif)
    
- **动态预览**：在预览器界面，可以在预览器中操作应用/元服务的界面交互动作，如单击、跳转、滑动等，与应用/元服务运行在真机设备上的界面交互体验一致。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.34754623138989995591975404797916:50001231000000:2800:2CB592BF2A72B5783CCBF0742F3EED6C0A3903CC77909212A6498EC51AC43FC0.gif)
    

以ArkTS为例，使用预览器的方法如下：

1. 创建或打开一个ArkTS应用/元服务工程。本示例以打开一个本地ArkTS Demo工程为例。
2. 在工程目录下，打开任意一个.ets文件（JS工程请打开.hml/.css/.js页面）。
3. 可以通过如下任意一种方式打开预览器，启动预览。
    
    - 通过菜单栏，单击**View > Tool Windows > Previewer**打开预览器。
    - 在编辑窗口右上角的侧边工具栏，单击**Previewer**，打开预览器。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.14138994215834983207655200521878:50001231000000:2800:4A5291C4000A8571586DD24172D13306CCF443CE0562069EF878A87641EF75F5.png)
    
4. 点击按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155825.98342904309917652415098803569710:50001231000000:2800:6ADBFA87E7CE90EDD2C49233223FE8E748CA656010B20CE200AC111C8C263678.png)，停止预览。

[PreviewChecker检测规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-previewchecker "PreviewChecker检测规则")

[查看ArkUI预览效果](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-arkui "查看ArkUI预览效果")
# 查看ArkUI预览效果

更新时间: 2025-12-16 15:58

ArkUI预览支持页面预览、组件预览和卡片预览，下图中左侧图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.74226791156821072030714282449822:50001231000000:2800:17AB498808D90BB1DEC7D51061F1C109D653B17C19A15568669B10E16F94BD7B.png)为页面预览，右侧图标![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.21942530265117851118839826760568:50001231000000:2800:D807B490D88D890C38CC61BB3819CC71CC8D7C56EC7AC8C8F54509C074FD9ECE.png)为组件预览，卡片预览在创建卡片文件后可直接预览。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.63931149790118592246216115187482:50001231000000:2800:34963B93E125A3CF03D8FE9C4293ABEB35D8066A7805E64675A0A9D1AED540F7.png)

## 页面预览

ArkTS应用/元服务支持页面预览。页面预览通过在工程的ets文件头部添加@Entry实现。

@Entry的使用参考如下示例：

1. @Entry
2. @Component
3. struct Index {
4.   @State message: string = 'Hello World'

5.   build() {
6.     Row() {
7.       Column() {
8.         Text(this.message)
9.           .fontSize(50)
10.           .fontWeight(FontWeight.Bold)
11.       }
12.       .width('100%')
13.     }
14.     .height('100%')
15.   }
16. }

## 组件预览

ArkTS应用/元服务支持组件预览。组件预览支持实时预览，不支持动态图和动态预览。组件预览通过在组件前添加注解@Preview实现，在单个源文件中，最多可以使用10个@Preview装饰自定义组件。

@Preview的使用参考如下示例：

1. @Preview({
2.   title: 'ContentTable'
3. })
4. @Component
5. struct ContentTablePreview {
6.   build() {
7.     Flex() {
8.       ContentTable({ foodItem: getDefaultFoodData() })
9.     }
10.   }
11. }

以上示例的组件预览效果如下图所示：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.34917648690192618803043253665045:50001231000000:2800:02C7197248BE9B345F3B901193EFD00EB1B61C129DB3CF7B695E745BF8E83FC1.gif)

组件预览默认的预览设备为Phone，若您想查看不同的设备，或者不同的屏幕形状，或者不同设备语言等情况下的组件预览效果，可以通过设置@Preview的参数，指定预览设备的相关属性。若不设置@Preview的参数，默认的设备属性如下所示：

1. @Preview({
2.   title: 'Component1',  //预览组件的名称
3.   deviceType: 'phone',  //指定当前组件预览渲染的设备类型，默认为Phone
4.   width: 1080,  //预览设备的宽度，单位：px
5.   height: 2340,  //预览设备的长度，单位：px
6.   colorMode: 'light',  //显示的亮暗模式，当前支持取值为light
7.   dpi: 480,  //预览设备的屏幕DPI值
8.   locale: 'zh_CN',  //预览设备的语言，如zh_CN、en_US等
9.   orientation: 'portrait',  //预览设备的横竖屏状态，取值为portrait或landscape
10.   roundScreen: false  //设备的屏幕形状是否为圆形
11. })

请注意，如果被预览的组件是依赖参数注入的组件，建议的预览方式是：定义一个组件片段，在该片段中声明将要预览的组件，以及该组件依赖的入参，并在组件片段上标注@Preview注解，以表明将预览该片段中的内容。例如，要预览如下组件：

1. @Component
2. struct Title {
3.   @Prop context: string; 
4.   build() {
5.     Text(this.context)
6.   }
7. }

建议按如下方式预览：

1. @Preview
2. @Component    //定义组件片段TitlePreview
3. struct TitlePreview {
4.   build() {
5.     Title({ context: 'MyTitle' })    //在该片段中声明将要预览的组件Title，以及该组件依赖的入参 {context: 'MyTitle'}
6.   }
7. }

## 卡片预览

创建卡片并选中卡片文件后，点击右侧边栏**Previewer**按钮即可预览卡片。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.50446976110614185771895109399039:50001231000000:2800:47C6350DB9C19EFBF96A811DC4DAEF3945F9E9C5D53ACA9D20E11BCD6B894397.png)

[查看ArkTS/JS预览效果](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-arkts-js "查看ArkTS/JS预览效果")

[Profile Manager](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-profile-manager "Profile Manager")
# Profile Manager

更新时间: 2025-12-16 15:58

由于真机设备有丰富的设备型号，不同设备型号的屏幕分辨率可能不一样。因此，在HarmonyOS应用/元服务开发过程中，由于设备类型繁多，可能需要查看在不同设备上的界面显示效果。对此，DevEco Studio的预览器提供了Profile Manager功能，支持开发者自定义预览设备Profile（包含分辨率和语言），从而可以通过定义不同的预览设备Profile，查看HarmonyOS应用/元服务在不同设备上的预览显示效果。当前支持自定义设备分辨率及系统语言。

定义设备后，可以在Previewer右上角，单击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155828.42461707720224380251414240022099:50001231000000:2800:4DC1E9A004EE5CC5AF11DC64C43142879EB5E34B26A1D0796E06643684F874DD.png)按钮，打开Profile管理器，切换预览设备。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.32020922217389250338659814377416:50001231000000:2800:6A68E69BF9690543D635D1D798E5E12680C4500A79BBE96046AFD3A0134DE9A7.png)

同时，Profile Manager还支持多设备预览功能，具体请参考[查看多端设备预览效果](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-multi-profile)。

下面以自定义一款Phone设备为例，介绍设备Profile Manager的使用方法。

1. 在预览器界面，打开Profile Manager界面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.75906976839946202435655074220267:50001231000000:2800:6EE50375A5F6CC0CA335EDEBA59A01890C2E456DB724499F236E82AC554C6688.png)
    
2. 在Profile Manager界面，单击**+ New Profile**按钮，添加设备。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.60659943425424056451481666129946:50001231000000:2800:7796C1E30749ECFB8609283FE38F9812FB3D52F29760DA01DB93C89D1227EA04.png)
    
3. 在**Create Profile**界面，填写新增设备的信息，如**Profile ID**（设备型号）、**Device type**（设备类型）、**Resolution**（分辨率）和**Language and region**（语言和区域）等。其中Device type只能选择module.json5中deviceTypes字段已定义的设备。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155829.55292636190606290748353460959319:50001231000000:2800:35661A5E72ED30C665A1B90C1D207907843385FDC84F872276C4D159E27CBC9E.png)
    
4. 设备信息填写完成后，单击**OK**完成创建。

[查看ArkUI预览效果](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-arkui "查看ArkUI预览效果")

[查看多端设备预览效果](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-multi-profile "查看多端设备预览效果")
# 查看多端设备预览效果

更新时间: 2025-12-16 15:58

DevEco Studio支持HarmonyOS分布式应用/元服务开发，同一个应用/元服务可以运行在多个设备上。在HarmonyOS分布式应用/元服务的开发阶段，因不同设备的屏幕分辨率、形状、大小等不同，开发者需要在不同的设备上查看应用/元服务的UI布局和交互效果，此时便可以使用多端设备预览器功能，方便开发者在应用/元服务开发过程中，随时查看不同设备上的界面显示效果。

说明

多端设备预览最多同时支持4个设备的预览。

前面介绍了DevEco Studio支持ArkTS、JS应用/元服务的预览器功能，多端设备预览器支持ArkTS、JS应用/元服务在不同设备上的同时预览。如果两个设备支持的编码语言不同，就不能使用多端设备预览功能。

下面以ArkTS应用/元服务为例，介绍多端设备预览器的使用方法，JS应用/元服务的多端设备预览器使用方法相同。

1. 在工程目录中，打开任意一个ets文件（JS请打开hml/css/js文件）。
2. 可以通过如下任意一种方式打开预览器开关，显示效果如下图所示：
    
    - 通过菜单栏，单击**View > Tool Windows > Previewer**，打开预览器。
    - 在编辑窗口右上角的侧边工具栏，单击**Previewer**，打开预览器。
    
3. 在Previewer窗口中，打开Profile Manager中的**Multi-profile preview**开关，同时查看多设备上的应用/元服务运行效果。
    
    说明
    
    多端设备预览不支持动画的预览，如果需要查看动画在设备上的预览效果，请关闭Multi-profile preview功能后在单设备预览界面进行查看。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155832.54818615727278666924638279357992:50001231000000:2800:64BC2C3135A8088836A5611402FEB66321B868896935DFA7DE033E2118AAA79E.png)
    
    多设备预览效果如下图所示：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155832.37151739077561908373400242145596:50001231000000:2800:FFB9F489B05F811E6DB40EE92565ACF43A816AD39651029B910CEF07ADABBFB1.gif)
    

[Profile Manager](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-profile-manager "Profile Manager")

[Inspector双向预览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-inspector "Inspector双向预览")
# Inspector双向预览

更新时间: 2025-12-16 15:58

DevEco Studio提供HarmonyOS应用/元服务的UI预览界面与源代码文件间的双向预览功能，支持ets文件与预览器界面的双向预览。使用双向预览功能时，需要在预览器界面单击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.66532853828847730111098131631777:50001231000000:2800:FE05EC1F3BDB9BEE9D435483F455D0040A3FE013FBC77C2CB04A901FE2716D0D.png)图标打开双向预览功能。

说明

不支持服务卡片的双向预览功能。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.27523625731752152331030901547607:50001231000000:2800:E9DDE75A59B1B59D152F5A4879B8A61E8889B773E89E221FE9C361EFA6FF0445.png)

开启双向预览功能后，支持代码编辑器、UI界面和Component Tree组件树三者之间的联动：

- 选中预览器UI界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。
- 选中布局文件中的代码块，则在UI界面会高亮显示，组件树上的组件节点也会呈现被选中的状态。

- 选中组件树中的组件，则对应的代码块和UI界面也会高亮显示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155834.17008042405700900456122960156893:50001231000000:2800:9472A80F6FC555BC103AAC364B201EDE13801030160A4866DA5FBB3F45F105FD.png "点击放大")

在预览界面还可以通过组件的属性面板修改可修改的属性或样式，在预览界面修改后，预览器会自动同步到代码编辑器中修改源码，并实时的刷新UI界面；同样的，如果在代码编辑器中修改源码，也会实时刷新UI界面，并更新组件树信息及组件属性。

说明

- 如果组件有做数据绑定，则其属性不支持在属性面板修改。
- 如果界面有使用动画效果或者带动画效果组件，则其属性不支持在属性面板修改。
- 多设备预览时，不支持双向预览。

[查看多端设备预览效果](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-multi-profile "查看多端设备预览效果")

[预览数据模拟](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-mock "预览数据模拟")
# 预览数据模拟

更新时间: 2025-12-16 15:58

说明

仅API 11及以上版本的Stage工程支持。

在预览场景中，由于代码的运行环境与真机设备上的运行环境不同，调用部分接口时无法获取到有效的返回值（例如获取电池电量信息等，在预览场景下batteryInfo.voltage返回的是一个固定的值0），这样开发者就无法在预览时查看到不同返回值带来的界面变化。因此，Hamock提供了预览场景的模拟功能，在不改变业务运行逻辑的同时，开发者可以模拟UI组件上的属性或方法，或模拟import的模块接口。

## 使用前提

使用Hamock在预览场景模拟，需要在工程或模块的oh-package.json5中添加该依赖，然后重新同步工程。

1. "devDependencies": {
2.     "@ohos/hamock": "1.0.0"
3. }

## UI组件上的Mock

Hamock提供了@MockSetup用于修饰Mock方法，仅支持声明式范式的组件。当开发者预览该组件时，预览运行时将在组件初始化时执行被@MockSetup修饰的方法。因此，开发者可以在这个被修饰的方法内重定义组件的方法或重赋值组件的属性，其将在预览时生效。

说明

@MockSetup修饰的方法仅在预览场景会自动触发，并先于组件的aboutToAppear执行。

### UI组件的方法

1. 在ArkTS页面代码中引入Hamock。
    
    1. import { MockKit, when, MockSetup } from '@ohos/hamock';
    
2. 在目标组件中定义一个方法，并用@MockSetup修饰该方法。在这个方法中，使用MockKit模拟目标方法。
    
    1. import { MockKit, when, MockSetup } from '@ohos/hamock';
    
    2. @Entry
    3. @Component
    4. struct Index {
    5.  ...
    6.  @MockSetup
    7.  randomName() {
    8.   let mocker: MockKit = new MockKit();
    9.   let mockfunc: Object = mocker.mockFunc(this, this.method1);
    10.   // mock 指定的方法在指定入参的返回值
    11.   when(mockfunc)('test').afterReturn(1);
    12.  }
    13.  ...
    14.  // 业务场景调用方法
    15.  const result = this.method1('test'); // in previewer, result = 1
    16. }
    

### UI组件的属性

1. 在ArkTS页面代码中引入Hamock。
    
    1. import { MockSetup } from '@ohos/hamock';
    
2. 在目标组件中定义一个方法，并用@MockSetup修饰该方法。在这个方法中，对于需要Mock的属性，可以重新赋值。
    
    1. import { MockSetup } from '@ohos/hamock';
    
    2. @Component
    3. struct Person {
    4.  @Prop species: string;
    5.  // 在@MockSetup片段中，定义对象属性
    6.  @MockSetup
    7.  randomName() {
    8.   this.species = 'primates'
    9.  }
    10.  ...
    11.  // 业务场景调用属性（如果从初始化到调用期间，该属性无变化）
    12.  const result = this.species // in previewer, result = primates
    13. }
    

说明

- ArkUI部分类型属性不支持Mock，如readonly、@ObjectLink。
- 被@Link/@Consume/@Prop/@BuilderParam装饰器修饰的变量，ArkUI语法要求父容器需要有对应属性的定义，因此更推荐开发者通过定义⼀个预览场景父容器（并通过父容器传递合适的数据）来预览这⼀类的组件。

## 模块的Mock

模块的Mock支持对系统模块、依赖模块及本地模块的Mock，通过新建ArkTS文件定义Mock实现代码，并在mock-config.json5配置文件中定义目标模块与Mock实现代码文件的映射关系。目标模块与Mock实现代码文件为一对一的关系，即对于同一目标模块，仅支持一份Mock实现代码，预览运行时，所有页面import目标模块都将指向这一份Mock实现代码。

### 系统模块/依赖的模块

1. 在src/mock目录下新建一个ArkTS文件，在这个文件内定义目标模块的Mock实现。
    
    1. // src/mock/MeasureText.mock.ets
    2. import MeasureText from '@ohos.measure'
    
    3. // 类的mock使用继承(extends)的方式实现
    4. class MockMeasureText extends MeasureText {
    5.   // 定义mock实现
    6.   static measureText(): number {
    7.     console.log('Return value of the mock measureText function')
    8.     return 100;
    9.   }
    10. };
    
    11. export default MockMeasureText;
    
    说明
    
    用户在对类定义Mock的实现时，需要使用继承(extends)的方式实现。
    
2. 在Mock配置文件src/mock/mock-config.json5中定义目标模块与Mock实现的替换关系。该替换关系会在预览场景下生效。
    
    1. {
    2.   "@ohos.measure": { // 待替换的moduleName
    3.     "source": "src/mock/MeasureText.mock.ets" // Mock代码的路径，相对于模块根目录
    4.   },
    5.  ...
    6. }
    
3. 在原调用处中添加Hilog日志，方便在预览时，在Log中打印获取返回值，从而验证Mock是否生效。
    
    1. hilog.debug(DomainNumber, logTag, 'Mock %{public}s', `${MeasureText.measureText({textContent: 'Hello World'})}`)
    

### 本地模块

1. 在src/mock目录下新建一个ArkTS文件，在这个文件内定义目标模块的Mock实现。
    
    1. // src/mock/module/utils/CommonUtils.mock.ts
    2. // import local module
    3. import LibDefaultExport from '../../../main/ets/utils/CommonUtils'; // get origin default export
    4. import { methodA, ObjectB } from '../../../main/ets/utils/CommonUtils'; // get origin export on demand
    
    5. class DefaultExportMock extends LibDefaultExport {
    6.   // 定义mock实现
    7.   public static getName(): String {
    8.     return "Mocked Name";
    9.   }
    10. };
    
    11. export {
    12.   methodA,
    13.   ObjectB,
    14. }
    
    15. export default DefaultExportMock;
    
    其中CommonUtils.ets文件示例如下：
    
    16. export default class CommonUtils {
    17.   public static getName(): String {
    18.     return "origin name";
    19.   }
    
    20.   public static getTitle(): String {
    21.     return "origin title";
    22.   }
    23. }
    
    24. export const methodA = (): string => {
    25.   return "methodA"
    26. }
    
    27. export const ObjectB: Object = new Object();
    
    说明
    
    本地模块的Mock仅支持src/main/ets目录下的ArkTS或TS文件。
    
2. 在Mock配置文件src/mock/mock-config.json5中定义目标模块与Mock实现的替换关系。该替换关系会在预览场景下生效。
    
    1. {
    2.  "utils/CommonUtils.ets": { // 本地模块只支持ets/xxx的相对路径，并需明确文件后缀
    3.   "source": "src/mock/module/utils/CommonUtils.mock.ts"
    4.  },
    5.  ...
    6. }
    
3. 在原调用处中添加Hilog日志，方便在预览时，在Log中打印获取返回值，从而验证Mock是否生效。
    
    1. hilog.debug(DomainNumber, logTag, 'Mock %{public}s', CommonUtils.getName());
    

[Inspector双向预览](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-inspector "Inspector双向预览")

[使用预览器调试应用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-debug "使用预览器调试应用")
# 使用预览器调试应用

更新时间: 2025-12-16 15:58

使用真机或模拟器进行调试时，修改后的代码需要经过较长时间的编译和安装过程，才能刷新至调试环境。使用预览器进行调试，可快速地修改代码和运行应用，在DevEco Studio中直接查看修改后的界面显示效果。

开发者可以使用预览器运行调试Ability生命周期代码和界面代码，预览器调试支持基础调试能力，包括断点、调试执行、变量查看等。

## 使用约束

- 一个工程内不支持启动多个预览调试任务。
- 一个预览器只能支持普通预览或预览调试模式，不可同时支持两种模式。
- 使用预览器进行调试不支持以下场景：
    - 不支持Attach调试。
    - 不支持跨Ability调试。
    - 不支持C++调试。
    - 不支持Hot Reload。
    - 不支持多进程和worker/taskpool调试。

## 普通预览与预览调试能力对比

|   |   |   |   |
|---|---|---|---|
**表1** 普通预览与预览调试能力对比
|**功能**|**普通预览**|**预览调试**|   |
|**页面预览**|**运行模式**|**调试模式**|
|ets页面预览|支持|支持|支持|
|动态预览|支持|支持|支持|
|指定页面文件预览|支持|不支持|不支持|
|Inspector双向预览|支持|从DevEco Studio 6.0.0 Beta2版本开始支持|从DevEco Studio 6.0.0 Beta2版本开始，支持查看，不支持修改|
|实时预览|支持|支持|断点中断时不支持|
|极速预览|支持|从DevEco Studio 6.0.0 Beta2版本开始支持|不支持|
|组件预览|支持|不支持|不支持|
|多语言切换|支持|从DevEco Studio 6.0.0 Beta2版本开始支持|从DevEco Studio 6.0.0 Beta2版本开始支持，但断点中断时不支持|
|动态修改分辨率|支持|从DevEco Studio 6.0.0 Beta2版本开始，支持横竖屏切换|从DevEco Studio 6.0.0 Beta2版本开始，支持横竖屏切换，但断点中断时不支持|
|引用HSP|从DevEco Studio 6.0.0 Beta3版本开始支持|   |   |

[预览数据模拟](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-mock "预览数据模拟")

[支持使用预览器的API清单](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-api-list "支持使用预览器的API清单")
# 支持使用预览器的API清单

更新时间: 2025-12-16 15:58

## 组件

### ArkTS组件

|组件|API|
|:--|:--|
|基础组件|AlphabetIndexer|
|Blank|
|Button|
|Checkbox|
|CheckboxGroup|
|DataPanel|
|DatePicker|
|Divider|
|Gauge|
|Image|
|ImageAnimator|
|ImageSpan|
|LoadingProgress|
|Marquee|
|Menu|
|MenuItem|
|MenuItemGroup|
|Navigation|
|NavRouter|
|NavDestination|
|PatternLock|
|Progress|
|QRCode|
|Radio|
|Rating|
|ScrollBar|
|Search|
|Select|
|Slider|
|Span|
|Stepper|
|StepperItem|
|Text|
|TextArea|
|TextClock|
|TextInput|
|TextPicker|
|TextTimer|
|Toggle|
|容器组件|Badge|
|Column|
|ColumnSplit|
|Counter|
|Flex|
|FlowItem|
|GridCol|
|GridRow|
|List|
|ListItem|
|ListItemGroup|
|Navigator|
|Panel|
|Refresh|
|RelativeContainer|
|Row|
|RowSplit|
|Scroll|
|SideBarContainer|
|Stack|
|Swiper|
|Tabs|
|TabContent|
|WaterFlow|
|绘制组件|Circle|
|Ellipse|
|Line|
|Polyline|
|Path|
|Rect|
|Shape|
|画布组件|Canvas|
|CanvasGradient|
|CanvasPattern|
|CanvasRenderingContext2D|
|ImageBitmap|
|ImageData|
|Matrix2D|
|OffscreenCanvasRenderingContext2D|
|Path2D|

### JS组件

|组件|API|
|:--|:--|
|基础组件|button|
|chart|
|divider|
|image|
|image-animator|
|input|
|label|
|marquee|
|menu|
|option|
|picker|
|picker-view|
|piece|
|progress|
|qrcode|
|rating|
|search|
|select|
|slider|
|span|
|switch|
|text|
|textarea|
|toolbar|
|toolbar-item|
|toggle|
|容器组件|badge|
|dialog|
|div|
|form|
|list|
|list-item|
|list-item-group|
|panel|
|popup|
|refresh|
|stack|
|stepper|
|stepper-item|
|swiper|
|tabs|
|tab-bar|
|tab-content|
|画布组件|canvas|
|CanvasRenderingContext2D|
|Image|
|CanvasGradient|
|ImageData|
|Path2D|
|ImageBitmap|
|OffscreenCanvas|
|OffscreenCanvasRenderingContext2D|
|栅格组件|grid-container|
|grid-row|
|grid-col|
|svg组件|svg|
|rect|
|circle|
|ellipse|
|path|
|line|
|polyline|
|polygon|
|text|
|tspan|
|textPath|
|animate|
|animateMotion|
|animateTransform|

## 接口

### UI界面

|模块|API|
|:--|:--|
|@ohos.animator (动画)|Animator|
|AnimatorResult|
|AnimatorOptions|
|@ohos.mediaquery (媒体查询)|matchMediaSync|
|MediaQueryResult|
|MediaQueryListener|
|@ohos.promptAction (弹窗)|showToast|
|showDialog|
|showActionMenu|
|ShowToastOptions|
|Button|
|ShowDialogSuccessResponse|
|ShowDialogOptions|
|ActionMenuSuccessResponse|
|ActionMenuOptions|
|@ohos.router (页面路由)|pushUrl|
|replaceUrl|
|back|
|clear|
|getLength|
|getState|
|enableAlertBeforeBackPage|
|disableAlertBeforeBackPage|
|getParams|
|RouterMode|
|RouterOptions|
|RouterState|
|EnableAlertOptions|

### 网络管理

|模块|API|
|:--|:--|
|@ohos.net.http (数据请求)|http.createHttp<br><br>如果Http请求需要配置代理才能访问，API 12及以上的预览器支持使用系统的http_proxy/https_proxy/no_proxy环境变量。|

### 数据管理

|模块|API|
|:--|:--|
|@ohos.data.preferences (用户首选项)|data_preferences.getPreferences|
|data_preferences.deletePreferences|
|data_preferences.removePreferencesFromCache|
|Preferences|
|ValueType|

### 文件管理

从DevEco Studio 6.0.0 Beta5版本开始，仅支持在预览/预览调试Stage模型的HAP/HSP时，使用文件管理的相关API，并且需要先打开**Enable file operation**开关。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155836.18279119716189057183090535272472:50001231000000:2800:6C852E1CEEAC5DCA9DBBCF2AE041DACA5670CD849B59DDE4944D90EC7CB097BD.png)

|模块|API|
|:--|:--|
|@ohos.file.fs (文件管理)|fs.open|
|fs.close|
|fs.fdatasync|
|fs.fsync|
|fs.read|
|fs.write|
|fs.mkdir|
|fs.mkdtemp|
|fs.rename|
|fs.rmdir|
|fs.unlink|
|fs.stat|
|fs.truncate|

[使用预览器调试应用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-debug "使用预览器调试应用")

[配置调试签名](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-signing "配置调试签名")
# 使用仿真器运行轻量级穿戴应用

更新时间: 2025-12-16 15:58

DevEco Studio提供的**Simulator**可以运行和调试Lite Wearable设备上的HarmonyOS应用，兼容签名与不签名两种类型的HAP。

## 操作步骤

1. 在DevEco Studio右上角的设备框中选择**Huawei Lite Wearable Simulator。**
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155812.42102936304212653386209335837007:50001231000000:2800:723186763962839348C8C8E0A622525FB5221D20619889278F638AECAB28FD96.png)
    
2. 点击**Run** ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155812.08084707982390229750097840579555:50001231000000:2800:9A48F240955BEF5B593BC9E2C7AB25F4AD317DEE362D5AED9585B39C1748584E.png)或**Debug** ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.08103934683018527486121364226255:50001231000000:2800:F515A2DC7DA954232013DBA634B7D318B49E2CBA72E863C32CFCE4424DD69B88.png)按钮，在弹框中选择设备形状和分辨率，点击**OK**按钮，开始运行或调试应用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.01251819743178912389935756879672:50001231000000:2800:F12436E05E9D3B24E37A4C522C4A1D3DE3B6E3FC9B76C16C9BF8BDFB87D88DC8.png "点击放大")
    
3. DevEco Studio会启动编译构建和安装，完成后应用即可运行在Simulator上。

## 功能介绍

在Simulator界面中，点击设备上方的**More**可展开更多功能。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.11955936062531119325997947546605:50001231000000:2800:33C7847EC26EE48ABF0695A36CAB8B202567C84F7E0F1A1A44C956C79EDC949A.png "点击放大")

### 屏幕

- **Turn screen on：**控制屏幕开关。
- **Keep screen on：**控制屏幕是否保持常亮状态。关闭开关时，息屏计时结束后，屏幕自动关闭，同时**Turn screen on**开关自动关闭。开启屏幕后，打开**Keep screen on**开关才能使屏幕常亮。
- **Brightness adjustment mode：**调节屏幕亮度。
    - **Manual：**手动调节，可拖动滑动条，或直接输入亮度。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.81891681890448868055195615278134:50001231000000:2800:5FEE018D239B3908E12B465C35109B7C960BA98E10B3AE738F69E041E688E71B.png)
        
    - **Automatic：**自动调节。
- **Resolution：**运行/调试模式下暂不支持调整分辨率，如需调整，请停止运行后，按照[操作步骤](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-simulator#section1332819367496)选择分辨率。

### 传感器

仿真器提供了虚拟传感器来模拟硬件传感器的能力。在该界面，您可以调节不同的传感器来测试您的应用，使用[@system.sensor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-system-sensor)模块监听传感器值的变化，使用[@system.geolocation](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-system-location)模块监听地理位置的变化。仿真器提供以下虚拟传感器：

- **On-body status**：传感器所在设备穿戴状态，包括已穿戴和未穿戴。
- **Barometer：**气压传感器用于测量环境气压，单位为Pa。
- **Heart rate：**心率传感器用于测量心率数值，拖动滑动条，或直接输入心率大小。
- **Step count：**计步传感器用于统计行走步数，拖动滑动条，或直接输入步数。
- **Geographic location：**输入经度、纬度，模拟设备所处的地理位置。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.50770284466856789189063059715280:50001231000000:2800:343686F004C82EA033CB7816520590F8B7F775902B4BD7C7581636577697EE89.png)

### 电池

您可以通过仿真器模拟不同的电池状态，包括以下三种充电状态，也可以手动输入或拖动滑动条来改变电量大小。在应用中，您可以通过[@system.battery](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-system-battery)模块查询仿真器的剩余电量以及充电状态。

- Not charging：未充电。
- Charging：正在充电。
- Wireless charging：无线充电。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.84188326877619990071507581433662:50001231000000:2800:862DF011B71C9F46E8B714C32CF4F637B9A8CD4E3C2BC02DF782B7279BBCEFD2.png)

### 设备设置

您可以更改设备的语言和地区，当前仅运行模式可以更改，调试模式暂不支持。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.76424311131264936105981369406736:50001231000000:2800:44B71E485662D80D0036B041924295D5ECAD48D051882B491D56E7E47ADBB09A.png)

### 调试

- **Screen coordinate system****：**开启屏幕坐标系后，将光标移动到表盘上时，会显示屏幕坐标。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.32422772720459637309632360270579:50001231000000:2800:1585C31EEC850B0FC6D8773274C0ABC05CED5F118A7A036154EECB3DAADA60B4.gif "点击放大")
    
- **Show device mask****：**关闭开关后，表盘周围的表冠颜色淡化。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155813.32575327342751054639988654194064:50001231000000:2800:B77C3022417FAE16DCFF6B940942A70C640FE6A25642244A274BE4A6486967E5.gif "点击放大")
    

[使用本地真机运行应用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-device "使用本地真机运行应用")

[使用模拟器运行应用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-emulator "使用模拟器运行应用")
# 使用环境

更新时间: 2025-12-16 15:58

模拟器在本地计算机上创建和运行，在运行和调试应用/元服务时可以保持良好的流畅性和稳定性，但是需要耗费一定的计算机资源，具体的运行环境要求如下。

Windows运行环境：

|类别|最低要求|推荐|
|:--|:--|:--|
|操作系统|Windows 10企业版、专业版或教育版及以上，且操作系统版本不低于10.0.18363|最新的64位Windows|
|CPU|- 具有二级地址转换 (SLAT) 的64位处理器<br>- CPU支持AES指令集<br>- CPU支持VM监视器模式扩展（Intel CPU的VT-c技术）<br>- 不支持在虚拟机系统中运行模拟器<br>- 不支持采用ARM CPU的Windows计算机<br>- 2017年以后CPU型号。|- 最新的Intel Core i5、i7、i9系列CPU<br>- 最新的AMD Ryzen 5、6、7、9系列CPU<br>- CPU后缀为H/HK/HX的笔记本电脑或后缀为S/F/K的台式机<br><br>由于性能不足，不推荐使用 Intel® Core™ N 系列和 U 系列处理器|
|RAM|16GB|32GB及以上|
|磁盘空间|16GB|32GB及以上|
|屏幕|屏幕分辨率1280*800像素以上|屏幕分辨率1920*1080像素以上|
|GPU|支持OpenGL版本4.1<br><br>从DevEco Studio 6.0.0 Release版本开始，AMD的GPU显示驱动要求不低于24.1.1版本|支持OpenGL版本4.1及以上<br><br>AMD的GPU显示驱动版本24.1.1及以上|

Mac运行环境：

|类别|最低要求|推荐|
|:--|:--|:--|
|操作系统|macOS系统为12.5及以上版本|最新的64位macOS|
|CPU|- 不支持在虚拟机系统中运行模拟器<br>- Apple Silicon芯片|最新的Apple Silicon|
|RAM|8GB|16GB及以上|
|磁盘空间|16GB|32GB及以上|
|屏幕|屏幕分辨率1280*800像素以上|屏幕分辨率1920*1080像素以上|
|GPU|支持OpenGL版本4.1|支持OpenGL版本4.1及以上|

[概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-overview "概述")

[设备支持类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-devicetype "设备支持类型")
# 设备支持类型

更新时间: 2025-12-16 15:58

模拟器在不同系统上支持的设备类型见下表。

|系统类型|设备类型|备注|
|:--|:--|:--|
|Windows(X86)<br><br>macOS(ARM)|Phone（包括折叠屏）|仅支持在中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）使用。|
|Tablet|仅支持在中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）使用。|
|PC/2in1（包括折叠屏）|从DevEco Studio 5.0.13.200版本开始，支持在中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）使用PC/2in1设备。<br><br>从DevEco Studio 6.0.0.456版本开始，支持在中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）使用折叠屏PC/2in1设备。|
|Wearable|从DevEco Studio 6.0.0.828版本开始，支持在中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）使用。<br><br>从DevEco Studio 6.0.1.249版本开始，支持在所有国家/地区使用。|
|TV|从DevEco Studio 5.1.1.840版本开始，支持在中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）使用。|

说明

使用x86模拟器时，C++工程及三方库需要编译出x86_64版本的so，请在工程级或模块级build-profile.json5的externalNativeOptions/abiFilters的值中增加"x86_64"，具体编译配置请参见[externalNativeOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-cpp#section0721057575)。

[使用环境](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-requirements "使用环境")

[模拟器与真机的差异](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-specification "模拟器与真机的差异")
# 模拟器与真机的差异

更新时间: 2025-12-16 15:58

模拟器是开发和调试HarmonyOS应用/元服务的便捷工具，例如不需要配置服务器域名即可开发和调试元服务，在大多数情况下，模拟器上推包调试不需要签名，但部分Kit仍需签名后才能正常运行，具体要求请参考Kit的开发指南。

由于模拟器和真机在硬件和能力上存在差异，部分功能场景仍需在真机上进行开发。您可以通过阅读本文档来决定哪些功能在模拟器中测试，哪些功能在真机上测试。

## 通用差异

模拟器是运行在Mac或Windows电脑上的虚拟机应用，会使用电脑的硬件资源，包括CPU、内存和网络连接等。这些资源在容量和速度上可能与真机存在显著差异。因此，模拟器不适合用于测试应用/元服务的性能（如数据处理、图形渲染、网络速度）、资源占用（如内存、CPU、功耗），模拟器的性能测试结果仅能用于评估应用功能的相对差异。如需获取真实场景下的用户体验数据，建议在真机上进行测试。

## 显示效果差异

- 模拟器使用电脑的显示器，与真机屏幕不同，可能会导致文本和图像在模拟器上出现边缘锯齿。放大模拟器窗口比例可以使文字和图像更清晰。
- 电脑屏幕的色域范围可能与移动设备不同，从而导致颜色显示不准确。
- 模拟器不支持屏幕亮度调节。

## 图形接口差异

- 不支持OpenGL ES 3.1、3.2接口
- 不支持Vulkan接口

## Kit能力差异

当前部分Kit不支持在模拟器上使用，具体参考以下说明。部分Kit能力有设备类型和使用地区限制，具体请参考对应Kit指南。

如遇到因Kit能力不支持导致的应用闪退问题，可以使用[动态引入Kit](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dynamic-import#%E5%8A%A8%E6%80%81import%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D)的方式规避此异常问题。

Kit不支持导致的报错信息如：

1. LastFatalMessage:[default] [LoadJSPandaFile:00] resolveBufferCallback get hsp buffer failed，hsp path:/data/storage/el1/bundle/com.huawei.hmos.{KitName}.kit

### 应用框架

以下Kit和场景暂不支持模拟器。

- Ability Kit（程序框架服务）：不支持拉起垂类应用面板，不支持使用App Linking实现应用间跳转，不支持以免安装方式拉起元服务。
- Accessibility Kit（无障碍服务）：不支持屏幕朗读以外的其他功能。
- Background Tasks Kit（后台任务开发服务）：模拟器短时任务不会被挂起。
- Data Augmentation Kit（数据增强服务）
- UI Design Kit（UI设计套件）：不支持侧边栏样式设置，不支持侧边栏菜单样式，不支持底部页签设置图标出血样式，不支持即时操作设置，不支持核心操作栏设置，不支持列表设置，不支持应用加载自定义Symbol，不支持视效。

### 安全

以下Kit和场景暂不支持模拟器。

- Data Protection Kit（数据保护服务）
- Device Security Kit（设备安全服务）
- Enterprise Data Guard Kit（企业数据保护服务）
- Online Authentication Kit（在线认证服务）
- 不支持安全GPS、人脸识别、设备证书等。

### 网络

以下Kit暂不支持模拟器。

- Distributed Service Kit（分布式管理服务）
- NearLink Kit（星闪服务）
- Network Boost Kit（网络加速服务）
- Service Collaboration Kit（协同服务）
- Telephony Kit（蜂窝通信服务）

### 基础功能

- Input Kit（多模输入服务）：不支持对鼠标光标的样式修改等操作。
- 不支持MDM Kit（企业设备管理服务）

### 硬件

以下Kit暂不支持模拟器。

- Car Kit（车服务）
- Driver Development Kit（驱动开发服务）
- Mechanic Kit（机械体设备控制器）
- Multimodal Awareness Kit（多模态融合感知服务）
- Pen Kit（手写笔服务）
- Sensor Service Kit（传感器服务）：支持部分传感器，参见[虚拟传感器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features#section830415558395)。
- Wear Engine Kit（穿戴服务）

### 媒体

以下Kit和场景暂不支持模拟器。

- Camera Kit（相机服务）：不支持预览、拍照以外的其他功能。
- DRM Kit（数字版权保护服务）
- Scan Kit（统一扫码服务）：不支持码图生成，不支持识别图像数据。
- 不支持heif格式的图片
- 视频播放：仅支持h264文件格式、RGBA像素格式的视频文件。
- 不支持视频录制/转码/处理、屏幕录像。

### 图形

以下Kit暂不支持模拟器。

- AR Engine（AR引擎服务）
- ArkGraphics 3D（方舟3D图形）
- Graphics Accelerate Kit（图形加速服务）
- Spatial Recon Kit（空间建模服务）
- XEngine Kit（GPU加速引擎服务）

### 应用服务

以下Kit和场景暂不支持模拟器。

- AppGallery Kit（应用市场服务）：不支持数字商品服务、应用市场推荐、生态查询服务、应用市场更新功能、应用评论服务、图标管理服务，不支持端云交互。
- App Linking Kit（应用链接服务）
- Call Service Kit（通话服务）
- Cloud Foundation Kit（云开发服务）：不支持预加载。更多关于如何在模拟器上调试Cloud Foundation Kit，请参考[使用模拟器调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-emulator)。
- Enterprise Space Kit（企业数字空间服务）
- Game Service Kit（游戏服务）
- Health Service Kit（运动健康服务）
- IAP Kit（应用内支付服务）
- Location Kit（位置服务）：不支持地理围栏。
- Map Kit（地图服务）：不支持3D地图、地图截图。
- Payment Kit（华为支付服务）
- PDF Kit（PDF服务）：X86版本不支持。
- Preview Kit（文件预览服务）：不支持.pdf/.pptx/.xlsx/.docx文件格式预览。
- Push Kit（推送服务）：不支持推送授权订阅消息、推送通知扩展消息、推送实况窗消息、推送应用内通话消息。
- Reader Kit（阅读服务）
- Scenario Fusion Kit（融合场景服务）：具体请参考[模拟器支持范围](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scenario-fusion-introduction#section1901742183715)。
- Share Kit（分享服务）：不支持跨端分享、基于意图框架的分享。
- Wallet Kit（钱包服务）
- Weather Service Kit（天气服务）

### AI

以下Kit和场景暂不支持模拟器。

- CANN Kit（CANN 服务）
- Core Vision Kit（基础视觉服务）
- Agent Framework Kit（智能体框架服务）
- Intents Kit（意图框架服务）
- MindSpore Lite Kit（昇思推理框架服务）：不支持图像分类之外的其他功能。
- Natural Language Kit（自然语言理解服务）
- Neural Network Runtime Kit（Neural Network运行时服务）
- Speech Kit（场景化语音服务）
- Vision Kit（场景化视觉服务）

## 其他差异

**表1**
|模拟器和真机的其他重要差异|影响场景|
|:--|:--|
|SIM卡|不支持拨打电话、发送短信|
|USB|不支持连接、数据传输|
|蓝牙|不支持蓝牙设备扫描、连接、数据传输|
|星闪|不支持星闪设备扫描、连接、数据传输、分布式能力|
|NFC|不支持NFC卡片读写、刷卡|
|TEE（Trusted Execution Environment，可信执行环境）|部分安全相关Kit暂不支持，详情参考[Kit能力差异](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-specification#section147193483010)|
|NPU|部分AI相关Kit暂不支持，详情参考[Kit能力差异](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-specification#section1155211435325)|
|生物识别|不支持指纹、人脸认证|
|摄像头/麦克风|依赖电脑设备，不支持多摄像头切换（广角/长焦）、闪光灯、降噪算法等|
|电源|模拟电源，不支持亮灭屏、温控、快充等场景|

## Kit支持情况变更说明

### DevEco Studio 6.0.1 Release

- 支持Ringtone Kit（铃声服务）

### DevEco Studio 6.0.0 Beta5

以下Kit支持在模拟器上使用：

- Ads Kit（广告服务）
- AppGallery Kit（应用市场服务）：支持产品特性按需分发、应用归因服务、隐私管理中不涉及端云交互的接口。
- Cloud Foundation Kit（云开发服务）：支持云函数、云数据库、云存储。具体调试方式请参考[使用模拟器调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-emulator)。

### DevEco Studio 6.0.0 Beta3

- 支持Screen Time Guard Kit（屏幕时间守护服务）

### DevEco Studio 6.0.0 Beta2

- Accessibility Kit（无障碍服务）：支持屏幕朗读。

### DevEco Studio 6.0.0 Beta1

以下Kit支持在模拟器上使用：

- Core Speech Kit（基础语音服务）
- Scan Kit（统一扫码服务）：支持使用电脑摄像头扫码。

### DevEco Studio 5.1.1 Beta1

- NDK：X86版本支持JSVM。

### DevEco Studio 5.1.0 Release

以下Kit支持在模拟器上使用：

- PDF Kit（PDF服务）：支持在ARM版本上使用。
- Map Kit（地图服务）：支持除3D地图和地图截图以外的其他功能。
- Camera Kit（相机服务）：支持预览、拍照。
- Share Kit（分享服务）：支持除了跨端分享、基于意图框架的分享以外的其他功能。

[设备支持类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-devicetype "设备支持类型")

[管理模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-management "管理模拟器")
# 创建模拟器

更新时间: 2025-12-16 15:58

## 操作步骤

1. 点击菜单栏的**Tools > Device Manager**，点击右下角的**Edit**设置模拟器实例的存储路径**Local Emulator Location**，Mac默认存储在~/.Huawei/Emulator/deployed下，Windows默认存储在C:\Users\xxx\AppData\Local\Huawei\Emulator\deployed下。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.30383431296821521601751937971647:50001231000000:2800:2681E9D8C5E332A45AAD8DDCDE67805F2E7336ED57DC32E693A09996E7533CD3.png "点击放大")
    
2. 在**Local Emulator**页签中，单击右下角的**New Emulator**按钮，创建一个模拟器。
    
    在模拟器配置界面，可以选择一个默认的设备模板，首次使用时请点击设备右侧的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.54469843627824709649555471571571:50001231000000:2800:56D46D4F59F6433B8F09481A564D313AF4DFF0394175CE0CD821CAD364A2A719.png)下载模拟器镜像，您也可以在该界面更新或删除不同设备的模拟器镜像。单击**Edit**可以设置镜像文件的存储路径。macOS默认存储在~/Library/Huawei/Sdk下，Windows默认存储在C:\Users\xxx\AppData\Local\Huawei\Sdk下。
    
    说明
    
    如果配置界面显示异常，例如设备列表为空等，可先关闭DevEco Studio，并清理~/Library/Huawei（Windows路径为C:\Users\xxx\AppData\Local\Huawei）路径下对应DevEco Studio版本的缓存。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.48399077447258742845021381661797:50001231000000:2800:BBCA114EB74E538D4EF917EA2EB140A11710322D0A821C8FA9035B6253F9FEB4.png)
    
3. 单击**Next**，设置设备相关的参数。该功能从DevEco Studio 6.0.0 Beta1版本开始支持。
    
    - **Name**：设置模拟器的名称。
    - **Screen Profile**：模拟器屏幕配置参数，可点击下拉框选择预置的机型配置，也可点击**Customize**自定义配置，在自定义配置的情况下可以对屏幕尺寸、分辨率和DPI进行修改，取值范围参考界面提示。
        - **Screen size：**屏幕的对角线长度，单位为英寸。
        - **Resolution**：分辨率，包括横向像素数量和纵向像素数量。
        - **DPI**：像素密度，DPI 越高，UI组件占用的像素点越多，从而提供更精细的显示效果。
    - **Memory**：设置模拟器的内存。
    - **Storage**：设置模拟器的存储空间。
    
    确认所有参数后，点击**Finish**创建模拟器。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.03638161339931971803955377500457:50001231000000:2800:2B1AC2D593EBB039596DDBDD996530C2A3BFD39243F2EC95DBABEAD1AF85DD5D.png)
    
4. 在设备管理器页面，单击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.03928192550639788218523810423864:50001231000000:2800:EA4467A36B2F168A6BD418C2C3134ECBE52416E5B836896586A811DAD89D2ED2.png)启动模拟器。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.41534708540020853644485604372213:50001231000000:2800:FDB95347C00FC57CACF0D889090592CB410E0BAF90D393DB083C7C180C919D9D.png)
    
5. 单击DevEco Studio的**Run > Run'模块名称'**或![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.18182097114881126591351040492292:50001231000000:2800:5AA3441AC7A3646310719EFE62ACD2BAC36869B3B81257D9E3788B728B6094A1.png)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155837.68091143927206647602032235376147:50001231000000:2800:CB7C366E0FF3A144EDD726B9E0558F300900A6E49D673C864F8B6971EFCA4A49.png)
    
6. DevEco Studio会启动应用/元服务的编译构建与推包，完成后应用/元服务即可运行在模拟器上。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155838.43013227424197323542543080836711:50001231000000:2800:0F6D6E1C406D0AB2143C991B6F1119453D60CB7318F5C6B929B76910604A7500.png)
    

[管理模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-management "管理模拟器")

[启动和关闭模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-start-and-close "启动和关闭模拟器")
# 启动和关闭模拟器

更新时间: 2025-12-16 15:58

在设备管理器页面，单击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.45387875142683932247728301003843:50001231000000:2800:B71B57CDF1A2BEF7766C8614709344BE682A409D03171D25C2858728FEF50B37.png)即可启动模拟器。模拟器启动时会默认携带上一次运行时的用户数据，包括用户上传的文件，安装的应用等。如果是新创建的模拟器，则不会携带用户数据。如果想清除上一次运行时的用户数据，点击**Actions >** ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.82949237282997555207066745300852:50001231000000:2800:C1E0536A11898002977FF1B093F428341B94DE9EB10B029390A1CE5BC35A5E51.png) **> Wipe User Data**。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.75541625950524459426785438534941:50001231000000:2800:1A3E4F8599EF1352831238C7180E28610F5CA62B8EC04EE44594F4494CB1D1F2.png "点击放大")

在模拟器运行期间，可以点击**Actions >** ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.11077824638639791576319828003549:50001231000000:2800:FCE868AC952C0DCC34973A8CEC319647A2E6966776711C005DE0249DE87577EA.png) **> Show on Disk**显示模拟器在本地生成的用户数据。点击**Actions >** ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.92082699900410239225556189751708:50001231000000:2800:2EEA9A7D32564C83E2651FF0FECA79E4E858933833FB953F91DD8EE4BF32E628.png) **> Generate logs**可以生成模拟器自启动到此刻的所有日志信息。想要关闭运行时的模拟器，可以在设备管理器页面点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.47307081516475048549005015361182:50001231000000:2800:49634D9A442F409A7DD64AAE2E8D6F873C4AD776E079B6BAF475E7DC76408E6A.png)，或者点击模拟器工具栏上的关闭按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155840.86843067498259953860525038824222:50001231000000:2800:8860CEE5799D65489737FA7EA6EA84F9C4775D2E32FD2BBEDD628BD3F5B8323C.png)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.45352989955589105560857734508914:50001231000000:2800:CD8C430CA26D5D63EA86504D77B8FA2F39AFF0E472233EF9AA6606C1BEC891F5.png "点击放大")

模拟器关闭后，点击**Actions >** ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.77697742215449203999826711275312:50001231000000:2800:A386A33038D6494E4FBE5D001B707ADDA845141F8109BA303BBB5D3A75EE3A2C.png) **> Delete**可以删除模拟器，并清除模拟器的用户数据和配置信息。

[创建模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-create "创建模拟器")

[使用模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-use "使用模拟器")
# 操控屏幕

更新时间: 2025-12-16 15:58

当模拟器运行时，您可以使用鼠标来模拟手指和设备屏幕进行交互，同时可以结合键盘来实现高级的屏幕操作，对应关系如下：

|常用操作|描述|
|:--|:--|
|滑动屏幕|将鼠标放置屏幕上方，按住鼠标左键，在屏幕上轻扫，然后释放。|
|拖动项目|将鼠标放置屏幕中的项目上方, 按住鼠标左键，移动项目，然后释放。|
|单击屏幕|将鼠标放置屏幕上方，按住鼠标左键，然后释放。|
|双击屏幕|将鼠标放置屏幕上方，快速双击鼠标左键，然后释放。|
|长按屏幕|指向屏幕上的一个项目，按下鼠标左键，保持一段时间，然后释放。|
|输入文字|鼠标点击输入域，随后您可以使用计算机键盘或屏幕上弹出的软键盘在模拟器中键入文字。|
|双指缩放|Windows系统按下Control键（macOS上的Command）会弹出一个捏合手势多点触控界面。单击鼠标左键模拟按住双指，并释放鼠标左键模拟松开双指。鼠标充当第一个手指，穿过锚点是第二个手指。拖动光标以移动第一个点。|
|垂直滑动|在屏幕上打开一个垂直菜单，使用鼠标滚轮滚动菜单项。单击菜单项可进行选择。|
|复制粘贴|在计算机上复制一段文本后，您可以在模拟器屏幕的文本输入框内进行粘贴。可支持复制的最大文本长度为30000英文字符，超过该长度会对文本进行截断。<br><br>从DevEco Studio 6.0.1 Beta1版本开始，支持在计算机和模拟器之间互相复制粘贴。|

[使用模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-use "使用模拟器")

[使用工具栏](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-toolbar "使用工具栏")
# 使用工具栏

更新时间: 2025-12-16 15:58

工具栏上集成了模拟器的各种调试工具和控制选项，其中的扩展菜单栏包含了更加丰富的扩展功能。注意，部分工具栏按键需要在模拟器开机亮屏后才能使用。以下对工具栏的各个按键功能作简要说明：

|按键|功能描述|
|:--|:--|
|关闭![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.21663509935017566374641978392517:50001231000000:2800:50B2D197143FBA05DB9F549AAD40ACD0C91A11069CD10F23039FA9A23B07725C.png)|关闭模拟器。|
|最小化![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.46256104552347823048388676264126:50001231000000:2800:DF6E8D0A81E64F71EE0E8C658213640441CB0F06CC49569101A01412FF9CB062.png)|最小化模拟器窗口。|
|更多![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.59326452345062239319256212681542:50001231000000:2800:B479B7246DA3768F54C349DB64AB17BB19E8656D23D3C80AAC2777A76F78F5A8.png)|打开侧边扩展菜单。|
|置顶![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.48118454443520622644844195788988:50001231000000:2800:8F98F88E7A47D4E67A90B755B50D70741099A0B1E4C06BAE56354341AFFC47BF.png)|将模拟器置于所有打开窗口的顶层。|
|左旋转![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.46347797419737119918752667015291:50001231000000:2800:10651FC0A4E67F78789C13DCD7C5911AECA6F026150B527AD6BBD83CCCB7A2FB.png)|将设备屏幕逆时针旋转90度。|
|右旋转![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.41279959240204216614763945461961:50001231000000:2800:69F0E47C0545BFF0D67D77837049DAA859B1964049CFB2595B52880A95EEA23C.png)|将设备屏幕顺时针旋转90度。|
|增大音量![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.16126153739314496896849585328554:50001231000000:2800:1B8A0382867D28A2E4BB2EC8E69BD9E241E47150D175D5624F5254C8D221DFFC.png)|调高设备音量，长按可持续调高设备音量。|
|减小音量![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.63421737914068878450122077096705:50001231000000:2800:3219A65B785BD876CBF8A3123DDF0B6B279383A0A5521493DCCE036C229FB0F0.png)|调低设备音量，长按可持续调低设备音量。|
|截屏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.61976877405270584611438827264451:50001231000000:2800:B9A8E5A4ABBB3A27C0905AEDBD6D3AA0C022F393B90FA83843CC755CA7583D5B.png)|生成当前屏幕的截图，并将图片保存在本地计算机。|
|返回![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.88691231485733005860349635118481:50001231000000:2800:4A142A6FEC1A10A4A74D59FE9ECDDEA119758F00C0BB1834C9007DB027106993.png)|返回上一屏幕或关闭对话框、选项菜单、通知面板或屏幕键盘。|
|主屏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.62755733244739721714020992322857:50001231000000:2800:DE0732C48F74752FEFA911078BB316A70ED71863E0526595A38ADA88F1EA0E46.png)|返回Home界面。|
|最近![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.17453998518363703575452646072016:50001231000000:2800:206512A8BB5D4E45D28F4E29714B4047730B3613E6EC94AD5D137AF32FBF379E.png)|点按可打开最近使用过的应用的缩略图列表。要打开某个应用，请点按其缩略图。要从列表中删除缩略图，请向上滑动缩略图。|
|摇一摇![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.37166147545079472622006265864708:50001231000000:2800:E6A4D2DEAD4D44D08B8D79A6AC0165E4591EC45B07B158D662AE5FBC3CB13310.png)|触发设备摇一摇操作，详情参考[摇一摇](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features#section1241612419541)。|
|多屏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.49318518067504477075635591596875:50001231000000:2800:98A9C397EB1C18BC4C90252CBC98D050F18872C9BAC5FAD720C324D6DCE8533D.png)|打开多屏面板，可以动态增删屏幕，详情参考[模拟器多屏能力](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features#section9744191415368)。|
|电池![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.20560052187239411983148890235930:50001231000000:2800:F38AF69518B994337136C9F65B28E97198E45C0D85C00EC6F3826CABB922FDC3.png)|打开电池模拟面板，详情参考[电池](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features#section169214910812)。|
|GPS![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155841.64768973096989866355883250864631:50001231000000:2800:5B6887F5E784ACD128C6F2489CC19CF5379553F94C9A5B9D2B76C90116D3B465.png)|打开GPS模拟面板，详情参考[GPS定位](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features#section81566471211)。|
|虚拟传感器![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.03935817865615210665174642338922:50001231000000:2800:2637F90342395E39CEF1D5AD75C0E7CD3C65D6A852EFE98A05F19D930AB38574.png)|打开虚拟传感器面板，详情参考[虚拟传感器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features#section830415558395)。|
|网络代理![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.94393971268596272142071535567909:50001231000000:2800:0046425D6FB229AB757AD46936E6C007F075117D47218D99410C63758CCCE454.png)|打开网络代理面板，详情参考[网络代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features#section206461549731)。|
|设置![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.88847204676085137405961599363560:50001231000000:2800:313B310F3FA259F1F9B6936536C60F4040080EF6305C4111A3694641617B66D3.png)|打开设置面板。可设置模拟器主题、截屏保存路径、模拟器使用语言。|
|Bug报告![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.25043374349595073384131327607836:50001231000000:2800:F55C75EB46745AD31C9F2FB6D213EB981F2D5184190752702876D97AB08FE70C.png)|打开Bug报告面板。点击**保存并发送**按钮可以将Bug日志传递给我们。|
|关于![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.62454412015140312254618841147772:50001231000000:2800:3A0E2A8532FF0A81B83DCF9E60CB1045CAC43C42D29DD1536CE5A8E951258E7C.png)|打开关于面板。可以查看模拟器相关信息及许可证。|
|展开![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.83250063686511815817375160702150:50001231000000:2800:7A32DF088B375BE51D8CC03512F433D3D6F8829BC40980E8E7DEED63763F32B5.png)|仅支持可折叠设备。切换设备形态至展开态。|
|悬停![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.19778386455676634634488291835648:50001231000000:2800:B654EFDBD2EA8BB08D1144A987797000D90B62FAC5BFE33219E7B5897A445D3E.png)|仅支持可折叠设备。切换设备形态至悬停态，并显示折痕避让区。|
|折叠![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.37600738704859076926985069876982:50001231000000:2800:480C47ADCCC1EA014F3575ED12F66F1F26457A566F830D3F23E252F6E4014A76.png)|仅支持可折叠设备。切换设备形态至折叠态。|
|三屏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.38495533488729339041373656304065:50001231000000:2800:AB5ADCC7AC11F878023E6F8133FE05B1E12EC3190ECDCB9C049830D9C58634E0.png)|仅支持三折叠设备。切换设备形态至三屏状态。|
|双屏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.55768012127392758098790396406985:50001231000000:2800:D172CB2EF979C5280F4579F1C92D2FD9E05CC28D7BD6850B271BC131A0A2F1F7.png)|仅支持三折叠设备。切换设备形态至双屏状态。|
|单屏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.32744078910350015692110996278311:50001231000000:2800:E4CF7FB4BE696773B891AE43E4CF641733FE0BAF21E43FE7BA18259E7BD9FD93.png)|仅支持三折叠设备。切换设备形态至单屏状态。|
|横展![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.72595588656542193594425013827761:50001231000000:2800:C17C1F18D8E783E53F7761146FCFF0C14B56B076B179AC5193B20E036CCA859D.png)|仅支持折叠PC设备。切换设备形态至横展状态。|
|竖展![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.98303786962846804653272950213679:50001231000000:2800:CFFE3E755B434B4A919B92589FC80766F1B814E9F8E6017E04A143AC4A9BDA2C.png)|仅支持折叠PC设备。切换设备形态至竖展状态。|
|悬停![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.96503501557062918661089514395131:50001231000000:2800:67C82B065CCF81A2604E0EA98AF0F2A55E06DF2ACB0CA829F79F6DDA48E0F2E1.png)|仅支持折叠PC设备。切换设备形态至悬停状态。|
|磁吸![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155842.36103839994607992818196774901692:50001231000000:2800:DA4390733D19BE09D10954800D223198EB4CBACDE56CD644B0C3EED00BFA15D6.png)|仅支持折叠PC设备。切换设备形态至磁吸状态。|

[操控屏幕](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-control-screen "操控屏幕")

[移动和缩放模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-move-and-zoom "移动和缩放模拟器")
# 移动和缩放模拟器

更新时间: 2025-12-16 15:58

- 移动模拟器
    
    您可以使用鼠标拖动模拟器到屏幕的指定位置。首先将鼠标放在屏幕边缘，当鼠标变成![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155843.83918086088653632177752927652123:50001231000000:2800:87C69A62020AFADC15582EDC5CF4075CD0C80EEF71DE7A62A15EBA8FA359E743.png)样式，按住鼠标左键并移动即可拖动模拟器。当模拟器被拖动到期望位置后，松开鼠标左键即可停止拖动。
    
- 缩放模拟器
    
    如需改变模拟器大小，将鼠标放到屏幕四角的任意一处，当鼠标变成![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155843.24675216984621571139677585717739:50001231000000:2800:85830E65160D2EBBFA7BFD7DC567DC40315581C99CD87287913BB6E3FB646BAE.png)，按住鼠标左键并移动即可缩放模拟器。当模拟器被缩放到期望大小后，松开鼠标左键即可完成缩放。
    

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155843.76918805261974334494208571394584:50001231000000:2800:DBCF6E64FA091D8158BEB899BB4A0F4342246D60FFD6D5460494FC6C22F5EE45.gif "点击放大")

[使用工具栏](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-toolbar "使用工具栏")

[模拟器访问网络](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-access-network "模拟器访问网络")
# 模拟器访问网络

更新时间: 2025-12-16 15:58

## 模拟器访问互联网

模拟器可以通过本地计算机的网络直接访问互联网。

如果连接失败请参考：[模拟器无法连接网络](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-26) 和 [使用模拟器发起https请求时如何安装数字证书](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-27)。

说明

由于模拟器的虚拟以太网一直处于连接状态，断开本地计算机的网络或模拟器内的WiFi，无法使模拟器进入网络完全断开的状态。

## 模拟器访问本机网络

在本地计算机上建立网络服务端，模拟器可以通过10.0.2.2:<localPort>访问本地计算机服务端，其中10.0.2.2为模拟器的默认网关。

## 两个模拟器实现互相访问

如果两个模拟器需要进行通信互联，请按如下步骤进行设置。

1. 在本地计算机上，运行模拟器A和模拟器B，模拟器本机IP为10.0.2.15。
2. 在模拟器B上设置服务端，使其监听10.0.2.15:<serverPort>。
3. 在本地计算机上，设置从本地计算机localhost:<localPort>到模拟器B 10.0.2.15:<serverPort>的重定向，如：
    
    1. hdc -t 127.0.0.1:5555 fport tcp:<localPort> tcp:<serverPort>
    
    该命令中127.0.0.1:5555为模拟器B的HDC服务端口号，可通过hdc list targets命令查询。
    
4. 在模拟器A上，设置客户端连接到10.0.2.2:<localPort>，其中10.0.2.2为模拟器的默认网关。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155846.92661774713212520728770585230370:50001231000000:2800:E12FB1A88B06F36C1AD32B4C622521EA18CD726414A4458894E619936E1C907E.png)

[移动和缩放模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-move-and-zoom "移动和缩放模拟器")

[安装应用程序包和上传文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-install-upload "安装应用程序包和上传文件")
# 安装应用程序包和上传文件

更新时间: 2025-12-16 15:58

- 安装应用程序包
    
    您可以将本地的HAP包安装到模拟器上，只需要将本地的HAP包拖动到屏幕上即可进行安装，支持一次性拖拽安装多个HAP包。模拟器也支持安装包含HSP文件的应用，只需要将HSP和HAP一起拖动到屏幕上即可进行安装。
    
    您也可以在命令行窗口进入DevEco Studio安装目录的sdk\default\openharmony\toolchains目录下，使用hdc app install命令安装包。安装完成后，可在应用列表里查看已安装的应用。
    
- 上传文件
    
    您可以将本地文件上传到模拟器中，只需要将文件拖动至模拟器屏幕上即可。模拟器支持批量上传文件，上传的文件存放在虚拟设备的/storage/media/100/local/files/Docs/Download/目录下。您可以在模拟器上打开**文件管理 > 我的手机 > 下载**查看上传的文件。
    
    此外，您也可以在命令行窗口进入DevEco Studio安装目录的sdk\default\openharmony\toolchains目录下，使用hdc file send命令上传文件。
    

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155847.06483076962319642185540586301903:50001231000000:2800:9E5703F296E14D2A733270AAD96A24EAEB22B88126878A7E8A79579E079D7F78.gif "点击放大")

[模拟器访问网络](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-access-network "模拟器访问网络")

[更多的扩展能力](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-more-features "更多的扩展能力")
# 更多的扩展能力

更新时间: 2025-12-16 15:58

## 电池

您可以在模拟器上模拟不同电池状态。在扩展菜单栏上点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.83588355371687866031538329170839:50001231000000:2800:25FC922E0B57604D9CD21C10EB7E65472924B249F93DD1B9E4DA111ED45DDEC9.png)打开电池模拟界面。在该界面，您可以手动输入或拖动滑块来改变电量百分比，也可以点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.56774037411692397777708515559080:50001231000000:2800:3E99B3D0873DC0B112D7B12D1A196AF676B0DEF6FB56D9F3180E1232584B973A.png)切换电池的充电/放电状态。电池具有以下三种充电状态：

- ENABLE：开启充电按钮，此时正在充电且电量没充满。
- NONE：关闭充电按钮，此时停止充电。
- FULL：开启充电按钮，且电量为100%，电量已充满。

在应用中，您可以通过[@ohos.batteryInfo](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-battery-info)模块查询模拟器的剩余电量以及充电状态。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.91019226651472789785983545025498:50001231000000:2800:7726E48BA938D0DCD51A74312C86405A333A6DA34C77070B5684A7C6BA657630.gif "点击放大")

## GPS定位

模拟器可以模拟设备所处的位置。您可以打开扩展菜单，并点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.00855201678657489456710003688164:50001231000000:2800:B52045C1BAF0E22163F87D31FA1C8BB5444A7B291D41826CED29DCA1C1F9D73F.png)进行位置信息的设置。模拟器提供以下方式的GPS位置模拟：

- 手动设置：在该界面，您可以手动输入此时所处位置的经度，纬度，海拔以及方位角。您也可以通过点击城市下拉框，快速定位到所选城市。
- 导入：在导入界面您可以注入一段时间内的连续位置信息。点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.27459413559106024130400789288946:50001231000000:2800:755BC4B662DA28619E91951A67C61BF4E68C7AA2B7018A9E893BA46A5C688719.png)导入本地的GPX文件，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.44674710004427689282688093374923:50001231000000:2800:F9D4628CD3515A37E75163CD92B2132E367E08DFE23291392FCB5DC422A7EBD3.png)即可开始模拟GPX文件中的轨迹。此外，您还可以选择不同回放速率来改变移动的速度。
- 场景模拟：如果没有本地的GPX文件，您可以在场景模拟界面使用我们预置的GPX文件。我们在模拟器内部预置了户外跑步、户外骑行、驾驶导航三种场景的GPX文件，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.46080697471064992138567210229113:50001231000000:2800:7BB67D93C39E535C5D9F7F7F5867A3785114971544199A8CDCBD65A8B6529F95.png)即可开始轨迹模拟。
    
    说明
    
    场景模拟功能仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。
    

在应用中，您可以通过[@ohos.geoLocationManager](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-geolocationmanager)模块获取模拟器的位置信息。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.76459915823527676332366984716798:50001231000000:2800:30DC333BB5DABA95BA461B8AC5F81980CF9C00870AA4B71686329577F919F6B9.gif "点击放大")

## 虚拟传感器

模拟器提供了虚拟传感器来模拟硬件传感器的能力。在扩展菜单上点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.64899767607111340267297408326935:50001231000000:2800:F58144C48A501CFCBFAA4AD3FED56820E149AA1BED75680FE149D8D4E77A6448.png)打开虚拟传感器界面。在该界面，您可以调节不同的传感器来测试您的应用，使用[@ohos.sensor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-sensor)模块监听传感器值的变化。模拟器提供以下虚拟传感器：

- 计步传感器：用于测量步数，对应的SensorId为PEDOMETER
- 环境温度传感器：用于测量环境温度，对应的SensorId为AMBIENT_TEMPERATURE
- 湿度传感器：用于测量湿度，对应的SensorId为HUMIDITY
- 环境光传感器：用于测量光照强度，对应的SensorId为AMBIENT_LIGHT

您可以拖动滑动条或者直接在文本框输入来改变不同传感器的值。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.98634733768950606071970755699668:50001231000000:2800:444BA6E8B306D9C0854ECD49CA7E9CF3BFF91EB0DEC22A183D887CBB42F5C8D4.png)

## 网络代理

说明

该功能仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。

模拟器可以将网络请求代理到代理服务器，利用代理服务器去请求目标服务器。从而满足以下开发场景：

- 开发者处于内网环境，希望通过设置代理的方式访问外网；
- 开发者已经在DevEco Studio上配置了网络代理，不希望在模拟器上重复配置代理；
- 开发者需要将网络请求代理到三方抓包工具，方便查看请求信息。

您可以打开扩展菜单，并点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.08783215015365711728827124249475:50001231000000:2800:7C3F3FD1ACE23AA90F876185D1151981CEADC7B9214B221EB2A4B5880DA2F905.png)进行代理的配置。模拟器提供以下三种代理模式：

- 使用DevEco Studio代理：读取并应用DevEco Studio上的网络代理配置，在**DevEco Studio > Preferences/Settings**（Windows上为**File >Settings**） **> Appearance&Behavior>System Settings>HTTP Proxy**下（模拟器不支持**HTTP Proxy**下的**no proxy for**功能），无需在模拟器上重复配置。同时模拟器会去监听DevEco Studio侧代理配置的更改，从而进行代理配置的同步。当DevEco Studio选择的是自动代理模式或者是SOCKS代理方式时，模拟器不支持，会切换到无代理模式。
- 无代理：不使用代理，即发送网络请求时会直接去请求目标服务器。
- 手工配置代理：配置代理服务器的信息，将网络请求代理到代理服务器上。

以上的代理配置需要点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.16834350973058136041275876997301:50001231000000:2800:E2C37304FA1CC474A02A5C204CD060E185F184AC92D36B13FDEAE18F40E979BA.png)按钮生效，同时可以通过点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155849.72544323005297522676023730743920:50001231000000:2800:B2CCAF1757459687ADD0A20E69B0F0EA441359BAB7FDA77E0A1FD52D1F953739.png)按钮对当前的代理配置进行校验。在发起https请求时，需要安装网站的数字证书，请参考[使用模拟器发起https请求时如何安装数字证书](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-27)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.37218535466320548125916927435006:50001231000000:2800:CAADA3F7A968834D2C72E9C718BC96B1D24ADED79035CB7AC173C3980D25377A.png "点击放大")

## 摇一摇

模拟器可以模拟用户对设备的摇一摇操作。点击工具栏上的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.72823897720999084883981350875345:50001231000000:2800:49095CA572C963AEBE2419867EC49C04C57A1AC0CB6474B48BFE8700A5E986E4.png)，您可以模拟时长为1s的摇一摇操作。您的应用可以通过[@ohos.sensor](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-sensor)模块监听加速度传感器变化，当加速度传感器的变化量达到设定阈值时，触发摇一摇对应的业务逻辑。

说明

仅phone和tablet类型的设备支持摇一摇。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.41877007485531449479355536406480:50001231000000:2800:BD3B1ECB22E6469223FDAE5C792B2FCE8377E1513743A0AB9A32D7F3AD555685.gif "点击放大")

## 音频输入

模拟器当前仅支持Audio Kit（音频服务）提供的音频输入能力，您可以使用本地计算机上的麦克风设备向模拟器中传输音频数据。使用步骤如下：

1. 首先，请确保本地计算机已连接上麦克风设备。
2. 应用调用Audio Kit提供的API接口（如AudioCapturer、OHAudio）开始接收音频数据。
3. 使用本地麦克风进行语音输入。

模拟器上的应用在调用相关API时，推荐使用如下格式的音频流信息格式，以保证清晰流畅的音质。

|音频流信息|推荐值|
|:--|:--|
|samplingRate（采样率）|48000Hz|
|channels（通道数）|2|
|sampleFormat（采样格式）|带符号的16位整数|
|encodingType（编码格式）|PCM编码|

## 相机

从DevEco Studio 5.1.0 Release版本开始，模拟器支持Camera Kit（相机服务）提供的预览和拍照能力，您可以使用本地计算机上的摄像头在模拟器上实现拍照和预览功能。

1. 请确保本地计算机上存在可用的摄像头，不支持通过USB连接的摄像头。
2. 应用调用Camera Kit提供的API接口，通过电脑摄像头展现拍摄画面、拍照。
    
    说明
    
    使用模拟器开发相机时，[相机配置信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-camera-i#profile)请使用：RGBA_8888格式、1280 * 720分辨率。
    

## 表冠

穿戴模拟器可以模拟表冠功能。

- 鼠标单击表冠：根据当前所在页面，单击后跳转到表盘或桌面。
- 鼠标双击表冠：进入多任务管理界面。
- 在屏幕上使用鼠标滚轮：模拟表冠旋转。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.22397957369867372442588360631099:50001231000000:2800:3D92A26D179F7FFEA0AC97B9A54F4BE3A948C8D429C7F86F5CAA7CE70674324D.png "点击放大")

## 模拟器多屏能力

从DevEco Studio 6.0.0 Beta1版本开始，模拟器可以使用多屏能力，基于同一个镜像创建不同分辨率、DPI的多屏幕模拟器，满足开发者快速测试不同分辨率、DPI场景下的UI布局等需求。

### 使用约束

- 模拟器旋转功能和多屏功能互斥，不能同时使用。
- 仅phone类型的模拟器支持多屏能力。从DevEco Studio 6.0.1 Beta1版本开始，新增tablet类型的模拟器支持多屏能力。
- 多屏状态下扩展屏不支持使用画中画功能。

### 添加屏幕

1. 启动模拟器，点击工具栏的多屏按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.10076681331612615574267191110975:50001231000000:2800:FB7DEBDA6E19A3C93A88F24F11C78B8C76982FBEBDD9863D2472222F9E56D689.png)，打开多屏界面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.13097097203651472610502974348949:50001231000000:2800:F2C163267DA7E63771F72EB4424CBB09169A0364D038B89BD90CAF83EF5C1C8B.png)
    
2. 点击**添加**，可以选择Mate系列、Pura系列、Nova系列等产品型号，点击**应用**即可添加对应的屏幕。
    
    默认情况下，所有的屏幕是整体拖动和缩放的，如需单独拖动和缩放单个屏幕，请勾选界面上的**每个副屏在独立窗口中显示**，并点击**应用**按钮。从DevEco Studio 6.0.1 Beta1版本开始支持。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.53721356903129545722497838116751:50001231000000:2800:9524513F9B27CC647CF32E30A2C4F6D6DFF1A91D8E90E6D686D2EB405CBA54B6.png)
    
3. 如需在多个屏幕上同时启动应用，请按界面提示，将module.json5中的launchType字段配置为multiton，具体请参考[UIAbility组件启动模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-launch-type)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.09721199952821173111333763401806:50001231000000:2800:79EBC679DEAD074F985289B4E4BA69721C0770F3EEAF247D3DFA07D659956536.png)
    

### 修改屏幕参数

如需自定义屏幕分辨率、DPI或尺寸，可以在多屏界面上直接修改屏幕参数，取值范围参考界面提示，修改后点击**应用**。

- **Width**：横向像素数量。
- **Height**：纵向像素数量。
- **DPI**：像素密度，DPI 越高，UI组件占用的像素点越多，从而提供更精细的显示效果。
- **Size：**屏幕的对角线长度，单位为英寸。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.90949041405167859971799360350425:50001231000000:2800:CECCF8B70D7F0149670AE3C7B2CD9385228D9219BC515D8EE45CD45B9EA2DA0D.png)

### 使用扩展屏

- 点击扩展屏，再点击模拟器工具栏返回按键![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.89159388485956520914556485235434:50001231000000:2800:A7F83843E32420B09F03D10B81FD0231093B85D4098F382C26E960BE7730EA59.png)，即可返回上一级目录。按键主屏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.15957499857358626287719518516556:50001231000000:2800:A9A7764DB50F7377C28AA33E2B84CDC7643B101D48F0B0AAAC8A2F3497984332.png)和最近![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.25690866702747356368943476706831:50001231000000:2800:F5CC61F527426E31F3AB85E505170BF11636DB452CE7D82CAF52B6C99B37EE02.png)暂不支持在扩展屏上使用。
- 从扩展屏底部上滑，可直接清除应用。

### 删除屏幕

点击多屏界面上的删除按钮![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.43465778359783314162434915260830:50001231000000:2800:8D6F892320B2DFCA9D232AE96E6CC408DF537B6A9C5CF9303FD6F6D6E7597B15.png)，再点击**应用**，即可删除一块屏幕。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155850.35866261167146874803677728281634:50001231000000:2800:6482A91051AF3DAF9771B0AB0CB5C31E3E301AE1CEE3C59AC24B573AC444FD1D.png)

[安装应用程序包和上传文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-install-upload "安装应用程序包和上传文件")

[修改模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-modify "修改模拟器")
# 通过命令行使用模拟器

更新时间: 2025-12-16 15:58

除了在DevEco Studio的设备管理中使用模拟器外，开发者还可以通过Emulator命令行使用模拟器，支持Windows和macOS平台。

## 环境准备

Emulator命令行在DevEco Studio安装目录的tools/emulator目录下，有两种执行命令的方式。

- 方式一：在命令行终端中进入emulator目录下，执行命令。
- 方式二：配置环境变量后，在任意目录下执行命令。
    - Windows环境变量设置方法：
        
        在系统或者用户的PATH变量中，添加Emulator的路径{DevEco Studio安装目录}/tools/emulator。
        
    - macOS环境变量设置方法：
        
        打开命令行终端，执行以下命令。
        
        1. export PATH={DevEco Studio安装目录}/tools/emulator:$PATH
        

## 前置条件

在使用命令行之前，需要先通过DevEco Studio创建模拟器，记录模拟器实例路径和模拟器镜像路径，具体请参考[创建模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-create)。

## 模拟器命令

说明

- 如果模拟器名称或路径中包含特殊字符、空格等，需要对名称或路径添加引号。
- 下列命令以Windows环境为例，如果在macOS上运行，并且未配置环境变量，需要在Emulator前添加./，例如./Emulator -help。

### 获取帮助

1. # 查看所有可执行的命令
2. Emulator -help

### 启动模拟器

1. Emulator -hvd {模拟器名称} -path {模拟器实例路径} -imageRoot {模拟器镜像路径} -hdcport {hdc端口号}

**表1** 参数列表
|参数|参数说明|
|:--|:--|
|-hvd|必选参数，模拟器名称。|
|-path|必选参数，模拟器实例路径。|
|-imageRoot|必选参数，模拟器镜像路径。|
|-hdcport|可选参数，hdc端口号，支持范围10000-16555。从DevEco Studio 6.0.1 Beta1版本开始支持。|

**示例：**

1. Emulator -hvd "my Emulator" -path D:\Emulator -imageRoot D:\Sdk

说明

如果在DevEco Studio中使用模拟器时需要登录开发者账号，那么该版本的模拟器无法通过命令行启动，请在DevEco Studio界面上启动。

### 关闭模拟器

1. Emulator -stop {模拟器名称}

**示例：**

1. Emulator -stop "my Emulator"

### 收集模拟器日志

模拟器在启动状态下，可以收集日志。

1. # {日志zip文件存放路径}需要指定.zip后缀
2. Emulator -logZip {模拟器名称} -logPath {日志zip文件存放路径}

**示例：**

1. Emulator -logZip "my Emulator" -logPath D:\EmulatorLog\20250730.zip

### 查看模拟器实例

从DevEco Studio 6.0.0 Beta3版本开始支持。

1. Emulator -list

### 查看模拟器版本

1. Emulator -version

[自定义屏幕配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-customize-screen-configuration "自定义屏幕配置")

[模拟器错误码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-emulator-faqs "模拟器错误码")
# 创建HarmonyOS应用工程

更新时间: 2025-12-16 15:57

## 新建工程

### 前提条件

- 您已使用[已实名认证](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-account)、且注册地为中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）的华为开发者账号登录DevEco Studio。
- 请确保您的华为开发者账号无欠款，账户欠费将导致云存储服务开通失败。

### 选择模板

1. 选择以下任一种方式，打开工程创建向导界面。
    - 如果当前未打开任何工程，可以在DevEco Studio的欢迎页点击“Create Project”开始创建一个新工程。
    - 如果已经打开了工程，可以在菜单栏选择“File > New > Create Project”来创建一个新工程。
2. 在“Application”页签，选择合适的云开发模板，然后点击“Next”。
    
    说明
    
    当前仅支持通用云开发模板（[CloudDev]Empty Ability）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.79600635581905896613258903958813:50001231000000:2800:95DE772A452C8FB4631AB532F0F6A6DBC3BA2E9B86B8D6182FF56F5D5846C7BA.png)
    

### 配置工程信息

1. 在工程配置界面，配置工程的基本信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.09106814919654489668258390741342:50001231000000:2800:EBFE43C0634201AC1682095F86B669C88F78DA160015D50A0DFE63D7E10CDF8B.png)
    
    |参数|说明|
    |:--|:--|
    |Project name|工程的名称，由大小写字母、数字和下划线组成。|
    |Bundle name|软件包名称，需保证唯一，且需与您在AGC创建的HarmonyOS应用的“应用包名”一致。|
    |Save location|工程文件本地存储路径，由大小写字母、数字和下划线等组成，不能包含中文字符。|
    |Compatible SDK|兼容的最低API Version。<br><br>使用基于Cloud Foundation Kit（云开发服务）的端云一体化开发功能，请选择5.0.0(12)或以上版本。|
    |Module name|模块名称。|
    |Device type|该工程模板支持的设备类型，目前仅支持手机设备。|
    |Enable CloudDev|是否启用云开发。云开发模板默认启用且无法更改。|
    

2. 点击“Next”，开始关联云开发资源。

### 关联云开发资源

为工程关联云开发所需的资源，即将您账号团队在AGC创建的同包名应用关联到当前工程。具体操作如下：

1. （可选）如您尚未登录DevEco Studio，点击“Sign In”，在弹出的账号登录页面，使用[已实名认证](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-account)的华为开发者账号完成登录。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.04968833567941547639261639896174:50001231000000:2800:3B49AA3789626A93139404F76A255137490DC11EB1899EA478AAFB232C1C5D13.png)
    
    登录成功后，界面将展示账号昵称。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.46252818223802355025715375411905:50001231000000:2800:6B854D119AB5347E14715735D49BCEDE5A5FCBB8C9B1867BEC0187413720CB2D.png)
    
2. 点击“Team”下拉框，选择开发团队。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.96784172007457244545840063411660:50001231000000:2800:7E573ACB3208A21C347C38E6B40BE531A568CCA3E87FA16527A9E27B4B4A27C9.png)
    
3. 关联应用。
    
    选中团队后，系统根据工程Bundle name在该团队中自动查询AGC上的同包名应用。
    
    - 如查询到应用，选中该应用，点击“Finish”即可。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.19778197266601023168405275463498:50001231000000:2800:78D25981863A478E2A21A3FA5CCB11AB2FEBBA90B71CB78A6D61395785BAB030.png)
        
    - 如查询到的应用尚未关联任何项目（即为游离应用），则无法选中。请先[将游离应用添加到AGC项目下](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-appproject#section152521927193013)。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.46645413620803103514499056286310:50001231000000:2800:4990DA48B7CBDC91FCEC9ABCFEC81366AAE6D86DA84A19D7BB47273AD0843C31.png)
        
    - 如果查询到的应用所属项目尚未启用数据处理位置，请点击界面提示内的“AppGallery Connect”[设置数据处理位置](https://developer.huawei.com/consumer/cn/doc/app/agc-help-datalocation-0000001160439813)。设置完成后返回DevEco Studio界面，点击Bundle name后的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.22309878715300224231410186422492:50001231000000:2800:471CF7502E055FE04F6577FA8770D7BA9567C2F7FCF447ACA0FB0A69BC82508B.png)刷新当前APP ID列表，即可看到设置的数据处理位置。
        
        注意
        
        - 由于云开发目前仅支持中国站点，请确保项目启用的数据处理位置包含中国站点。
        - 无论项目启用的默认数据处理位置为哪个站点，后续开发的云服务资源都将部署在中国站点。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.90233515267212782252103874340610:50001231000000:2800:B96AD69DF9406CDE76113B4CF011EDE6C61211445884FAD996A4EA196EEB18E5.png)
        
    - 如查询到应用但出现如下提示，表明查询到的应用类型为元服务，与当前工程类型不一致。请修改以确保当前工程与AGC上同包名应用均为HarmonyOS应用类型。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.55527931854692162934025286125557:50001231000000:2800:74BD50732C6A0689DD5A920BF15E68F72B503F008D0009EECB936DA6257894F9.png)
        
    
    - 如在当前团队中未查询到同包名应用，请先确认填写的包名是否有误。
        
        - 如包名有误，点击界面提示中的“go back”返回工程信息配置界面进行修改。
        - 如包名无误，则表明当前团队尚未在AGC控制台创建与当前工程包名相同的应用。您可点击界面提示中的“AppGallery Connect”，[前往AGC控制台进行补充创建](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-appproject#section397317130308)。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.05745156566973796578653032830764:50001231000000:2800:0FBA31346FF14714DCD9610E99048B47122AE0964F76E88AA6B1FC260BE96062.png)
        
        完成以上操作后，DevEco Studio即可获取到同包名应用信息。选中应用后，点击“Finish”。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155748.62885876124172032709536547015914:50001231000000:2800:0A9FABB4E0FECC2C84B76F20EF0B2B2BFBBFA72A5AD742293E7E2ABFDDF3672A.png)
        
4. 如您所属的团队尚未签署云开发相关协议，点击协议链接仔细阅读协议内容后，勾选同意协议，点击“Finish”。
    
    说明
    
    只有账号持有者和法务角色才有权限签署协议。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.13185191075503770384826604850715:50001231000000:2800:2C8778746AEBEBF554E34854F1ED0A788843375BDAB3F8683E8232C62C55C247.png)
    
5. 进入主开发界面，DevEco Studio执行工程同步操作，端侧工程会自动执行“ohpm install”，云侧工程会自动执行“npm install”，以分别下载端侧和云侧依赖。
    
    说明
    
    若云侧执行“npm install”失败，请排查是否尚未[配置NPM代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-environment-config#section197296441787)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.58025678440190351870759122932311:50001231000000:2800:188E35BC2A3EE957429152C1788DA057FE30404DBB2CDAC1EEFA1D9E8F8296C3.png)
    
6. 在主开发界面，可查看刚刚新建的工程。关于工程的详细目录结构介绍，请参见[端云一体化开发工程目录结构](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-appproject#section20250910164411)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.89984585890931198496864436717181:50001231000000:2800:E6D59C1A429CDF1D6E8B0B6321D1D3819884810AADC7073143ACE791768931C0.png)
    

## 工程初始化配置

当您成功创建工程并关联云开发资源后，DevEco Studio会为您的工程自动执行一些初始化配置。

### 自动开通云开发服务

DevEco Studio为工程关联的项目自动开通云函数、云数据库、云存储等云开发服务，您可在“Notifications”窗口查看服务开通状态。

说明

- 如服务开通失败，您可通过[CloudDev云开发管理面板](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-console)快捷进入AGC控制台进行手动开通。
- 如云存储服务自动开通与手动开通均失败，可能是账户欠费导致。请您[检查账户是否余额不足](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-account-bill-0000001200817917#section813072912208)，[补齐欠款](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-account-recharge-0000001126625360)后再前往AGC控制台进行手动开通。

## 端云一体化开发工程目录结构

端云一体化开发工程主要包含端开发工程（Application）与云开发工程（CloudProgram）。

### 端开发工程（Application）

端开发工程主要用于开发应用端侧的业务代码，通用云开发模板的端开发工程目录结构如下图所示。“Application/cloud_objects”模块用于存放云对象的端侧调用接口类，“src/main/ets/pages”目录下包含了云存储、云数据库和云函数页面，其他目录文件介绍请参见[工程目录结构](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-project-structure)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.26739765724565654296781574654314:50001231000000:2800:43162DD3B3EE4CFAC8B3CE0BA64FD3DABBF892A3BED73DBB65A0B1B96C211FC0.png)

### 云开发工程（CloudProgram）

在云开发工程中，您可为您的应用开发云端代码，包括云函数和云数据库服务代码。通用云开发模板的云开发工程目录结构如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.05554049389182174904484470665450:50001231000000:2800:8A9EAD8469959C85C53417F9985F4C139FBED37CCFC05F633FC7738E75DAC7F2.png)

- clouddb：云数据库目录，包含数据条目目录（dataentry）和对象类型目录（objecttype）。
    - dataentry：用于存放数据条目文件。
        
        该目录下一般会根据您选择的云开发模板预置数据条目示例文件。在通用云开发模板工程中，该目录下会预置名为“d_Post.json”的数据条目示例文件，内含两条示例数据。您可按需使用、修改或删除。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.65818031514088143696980910099302:50001231000000:2800:8FF22149FABAC3385899FD212897E8B1AF59502FF5214FA9FC8365238024BEF8.png)
        
    - objecttype：用于存放对象类型文件。
        
        该目录下一般会根据您选择的云开发模板预置对象类型示例文件。在通用云开发模板工程中，该目录下会预置名为“Post.json”的对象类型示例文件，内含对象类型“Post”的权限、索引、字段名称和字段值等。您可按需使用、修改或删除。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.11060082129160393148411388468060:50001231000000:2800:A33CEBE43B7B848DD253BD2F94F14CE03F9C7514BCBB4560C68AF82D59B9D555.png)
        
    - db-config.json：模块配置文件，主要包含云数据库工程的配置信息，如默认存储区名称、默认数据处理位置。
- cloudfunctions：云函数目录，包含各个云函数/云对象子目录。每个子目录下包含了云函数/云对象的配置文件、入口文件、依赖文件等。
    
    该目录下一般会根据您选择的云开发模板预置示例函数。通用云开发模板工程下预置了一个用于生成UUID的示例云对象“id-generator”，您可按需使用、修改或删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.94293990687352680285306043751250:50001231000000:2800:A6C9681DE53425D4D0F2EEFEF99DDB5AE26955C8B3B3C9168A9079ED933A50A5.png)
    
- node_modules：工程同步时执行“npm install”生成，包含“typescript”和“@types/node”公共依赖。
- cloud-config.json：云开发工程配置文件，包含应用名称与ID、项目名称与ID、启用的数据处理位置、支持的设备类型等。
- package.json：定义了“typescript”和“@types/node”公共依赖。
- package-lock.json：工程同步时执行“npm install”生成，记录当前状态下实际安装的各个npm package的具体来源和版本号。

## （可选）AGC应用管理

### 从DevEco Studio补充创建同包名应用

如创建工程时，发现尚未在AGC控制台创建与工程包名相同的应用，可进行补充创建。

1. 点击界面提示内的“AppGallery Connect”，浏览器打开AGC控制台页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.91654240188293103973679882255946:50001231000000:2800:4F4360EAF12E4537AEDF50A35272952C8EE1725BE5051E9AD9AAB5F583AE3668.png)
    
2. 在“应用开发基础信息”页面，填写待创建的应用信息，完成后点击“下一步”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.00426337137573088170794093654724:50001231000000:2800:FE52BF21C23FC4C2EAC3501A654B47128478161742B35B7FF324FB55B76D71E5.png)
    
    |参数|说明|
    |:--|:--|
    |应用类型|创建的HarmonyOS应用形态，默认与您本地工程类型保持一致，不可更改。|
    |应用名称|应用在华为应用市场详情页展示的名称。|
    |应用包名|从DevEco Studio中带入自动填充，且不可更改。|
    |应用分类|请选择普通应用或游戏类应用。<br><br>说明<br><br>应用分类设置后不支持修改，请谨慎选择。|
    
3. 进入“所属项目信息”页面，为应用选择所属的项目后点击“下一步”。
    
    - 如需将应用添加到已有项目，点击下拉框进行选择。
    - 如需将应用添加到新项目，直接在框中填写新项目名称。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.09403337511118861079209499164839:50001231000000:2800:BBC309EB22F7C72916F61F4697CDF5F404EE493721B39587B6186DBD00586BC3.png)
    
4. 进入“云开发数据处理位置”页面，设置或管理项目的数据处理位置。
    - 如项目尚未设置数据处理位置：
        1. 点击“启用”。
            
            ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.25887511605284306915318961641732:50001231000000:2800:9AD9BA6F72E7849FB557078C242DC7507C3EE1CC08FB1B158BE995CEDF2FE610.png)
            
        2. 仔细阅读提示框的文字说明后，在“启用”栏为您的项目勾选一个或多个数据处理位置，并在“设为默认”栏将其中一个设置为默认数据处理位置。
            
            注意
            
            启用的数据处理位置必须包含中国站点。
            
            ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.48953691115978972873506320144540:50001231000000:2800:4BB6BA477D5E9AEA5928E399B23AE2E925812975F45950EB66F9789E54F4DBC2.png)
            
    - 如项目已设置过数据处理位置，可点击“管理”启用新的数据处理位置、取消已启用的数据处理位置，或修改默认数据处理位置。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.35634169834506782786978179773238:50001231000000:2800:3C71FBDB534675BC8DE4973C69F0CD6B76BCA50636657E2BECDC124DF82CA832.png)
        
5. 点击“确认”，应用创建完成。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.99694691054037837303988949035666:50001231000000:2800:7DF8A60710B2514372392D89662C726274FD3D557D32728C9E03C593A3CCDBAA.png)
    
6. 返回DevEco Studio，可看到界面已获取并展示了刚刚创建的应用信息。若不展示，可点击Bundle name后的![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155749.95422172943089818171874434273892:50001231000000:2800:683F26075DF47B3CBD6B260012787A41E7494869BA6BAA801689DD7CF111D8B7.png)刷新。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.82285921831418952191230390269815:50001231000000:2800:F8476950293750DE9E727E15D5EA26B906CDEBB30D236521864376985421A6DE.png)
    

### 将游离应用添加到AGC项目下

游离应用指未关联任何AGC项目的应用。创建工程时，如需要关联的AGC应用为游离应用，则您需要将该应用添加到您的AGC项目下。

注意

应用与项目的关联关系一旦创建则无法再修改，请谨慎操作。

1. 点击“Not associated yet”，或点击界面下方提示内的“AppGallery Connect”，可打开AGC控制台“开发与服务”页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.60903032257795107976231438694545:50001231000000:2800:1E626ABC0ADCAD6261292E934A2B9654D662823A9BCB058303576429BDBCF5C6.png)
    
2. 点击选择希望为应用关联的项目，或者点击“添加项目”新建一个项目。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.04809654818357657037847163127416:50001231000000:2800:E181237385E3F2660513BD2C5E6D5C16A4970772E667D7204981C159124C2262.png)
    
3. 如选择了新建一个项目，设置项目名称，点击“确认”。
    
    如选择了已有项目，则忽略此步骤。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.64953810466875571569545453711725:50001231000000:2800:B72CE5D4FBC2B160AA3FA773BBD9DB1EF6205B0C5D7B9D57E3476677BF38B35A.png)
    
4. 设置或管理项目的数据处理位置。
    - 如项目尚未设置数据处理位置：
        1. 点击“启用”。
            
            ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.23579299828330905476898557230758:50001231000000:2800:0E99B95B084F396D4F458C06C4DC57AB2B8D93DA70D785CD3D3324964EF0867F.png)
            
        2. 仔细阅读提示框的文字说明后，在“启用”栏为您的项目勾选一个或多个数据处理位置，并在“设为默认”栏将其中一个设置为默认数据处理位置。
            
            注意
            
            启用的数据处理位置必须包含中国站点。
            
            ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.14842160459851708955058791692846:50001231000000:2800:7BE29341F8469394830FF2BC81C6999D99D5C67FF99E8DD2E5920EE65F66D992.png)
            
    - 如项目已设置过数据处理位置，可点击“管理”启用新的数据处理位置、取消已启用的数据处理位置，或修改默认数据处理位置。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.68408943126992713958694126826552:50001231000000:2800:D06C4AF820EA79043336008AAF4274F559FE191C8C535C9DFE14E1879E313732.png)
        
5. 点击“确认”，应用成功关联项目。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.82760883425287818385889458424475:50001231000000:2800:A6D0CE1FFA2A6BB0E77E02BFAEDABCE3934E46D1C46253DC208D6AD3E1E07D60.png)
    
6. 返回DevEco Studio，可看到应用已关联上了项目。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155750.36920958218481230619902061616431:50001231000000:2800:5ED9657F8C38FCCDA2D85F20658CE35E061EA431659AD5472E7DC2FE9A121790.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-devproject "创建端云一体化开发工程")
# 创建元服务工程

更新时间: 2025-12-16 15:57

## 新建工程

### 前提条件

- 您已使用[已实名认证](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-account)、且注册地为中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）的华为开发者账号登录DevEco Studio。
- 请确保您的华为开发者账号无欠款，账户欠费将导致云存储服务开通失败。

### 选择模板

1. 选择以下任一种方式，打开工程创建向导界面。
    - 如果当前未打开任何工程，可以在DevEco Studio的欢迎页点击“Create Project”开始创建一个新工程。
    - 如果已经打开了工程，可以在菜单栏选择“File > New > Create Project”来创建一个新工程。
2. 点击“Atomic Service”页签，选择合适的云开发模板，然后点击“Next”。
    
    说明
    
    当前仅支持通用云开发模板（[CloudDev]Empty Ability）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.22049203275612152534644681538035:50001231000000:2800:695AF3FB8C175A0DF39EEFD1A3E0FE08D64D9312A63766D6A2B5A31FFD8C5458.png)
    

### 关联云开发资源

为工程关联云开发所需的资源，即将您账号团队在AGC创建的元服务关联到待创建工程。具体操作如下：

1. （可选）如您尚未登录DevEco Studio，点击“Sign In”，在弹出的账号登录页面，使用[已实名认证](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-account)的华为开发者账号完成登录。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.92761315675236902163777029122570:50001231000000:2800:F23E87676666C6986D3237850913E45574A644C6AD49A8664B32C373A4971857.png)
    
    登录成功后，界面将展示账号昵称。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.45154794798658751641474045503488:50001231000000:2800:42D2D0A76098993EAF00C7AB216E30C502D55DE08DA6DDDEAEF48E62C85E4137.png)
    
2. 选择已登录账号下的APP ID，以关联AGC上的元服务。
    
    - 从APP ID下拉列表中选中所需的APP ID后，界面会展示该元服务在AGC控制台的名称、所属项目、包名与数据处理位置。确认无误后，点击“Next”。
        
        说明
        
        元服务包名为自动生成，格式为固定前缀与appid的组合（com.atomicservice.[appid]）。不符合命名规范的包名无法在APP ID下拉列表中展示。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.97315914944044832088405602764847:50001231000000:2800:2E44F014E140AF940239BCF8744B0856CA92FF900ECB116E64E4D1C0FCD2E270.png)
        
    
    - 当出现以下场景时，您可点击“Register App ID”，[前往AGC控制台补充创建元服务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-faproject#section397317130308)。创建成功后返回DevEco Studio界面，即可看到新建的元服务信息。
        
        - APP ID框为空，即当前账号尚未在AGC控制台创建任何元服务。
        - 您需为待创建工程关联一个新的元服务。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.82880155826175568318779981700426:50001231000000:2800:1E7252437144E9ACEDCCD3BBC200C9E1D6E1A2CB875E8226EBE78DD17C2DD821.png)
        
    - 如查询到的元服务尚未关联任何项目，则无法选中。请先[将游离元服务添加到AGC项目下](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-faproject#section152521927193013)，再返回DevEco Studio界面操作。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.26521933433004547871190043743385:50001231000000:2800:EEF60534713D0A6BC57EEE7E8F2F5222C9FD7A695D6FAAA0BCC86ACCA6076F1D.png)
        
    
    - 如果查询到的元服务所属项目尚未启用数据处理位置，请点击界面提示内的“AppGallery Connect”[设置数据处理位置](https://developer.huawei.com/consumer/cn/doc/app/agc-help-datalocation-0000001160439813)。设置完成后返回DevEco Studio界面，点击“Refresh”刷新当前APP ID列表，即可看到设置的数据处理位置。
        
        注意
        
        - 由于云开发目前仅支持中国站点，请确保项目启用的数据处理位置包含中国站点。
        - 无论项目启用的默认数据处理位置为哪个站点，后续开发的云服务资源都将部署在中国站点。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.74609894718131148022707359392380:50001231000000:2800:A6F692650FC33CBBE6765A17940890CAAB2F61EC51DD0E3F840E1626D529E916.png)
        
    

### 配置工程信息

1. 进入工程配置界面，配置工程的基本信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.23185552798255858351829252801055:50001231000000:2800:930B47772B47E6F1C1D9B251DCB098EE7009543542073C81A061BE9CCC622C44.png)
    
    |参数|说明|
    |:--|:--|
    |Project name|工程的名称，由大小写字母、数字和下划线组成。|
    |Bundle name|创建元服务时自动生成，不支持手动修改。|
    |Save location|工程文件本地存储路径，由大小写字母、数字和下划线等组成，不能包含中文字符。|
    |Compatible SDK|兼容的最低API Version。<br><br>元服务使用基于Cloud Foundation Kit（云开发服务）的端云一体化开发功能，请选择5.0.0(12)或以上版本。|
    |Module name|模块名称。|
    |Device type|该工程模板支持的设备类型，目前仅支持手机设备。|
    |Enable CloudDev|是否启用云开发。云开发模板默认启用且无法更改。|
    

2. 点击“Finish”，进入主开发界面，DevEco Studio执行工程同步操作，端侧工程会自动执行“ohpm install”，云侧工程会自动执行“npm install”，以分别下载端侧和云侧依赖。
    
    说明
    
    若云侧执行“npm install”失败，请排查是否尚未[配置NPM代理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-environment-config#section197296441787)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.65085991566600370786968295906752:50001231000000:2800:75A1C9BAA2C791EA550DB16A9D90254C903C6CF026C2CD6365B5F800537AFB90.png)
    
3. 在主开发界面，可查看刚刚新建的工程。关于工程的详细目录结构介绍，请参见[端云一体化开发工程目录结构](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-faproject#section20250910164411)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.47619446026878472776362751035481:50001231000000:2800:687DB46B8AD36B59CEBBEFFD6A2E69D3678A49F974CE8CCA40A05EF03BFB8FEC.png)
    

## 工程初始化配置

当您成功创建工程并关联云开发资源后，DevEco Studio会为您的工程自动执行一些初始化配置。

### 自动开通云开发服务

DevEco Studio为工程关联的项目自动开通云函数、云数据库、云存储等云开发服务，您可在“Notifications”窗口查看服务开通状态。

说明

- 如服务开通失败，您可通过[CloudDev云开发管理面板](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-console)快捷进入AGC控制台进行手动开通。
- 如云存储服务自动开通与手动开通均失败，可能是账户欠费导致。请您[检查账户是否余额不足](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-account-bill-0000001200817917#section813072912208)，[补齐欠款](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-account-recharge-0000001126625360)后再前往AGC控制台进行手动开通。

## 端云一体化开发工程目录结构

端云一体化开发工程主要包含端开发工程（Application）与云开发工程（CloudProgram）。

### 端开发工程（Application）

端开发工程主要用于开发应用端侧的业务代码，通用云开发模板的端开发工程目录结构如下图所示。“Application/cloud_objects”模块用于存放云对象的调用接口类，“src/main/ets/pages”目录下包含了云存储、云数据库和云函数页面，其他目录文件介绍请参见[工程目录结构](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-project-structure)。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155752.80520404672928882817424043447963:50001231000000:2800:2ECDCF6BBF64ED101C6E9B9C77DD2E046D4775DAB56B759FF62EB23CB4A4C77F.png)

### 云开发工程（CloudProgram）

在云开发工程中，您可为您的元服务开发云端代码，包括云函数和云数据库服务代码。通用云开发模板的云开发工程目录结构如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.55033108513751341851344033240296:50001231000000:2800:F86A7DC7C6425D6406E8D546745944BDD3D20A2BFDF27CCA55066831CB5B1210.png)

- clouddb：云数据库目录，包含数据条目目录（dataentry）和对象类型目录（objecttype）。
    - dataentry：用于存放数据条目文件。
        
        该目录下一般会根据您选择的云开发模板预置数据条目示例文件。在通用云开发模板工程中，该目录下会预置名为“d_Post.json”的数据条目示例文件，内含两条示例数据。您可按需使用、修改或删除。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.44926810331125522865893627698957:50001231000000:2800:A31472FD0606DCABE293556840FECB761DDCC57CD525AD6C1DD97D3D20234874.png)
        
    - objecttype：用于存放对象类型文件。
        
        该目录下一般会根据您选择的云开发模板预置对象类型示例文件。在通用云开发模板工程中，该目录下会预置名为“Post.json”的对象类型示例文件，内含对象类型“Post”的权限、索引、字段名称和字段值等。您可按需使用、修改或删除。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.12545969390383319922372190934581:50001231000000:2800:F212DDA677E0C0F96EACBCDAD128B6AB4841F47EF30D8087E8E598989831FFFF.png)
        
    - db-config.json：模块配置文件，主要包含云数据库工程的配置信息，如默认存储区名称、默认数据处理位置。
- cloudfunctions：云函数目录，包含各个云函数/云对象子目录。每个子目录下包含了云函数/云对象的配置文件、入口文件、依赖文件等。
    
    该目录下一般会根据您选择的云开发模板预置示例函数。通用云开发模板工程下预置了一个用于生成UUID的示例云对象“id-generator”，您可按需使用、修改或删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.62959246847683245517044094369095:50001231000000:2800:5428E31DADE020FA6B7295666865A30D8C183438D0488FDD637B280EA4E8EEA9.png)
    
- node_modules：工程同步时执行“npm install”生成，包含“typescript”和“@types/node”公共依赖。
- cloud-config.json：云开发工程配置文件，包含应用名称与ID、项目名称与ID、启用的数据处理位置、支持的设备类型等。
- package.json：定义了“typescript”和“@types/node”公共依赖。
- package-lock.json：工程同步时执行“npm install”生成，记录当前状态下实际安装的各个npm package的具体来源和版本号。

## （可选）AGC元服务管理

### 从DevEco Studio补充创建元服务

如创建元服务工程时，发现尚未在AGC控制台创建对应的元服务，可直接从DevEco Studio进行补充创建。

1. 点击“Register App ID”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.07801216629980392786699126225209:50001231000000:2800:4B3871872FAB72879F6F3BEF3AB0C54C441F3CCDE8C9C78C588E57A24D1E234F.png)
    
2. 在弹窗中填写待创建的元服务信息后，点击“OK”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.21908308395150269028131723703753:50001231000000:2800:9692690C1552D80F47438F58FCAFDA64705AF397611034AA14491177A1D02758.png)
    
    |参数|说明|
    |:--|:--|
    |Project|为当前元服务选择所属的项目。可以输入一个新项目名称，或在下拉框中选择已有项目。|
    |App type|应用形态。默认为“AtomicService”，不支持修改。|
    |App name|元服务在华为应用市场详情页展示的名称。|
    |App category|应用分类。元服务暂不支持游戏类别，请选择“App”。<br><br>说明<br><br>应用分类设置后不支持修改，请谨慎选择。|
    
3. 返回DevEco Studio界面，可查看到刚刚创建的元服务的名称及APP ID、所属项目及项目ID、包名、数据处理位置。
    
    说明
    
    若元服务关联的是一个新建项目或者尚未启用数据处理位置的已有项目，则还会提示尚未启用数据处理位置，参考[上文](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-faproject#li58931263712)处理即可。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.63829788964561050764731113453302:50001231000000:2800:43D0494BF2A3BBF627E6C595DC4BC7D808A8FA083CE2ECADD89EDC26FF146F4B.png)
    

### 将游离元服务添加到AGC项目下

游离元服务指未关联任何AGC项目的元服务。创建工程时，如需要关联的AGC元服务为游离状态，则您需要将该元服务添加到您的AGC项目下。

注意

元服务与项目的关联关系一旦创建则无法再修改，请谨慎操作。

1. 点击“Not associated yet”，或点击界面下方提示内的“AppGallery Connect”，可打开AGC控制台“开发与服务”页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.07606077430602321534420774081240:50001231000000:2800:510B74EC2E5A5884BF36427B7B4486776EA490813802AB8D5BEF4142A4271DA6.png)
    
2. 点击选择希望为元服务关联的项目，或者点击“添加项目”新建一个项目。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.22972333898490651116792084138821:50001231000000:2800:445E41C9CD31535F9FA612BB726BD88124CC37ED4F839A7E608FD207CDAB165B.png)
    
3. 如选择了新建一个项目，设置项目名称，点击“确认”。
    
    如选择了已有项目，则忽略此步骤。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.82178835541070298312572301625007:50001231000000:2800:D7967D9E2C35877CE602F2C45163A547666528DD4786764CE23F82B1DDEC1A78.png)
    
4. 设置或管理项目的数据处理位置。
    - 如项目尚未设置数据处理位置：
        1. 点击“启用”。
            
            ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.39145209084376842144268631936797:50001231000000:2800:23A8329516193133447C1D01C19219ADC6F7245D55C161BB6DAE6E59E74A7D9D.png)
            
        2. 仔细阅读提示框的文字说明后，在“启用”栏为您的项目勾选一个或多个数据处理位置，并在“设为默认”栏将其中一个设置为默认数据处理位置。
            
            注意
            
            启用的数据处理位置必须包含中国站点。
            
            ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.81543814712950213615276392596579:50001231000000:2800:13808F0594397948E2A71EE8ED9CF78A69C3E9B1AEA64B918D5069AB2E2C0F20.png)
            
    - 如项目已设置过数据处理位置，可点击“管理”启用新的数据处理位置、取消已启用的数据处理位置，或修改默认数据处理位置。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.75789320553542914779058627808349:50001231000000:2800:C4F0196F40C10B6D4C13E93E7DDF5A37544CE31D238C20151C7F76B1890A9B03.png)
        
5. 点击“确认”，元服务成功关联项目。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.98258676870375502987915990320492:50001231000000:2800:FD1E3B90DCBE846031778B938CB5040FD97FA0BEA6C56A9CBA73D8AA70071B0D.png)
    
6. 返回DevEco Studio，点击“Refresh”刷新，可看到元服务已关联上了项目。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155753.13281887693946892547573538673065:50001231000000:2800:32C7C2A7C8DDD4E7D6296A57E61A4D7FCD8ECDB07B96D87EA985DB9BE6CD19FA.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-appproject "创建HarmonyOS应用工程")
# 历史工程转换为端云一体化开发工程

更新时间: 2025-12-16 15:57

如您此前已经创建了非端云一体化开发工程，希望直接转换为端云一体化开发工程，可执行如下操作：

说明

DevEco Studio NEXT Beta1版本之前的非端云一体化历史工程，在转换前需先进行[一体化工程迁移](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ide-integrated-project-migration-V14)。

1. [创建一个端云一体化开发工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-devproject)，其中工程的类型（HarmonyOS应用或元服务）必须与您历史工程类型一致，同时Bundle name必须指定为您历史工程的Bundle name。在创建端云一体化开发工程过程中，该Bundle name会关联到AGC应用、项目等云端资源。
2. 打开创建的端云一体化开发工程，右击端开发工程“Application”，选择“Open In > Explorer”，打开工程文件所在的目录。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155754.72114179069147137584679119664436:50001231000000:2800:AE33EA07BB739C5FBBE06BACF6E55B212E2B4C61CC5F2F37D4F98886B8591A7D.png)
    
3. 删除端云一体化开发工程的端侧工程目录“Application”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155754.17662145483806537855478340885019:50001231000000:2800:45920C1454202E4B20144FD9373A6A4746B96DD75AF7CC70462B87C33C400C62.png)
    
4. 将历史工程目录（如“MyApplication30”）拷贝至[步骤3](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-project-migration#li104559101267)的端云一体化开发工程目录下，并改名为“Application”。
5. 重新打开端云一体化开发工程，可发现历史工程的端侧代码已迁移至端云一体化开发工程。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-create-faproject "创建元服务工程")
# 开发流程

更新时间: 2025-12-16 15:57

云函数是一项Serverless计算服务，可以根据函数的实际流量对函数进行弹性收缩。您只需聚焦业务逻辑，开发与上传业务模块相关的函数，云函数即可为您自动完成资源分配、代码部署、负载均衡等工作，既提高了开发和上线函数的速度，也保证了函数的高可用性。

云函数当前分为传统云函数和云对象两种类型，本章节仅介绍传统云函数，了解云对象详情请参考[开发云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudobj)。

使用DevEco Studio在端云一体化云侧工程下开发云函数，总体流程如下。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155754.65568840935962363876448632076344:50001231000000:2800:81018B6177A41C46652260A5B47468991F983FA30880A8B7871DE6C4E2561AD4.png "点击放大")

1. [创建并配置函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-createfunc)：您可直接在DevEco Studio创建函数、为函数配置入口以及调用的触发器等。
2. [开发函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-funccoding)：函数创建并配置完成后，您便可以开始编写函数业务代码了。
3. [调试函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugfunc)：您可以对函数进行调试，以测试函数代码运行是否正常。
4. [部署函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deployfunc)：完成函数代码开发与调试后，您可将函数部署到AGC云端，支持单个部署和批量部署。

说明

一般建议先将函数调试无误后再部署至云端，但某些业务场景下需要先部署函数才能进行调试。请根据实际业务需要操作。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudfunctions "开发云函数")
# 创建并配置函数

更新时间: 2025-12-16 15:57

您可直接在DevEco Studio创建函数、为函数配置调用的触发器等。

## 创建函数

1. 右击“cloudfunctions”目录，选择“New > Cloud Function”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.10559866167505149469186875889865:50001231000000:2800:E95182784612EDF6ED6CD7B644DB01A9A6114EF8C377ED8126DD74798635ABE6.png)
    
2. 在“Select the Cloud Function Type”栏选择“Cloud Function”，输入云函数名称（如“my-cloud-function”），点击“OK”。
    
    函数名称长度2-63个字符，仅支持小写英文字母、数字、中划线（-），首字符必须为小写字母，结尾不能为中划线（-）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.86573017809628721735664219850360:50001231000000:2800:5D50510CE9755514D992F7598432ED186760C87B6CC2ED3D19C7C16598FB4FF1.png)
    
    “cloudfunctions”目录下生成新建的“my-cloud-function”函数目录，目录下主要包含如下文件：
    
    - 函数配置文件“function-config.json”
    - 函数入口文件“myCloudFunction.ts”
    - 依赖配置文件“package.json”
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.53458648776495118804064806163552:50001231000000:2800:2D7453701B01947818BD96E4C8481E6867758E010A3F98E4DF6A248BB7740BC3.png)
    

## 配置函数

函数创建完毕后，您可在配置文件“function-config.json”的“triggers”下配置触发器，通过触发器暴露的触发条件来实现函数调用。

说明

“functionType”表示函数类型，“0”表示云函数，“1”表示云对象。“functionType”的值为创建时自动生成，不可手动修改，否则将导致云函数部署失败。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.32981496705305715965328359294964:50001231000000:2800:BDE7A983FAAAC2FE10B5EF3311C642355A26F2D19A5F33E6256E2EA4698BB88A.png)

云函数当前仅支持HTTP触发器， “function-config.json”文件中已为您自动完成HTTP触发器配置。配置了HTTP触发器的函数被部署到云端后，您的应用即可通过Cloud Foundation Kit调用函数。关于如何使用HTTP触发器调用函数，请参见[调用函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-call-function)。

注意

如您需在函数部署完成后更新触发器，请先删除之前的触发器配置，再添加新的触发器配置，否则您的更新将不生效。

1. {
2.   "type": "http",
3.   "properties": {
4.     "enableUrlDecode": true,
5.     "authFlag": "true",
6.     "authAlgor": "HDA-SYSTEM",
7.     "authType": "apigw-client"
8.   }
9. }

- type：触发器类型，配置为“http”。
- properties：触发器属性，属性参数如下表所示。
    
    |参数|说明|
    |:--|:--|
    |enableUrlDecode|通过HTTP触发器触发函数时，对于contentType为“application/x-www-form-urlencoded”的触发请求，是否使用URLDecoder对请求body进行解码再转发到函数中。<br><br>- true：启用。<br>- false：不启用。|
    |authFlag|是否鉴权，默认为true。|
    |authAlgor|鉴权算法，默认为HDA-SYSTEM。|
    |authType|HTTP触发器的认证类型。<br><br>- apigw-client：端侧网关认证，适用于来自APP客户端侧（即本地应用或者项目）的函数调用。<br>- cloudgw-client：云侧网关认证，适用于来自APP服务器侧（即云函数）的函数调用。|
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-functionprocess "开发流程")
# 开发函数

更新时间: 2025-12-16 15:57

函数创建并配置完成后，您便可以开始编写函数业务代码了。

1. 打开函数入口文件，编写函数代码。关于开发函数代码的更详细信息，请参考[开发函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-develop-function-nodejs)。
    
    此处我们以函数“my-cloud-function”为例，构造一个用于返回时间戳的函数。
    
    1. /**
    2.  * Describe the basic method of Cloud Functions
    3.  */
    
    4. let myHandler = function(event, context, callback, logger){
    5.     // example of display environment variables
    6.     let env1 = context.env.env1;
    
    7.     // example of display logs
    8.     logger.info("Test info log");
    9.     logger.warn("Test warn log");
    10.     logger.debug("Test debug log");
    11.     logger.error("Test error log");
    
    12.     logger.info("--------Start-------");
    13.     try {
    14.         let startTime = new Date().getTime();
    15.         let endTime = startTime;
    16.         let interval = 0;
    17.         startTime = process.uptime() * 1000;
    
    18.         // print input parameters and environment variables
    19.         logger.info("request: " + JSON.stringify(event.request));
    20.         logger.info("env1: " + env1);
    
    21.         endTime = process.uptime() * 1000;
    22.         interval = endTime - startTime;
    23.         logger.info("intervalTime: " + interval);
    24.         logger.info("--------Finished-------");
    
    25.         let res = new context.HTTPResponse(context.env, {
    26.             "res-type": "context.env",
    27.             "faas-content-type": "json",
    28.         }, "application/json", "200");
    29.         res.body = {"intervalTime": interval};
    30.         callback(res);
    31.     } catch (error) {
    32.         logger.error("--------Error-------");
    33.         logger.error("error: " + error);
    34.         callback(error);
    35.     }
    36. };
    
    37. module.exports.myHandler = myHandler;
    
    注意
    
    云函数与云函数之间是相互独立的，部署至云侧时，只会部署所选云函数目录下的文件，不可在一个云函数中通过import '../anotherDirectory/xxx'的方式引入依赖。如果有多个云函数公共的配置，建议存储在云数据库中，通过云数据库Server API类查询出公共配置；也可以将多个云函数整合成一个云对象，将公共配置变成云对象的私有配置。
    

2. （可选）如函数存在依赖关系，可在“package.json”文件的“dependencies”下添加需要的依赖，然后点击右上角“Sync Now”。
    
    下文以添加“@hw-agconnect/cloud-server”依赖为例进行说明，请添加实际业务所需的依赖。
    
    说明
    
    右击“package.json”文件，选择“Run 'npm install'”菜单，也可以实现依赖包安装。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.46232991599764175789957889982253:50001231000000:2800:5A74EEF7B0C149CC68A136617594C84AE360AFD98E2009648B6FEAEA69A4E29A.png)
    
    所有安装的依赖包都会存储在当前函数的“node_modules”目录下。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.03250659709478578724757587264929:50001231000000:2800:6C6C67C5F700EA41714FA077847DBDE82E686394768246190203EFA0305E3119.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-createfunc "创建并配置函数")
# 调试函数

更新时间: 2025-12-16 15:57

函数开发完成后，您可以对函数进行调试，以验证函数代码运行是否正常。

目前DevEco Studio函数调试支持本地调用和远程调用，请根据实际场景选择使用：

- [通过本地调用方式调试函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugfunc#section248615546567)：在DevEco Studio调试本地开发好的函数。支持单个调试和批量调试，并支持Run和Debug两种模式，调试功能丰富，常在函数开发过程或问题定位过程中使用。
- [通过远程调用方式调试函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugfunc#section123191549587)：先将函数部署至AGC云端，然后直接在DevEco Studio调用云端函数。此方式主要用于测试函数在云端的运行情况、或补充测试因各种因素限制未能在本地调用方式中发现的问题。

## 前提条件

- 请确保您已登录。
- 如果您的工程有代码逻辑涉及云函数调用云数据库，您需在调试前先[将整个云工程部署到AGC云端](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploy)，否则云端将没有相关数据及环境变量。

## 通过本地调用方式调试函数

您可在DevEco Studio调试本地开发好的函数，支持单个调试和批量调试，并支持Run和Debug两种模式。

- 单个调试和批量调试流程相同，区别仅在于：单个调试是一次只为一个函数启动本地调试，之后只能调用该函数；批量调试是一次为“cloudfunctions”目录下所有函数启动本地调试、然后逐个调用各个函数。
- Run模式和Debug模式的区别在于：Debug模式支持使用断点来追踪函数的运行情况，Run模式则不支持。

下文以Debug模式下调试单个函数“my-cloud-function”为例，介绍如何在DevEco Studio调试本地函数。

1. 右击“my-cloud-function”函数目录，选择“Debug 'my-cloud-function'”。
    
    说明
    
    - 直接从当前路径下Debug，使用的是默认的Debug配置，您也可[自定义Debug配置](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugfunc#section65830284215)。自定义Debug配置后再从此路径下Debug，将优先采用自定义Debug配置。
    - 如需批量调试多个函数，右击“cloudfunctions”目录，选择“Debug Cloud Functions”，即可启动该目录下所有函数。如“cloudfunctions”目录下同时存在云函数和云对象，将会启动所有的云函数和云对象。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.18859910487465051755593777060082:50001231000000:2800:CFAE65BE50EC1E01A628EE2D2E51862777329A644CC4DE2B830BF20A2F54E7BC.png)
    
2. 在下方通知栏“cloudfunctions”窗口，查看调试日志。如果出现“Cloud Functions loaded successfully”，表示函数成功加载到本地运行的HTTP Server中，并生成对应的Function URI。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.18171215111667214174016332569486:50001231000000:2800:5660FD44563C7DCFA2021F2580984F23EE78BA0D8C9122E6278EB0318CCF8A07.png)
    
3. 如需设置断点调试，在函数代码中选定要设置断点的有效代码行，在行号（如下图行15）后单击鼠标左键设置断点（如下图的红点）。
    
    设置断点后，调试能够在断点处中断，并高亮显示该行。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.35113355087590711123398266102040:50001231000000:2800:A07127CEAD45EE62FAB4CC7DD94D5E9EAEF1B9237FC0FD82CC2D09297757A71E.png)
    
4. 在菜单栏选择“View > Tool Windows > Cloud Functions Requestor”，使用事件模拟器（Cloud Functions Requestor）触发函数调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.30526958353288303449200454381278:50001231000000:2800:795EA93170DA4C3DFE6D089DA43A54F2377FC58FE561B3A87EA80375AC7F5075.png)
    
5. 在弹出的“Cloud Functions Requestor”面板，配置触发事件参数。
    
    - Cloud Function：选择需要触发的云函数，此处以函数“my-cloud-function”为例。
    - Environment：选择函数调用环境。此处选择“Local”，表示本地调用。
    - Event：输入事件参数，内容为JSON格式请求体数据。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.06845850879859970653940400674370:50001231000000:2800:203EB11FFC370F408FC7546431C493ADE1D35221574B0F69BA31BE57109C3DA6.png)
    
6. （可选）点击“Save”，可保存当前触发事件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.35505199646554105657236321670345:50001231000000:2800:21A1F2486F17C0B645384FBBD1332E6B4F669790EC70DDC8D86E0A0C48B065BC.png)
    
    点击右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.20872526377964682314257655244148:50001231000000:2800:FDF1C8A7C1F817024CF50FC7F9F3E2E951928F8FD662E95493D5A83B3F3B4BE9.png)可展开保存的触发事件，后续可直接点击“Load”加载事件。对于不需要保存的触发事件，也可以点击“Delete”删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.02264106826502923685147053176266:50001231000000:2800:B838BBF3C9401B66F8366E0B2B4C3EB8996DDC84419C5E6766F4337DAEA094CF.png)
    
7. 点击“Trigger”， 将会触发执行用户函数代码。执行结果将展示在“Result”框内，“cloudfunctions”窗口同时打印调试日志。
    
    说明
    
    “Result”框右侧的“Logs”面板仅用于在[通过远程调用方式调试函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugfunc#section123191549587)时查看日志。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.25135028497178826260569792178308:50001231000000:2800:6AAF7D350E55518AD404FAC3F605950C9520086FDF9BFDB00B795246DF0EAD42.png)
    
8. （可选）如[配置了环境变量](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugfunc#li15793566149)，可将变量信息传入到函数执行环境中，用于函数运行时读取。
    
    logger.info(context.env._name_);//name为环境变量名称
    
    如下图，函数“my-cloud-function”配置了环境变量“env1”，可成功访问环境变量“env1”的值“value1”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.11456014083101209722647979886123:50001231000000:2800:FB357FFA29098C33872000FAAE04CA0D94BF9E2CD6B2AE4047A82B9EDC26F126.png)
    
9. 点击菜单栏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.48852185257675033617464824688361:50001231000000:2800:C20D77292C6F017BB52A2E750C7B3C37ABB63FB0266DAB6CC81CC75254BA4431.png)，可停止调试。
10. 根据调试结果修改函数代码后，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.13809709244240457413422540916132:50001231000000:2800:5F6EB6F5880BD93A06334C28D3E5B79915987D35897BA452831499941266ECAA.png)重新以Debug模式启动调试，直至没有问题。
11. 参考步骤5~10，完成其他函数的调试。

## 通过远程调用方式调试函数

您还可以将函数部署至AGC云端，然后在DevEco Studio调用云端函数，以测试函数在云端的运行情况、或补充测试因各种因素限制未能在本地调试中发现的问题。

1. 参考[部署函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deployfunc)将需要调试的函数部署至AGC云端。
2. （可选）如函数代码涉及访问环境变量，需在AGC Portal函数列表中点击函数名称，为函数配置环境变量的值，供函数在运行时读取和使用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.03978403780959216271949888308364:50001231000000:2800:1A87EDB3B8930B1EAD642C9F949DF26DD9433B462D3AF697354C89E4C5578B01.png)
    
3. 在菜单栏选择“View > Tool Windows > Cloud Functions Requestor”，使用事件模拟器（Cloud Functions Requestor）触发函数调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.57686765710096827114251228859222:50001231000000:2800:E3804868E9AF84E13BDAF9E63A4BDBFA7E2A562E99E801E466C9AD2E19FDED36.png)
    
4. 在弹出的“Cloud Functions Requestor”面板，配置触发事件参数。
    
    - Cloud Function：选择需要触发的云函数，此处依然以函数“my-cloud-function”为例。
    - Environment：选择函数调用环境。此处选择“Remote”，表示远程调用。
    - Event：输入事件参数，内容为JSON格式请求体数据。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.98496175997904216293705559221525:50001231000000:2800:096D089699D9AC6F78A154895E3B58A7B2FAD50B91ACFE8F8103B5E273599E4A.png)
    
5. 点击“Trigger”， 将会触发执行用户函数代码，执行结果将展示在“Result”框内。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.98460324484925318796603545036665:50001231000000:2800:36A19F5718FF8C21C0886CC7CD031FCE2316FF625D33CC71D3CACA09AFBB6A7B.png)
    
6. 点击“Logs”页签，可查看打印的日志定位问题。修改函数代码、重新部署函数后再次执行远程调用，直至没有问题。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.31819844718793282437045101646605:50001231000000:2800:D7605B07C459468697C53C2EB12F3155D757EB469463104AE19BDB297FF39C16.png)
    
7. 参考步骤1~5，完成其他函数的调试。

## （可选）自定义Run/Debug配置

直接启动函数调试采用的是默认的Run/Debug配置。如有特殊需求，您也可使用自定义Run/Debug配置项来进行调试。

1. 在菜单栏选择“Run > Edit Configurations”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.69752590351415907590583376453193:50001231000000:2800:53EC34DB6E4CBEF9990030B8D8735CAED967D9C2A47653E8B3A5E9997D9D481A.png)
    
2. 在“Run/Debug Configurations”窗口，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.07184851833659906776205448932856:50001231000000:2800:3B0A1EFB063B9D50C48D97508B8BCD7D14A7460689C7584F8BECC77E01052AAD.png)，选择“Cloud Functions”，新增一个Run/Debug配置。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.20998124584612640911883283009350:50001231000000:2800:0F15C62D5FB0A0960F7F6CA8C38125CE51699A396FADC84C886FE9437C8899EC.png)
    
3. 自定义Run/Debug配置，完成后点击“Run”或“Debug”即可立即按当前自定义配置启动本地调试。
    
    如当前暂不使用自定义配置，可点击“OK”保存配置。后续有需要时再选择自定义配置，分别点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.40487490870330828077655957495997:50001231000000:2800:B14C180E36965964650C68FB6543F8B8DC4772AECC50E32A0C3B44829DD4BEE4.png)或![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.43406365816786428586872848587684:50001231000000:2800:0BD6C580C1B3A506828FA5CA2C32B05FB1BA45578E59686F5B9FFCC61FD768D0.png)进行Run或Debug。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.69561785357906467076262447804360:50001231000000:2800:CDF374ED8E855773188A7F9C1384BE664D810158AE62675478A1C7DE7A4A2A56.png)
    
    - Name：Run/Debug配置的名称，如“functions-custom1”。
    - Server IP Address：HTTP服务端监听IP地址，默认为localhost，支持切换为您的局域网IP地址。
    - Server Port：HTTP服务端监听端口。默认为“18090”，自定义端口号建议大于1024。勾选“Auto increment”表示如当前端口被占用则端口号自动加“1”。
    - Environment variables：函数运行的环境变量，为key-value形式。
        
        点击“Edit environment variables”按钮，在“Environment Variables”弹窗中点击“+”添加一个环境变量，然后点击“OK”。添加成功后，您便可以将变量配置信息传入到函数执行环境中，用于函数运行时读取。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.87656049242546193895687724612866:50001231000000:2800:7A60AB62556FFABDA7C88CCEB2FF0B92CCA2BC3B7658AE5A9D243E2893C21DCD.png)
        
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-funccoding "开发函数")
# 部署函数

更新时间: 2025-12-16 15:58

完成函数代码开发后，您可将函数部署到AGC云端，支持单个部署和批量部署。

单个部署仅部署选中的函数，批量部署则会将整个“cloudfunctions”目录下的所有函数同时部署到AGC云端。

下文以部署单个函数“my-cloud-function”为例，介绍如何部署函数。

1. 右击“my-cloud-function”函数目录，选择“Deploy 'my-cloud-function'”。
    
    说明
    
    如需批量部署多个函数，右击“cloudfunctions”目录，选择“Deploy Cloud Functions”即可部署该目录下所有函数。如“cloudfunctions”目录下同时存在云函数和云对象，云函数和云对象将会被一起部署到AGC云端。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.75701673390003246951231620180531:50001231000000:2800:169D1CF768043D74EFDEA695DD3C8C4936DA61D1A410FC73EC1B1F32DF7DFB2C.png)
    
2. 您可在底部状态栏右侧查看函数打包与部署进度。
    
    请您耐心等待，直至出现“Deploy successfully”消息，表示当前函数已成功部署。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.41937645567728229690548432785788:50001231000000:2800:7E589A812D22BBEC98E1D12335CDEC517B9C254B805297F00C29EC5B0FD62A23.png)
    
3. 在菜单栏选择“Tools > CloudDev”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.95499194954059723240450160550071:50001231000000:2800:B1185AA9734FE91AD57DC593E3A2BAD46B9D57CB4A66368B3CE924AA2A266694.png)
    
4. 在打开的CloudDev面板中，点击“Serverless > Cloud Functions”下的“Go to console”，进入当前项目的云函数服务页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.07813284557895716021037811089140:50001231000000:2800:FA8ECA460C05F37743BF5DF7BBF1FDD906CE27F8DA570D7DB3E64EC7F1A1AF84.png)
    
5. 查看到“my-cloud-function”函数已成功部署至AGC云端，函数名称与本地工程的函数目录名相同。
    
    部署成功后，您便可以从端侧调用云函数了，具体请参见[在端侧调用云函数](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokecloudfunc)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.36860649613711288461911963176157:50001231000000:2800:FA494B5712BE0D0592B8F72C437E02CFC813FB6DA8416B9B9489FD241AC91B09.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugfunc "调试函数")
# 开发流程

更新时间: 2025-12-16 15:57

除去传统的云函数，您还可在端云一体化云侧工程下开发云对象。云对象是一种特殊的云函数，本质是对云函数的一种封装，客户端可通过导入一个云对象来直接使用这个对象的方法，为您提供在端侧直接调用云侧代码的开发体验。相对普通云函数方式，云对象代码更精简、逻辑更清晰，大多数场景下推荐使用云对象代替传统云函数。开发流程大致如下：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.31217567691347977841961189522643:50001231000000:2800:97C79EED052115B679BD158FBAF94697042B95AC812CB8EBFA7825262E53A3DA.png "点击放大")

1. [创建云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-createcloudobj)：您可直接在DevEco Studio创建云对象。
2. [开发云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudobj-coding)：云对象创建完成后，您便可以开始编写云对象业务代码了。
3. [调试云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugcloudobj)：您可以对云对象进行调试，以测试云对象代码运行是否正确。
4. [部署云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploycloudobj)：完成云对象代码开发与调试后，您可将云对象部署到AGC云端，支持单个部署和批量部署。

说明

一般建议先将云对象调试无误后再部署至云端，但某些业务场景下需要先部署云对象才能进行调试。请根据实际业务需要操作。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudobj "开发云对象")
# 创建云对象

更新时间: 2025-12-16 15:57

首先您需要在云侧工程下创建云对象。

1. 右击“cloudfunctions”目录，选择“New > Cloud Function”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.73244909589914712235640631562164:50001231000000:2800:DF25BA6B58050C187DF46A64EF9A5EE4F007A97BEC534A11439D44A35A9D8B45.png)
    
2. 在“Select the Cloud Function Type”栏选择“Cloud Object”，输入云对象名称（如“my-cloud-object”），点击“OK”。
    
    与云函数名一样，云对象名称长度2-63个字符，仅支持小写英文字母、数字、中划线（-），首字符必须为小写字母，结尾不能为中划线（-）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.47657019742259790375970695837167:50001231000000:2800:3C29CB0C7D75B6F06168A72AA4A0141762D5E7B4C5CB7406EB03994940BE8000.png)
    
    “cloudfunctions”目录下生成新建的云对象目录，目录下主要包含如下文件：
    
    - 云对象配置文件“function-config.json”：包含handler、触发器等信息。
        
        - handler: 云对象的入口模块及云对象导出的类，通过“.”连接。
        - functionType：表示函数类型，“0”表示云函数，“1”表示云对象。
        - triggers：定义了云对象使用的触发器类型，当前云对象仅支持HTTP触发器。
        
        说明
        
        云对象的配置文件“function-config.json”不建议手动修改，否则将导致云对象部署失败或其它错误。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.84341079117794600787893562554781:50001231000000:2800:05402A400E2D4905F73A0CE9C23DD1088A69960B208447132DBE26CD75C425DB.png)
        
    - 云对象入口文件“_xxx_.ts”（如“myCloudObject.ts”）：在此文件中编写云对象代码。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.91995828495014410642149386941073:50001231000000:2800:F61F688F256E21C957F993CE6C649CB24CE22003B091E06D22AC5000F8525642.png)
        
    - 云对象依赖配置文件“package.json”：在此文件中添加依赖。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.78731143157557333539622354563582:50001231000000:2800:8FB70353B5CFF88F3CA155F30C83AD610B05433524CFD100929F5857D67323F9.png)
        
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudobjprocess "开发流程")
# 开发云对象

更新时间: 2025-12-16 15:57

云对象创建完成后，您便可以直接在云对象中编写需要实现的方法。例如，通过云对象实现add与subtract两个方法。

1. 打开云对象入口文件（此处以“myCloudObject.ts”为例），添加add与subtract方法。
    
    1. export class MyCloudObject {
    2.     add(num1: number, num2: number) {
    3.         return { result: num1 + num2 };
    4.     }
    5.     subtract(num1: number, num2: number) {
    6.         return { result: num1 - num2 };
    7.     }
    8. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.19975402190557376334231620677371:50001231000000:2800:C997413B3E1C732EDBD20407EC9A85F7AE9BD7029579744331433776044B4A74.png)
    
    注意
    
    - 云对象是无状态性。云对象部署至云侧后，每一次调用都可能是不同的后台节点，因此在云对象上定义类成员变量是无意义的。从一个Method中对一个类成员属性赋值，然后期望从另一个Method去获取类成员属性，这样的做法是错误的。
    - 云对象无需编写构造函数。云侧在收到对云对象的某一个函数的请求时，会调用云对象的默认的无参构造函数。
    - 云对象方法的输入是从JSON反序列化而来，只能是string、number或者Object，不支持Date、Uint8Array等类型。如果在编写云对象代码的过程中需要传递Date或Uint8Array，建议通过定义成number或者数组，在Method内通过显式地调用Date或Uint8Array的构造函数来达到目的。
    - 云对象的方法的输出当前不支持单个number返回。
    - 云对象的方法的输入、输出可以使用自定义对象，不能使用第三方依赖定义的对象或类型。注意，并不是云对象不能有第三方依赖，而是云对象的输入和输出不能有第三方依赖，否则在"Generator Invoke Interface"阶段，将会因为找不到依赖而失败，根本原因是，端侧代码运行在HarmonyOS支持方舟运行时，而云侧运行在Node.js中，二者的依赖管理不同。
    

2. （可选）如云对象存在依赖关系，可在“package.json”文件的“dependencies”下添加需要的依赖，然后点击右上角“Sync Now”。
    
    下文以添加“@hw-agconnect/cloud-server”依赖为例进行说明，请添加实际业务所需的依赖。
    
    说明
    
    右击“package.json”文件，选择“Run 'npm install'”菜单，也可以实现依赖包安装。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.02260563866938459143653670436085:50001231000000:2800:8C31D065B318FDE37824B21F91CA4BC07D7D5267FDD69E57384888028BD66A12.png)
    
    所有安装的依赖包都会存储在当前云对象的“node_modules”目录下。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.20541237972141996355923893893855:50001231000000:2800:CDDBBFBFB8E47C1A38294D847C5A684E63B8ABEBBD39066EBB50F9ED672503FB.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-createcloudobj "创建云对象")
# 调试云对象

更新时间: 2025-12-16 15:58

云对象开发完成后，您可以对其进行调试，以验证云对象代码运行是否正常。

目前DevEco Studio云对象调试支持本地调用和远程调用，请根据实际场景选择使用：

- [通过本地调用方式调试云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugcloudobj#section248615546567)：在DevEco Studio调试本地开发好的云对象。支持单个调试和批量调试，并支持Run和Debug两种模式，调试功能丰富，常在云对象开发过程或问题定位过程中使用。
- [通过远程调用方式调试云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugcloudobj#section123191549587)：先将云对象部署至AGC云端，然后直接在DevEco Studio调用云端云对象。此方式主要用于测试云对象在云端的运行情况、或补充测试因各种因素限制未能在本地调用方式中发现的问题。

## 前提条件

- 请确保您已登录。
- 如果您的工程有代码逻辑涉及云对象调用云数据库，您需在调试前先[将整个云工程部署到AGC云端](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploy)，否则云端将没有相关数据及环境变量。

## 通过本地调用方式调试云对象

您可在DevEco Studio调试本地开发好的云对象，支持单个调试和批量调试，并支持Run和Debug两种模式。

- 单个调试和批量调试流程相同，区别仅在于：单个调试是一次只为一个云对象启动本地调试，之后只能调用该云对象；批量调试是一次为“cloudfunctions”目录下所有云对象启动本地调试、然后逐个调用各个云对象。
- Run模式和Debug模式的区别在于：Debug模式支持使用断点来追踪云对象的运行情况，Run模式则不支持。

下文以Debug模式下调试单个云对象“my-cloud-object”为例，介绍如何在DevEco Studio调试本地云对象。

1. 右击“my-cloud-object”云对象目录，选择“Debug 'my-cloud-object'”。
    
    说明
    
    - 如需批量调试多个云对象，右击“cloudfunctions”目录，选择“Debug Cloud Functions”，即可启动该目录下所有云对象。如“cloudfunctions”目录下同时存在云函数和云对象，将会启动所有的云函数和云对象。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.71855554268959851448171564273151:50001231000000:2800:8275583B5EBE4BC0349423930F1C93D523E23416423ED43ECA0ABA4C072EE25C.png)
    
2. 在下方通知栏“cloudfunctions”窗口，查看调试日志。如果出现“Cloud Functions loaded successfully”，表示云对象已成功加载到本地运行的HTTP Server中，并生成对应的Function URI。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.27467719522909506722190897525829:50001231000000:2800:22F66ED0A34683033AF4B6086DD9154AAB6731C242E1FB53FB14C43253E705CE.png)
    
3. 如需设置断点调试，在函数代码中选定要设置断点的有效代码行，在行号（如下图行3）后单击鼠标左键设置断点（如下图的红点）。
    
    设置断点后，调试能够在断点处中断，并高亮显示该行。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.63980104491319073858492162620301:50001231000000:2800:57CAF9945505C1D6CE55ED8093E605EDC00134CA8100209222D1A529E602FA58.png)
    
4. 在菜单栏选择“View > Tool Windows > Cloud Functions Requestor”，使用事件模拟器（Cloud Functions Requestor）触发云对象调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.67928755908212196071351126173073:50001231000000:2800:026DF6C3703B514484C69AABD0EF5541A1B65F47A8441D4644F49A4D117CF3E7.png)
    
5. 在弹出的“Cloud Functions Requestor”面板，配置触发事件参数。
    
    - Cloud Function：选择需要触发的云对象，此处以云对象“my-cloud-object”为例。
    - Environment：选择云对象调用环境。此处选择“Local”，表示本地调用。
    - Method：必填项，输入云对象的方法名称，如“add”。
    - Event：方法参数列表，JSON array格式，依次代表Method的入参。如add方法接收两个number类型的形参，num1与num2，那么填入“[1, 2]”表示构造num1=1，num2=2的请求。
        
        注意
        
        如果Method的入参中的某一个是数组[]类型，那么Event中将至少包含两层方括号，如'[[1, 2], 3]'，外层的方括号表示参数列表。
        
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.79906847307357781526870084374125:50001231000000:2800:E227F2D4C2512402CEF584E7DF4499E768B8B4AA8F7D3A604EF677A6A19AD708.png)
    
6. （可选）点击“Save”，可保存当前触发事件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.31846617724977360983490319507135:50001231000000:2800:D8CAAF7B9103EA9538A4B5A19A929843606208C2C69E630419E4E31BA53443AE.png)
    
    点击右上角![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.32930618899926802247903672492763:50001231000000:2800:E3F47FBA289F07E3C15B003177BDD1FAAF1C3EF6109D1486927D94E89AA2197B.png)可展开保存的触发事件，后续可直接点击“Load”加载事件。对于不需要保存的触发事件，也可以点击“Delete”删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155759.57778562446315417537891110746039:50001231000000:2800:07DFE3D41CDC72E6843036CDDB675E73D0EB8481F5F9EC5532B4A4D411279D22.png)
    
7. 点击“Trigger”， 将会触发执行云对象的方法，执行结果将展示在“Result”框内。
    
    说明
    
    “Result”框右侧的“Logs”面板仅用于在[通过远程调用方式调试云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugcloudobj#section123191549587)时查看日志。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.72992920114444742560704649828351:50001231000000:2800:72A10F67E7B72D426E8203E9DCECAADF82D4F569200DF8235E5C9F4FD0F9FE74.png)
    
8. 点击菜单栏![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.48217222551865325075288862633065:50001231000000:2800:0F46CF6A57C70E4D608FB9E70C48541EF507FED7BBE16CC308F70B71411DAAD9.png)，可停止调试。
9. 根据调试结果修改云对象代码后，点击![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.35312711392450810598386132239004:50001231000000:2800:8E4183C6332F944BF9BAAD3A5487BF1803B915621B9F9DBF6E86A1F126F911E3.png)重新以Debug模式启动调试，直至没有问题。
10. 参考步骤5~9，完成云对象其他方法或其他云对象的调试。

## 通过远程调用方式调试云对象

您还可以将云对象部署至AGC云端，然后在DevEco Studio调用云端云对象，以测试云对象在云端的运行情况、或补充测试因各种因素限制未能在本地调试中发现的问题。

1. 参考[部署云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploycloudobj)将需要调试的云对象部署至AGC云端。
2. 在菜单栏选择“View > Tool Windows > Cloud Functions Requestor”，使用事件模拟器（Cloud Functions Requestor）触发云对象调用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.03211094285602086849519606140693:50001231000000:2800:E8CB348DA78159C1C100530002568C4009753037D4B7EDDDEAF3D4D2C9F8A3E4.png)
    
3. 在弹出的“Cloud Functions Requestor”面板，配置触发事件参数。
    
    - Cloud Function：选择需要触发的云对象，此处依然以“my-cloud-object”为例。
    - Environment：选择云对象调用环境。此处选择“Remote”，表示远程调用。
    - Method：输入云对象的方法名称，如“add”。
    - Event：方法参数列表，JSON array格式，按顺序代表Method的入参，如add方法接收两个number类型的形参，num1与num2，那么填入“[1, 2]”表示构造num1=1，num2=2的请求，如“[1, 2]”。
        
        注意
        
        如果Method的入参中的某一个是数组[]类型，那么Event中将至少包含两层方括号，如'[[1, 2], 3]'，外层的方括号表示参数列表。
        
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.44812571132728788698274126678876:50001231000000:2800:016E30579702394FF76D5DF8B26C782F7196EC6DA9908641539EDE6885D04AA9.png)
    
4. 点击“Trigger”， 将会触发执行云对象方法，执行结果将展示在“Result”框内。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.34759526149913858009314278407214:50001231000000:2800:A96AB65FBE051D2DD24E0FBD6AC9A9F900F246700F17556BCACADA2C3AD41A61.png)
    
5. 点击“Logs”页签，还可查看打印的日志定位问题。修改云对象代码、重新部署云对象后再次执行远程调用，直至没有问题。
6. 参考步骤1~5，完成云对象其他方法或其他云对象的调试。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-cloudobj-coding "开发云对象")
# 部署云对象

更新时间: 2025-12-16 15:58

完成云对象代码开发后，您可将云对象部署到AGC云端，支持单个部署和批量部署。

单个部署仅部署选中的云对象，批量部署则会将整个“cloudfunctions”目录下的所有云对象同时部署到AGC云端。

下文以部署单个云对象“my-cloud-object”为例，介绍如何部署云对象。

1. 右击“my-cloud-object”云对象目录，选择“Deploy 'my-cloud-object'”。
    
    说明
    
    如需批量部署多个云对象，右击“cloudfunctions”目录，选择“Deploy Cloud Functions”即可部署该目录下所有云对象。如“cloudfunctions”目录下同时存在云函数和云对象，云函数和云对象将会被一起部署到AGC云端。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.58630058078140854230497294793121:50001231000000:2800:B19F55FDAD7B016A82DE8F66C249290FB61D76403417838CE2401045FF8A2FFA.png)
    
2. 您可在底部状态栏右侧查看云对象打包与部署进度。
    
    请您耐心等待，直至出现“Deploy successfully”消息，表示当前云对象已成功部署。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.77854698377155361025141435210987:50001231000000:2800:3101601FF41AB9792E9C64C955D578BD6BB6E8FBDF541923793942BEA8C80889.png)
    
3. 在菜单栏选择“Tools > CloudDev”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.43413563402043485367524673291737:50001231000000:2800:A684E72874EA87DB3C2CA1D8CA4CB3CE0D5081B7EC2C55D709795CAA9FB0F0A1.png)
    
4. 在打开的CloudDev面板中，点击“Serverless > Cloud Functions”下的“Go to console”，进入当前项目的云函数服务页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.83407106977226160311097473428038:50001231000000:2800:D5B73DF0F6C5CA40B3FFE6D2A68BCECD490A94247D8BCD6AB8903022A5255E09.png)
    
5. 查看到“my-cloud-object”云对象已成功部署至AGC云端，云对象名称与本地工程的云对象目录名相同。
    
    部署成功后，您便可以从端侧调用云对象了，具体请参见[在端侧调用云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokecloudobj)。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.63254909716008752766315286230654:50001231000000:2800:85663E3F2BA57F9BFA51945E69445B1F8228C02CD0D569A12B152B298C04C82F.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-debugcloudobj "调试云对象")
# 开发流程

更新时间: 2025-12-16 15:57

|   |   |
|---|---|
|云数据库是一款端云协同的数据库产品，提供端云数据的协同管理、统一的数据模型和丰富的数据管理API接口等能力。云数据库采用基于对象模型的数据存储结构。<br><br>- 数据以对象（Object）的形式存储在不同的存储区中，每一个对象，都是一条完整的数据记录。<br>- 对象类型（ObjectType）用于定义存储对象的集合，不同的对象类型对应的不同数据结构。<br>- 存储区（Zone）是一个独立的数据存储区域，每个存储区拥有完全相同的对象类型定义。|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.17181602433494012616980599325938:50001231000000:2800:61EC9A31E31A83E0A5F74066FE1B11C9D7A23CD4866DCC74BDDD6049E894CBA9.png "点击放大")|

您可以使用DevEco Studio在端云一体化云侧工程下开发云数据库，总体流程如下。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155755.32132435891543507534394708201283:50001231000000:2800:1A4F2EE0E3CF050264FE7F8AEEE708BBE8FB42DA5475A837699724936088C2B8.png "点击放大")

1. [创建对象类型](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-objecttype)：创建一个用于存储数据条目的对象类型。
2. [添加数据条目](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-dataentry)：在刚刚创建的对象类型内添加一条条数据，并配置数据所在的存储区。
3. [部署云数据库](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploydatabase)：数据成功添加后，您可以直接将该数据部署至AGC云端。您也可以等所有对象类型和数据条目开发完成后，再统一批量部署到AGC云端。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-clouddb "开发云数据库")
# 创建对象类型

更新时间: 2025-12-16 15:57

对象类型（ObjectType）用于定义存储对象的集合，不同的对象类型对应的不同数据结构。每创建一个对象类型，云数据库会在每个存储区实例化一个与之结构相对应的对象类型，用于存储对应的数据。

创建对象类型的操作如下：

1. 右击“clouddb/objecttype”目录，选择“New > Cloud DB Object Type”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.71826068690328065366278252080743:50001231000000:2800:6C8671159E6F3AE3345D3443C8793E69E7A8FE2302E370625031C3FDC1B267A9.png)
    

2. 输入对象类型名称（下文以“objecttype1”为例）后，点击“OK”。
    
    说明
    
    对象类型名称必须符合如下规范：
    
    - 只能包含字母（A-Z或a-z）、数字（0-9）和下划线（_），并且至少包含字母类型。
    - 必须以字母开头，以字母或者数字结尾，不允许以“sqlite_”开头，不允许以下划线（_）结尾。
    - 不允许使用如下系统保留名称： naturalbase_metadata、objecttypeinfohelper、t_data_upgrade_info、t_index_schema、t_nstore_config、t_schema_negotiate_info、t_metadata_schema、t_nstore_permission、t_system_config。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.01185577284063894783768070589522:50001231000000:2800:1A310D03E92CF4CBBB246A249672D2804D1A90F6634FBBCFB406B46C3DCB6ED9.png)
    
    “clouddb/objecttype”目录下生成并打开新建的对象类型JSON文件“objecttype1.json”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.15273860627804972082422463630185:50001231000000:2800:3496D2FF513487FBDECC641BDD6E5BBC568952234DE2406EFA5C14BA0F45BE49.png)
    
3. 在“fields”中为该对象类型配置字段信息。
    
    |参数|必选(M)/可选(O)|说明|
    |:--|:--|:--|
    |fieldName|M|字段名称。<br><br>输入要求具体如下：<br><br>- 字段的名称长度必须大于或等于1个字符，小于或等于30个字符，只能包含以下3种类型，并且至少包含“字母”类型：<br>    - 字母（A-Z或a-z）<br>    - 数字（0-9）<br>    - 特殊字符：_<br>- 字段名称必须以字母开头，以字母或者数字结尾。<br>- 字段名称中不区分字母的大小写。<br>- 修改对象类型时，支持删除字段。<br>- 字段名称不允许使用系统保留字段名称： naturalbase_version、naturalbase_deleted、naturalbase_operationtype、naturalbase_creator、naturalbase_accesstime、naturalbase_operationtime、naturalbase_syncstatus、naturalbase_changedfieldsbitmap、naturalbase_lastmodifier、cmin、cmax、xmin、xmax、ctid、oid、tableoid、xc_node_id、tablebucketid、rowid。<br><br>说明<br><br>当前Cloud Foundation Kit暂不支持自增类型字段IntAutoIncrement或LongAutoIncrement。|
    |fieldType|M|字段的数据类型。<br><br>当前支持的数据类型：String、Boolean、Byte、Short、Integer、Long、Float、Double、ByteArray、Text、Date。|
    |belongPrimaryKey|O|设置该字段是否为对象类型的主键，默认值为false。<br><br>- 至少设置一个字段为主键。<br>- 支持设置复合主键，由多个字段组合成为主键，一个复合主键包含的字段小于等于5个，复合主键字段顺序与字段的顺序一致。<br>- 数据类型为ByteArray、Text、Date、Double、Float和Boolean的字段不支持设置为主键。<br>- 主键的值不允许更改。|
    |notNull|O|设置字段值是否为非空，默认值为false。<br><br>- 数据类型为ByteArray和Date的字段不支持设置为非空。<br>- 主键默认非空，且不允许更改。<br>- 设置为非空的字段不支持加密和敏感。|
    |isNeedEncrypt|O|设置字段是否需要加密，开启全程加密数据管理功能，默认值为false。<br><br>选择加密后，该字段对应的数据会加密存储在存储区中。<br><br>- 主键字段不支持加密。<br>- 加密的字段不支持设置为非空。<br>- 加密的字段不支持设置为敏感字段。<br>- 一个对象类型中包含的加密字段和敏感字段的总数需小于或等于5个。<br>- 字段设置为加密后，不支持导出该字段的数据值。<br>- 数据类型为ByteArray、Text的字段不支持加密。<br>- 对象类型创建成功后，不支持修改加密属性。|
    |isSensitive|O|设置字段是否为敏感字段，默认值为false。<br><br>选择敏感后，该字段对应的数据会加密存储在存储区中。<br><br>- 敏感字段不支持设置为主键。<br>- 敏感字段不支持设置为非空。<br>- 敏感字段不支持设置为加密。<br>- 敏感字段不支持设置为默认值。<br>- 对象类型创建成功后，不支持修改敏感属性。<br>- 仅支持数据类型为Byte、Short、Integer、Long、Float、Double、String和Date的字段设置为敏感字段。<br>- 敏感字段不支持设置为索引。<br>- 一个对象类型中包含的加密字段和敏感字段的总数需小于或等于5个。|
    |defaultValue|O|字段为非空时，必须设置默认值。<br><br>- 主键不支持设置默认值。<br>- 加密字段和敏感字段不支持设置默认值。<br>- 数据类型为ByteArray、Date不支持为其设置默认值。<br>- 数据类型为Text的字段设置默认值时，默认值的长度小于或等于200个字符。|
    
    例如，我们可为“objecttype1”对象类型配置如下字段。
    
    |fieldName|fieldType|belongPrimaryKey|notNull|isNeedEncrypt|defaultValue|
    |:--|:--|:--|:--|:--|:--|
    |author|String|true|true|-|-|
    |shadowFlag|Boolean|-|true|-|true|
    |bookName|String|-|-|-|-|
    |id|Integer|-|-|-|-|
    |price|Double|-|-|-|-|
    |publishTime|Date|-|-|-|-|
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.66976924199962607540953887004242:50001231000000:2800:88CE497FE4102D570A65CB1DA3A89B7084970681001EC809DC00A7AEE38E3E18.png)
    
4. 在“indexes”中为该对象类型配置索引、索引包含的字段、以及索引包含的字段的排序方式。
    
    |参数|必选(M)/可选(O)|说明|
    |:--|:--|:--|
    |indexName|M|索引名称。<br><br>输入要求具体如下：<br><br>- 索引的名称长度必须大于或等于1个字符，小于或等于30个字符，只能包含以下3种类型，并且至少包含“字母”类型：<br>    - 字母（A-Z或a-z）<br>    - 数字（0-9）<br>    - 特殊字符：_<br>- 索引名称必须以字母开头。<br>- 索引名称中不区分字母的大小写。<br>- 修改对象类型时，仅支持新增或者删除索引。当删除索引后，本次提交前不允许新增同名索引。<br>- 每个对象类型可以设置小于或等于16个索引。<br>- 数据类型为ByteArray和Text的字段不支持设置为索引。|
    |indexList > fieldName|M|索引包含的字段。<br><br>支持设置组合索引，由多个字段组合成为索引，一个组合索引包含的字段不超过5个。|
    |indexList > sortType|M|索引包含的字段的排序方式，支持升序或降序。|
    
    例如，我们可为“objecttype1”对象类型配置如下两个索引。
    
    |indexName|fieldName|sortType|
    |:--|:--|:--|
    |id_Index|id|ASC|
    |price_Index|price|DESC|
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.26528015447767909113378981140376:50001231000000:2800:3B409A484FF9640C7CEC7D484B405C81263ECFF1F59588100AACF2A59540A4E9.png)
    
5. 在“permissions”中设置各角色是否具有该对象类型的Read、Upsert（包含新增和修改）和Delete权限。
    
    |参数|必选(M)/可选(O)|说明|
    |:--|:--|:--|
    |role|M|用户角色，包括：<br><br>- World：代表所有用户，包含认证和非认证用户。该角色默认拥有Read权限，可自定义配置Upsert和Delete权限。但是，不建议将Upsert和Delete权限配置给所有人角色。当对象类型中设置了加密字段之后，表示开启全程加密功能，此时所有人角色将不会拥有Read、Upsert和Delete权限，且不允许修改。<br>- Authenticated：经过AGC登录认证的用户。该角色默认拥有Read权限，可自定义配置Upsert和Delete权限。当对象类型中设置了加密字段之后，表示开启全程加密功能，此时认证用户角色将不会拥有Read、Upsert和Delete权限，且不允许修改。<br>- Creator：经过认证的数据创建用户。该角色默认拥有所有权限，且可自定义配置所有权限。每条数据都有其对应的数据创建人（即应用用户），每个数据创建者仅可以Upsert或者Delete自己创建的数据，不能Upsert或者Delete他人创建的数据。数据创建者的信息保存在数据记录的系统表中。<br>- Administrator：应用开发者，主要是指通过AGC控制台或FaaS（Function as a Service，函数即服务）侧访问云数据库的角色。该角色默认拥有所有权限，且可自定义配置所有权限。Administrator可以管理并配置其他角色的权限。|
    |rights|M|授予角色的权限，包括Read、Upsert（包含新增和修改）和Delete权限。|
    
    说明
    
    各角色只能完成对应权限的操作，超出权限范围的操作云侧将返回“permission denied”错误。由于端云一体化工程的初始化代码未[配置AccessToken](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-cloudcommon#section9723191765120)，故“CloudProgram/clouddb/objecttype/Post.json”中给World角色添加了Upsert和Delete权限。
    
    例如，我们可按下表为各个角色配置“objecttype1”对象类型的权限。
    
    |角色|Read|Upsert|Delete|
    |:--|:--|:--|:--|
    |World|√|–|–|
    |Authenticated|√|√|–|
    |Creator|√|√|√|
    |Administrator|√|√|√|
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.95380571954949769397635709637734:50001231000000:2800:D0145671D2D3ED1FCA4CA3EEB83EC22FF1047F9155C539F5C5E440D85E9A9B7E.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-dbprocess "开发流程")
# 添加数据条目

更新时间: 2025-12-16 15:57

创建完对象类型后，您可在对象类型内添加数据条目（DataEntry），并配置数据所在的存储区。

支持手动创建和自动生成数据条目文件。

## 手动创建数据条目文件

1. 右击“clouddb/dataentry”目录，选择“New > Cloud DB Data Entry”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.71211765838168872454202164881854:50001231000000:2800:02B8E81015F3BD41F3B8A649147DA3E2C8E61C857D9157752468133164F60FE5.png)
    

2. 在“Associated Cloud DB Object Type”栏选择需添加数据条目的对象类型，在“Enter Cloud DB Data Entry Name”栏定义数据条目文件名，完成后点击“OK”。
    
    例如，选择刚刚创建的对象类型“objecttype1”，数据条目文件取默认名“d_objecttype1”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.88613863309132977925218649251382:50001231000000:2800:2D16AC1DFC092B8D98864E246B7237C24A1ED52A724D8901BD708F470E8ABACB.png)
    
    如下图，“clouddb/dataentry”目录下生成并打开新建的数据条目JSON文件“d_objecttype1”，该文件中已为您预置好所属对象类型名称（“objecttype1”）与对象类型的字段名（“id”、“bookName”、“author”、“price”、“publishTime”、“shadowFlag”）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.14080375154413081890601477505456:50001231000000:2800:12D3E9DA3BA401AB8592CECA2EB82A2B7CE037FA3FAC720B56CA60BD20AF0E54.png)
    
3. 配置存储区和字段的值（即数据）。
    
    - “cloudDBZoneName”：配置存储区名称。上图示例中的“default”表示添加数据条目至default存储区。支持修改，如下图“cloudDBZoneName1”。另外，在使用API访问云数据库编码时需要引用该字段。
    - “objects”：配置当前对象类型中所有字段的值，即写入数据。一个对象（object）即为一条数据，您可以通过新建一个对象（object）来为字段赋新值，也可以修改某个对象（object）下字段的值（主键或加密字段的值不支持修改）。如下图，写入了两条数据。
        
        |字段|数据条目1|数据条目2|
        |:--|:--|:--|
        |author|Nancy|Peter|
        |shadowFlag|true|false|
        |bookName|My Favorite Book|Your First English Book|
        |id|10|20|
        |price|10.5|20.5|
        |publishTime|19961007|19961007|
        
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.09589891954401941227135121782288:50001231000000:2800:EC0EF7E30AE65252DD1D75965DC669E7789F1E4457523ECDEF135336729F1C13.png)
    

## 自动生成数据条目文件

1. 右击对象类型JSON文件，选择“Generate Data Entry”。
    
    依旧以对象类型“objecttype1”为例，其包含了“id”、“bookName”、“author”、“price”、“publishTime”、“shadowFlag”六个字段。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.37805171993341042197964512170084:50001231000000:2800:183EC9EA18F527C7990B5710A263DAE5E8EE8EDE1DF8E99E1B94904ED9EE212C.png)
    

2. 在弹出的“New Cloud DB Data Entry”框内，为即将生成的数据条目文件定义名称。此处取默认值“d_objecttype1”为例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.31017682485871345529431328683882:50001231000000:2800:FC17303A5127CFE7B0D19730878F3FD58666702ED0BFA5BDDF25A56B9CB0415D.png)
    
    如下图，“clouddb/dataentry”目录下自动为对象类型“objecttype1”生成数据条目文件“d_objecttype1”，该文件中已为您预置好所属对象类型名称（“objecttype1”）与对象类型的字段名（“id”、“bookName”、“author”、“price”、“publishTime”、“shadowFlag”）。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.42690517352263846308939151902609:50001231000000:2800:067045C3540A49417F9CE11A809F8780E6FC50E4D4A3160A0D278844CB7AE8DC.png)
    
3. 配置存储区和字段的值（即数据）。
    
    - “cloudDBZoneName”：配置存储区名称。上图示例中的“default”表示添加数据条目至default存储区。支持修改，如下图“cloudDBZoneName1”。另外，在使用API访问云数据库编码时需要引用该字段。
    - “objects”：配置当前对象类型中所有字段的值，即写入数据。一个对象（object）即为一条数据，您可以通过新建一个对象（object）来为字段赋新值，也可以修改某个对象（object）下字段的值（主键或加密字段的值不支持修改）。如下图，写入了两条数据。
        
        |字段|数据条目1|数据条目2|
        |:--|:--|:--|
        |author|Nancy|Peter|
        |shadowFlag|true|false|
        |bookName|My Favorite Book|Your First English Book|
        |id|10|20|
        |price|10.5|20.5|
        |publishTime|19961007|19961007|
        
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155757.84374636493900212303330368511807:50001231000000:2800:A6D157E9118C3EE443B78908C7A6124F26C16B1EADD93BE2812BED4FC040B7DE.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-objecttype "创建对象类型")
# 部署云数据库

更新时间: 2025-12-16 15:58

完成数据条目创建后，您可以直接部署该数据条目。您也可以等所有对象类型和数据条目开发完成后，再统一批量部署到AGC云端。

说明

- 部署到AGC云端的存储区数量不得超过4个，否则会导致部署失败，提示“clouddb deploy failed. Reason is the number of CloudDBZone exceeds the limit.”错误。如AGC云端当前已存在4个存储区，请将数据部署到已有的存储区，或者删除已有存储区后再部署新的存储区。**需要注意的是，删除存储区，该存储区内的数据也将一并删除，且不可恢复。**
- 对象类型中的fieldType等字段信息，部署到AGC云端后，请勿在本地再做修改。例如，fieldType设置为String，对象类型部署成功后，又在本地修改fieldType为Integer，再次部署将失败，提示“clouddb deploy failed. Reason is existing fields cannot be modified.”错误。如需更改fieldType等字段信息，请先删除云端部署的对象类型。**需要注意的是，删除云端对象类型，对象类型内添加的数据也将一并删除，且不可恢复。**

部署云数据库的操作如下：

1. 右击“clouddb”目录，选择“Deploy Cloud DB”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.34676704163479890659894143472049:50001231000000:2800:22B81B08C3A11AEE9F856198B8B67E27AF587092C3275584A09638C47DD40C08.png)
    
2. 您可在底部状态栏右侧查看云数据库打包与部署进度。
    
    请您耐心等待，直至出现“Deploy successfully”消息，表示云数据库已成功部署。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.66007125660008946514061289920162:50001231000000:2800:436A993F8FCF103BEEAC52A4BD06B84D7250D2AD926B3004520293B604D01D9B.png)
    
    注意
    
    云数据库部署成功后，DevEco Studio将自动从云侧下载云数据库的schema文件至“AppScope/resources/rawfile/schema.json”路径，该文件是云数据库端侧API必须引入的配置文件。
    
    如果后续又在本地工程修改了对象类型，请重新部署云数据库，DevEco Studio将自动更新schema.json文件；如果后续在AGC云侧修改了对象类型，您需[手动从AGC控制台导出schema.json文件](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-clouddb-agcconsole-objecttypes-0000001127675459#section1558018208151)，拷贝至本地工程的“AppScope/resources/rawfile”目录下。否则，可能导致schema.json文件中的对象类型和代码中的对象类型不一致，端侧访问云数据库时提示[1008230002](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-arkts-error-code#section1432118584210)错误。
    
3. 在菜单栏选择“Tools > CloudDev”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.15608213267029042845068461922650:50001231000000:2800:F8507848983B52F60307069DCEB8762D3BEA47D3D36278511B3CEE2CDD7D5E69.png)
    
4. 在打开的CloudDev面板中，点击“Serverless > Cloud DB”下的“Go to console”，进入当前项目的云数据库服务页面。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.83125664121720453010161715027078:50001231000000:2800:F63E11341F83E19AC79142F908432F962D0023C0FB124C7E58C63F0675B57E7A.png)
    
5. 分别点击“对象类型”、“存储区”与“数据”页签，可查看到本地开发的云数据库资源均已成功部署至AGC云端。
    
    部署成功后，您便可以从端侧访问云数据库了，具体请参见[在端侧访问云数据库](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokeclouddatabase)。
    
    您还可以在AGC控制台继续编辑以上部署的云数据库资源，具体操作请参考[管理数据库](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-clouddb-managingclouddb-0000001080815650)。
    
    对象类型“Post”与“objecttype1”：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.13081383994200009104191561071506:50001231000000:2800:ABE2DEE469E703287626D908E0866B6DE2259CF53B624DE666F1F3742849C602.png)
    
    对象类型“Post”所属存储区“Demo”、“objecttype1”所属存储区“cloudDBZoneName1”：
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155800.05883793100800935071076355099639:50001231000000:2800:259EEB174CCA671ACF98822FAB00071DB131488C5A1A21A1A11A5778224B9F66.png)
    
    “d_Post.json”内的数据条目、“d_objecttype1.json”内的数据条目：
    
    说明
    
    部署对象类型或数据条目JSON文件，实际是部署JSON文件内包含的对象类型或数据条目。因此，您在AGC控制台查看到的将是一个个对象类型或者一条条数据，而非JSON文件。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.74201683337679074145438121253887:50001231000000:2800:49C737A5D429C933C6D3609215B84F015598C8B4BAFA18534C493F8E5686DA4F.png)
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.52961396571359547942510216892512:50001231000000:2800:DB6CF62B6CFECF4F381596B0B678B43CF9D0EDF37267940CC21D33C458504F10.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-dataentry "添加数据条目")
# (可选）一键生成Model Class

更新时间: 2025-12-16 15:58

云数据库支持从端侧或者云侧云函数（含云对象）访问云数据库，代码涉及调用云数据库时，需引入对应云数据库对象类型的Model Class。DevEco Studio当前支持为对象类型一键生成Server Model与Client Model，供您在端侧及云侧云函数（含云对象）开发时引用。

## 生成Server Model

1. 右击需要调用的对象类型文件（以“Post.json”为例），选择“Generate Server Model”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155801.86869674119496787414192991284166:50001231000000:2800:B6F2BB9ABB33278F7747A4A3D3940D9C994E14E8149904A1095163D14AC36A6C.png)
    
2. 选择生成的Server Model文件存放的云函数目录，以“id-generator”为例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.74481074432222058084572556931908:50001231000000:2800:DE662CD56FA7ED86C85BCB65036E6E9792852DADEC7893135CF52EB978CEB852.png)
    
3. 点击“OK”。
    
    指定目录下生成对应对象类型的Server Model文件，后续您便可以在代码中方便地引用该Server Model 。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.91118006916606623199676850031687:50001231000000:2800:0D64FC6BB7727181E5F2E7282DBD5C8C409767D22DEFB59813BDBCAEEAEF5EDA.png)
    
4. 在云对象“id-generator”目录的package.json文件中引入@hw-agconnect/cloud-server依赖。
    
    1. "dependencies": {
    2.   "@hw-agconnect/cloud-server": "latest"
    3. }
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.85432452670133910359155684028149:50001231000000:2800:66BCA54BB1781F25C716C3587ABF20B87186D48640CB50CB88D7547E2A5156D3.png)
    
5. 在云对象文件idGenerator.ts中添加如下代码，实现云函数访问云数据库。
    
    1. import { cloud } from '@hw-agconnect/cloud-server'; 
    2. import { Post } from './Post'; // Post是Server Model 
    
    3. // Demo是Post对象类型使用的存储区名
    4. const collection = cloud.database({ zoneName: 'Demo' }).collection(Post);
    
    5. // IdGenerator云对象，实现了对Post对象类型的查询和更新
    6. export class IdGenerator {
    7.   query() {
    8.     return collection.query().get();
    9.   }
    
    10.   upsert(posts: Post[]) {
    11.     return new Promise((resolve, reject) => {
    12.       collection.upsert(posts.map(post => Post.parseFrom(post)))
    13.         .then(result => resolve({ result }))
    14.         .catch(err => reject(err))
    15.     });
    16.   }
    17. }
    
    注意
    
    如果定义的云数据库表字段中包含ByteArray或Date类型的字段，在插入或者更新云数据库时需要使用Server Model的parseFrom方法将入参转化成API识别的类型，例如上述示例中的Post.parseFrom方法。
    

## 生成Client Model

1. 右击需要调用的对象类型文件（以“Post.json”为例），选择“Generate Client Model”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.25247514119891482748826265550536:50001231000000:2800:879C363A544AF1946E72AD4105EF42AAD9B9E75FAC9050B09532388464B4DF1D.png)
    
2. 选择生成的Client Model文件存放的端侧目录。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.11512568355852907624329005995365:50001231000000:2800:E6BA6866F5C76CB59C5604E29AD2868EAD47485C9CCC1E6B77A3CA52A8AD7DF8.png)
    
3. 点击“OK”。
    
    指定目录下生成对应对象类型的Client Model文件，后续您便可以在端侧代码中方便地引用该Client Model，具体可参考端云一体化工程初始化代码中的Client Model示例（“ets/pages/CloudDb/Post.ts”）在CloudDb.ets以及DbInset.ets中的引用。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155802.81838238711183206552921154186620:50001231000000:2800:DBC91F053E569A6C764D125664C06C7042485C8D50C6F6A7614D5DD4688A3D52.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploydatabase "部署云数据库")
# 部署云侧工程

更新时间: 2025-12-16 15:57

您也可选择在云函数和云数据库全部开发完成后，将整个云工程资源统一部署到AGC云端。

1. 右击云开发工程（“CloudProgram”），选择“Deploy Cloud Program”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155737.75677703580197461899705327271381:50001231000000:2800:E43996C817D7C1CB73733479CBD4EAAFF349849586A7D5AA905861D6298FC214.png)
    
2. 您可在底部状态栏右侧查看云工程打包与部署进度。
    
    请您耐心等待，直至出现“Deploy successfully”消息，表示云工程已成功部署。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155737.45770238263650785792997819326721:50001231000000:2800:776B6D4F5ACF984DA29D22E85625B505E376C48A643EE59E87BDE3E1000A1CC8.png)
    
3. 在菜单栏选择“Tools > CloudDev”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155737.16074850446835241365573509784954:50001231000000:2800:7289A41D4ECA634B8AF4C8F01DB4D2AB10F9BB172CB71BD76C98FB1C9B151C7C.png)
    
4. 在打开的CloudDev面板中，点击“Go to console”，打开当前项目的AGC Serverless子控制台。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155737.54646952398044425375261739635982:50001231000000:2800:269A1A14DF47328CDB8B5A29A1E7475B9E9528517E511D71E371473352F73948.png)
    
5. 分别进入云函数与云数据库服务菜单，可查看到您刚刚部署的云函数与云数据库资源。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155737.91538776856722868467056655894069:50001231000000:2800:1E3CE7DBF8658F37F4D196B5047023DB267164707A4FD4B3A82F9A09479A2620.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-modelclass "(可选）一键生成Model Class")
# （可选）同步云端代码至DevEco Studio工程

更新时间: 2025-12-16 15:57

DevEco Studio还支持您将AGC云端当前项目下的代码同步至本地工程，包括之前从本地部署到AGC云端的代码、以及在AGC云端编写的代码，以保证云端和本地的版本一致性，方便您的日常开发。

云端代码同步目前支持以下模式：[仅同步云函数/云对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-sync#section588213529814)、[仅同步云数据库](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-sync#section474014335350)、[一键同步云侧代码](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-sync#section1198316575339)。

## 同步云函数/云对象

说明

对于使用DevEco Studio 4.1 Canary 2之前的版本部署的函数，同步下来的是JavaScript代码。

### 同步单个云函数/云对象

云函数/云对象部署到AGC云端后，如在云端又进行了新改动，您可再将云端的云函数/云对象同步到本地工程。云函数/云对象的同步方式一致，下文以云对象为例进行说明。

1. 右击云对象目录，选择“Sync '_云对象名_'”。下文以云对象“id-generator”为例。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.78306657759754180640607933108469:50001231000000:2800:5A06AFA3BCFA15BFEBE910EB976E780EEE4A4D787D23CD1E90E1E545AE2256D7.png)
    
2. 在确认弹框中点击“Overwrite”，AGC云端的云对象“id-generator”将覆盖更新本地云对象“id-generator”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.10766181437731481849959359657108:50001231000000:2800:5DB7AA64A2AED00D5B4BEF3B478D15FCF0F2A74A703CF38382AFD87798FC5FF6.png)
    
3. 等待同步完成，“cloudfunctions”目录下将生成从云端同步下来的云对象“id-generator”，同时将本地原云对象“id-generator”备份在同路径下。
    
    说明
    
    后续如执行部署或调试，DevEco Studio会自动跳过备份数据。但出于精简包的考虑，建议您在对比代码差异后，及时将无用的备份数据删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.02365794747165770445245494266958:50001231000000:2800:8A72CA935ABDE7BD7E207929F13EF019904B0A64C8C83A947C35A76F2A3D55EE.png)
    

### 批量同步云函数/云对象

批量同步云函数/云对象即将AGC云端当前项目下的所有云函数/云对象同步至本地工程。

1. 右击“cloudfunctions”目录，选择“Sync Cloud Functions”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.22841819525421179948499607792824:50001231000000:2800:ADD5477B36C43C2BD8A41D16BF440C3B332DBCB3026A90A074BCBF6113E0C509.png)
    
2. 弹窗提示您本地工程下存在同名云函数/云对象。
    
    - 选择“Skip”，同步时将跳过本地同名云函数/云对象。
    - 选择“Overwrite”，AGC云端的云函数/云对象将覆盖更新本地同名云函数/云对象。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.82281567942683134010396465555610:50001231000000:2800:C2D3F2A37BDF4C694DA1FD87D57DCD80CD8BA3C0BE9DDE2E8113C52B965427C5.png)
    
3. 如选择“Skip”，等待同步完成后，“cloudfunctions”目录下将生成从云端同步下来的本项目下所有云函数/云对象，本地已存在的不同步。
    
    如下图，“cloudfunctions”目录下新增了云端同步下来的“test-cloud-function”，上图中本地已存在的云函数/云对象未被覆盖更新。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.52139666673936494763442986166428:50001231000000:2800:B120697631416B173713491CD4055E2BDACC03A8D7EFD4FE04B845672F1768D9.png)
    
4. 如选择“Overwrite”，等待同步完成后，“cloudfunctions”目录下将生成从云端同步下来的本项目下所有云函数/云对象；本地同名云函数/云对象也被覆盖更新，同时更新前的原云函数/云对象会备份在同路径下。
    
    如下图，“cloudfunctions”目录下新增了云端同步下来的“test-cloud-function”，本地已存在的几个云函数/云对象也被覆盖更新，并且均生成了备份文件“xxxx-_备份时间_.backup”。
    
    说明
    
    后续如执行部署或调试，DevEco Studio会自动跳过备份数据。但出于精简包的考虑，建议您在对比代码差异后，及时将无用的备份数据删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.70803199746766233358580436781066:50001231000000:2800:354EA82902334DD7D175807161F09449E1295C3A816F924F5B7487D2383EE134.png)
    

## 同步云数据库

说明

目前仅支持同步对象类型。

### 同步单个对象类型

对象类型部署到AGC云端后，如又发生了新改动，您可再将云端的对象类型同步到本地。

1. 右击对象类型JSON文件（以“objecttype1.json”为例），选择“Sync 'objecttype1.json'”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155739.44835823737734152886749442110786:50001231000000:2800:75A0DCC132CB70992696D96034CF69BD2D501339F53F1A51C60E14F007CB22BF.png)
    
2. 在确认弹框中点击“Overwrite”，AGC云端的对象类型“objecttype1.json”将覆盖更新本地对象类型“objecttype1.json”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.20890725872933011087230618689504:50001231000000:2800:8523CBDB6CA789F112B17EC4B921A71A4185B0F206F643C702D04F28CBD306A7.png)
    
3. 等待同步完成，“objecttype”目录下将生成从云端同步下来的对象类型“objecttype1.json”。
    
    - 如果云端和本地的同名对象类型内容存在差异，则还会将本地原对象类型备份在同路径下。
    - 如果云端和本地的同名对象类型内容完全一致，则不生成备份。
    
    说明
    
    后续如执行部署，DevEco Studio会自动跳过备份数据。但出于精简包的考虑，建议您在对比代码差异后，及时将无用的备份数据删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.58407173914326328486418935287044:50001231000000:2800:5DF089F6A2B9566D03FEF65F5BC3C9AD7407EF277AA1336F985C1F9ABC3C383E.png)
    

### 批量同步对象类型

您可以将AGC云端当前项目下所有的对象类型一键同步至本地。

1. 右击“objecttype”目录，选择“Sync Object Type”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.04222927459390116870570881429753:50001231000000:2800:F093615167510E892F4862DAA2A85689EA216838AF5ED5D3F84C850326FB88D2.png)
    

2. 弹窗提示您本地工程下已存在同名对象类型，如下图“Post.json”与“objecttype1.json”。
    
    - 选择“Skip”，同步时将跳过本地同名对象类型。
    - 选择“Overwrite”，AGC云端的对象类型将覆盖更新本地同名对象类型。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.07367360475078574405942092990938:50001231000000:2800:7AFBECFDEF6CE7D7672FAFBB9009A651DA451DAD4235FD49C39E01FA30558F07.png)
    
3. 如选择“Skip”，等待同步完成后，“objecttype”目录下将生成从云端同步下来的本项目下所有对象类型，本地已存在的不同步。
    
    如下图，“objecttype”目录下新增了云端同步下来的“test_object.json”，本地已存在的“Post.json”与“objecttype1.json”未被覆盖更新。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.46304442012929923216285732227876:50001231000000:2800:532B5B0A91B8D067CAC0F786C632FF9523DE383A2F47351165D649B17E2F1725.png)
    
4. 如选择“Overwrite”，等待同步完成后，“objecttype”目录下将生成从云端同步下来的所有对象类型，本地已存在的对象类型也被覆盖更新。
    
    - 如果云端和本地的同名对象类型内容存在差异，则还会将本地原对象类型备份在同路径下。
    - 如果云端和本地的同名对象类型内容完全一致，则不生成备份。
    
    如下图，“objecttype”目录下生成了“test_object.json”、“Post.json”与“objecttype1.json”三个对象类型文件，其中：“test_object.json”为从云端新同步下来的对象类型；“objecttype1.json”本地已存在且与云端内容一致，不生成备份；“Post.json”本地已存在但与云端内容存在差异，因此被覆盖更新，同时原“Post.json”备份为“Post.json-_备份时间_.backup”。
    
    说明
    
    后续如执行部署，DevEco Studio会自动跳过备份数据。但出于精简包的考虑，建议您在对比代码差异后，及时将无用的备份数据删除。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.15410285680879497100762895184494:50001231000000:2800:A895961AD7A945B1352F65B817C3409E27F3D996B4C0479E935F95D972FC113F.png)
    

## 一键同步云侧代码

说明

对于使用DevEco Studio 4.1 Canary 2之前的版本部署的函数，同步下来的是JavaScript代码。

1. 右击云开发工程（“CloudProgram”），选择“Sync Cloud Program”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.45215109214398119302100250113995:50001231000000:2800:AA6B99C0C9E5C967E4880E18FFB2BEB6B40F62AD0224E8942D0FCFA2ABCE4D73.png)
    
2. 弹窗提示您本地工程下已存在同名对象类型/云函数/云对象。
    
    - 选择“Skip”，同步时将跳过本地同名对象类型/云函数/云对象。
    - 选择“Overwrite”，AGC云端的对象类型/云函数/云对象将覆盖更新本地同名对象类型/云函数/云对象。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.56975866599072467655897348898457:50001231000000:2800:D2B642D1FDF1CBD6932DE6DAE115CBF9B7EADD9DA6BBAFF5518676DF309F05B4.png)
    
3. 如选择“Skip”，等待同步完成后，“objecttype”目录下将生成从云端同步下来的本项目下所有对象类型，“cloudfunctions”目录下将生成从云端同步下来的本项目下所有云函数/云对象，本地已存在的云函数/云对象/对象类型均不同步。
    
    如下图：
    
    - “objecttype”目录下新增了云端同步下来的“test_object.json”，本地已存在的“Post.json”与“objecttype1.json”未被覆盖更新。
    - “cloudfunctions”目录下生成了从云端同步下来的“test-cloud-function”，本地已存在的“id-generator”、“my-cloud-function”与“my-cloud-object”未被覆盖更新。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.99593665535224015444537984658957:50001231000000:2800:FF9040F11DE40872E6EA4D0C315CF1EE1350BD940C898C78B2C59DEED1485807.png)
    
4. 如选择“Overwrite”，等待同步完成后，“objecttype”目录下将生成从云端同步下来的本项目下所有对象类型，“cloudfunctions”目录下将生成从云端同步下来的本项目下所有云函数/云对象，本地已存在的云函数/云对象/对象类型也被覆盖更新。
    
    - 如果云端和本地的同名对象类型内容存在差异，则还会将本地原对象类型备份在同路径下。
    - 如果云端和本地的同名对象类型内容完全一致，则不生成备份。
    - 无论云端和本地的同名云函数/云对象代码是否一致，均会将本地原云函数/云对象备份在同路径下。
    
    如下图：
    
    - “objecttype”目录下生成了“test _object.json”、“Post.json”与“objecttype1.json”三个对象类型文件，其中：“test _object.json”为从云端新同步下来的对象类型；“Post.json”本地已存在且与云端内容一致，不生成备份；“objecttype1.json”本地已存在但与云端内容存在差异，因此被覆盖更新，同时原“objecttype1.json”备份为“objecttype1.json-_备份时间_.backup”。
    - “cloudfunctions”目录下生成了从云端同步下来的“test-cloud-function”，本地已存在的“id-generator”、“my-cloud-function”与“my-cloud-object”也被覆盖更新，并且均生成了备份文件“xxxx-_备份时间_.backup”。
        
        说明
        
        后续如执行部署或调试，DevEco Studio会自动跳过备份数据。但出于精简包的考虑，建议您在对比代码差异后，及时将无用的备份数据删除。
        
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155740.85271874922980510160118098289709:50001231000000:2800:FB1404CE755365CADA73EC8B77CCBC6E90E2F68F698796497DA154CA266D7E4E.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploy "部署云侧工程")
# 在端侧调用云函数

更新时间: 2025-12-16 15:57

## 前提条件

请确保[云函数已正确开发并部署](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deployfunc)。

## 操作步骤

1. 在代码文件中引入Cloud Foundation Kit。
    
    1. import { cloudFunction } from '@kit.CloudFoundationKit'
    2. import { BusinessError } from '@kit.BasicServicesKit';
    
2. 调用您云侧部署的云函数。关于云函数接口的更详细信息，请参考[Cloud Foundation Kit API参考-云函数模块](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-cloudfunction)。
    
    1. //填入需要调用的云函数名称
    2. cloudFunction.call({name: 'xxxx'})
    3. .then((res: cloudFunction.FunctionResult) => {  
    4.   // 处理调用返回
    5. }).catch((err: BusinessError) => {
    6.   // 调用云函数异常时的处理逻辑
    7. })
    
    例如，调用云侧函数“my-cloud-function”，以返回一个时间戳。
    
    8. import { cloudFunction } from '@kit.CloudFoundationKit';
    9. import { BusinessError } from '@kit.BasicServicesKit';
    
    10. interface result {
    11.   intervalTime: number
    12. }
    
    13. interface res {
    14.   result: result
    15. }
    
    16. @Entry
    17. @Component
    18. struct CloudFunction {
    19.   @State globalId: string = '';
    
    20.   build() {
    21.     Column() {
    22.       Navigation()
    23.         .title($r('app.string.cloud_function_title'))
    24.         .height('50vp')
    25.         .width('100%')
    26.         .margin({ bottom: 10 })
    27.         .titleMode(NavigationTitleMode.Mini)
    
    28.       Text($r('app.string.cloud_function_description'))
    29.         .width('90%')
    30.         .textAlign(TextAlign.Center)
    31.         .margin({ top: 20, bottom: 20 })
    32.         .fontSize($r('app.float.body_font_size'))
    33.       Button({ type: ButtonType.Normal }) {
    34.         Text($r('app.string.cloud_function_button_text'))
    35.           .fontColor($r('app.color.white'))
    36.           .margin({ top: 5, bottom: 5 })
    37.       }
    38.       .width('90%')
    39.       .borderRadius('8vp')
    40.       .height('30vp')
    41.       .margin({ top: 10 })
    42.       .onClick(() => {
    43.         this.callMyFunction()
    44.       })
    
    45.       Column() {
    46.         Text(this.globalId).fontSize($r('app.float.body_font_size'))
    47.       }
    48.       .width('90%')
    49.       .padding({ top: 20, bottom: 20 })
    50.       .margin({ top: 20 })
    51.       .backgroundColor($r('app.color.placeholder_background'))
    52.     }.height('100%')
    53.   }
    
    54.   callMyFunction() {
    55.     cloudFunction.call({ name: 'my-cloud-function' }).then((res: cloudFunction.FunctionResult) => {
    56.       let callback  = res as res;
    57.       console.info(`Succeeded in call the function, time:${callback.result.intervalTime} `);
    58.     }).catch((err: BusinessError) => {
    59.       console.error(`Failed to call the function, Code: ${err.code}, message: ${err.message}`);
    60.     });
    61.   }
    62. }
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokecloudcode "在端侧调用云侧代码")
# 在端侧调用云对象

更新时间: 2025-12-16 15:57

云对象开发完成后，您可以为其生成端侧调用接口类，供后续端侧工程调用云对象使用。

## 前提条件

请确保[云对象已正确开发并部署](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploycloudobj)。

## 操作步骤

1. 右击云对象（以“my-cloud-object”为例），选择“Generate Invoke Interface”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.62344788317802621312127439940215:50001231000000:2800:D6A25F959928C3DD2B6EB888E81FA2D642CF642D05A658D1127C4F062E754E17.png)
    
2. 在弹出的“Generate Invoke Interface”窗口，可以看到生成的端侧调用接口类将默认存储在“Application/cloud_objects”模块目录下，点击“OK”确认。您也可以点击“...”按钮自定义存储目录。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.88366125139889401220342366681953:50001231000000:2800:AAA6ADFF1F500287D6D0CEDFEE4A511B7F67EDC2F51119D4AD940261080E097F.png)
    
3. DevEco Studio自动打开指定的端侧调用接口类存储目录，该目录包含“ImportObject.ts”文件和“my-cloud-object”文件夹。
    
    - “ImportObject.ts”文件定义了importObject方法，可以通过该方法来实例化一个云对象的代理。
    - “my-cloud-object”文件夹包含了该云对象在端侧可能用到的所有模型。示例中只有一个“MyCloudObject.ts”文件，如果有其它的模型也将生成在该文件夹下。
    - “MyCloudObject.ts”文件中定义了MyCloudObject class，并且定义了add和subtract两个方法。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.21666741433035592674204887364104:50001231000000:2800:3D09CAFA79E8CFA82E78E156A0156EC6D29482DA5F95F7597AEDCF698432D159.png)
    
4. 在代码文件中引入云对象。
    
    1. import { MyCloudObject, importObject } from 'cloud_objects';
    
5. 调用云对象中的方法。
    
    1. let myCloudObject = importObject(MyCloudObject); // 使用importObject实例化MyCloudObject的代理
    2. myCloudObject.add(1, 2).then(addResult => {
    3.   console.log(`1 + 2 = ${addResult.result}`);
    4. }); // 忽略异常处理
    5. myCloudObject.subtract(6, 3).then(subtractResult => {
    6.   console.log(`6 - 3 = ${subtractResult.result}`);
    7. });
    
    由于“Generate Invoke Interface”时已经生成所需要的模型以及importObject方法，因此在编码时可以很方便地使用联想、自动引入等DevEco Studio提供的高阶能力，如下图所示。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155756.11124472319339006864267560909114:50001231000000:2800:48016B9BE9C76B7E77F939D13C5FBEF4BF590F2F6F68A1CAFFB42699647372E8.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokecloudfunc "在端侧调用云函数")
# 在端侧访问云数据库

更新时间: 2025-12-16 15:57

## 前提条件

- 请确保[云数据库已正确开发并部署](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploydatabase)。
- 请确保“AppScope/resources/rawfile/schema.json”文件已存在。
    
    注意
    
    云数据库部署成功后，DevEco Studio将自动从云侧下载云数据库的schema文件至“AppScope/resources/rawfile/schema.json”路径，该文件是云数据库端侧API必须引入的配置文件。
    
    如果后续又在本地工程修改了对象类型，请重新部署云数据库，DevEco Studio将自动更新schema.json文件；如果后续在AGC云侧修改了对象类型，您需[手动从AGC控制台导出schema.json文件](https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-clouddb-agcconsole-objecttypes-0000001127675459#section1558018208151)，拷贝至本地工程的“AppScope/resources/rawfile”目录下。否则，可能导致schema.json文件中的对象类型和代码中的对象类型不一致，端侧访问云数据库时提示[1008230002](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-arkts-error-code#section1432118584210)错误。
    

- 检查您的角色拥有的对象类型操作权限。如果未[配置AccessToken](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-cloudcommon#section9723191765120)，需要给World角色添加Upsert和Delete权限。

## 生成Client Model

在端侧通过Cloud Foundation Kit访问云数据库，需先引入对应云数据库对象类型的Client Model。

参考[生成Client Model](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-modelclass#section1037851593420)生成云数据库对象类型的端侧模型，如下图初始化代码中的Client Model示例“ets/pages/CloudDb/Post.ts”。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155758.52000665261267637365828015080354:50001231000000:2800:8B44503903F8D46CA624492B3721777D1DDABC396B9F48E7B3B13055E38618A0.png)

## 访问数据库

接下来您便可参考[初始化数据库访问](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-database-initialize)、[查询数据](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-database-query)、[写入数据](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-database-upsert)、[删除数据](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-database-delete)等访问数据库。

“src/main/ets/pages/CloudDb”目录下提供了部分示例代码，更完整的接口信息请参考[Cloud Foundation Kit API参考-云数据库模块](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-clouddatabase)。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokecloudobj "在端侧调用云对象")
# 在端侧调用云存储

更新时间: 2025-12-16 15:58

## 前提条件

- 请确保云存储服务已经开通。
- 使用云存储功能，需要获取用户凭据。请确保您已[配置AccessToken](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-cloudcommon#section9723191765120)。

## 操作步骤

1. 在代码文件中引入Cloud Foundation Kit。
    
    1. import { cloudStorage } from '@kit.CloudFoundationKit';
    2. import { BusinessError, request } from '@kit.BasicServicesKit';
    
2. 初始化云存储实例。
    
    1. const bucket: cloudStorage.StorageBucket = cloudStorage.bucket();
    
3. 调用云存储接口，如uploadFile接口。“src/main/ets/pages/CloudStorage.ets”代码片段节选如下，更完整的接口信息请参考[Cloud Foundation Kit API参考-云存储模块](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-cloudstorage)。
    
    1. bucket.uploadFile(getContext(this), {
    2.   localPath: cacheFilePath,
    3.   cloudPath: cloudPath,
    4. }).then(task => {
    5.   // add task event listener
    6.   this.addEventListener(task, this.onUploadCompleted(cloudPath, cacheFilePath));
    7.   // start task
    8.   task.start();
    9. }).catch((err: BusinessError) => {
    10.   hilog.error(HILOG_DOMAIN, TAG, 'uploadFile failed, error code: %{public}d, message: %{public}s',
    11.     err.code, err.message);
    12.   this.isUploading = false;
    13. });
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokeclouddatabase "在端侧访问云数据库")
# （可选）通过CloudDev面板获取云开发资源支持

更新时间: 2025-12-16 15:57

DevEco Studio为您提供了CloudDev云开发管理面板。该面板集成了AGC云开发子控制台、文档和社区入口，方便您直达AGC云开发子控制台进行服务和资源管理，并且可轻松跳转至各指导文档和社区论坛来获取技术支持，为您提供开发、调试、部署、管理与技术支持的端到端体验。

1. 在菜单栏选择“Tools > CloudDev”。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155730.77382259222633995919319241389460:50001231000000:2800:5B7371BE489E131C36966F213515DF92479A6FEF6A994BF8E6B4D1538ED20C37.png)
    
2. 在打开的云开发管理面板中，您可轻松获取各种云开发资源。
    
    说明
    
    如尚未登录，请点击“Sign in”登录您的华为开发者账号。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155730.46275369536606368555619057625160:50001231000000:2800:CD083218E10EB3A143B289AFA0693A152EC16230E16CC1F19AAFB57806D50D2A.png)
    
    其中，AGC云开发子控制台如下图所示，您可按需进入对应菜单进行服务或资源管理。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155730.83697012871571218713634596497874:50001231000000:2800:2AA8A577EE599F96F90720F298FD8A6B5F494EFC0BE1A1E4645E87F1248C174D.png)
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-invokecloudstorage "在端侧调用云存储")
# 打包测试

更新时间: 2025-12-16 15:57

端云两侧工程代码全部开发完成后，建议您在本地进行调试，以查看和验证应用/元服务运行效果，减少发布过程中可能遇到的问题，具体请参见[应用/服务调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-debug-device)。

注意

当前自动签名仅支持“[关联注册应用进行签名](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-signing#section20943184413328)”方式。

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-console "（可选）通过CloudDev面板获取云开发资源支持")
# 通用云开发模板

更新时间: 2025-12-16 15:57

## 适用范围

|   |   |
|---|---|
|模板名称|通用云开发模板（[CloudDev]Empty Ability）|
|模板说明|DevEco Studio内预置的端云一体化开发模板。当前使用Cloud Foundation Kit（云开发服务，包括云函数、云数据库和云存储）搭建了基础的演示项目，不含业务属性。您可参考模板学习如何进行基础的端云工程开发，后续开发时可删除预置的页面代码。|
|支持的应用类型|- HarmonyOS应用<br>- 元服务|

## 效果图

以下为通用云开发模板主要功能模块的效果图。

|功能模块|效果图|功能说明|
|:--|:--|:--|
|云函数|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155734.77521837135115492281241768125208:50001231000000:2800:C0F851457D90C97C6919ABD98A918917EA2A92D004369907F69A94A6E4528450.png "点击放大")|点击“Generate Global Unique ID”时，调用云函数SDK执行部署在AGC云端的云对象“id-generator”，生成UUID。|
|云数据库|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155734.74336699504160336281260059024337:50001231000000:2800:8CDB946B0FEB0668E30905C9AA9A225465E5DC3E069530025724906C5AE0A634.png "点击放大")|点击“New”创建数据，可在AGC云端查看到创建的数据。|
|云存储|![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155734.33988178246856036077514986321809:50001231000000:2800:BE15EF2954184238446A38F108E054BD855A6CC5B39B3A7A3BF28B3F7CDCEF36.png "点击放大")|点击“Upload Image”上传本地图片，成功后可获取图片链接。|

## 体验模板

如您希望在设备上亲自体验该模板的功能和页面效果，可按如下流程操作：

1. [使用模板创建端云一体化开发工程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-devproject)。
2. [将云侧工程一键部署至AGC云端](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-deploy)。
3. 配置云存储安全策略。
    
    由于端云一体化开发工程的初始化代码未[配置AccessToken](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/cloudfoundation-cloudcommon#section9723191765120)，因此您还需配置云存储的安全策略为始终可读写，否则会导致云存储无法上传文件。具体操作如下：
    
    1. 登录[AppGallery Connect](https://developer.huawei.com/consumer/cn/service/josp/agc/index.html)，点击“开发与服务”。
    2. 在项目列表中点击您的项目。
        
    3. 在左侧导航栏选择“云开发（Serverless） > 云存储”，进入云存储页面。
    4. 选择“安全”页签，在“配置策略”页面修改默认安全策略为始终可读写后，点击“发布”。
        
        1. agc.cloud.storage[
        2.     match: /{bucket}/{path=**} {
        3.         allow read, write: if true;
        4.     }
        5. ]
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155734.25482226611821197818503654245571:50001231000000:2800:D814359149128382EB75959DE48A4BF593670AD4BFA2E3F9642F951C89F35129.png)
        
4. 将模板工程推包到手机上，在手机上开通应用访问数据权限，即可开始体验模板。
    
    注意
    
    当前自动签名仅支持“[关联注册应用进行签名](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-signing#section20943184413328)”方式。
    
    如使用模拟器体验，请参考[使用模拟器调试](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cloudfoundation-emulator)操作。
    

[  
](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/agc-harmonyos-clouddev-template "附录：云开发工程模板")
# 导入Sample工程

更新时间: 2025-12-16 15:57

DevEco Studio支持Sample工程的导入功能，通过对接Gitee开源社区中的Sample资源，可一键导入Sample工程到DevEco Studio中。下面介绍导入Sample的方法。

## 约束与限制

### 支持的国家/地区

该功能仅支持中国境内（香港特别行政区、澳门特别行政区、中国台湾除外）。

## 操作步骤

1. 在DevEco Studio的欢迎页，进入**Customize** **> All Settings... > Version Control > Git**界面，单击**Test**按钮检测是否安装Git工具。
    
    说明
    
    在打开工程的情况下，可以单击**File > Settings**（macOS为**DevEco Studio > Preferences/Settings**）进入设置界面。
    
    - 已安装，请根据[2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-import-sample#li1599692216194)开始导入Sample。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.87240524158373997822811793586820:50001231000000:2800:65EAED478E1F21ADFD8BA06715AF2FF08B85984807E68C8BEEEED9B2E514DCBB.png)
        
    - 未安装，请单击**Download and Install**，DevEco Studio会自动下载并安装。安装完成后，请根据[2](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-import-sample#li1599692216194)开始导入Sample。
        
        ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.27060013830879554725597183775767:50001231000000:2800:10574692CF22F0013C9ED09D3CC4C923D0C14F37352EE14CA88D10AAEA0BE477.png)
        
    
2. 在DevEco Studio的欢迎页，在**Projects**页签下，单击**M****ore Action >** **Import Sample**按钮，导入Sample工程。
    
    说明
    
    在打开工程的情况下，可以单击**File > New > Import > Import Sample**来进行导入。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.25287169962574779297194741617614:50001231000000:2800:E18ACEA0A3ADB8838A0C3FD082E417E39F456A4A55233EA4236E6A9447425F04.png)
    
3. 选择需要导入的Sample工程，然后单击**Next**。
4. 设置**Project name**和**Project location**，然后单击**Finish**，等待Sample工程导入完成。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.68426570967571942920046891010998:50001231000000:2800:BD622869C777F59FCED79F1D1D07A5CA522F24176BE25AC123DABFF06E21EB5E.png)
    
5. 导入Sample后，等待工程同步完成即可。
    
    说明
    
    如果网络受限，导入时会提示“Failed to connect to gitee.com port 443: Time out”连接超时错误，请[配置Git代理信息](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-2)。
    # 创建意图框架

更新时间: 2025-12-16 15:57

DevEco Studio支持创建意图框架，帮助应用理解用户意图，并提供相应的服务和体验。

## 使用约束

- 支持API 11及以上工程创建意图框架；
- 仅支持在Stage工程的HAP模块中创建意图框架。

## 使用方式

1. 选中模块或模块下的文件，右键单击**New > Insight Intent**，进入意图框架配置界面。
    
    - **Intent domain**：意图垂域。
    - **Source entry name**：意图框架入口代码文件名。
    - **Intent Settings**：意图配置。以MusicDomain为例：
        
        - **PlayMusic：**开启/关闭PlayMusic意图能力，实现播放歌曲（指定一首）**。**默认需要关联UIAbility，可在**Ability name**中下拉框选择需要关联的Ability能力。
        - **PlayMusicList**：开启/关闭PlayMusicList意图能力，实现播放歌单（指定一整个歌单）**。**默认需要关联UIAbility，可在**Ability name**下拉框中选择需要关联的Ability能力。
        
        说明
        
        PlayMusic和PlayMusicList不支持同时关闭，请至少开启一个意图。
        
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.79513479122419922523830415984287:50001231000000:2800:E75AFD750CE3E77B9DFF6AB66523C38FB36794A304534DDADB7CE3ECBAD824FA.png)
    
2. 点击**Finish**，完成意图框架创建。此时将在**entry > src > main > ets > insightintents**目录下生成入口代码文件；在**entry > src > main > resource > base > profile**中，生成**i****nsight_intent.json**文件，可在该文件查看当前意图框架配置的相关信息。
    
    ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251216155725.53799567197510835067659041663734:50001231000000:2800:00C9E4D56B053E8C96B5B7BA30B98DE4ACA4D1B42289EAE9CCDE5E3F65023368.png)


